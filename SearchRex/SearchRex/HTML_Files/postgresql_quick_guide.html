<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 15:31:39 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>PostgreSQL - Quick Guide</title>
<meta name="description" content="PostgreSQL Quick Guide - Learn PostgreSQL in simple and easy steps starting from basic to advanced concepts with examples including database programming, Overview, Environment Setup, Syntax, Data Type, Create, Select, Drop Database, Drop, Create Table, Schema, Insert, Select, Update, Delete Query, Operators, Expressions, Where, Like, Limit, Order By, Group By, With, Having Clause, AND and OR Operators, Distinct Keyword, Constraints, Joins, Unions Clause, NULL Values, Alias Syntax, Triggers, Indexes, Alter Table Command, Truncate Table Command, Views, Transactions, Locks, Sub Queries, Auto Increment, Privileges, DATE/TIME Functions and Operators, Functions, Useful Functions, C/C++, JAVA, PHP, Perl, Python Interface." />
<meta name="keywords" content="PostgreSQL, Tutorial, Programming, Database, Overview, Environment Setup, Syntax, Data Type, Create, Select, Drop Database, Drop, Create Table, Schema, Insert, Select, Update, Delete Query, Operators, Expressions, Where, Like, Limit, Order By, Group By, With, Having Clause, AND and OR Operators, Distinct Keyword, Constraints, Joins, Unions Clause, NULL Values, Alias Syntax, Triggers, Indexes, Alter Table Command, Truncate Table Command, Views, Transactions, Locks, Sub Queries, Auto Increment, Privileges, DATE/TIME Functions and Operators, Functions, Useful Functions, C/C++, JAVA, PHP, Perl, Python Interface." />
<base  />
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="../theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="../theme/css/style-min5e1f.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #316192 url(../images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #316192 !important;}
.submenu-item{ border-bottom: 2px solid #316192 !important; border-top: 2px solid #316192 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="../images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="../index-2.html" title="tutorialspoint">
      <img alt="tutorialspoint" src="images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="../about/about_careers.html" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="../whiteboard.html"><img src="../theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="../netmeeting.html"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="../online_dev_tools.html"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="../articles/index.html"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="../index-2.html"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../codingground.html"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../tutor_connect/index.html"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../videotutorials/index.html"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="images/postgresql-mini-logo.jpg" alt="PostgreSQL Tutorial" />
</div>
<ul class="nav nav-list primary left-menu">
<li class="heading">PostgreSQL Tutorial</li>
<li><a href="index.html">PostgreSQL - Home</a></li>
<li><a href="postgresql_overview.html">PostgreSQL - Overview</a></li>
<li><a href="postgresql_environment.html">PostgreSQL - Environment Setup</a></li>
<li><a href="postgresql_syntax.html">PostgreSQL - Syntax</a></li>
<li><a href="postgresql_data_types.html">PostgreSQL - Data Types</a></li>
<li><a href="postgresql_create_database.html">PostgreSQL - Create Database</a></li>
<li><a href="postgresql_select_database.html">PostgreSQL - Select Database</a></li>
<li><a href="postgresql_drop_database.html">PostgreSQL - Drop Database</a></li>
<li><a href="postgresql_create_table.html">PostgreSQL - Create Table</a></li>
<li><a href="postgresql_drop_table.html">PostgreSQL - Drop Table</a></li>
<li><a href="postgresql_schema.html">PostgreSQL - Schema</a></li>
<li><a href="postgresql_insert_query.html">PostgreSQL - Insert Query</a></li>
<li><a href="postgresql_select_query.html">PostgreSQL - Select Query</a></li>
<li><a href="postgresql_operators.html">PostgreSQL - Operators</a></li>
<li><a href="postgresql_expressions.html">PostgreSQL - Expressions</a></li>
<li><a href="postgresql_where_clause.html">PostgreSQL - Where Clause</a></li>
<li><a href="postgresql_and_or_clauses.html">PostgreSQL - AND &amp; OR Clauses</a></li>
<li><a href="postgresql_update_query.html">PostgreSQL - Update Query</a></li>
<li><a href="postgresql_delete_query.html">PostgreSQL - Delete Query</a></li>
<li><a href="postgresql_like_clause.html">PostgreSQL - Like Clause</a></li>
<li><a href="postgresql_limit_clause.html">PostgreSQL - Limit Clause</a></li>
<li><a href="postgresql_order_by.html">PostgreSQL - Order By Clause</a></li>
<li><a href="postgresql_group_by.html">PostgreSQL - Group By</a></li>
<li><a href="postgresql_with_clause.html">PostgreSQL - With Clause</a></li>
<li><a href="postgresql_having_clause.html">PostgreSQL - Having Clause</a></li>
<li><a href="postgresql_distinct_keyword.html">PostgreSQL - Distinct Keyword</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Advanced PostgreSQL</li>
<li><a href="postgresql_constraints.html">PostgreSQL - Constraints</a></li>
<li><a href="postgresql_using_joins.html">PostgreSQL - Joins</a></li>
<li><a href="postgresql_unions_clause.html">PostgreSQL - Unions Clause</a></li>
<li><a href="postgresql_null_values.html">PostgreSQL - NULL Values</a></li>
<li><a href="postgresql_alias_syntax.html">PostgreSQL - Alias Syntax</a></li>
<li><a href="postgresql_triggers.html">PostgreSQL - Triggers</a></li>
<li><a href="postgresql_indexes.html">PostgreSQL - Indexes</a></li>
<li><a href="postgresql_alter_command.html">PostgreSQL - Alter Table Command</a></li>
<li><a href="postgresql_truncate_table.html">Truncate Table Command</a></li>
<li><a href="postgresql_views.html">PostgreSQL - Views</a></li>
<li><a href="postgresql_transactions.html">PostgreSQL - Transactions</a></li>
<li><a href="postgresql_locks.html">PostgreSQL - Locks</a></li>
<li><a href="postgresql_sub_queries.html">PostgreSQL - Sub Queries</a></li>
<li><a href="postgresql_using_autoincrement.html">PostgreSQL -  Auto Increment</a></li>
<li><a href="postgresql_privileges.html">PostgreSQL - Privileges</a></li>
<li><a href="postgresql_date_time.html">Date/Time Functions &amp; Operators</a></li>
<li><a href="postgresql_functions.html">PostgreSQL - Functions</a></li>
<li><a href="postgresql_useful_functions.html">PostgreSQL - Useful Functions</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">PostgreSQL Interfaces</li>
<li><a href="postgresql_c_cpp.html">PostgreSQL - C/C++</a></li>
<li><a href="postgresql_java.html">PostgreSQL - Java</a></li>
<li><a href="postgresql_php.html">PostgreSQL - PHP</a></li>
<li><a href="postgresql_perl.html">PostgreSQL - Perl</a></li>
<li><a href="postgresql_python.html">PostgreSQL - Python</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">PostgreSQL Useful Resources</li>
<li><a href="postgresql_quick_guide.html">PostgreSQL - Quick Guide</a></li>
<li><a href="postgresql_useful_resources.html">PostgreSQL - Useful Resources</a></li>
<li><a href="postgresql_discussion.html">PostgreSQL - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../questions_and_answers.html">Questions and Answers</a></li>
<li><a target="_top" href="../effective_resume_writing.html">Effective Resume Writing</a></li>
<li><a target="_top" href="../hr_interview_questions/index.html">HR Interview Questions</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>PostgreSQL - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="postgresql_python.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="postgresql_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>PostgreSQL - Overview</h1>
<p>PostgreSQL is a powerful, open source object-relational database system. It has more than 15 years of active development phase and a proven architecture that has earned it a strong reputation for reliability, data integrity, and correctness.</p>
<p>This tutorial will give you a quick start with PostgreSQL and make you comfortable with PostgreSQL programming.</p>
<h2>What is PostgreSQL?</h2>
<p>PostgreSQL (pronounced as <b>post-gress-Q-L</b>) is an open source relational database management system (DBMS) developed by a worldwide team of volunteers. PostgreSQL is not controlled by any corporation or other private entity and the source code is available free of charge.</p>
<h3>A Brief History of PostgreSQL</h3>
<p>PostgreSQL, originally called Postgres, was created at UCB by a computer science professor named Michael Stonebraker. Stonebraker started Postgres in 1986 as a follow-up project to its predecessor, Ingres, now owned by Computer Associates.</p>
<ul class="list">
<li><p><b>1977-1985</b> &minus; A project called INGRES was developed.</p>
<ul class="list">
<li><p>Proof-of-concept for relational databases</p></li>
<li><p>Established the company Ingres in 1980</p></li>
<li><p>Bought by Computer Associates in 1994</p></li>
</ul>
</li>
<li><p><b>1986-1994</b> &minus; POSTGRES</p>
<ul class="list">
<li><p>Development of the concepts in INGRES with a focus on object orientation and the query language - Quel</p></li>
<li><p>The code base of INGRES was not used as a basis for POSTGRES</p></li>
<li><p>Commercialized as Illustra (bought by Informix, bought by IBM)</p></li>
</ul>
</li>
<li><p><b>1994-1995</b> &minus; Postgres95</p>
<ul class="list">
<li><p>Support for SQL was added in 1994</p></li>
<li><p>Released as Postgres95 in 1995</p></li>
<li><p>Re-released as PostgreSQL 6.0 in 1996</p></li>
<li><p>Establishment of the PostgreSQL Global Development Team</p></li>
</ul>
</li>
</ul>
<h2>Key Features of PostgreSQL</h2>
<p>PostgreSQL runs on all major operating systems, including Linux, UNIX (AIX, BSD, HP-UX, SGI IRIX, Mac OS X, Solaris, Tru64), and Windows. It supports text, images, sounds, and video, and includes programming interfaces for C / C++, Java, Perl, Python, Ruby, Tcl and Open Database Connectivity (ODBC).</p>
<p>PostgreSQL supports a large part of the SQL standard and offers many modern features including the following &minus;</p>
<ul class="list">
<li>Complex SQL queries</li>
<li>SQL Sub-selects</li>
<li>Foreign keys</li>
<li>Trigger</li>
<li>Views</li>
<li>Transactions</li>
<li>Multiversion concurrency control (MVCC)</li>
<li>Streaming Replication (as of 9.0)</li>
<li>Hot Standby (as of 9.0)</li>
</ul>
<p>You can check official documentation of PostgreSQL to understand the above-mentioned features. PostgreSQL can be extended by the user in many ways. For example by adding new &minus;</p>
<ul class="list">
<li>Data types</li>
<li>Functions</li>
<li>Operators</li>
<li>Aggregate functions</li>
<li>Index methods</li>
</ul>
<h2>Procedural Languages Support</h2>
<p>PostgreSQL supports four standard procedural languages, which allows the users to write their own code in any of the languages and it can be executed by PostgreSQL database server. These procedural languages are - PL/pgSQL, PL/Tcl, PL/Perl and PL/Python. Besides, other non-standard procedural languages like PL/PHP, PL/V8, PL/Ruby, PL/Java, etc., are also supported.</p>
<h1>PostgreSQL - Environment Setup</h1>
<p>To start understanding the PostgreSQL basics, first let us install the PostgreSQL. This chapter explains about installing the PostgreSQL on Linux, Windows and Mac OS platforms.</p>
<h2>Installing PostgreSQL on Linux/Unix</h2>
<p>Follow the given steps to install PostgreSQL on your Linux machine. Make sure you are logged in as <b>root</b> before you proceed for the installation.</p>
<ul class="list">
<li><p>Pick the version number of PostgreSQL you want and, as exactly as possible, the platform you want from <a rel="nofollow" href="https://www.enterprisedb.com/products-services-training/pgdownload" target="_blank">EnterpriseDB</a></p></li>
<li><p>I downloaded <b>postgresql-9.2.4-1-linux-x64.run</b> for my 64 bit CentOS-6 machine. Now, let us execute it as follows &minus;</p></li>
</ul>
<pre class="prettyprint notranslate">
[root@host]# chmod +x postgresql-9.2.4-1-linux-x64.run
[root@host]# ./postgresql-9.2.4-1-linux-x64.run
------------------------------------------------------------------------
Welcome to the PostgreSQL Setup Wizard.

------------------------------------------------------------------------
Please specify the directory where PostgreSQL will be installed.

Installation Directory [/opt/PostgreSQL/9.2]:
</pre>
<ul class="list">
<li><p>Once you launch the installer, it asks you a few basic questions like location of the installation, password of the user who will use database, port number, etc. So keep all of them at their default values except password, which you can provide password as per your choice. It will install PostgreSQL at your Linux machine and will display the following message &minus;</p></li>
</ul>
<pre class="prettyprint notranslate">
Please wait while Setup installs PostgreSQL on your computer.

 Installing
 0% ______________ 50% ______________ 100%
 #########################################

-----------------------------------------------------------------------
Setup has finished installing PostgreSQL on your computer.
</pre>
<ul class="list">
<li><p>Follow the following post-installation steps to create your database &minus;</p></li>
</ul>
<pre class="prettyprint notranslate">
[root@host]# su - postgres
Password:
bash-4.1$ createdb testdb
bash-4.1$ psql testdb
psql (8.4.13, server 9.2.4)

test=#
</pre>
<ul class="list">
<li><p>You can start/restart postgres server in case it is not running using the following command &minus;</p></li>
</ul>
<pre class="prettyprint notranslate">
[root@host]# service postgresql restart
Stopping postgresql service:                               [  OK  ]
Starting postgresql service:                               [  OK  ]
</pre>
<ul class="list">
<li><p>If your installation was correct, you will have PotsgreSQL prompt <b>test=#</b> as shown above.</p></li>
</ul>
<h2>Installing PostgreSQL on Windows</h2>
<p>Follow the given steps to install PostgreSQL on your Windows machine. Make sure you have turned Third Party Antivirus off while installing.</p>
<ul class="list">
<li><p>Pick the version number of PostgreSQL you want and, as exactly as possible, the platform you want from <a rel="nofollow" href="https://www.enterprisedb.com/products-services-training/pgdownload#windows" target="_blank">EnterpriseDB</a></p></li>
<li><p>I downloaded postgresql-9.2.4-1-windows.exe for my Windows PC running in 32bit mode, so let us run <b>postgresql-9.2.4-1-windows.exe</b> as administrator to install PostgreSQL. Select the location where you want to install it. By default, it is installed within Program Files folder.</p></li>
</ul>
<img src="images/postgresql-install-dir.jpg" alt="postgresql install dir" />
<ul class="list">
<li><p>The next step of the installation process would be to select the directory where your data would be stored. By default, it is stored under the "data" directory.</p></li>
</ul>
<img src="images/postgresql-install-data.jpg" alt="postgresql install data dir" />
<ul class="list">
<li><p>Next, the setup asks for password, so you can use your favorite password.</p></li>
</ul>
<img src="images/postgresql-install-password.jpg" alt="postgresql install password" />
<ul class="list">
<li><p>The next step; keep the port as default.</p></li>
</ul>
<img src="images/postgresql-install-port.jpg" alt="postgresql install port" />
<ul class="list">
<li><p>In the next step, when asked for "Locale", I selected "English, United States".</p>
</li>
<li><p>It takes a while to install PostgreSQL on your system. On completion of the installation process, you will get the following screen. Uncheck the checkbox and click the Finish button.</p></li>
</ul>
<img src="images/postgresql-install-finish.jpg" alt="postgresql install finish" />
<p>After the installation process is completed, you can access pgAdmin III, StackBuilder and PostgreSQL shell from your Program Menu under PostgreSQL 9.2.</p>
<h2>Installing PostgreSQL on Mac</h2>
<p>Follow the given steps to install PostgreSQL on your Mac machine. Make sure you are logged in as <b>administrator</b> before you proceed for the installation.</p>
<ul class="list">
<li><p>Pick the latest version number of PostgreSQL for Mac OS available at <a rel="nofollow" href="https://www.enterprisedb.com/products-services-training/pgdownload" target="_blank">EnterpriseDB</a></p></li>
<li><p>I downloaded <b>postgresql-9.2.4-1-osx.dmg</b> for my Mac OS running with  OS X version 10.8.3. Now, let us open the dmg image in finder and just double click it which will give you PostgreSQL installer in the following window &minus;</p></li>
</ul>
<img src="images/postgresql-install-mac.jpg" width="500" alt="postgresql install on Mac" />
<ul class="list">
<li><p>Next, click the <b>postgres-9.2.4-1-osx</b> icon, which will give a warning message. Accept the warning and proceed for further installation. It will ask for the administrator password as seen in the following window &minus;</p></li>
</ul>
<img src="images/postgresql-password-mac.jpg" width="500" alt="postgresql Password on Mac" />
<p>Enter the password, proceed for the installation, and after this step, restart your Mac machine. If you do not see the following window, start your installation once again.</p>
<img src="images/postgresql-startinstall-mac.jpg" width="500" alt="Postgresql Start installation on Mac" />
<ul class="list">
<li><p>Once you launch the installer, it asks you a few basic questions like location of the installation, password of the user who will use database, port number etc. Therefore, keep all of them at their default values except the password, which you can provide as per your choice. It will install PostgreSQL in your Mac machine in the Application folder which you can check &minus;</p></li>
</ul>
<img src="images/postgresql-application-mac.jpg" width="500" alt="Postgresql Application on Mac" />
<ul class="list">
<li><p>Now, you can launch any of the program to start with. Let us start with SQL Shell. When you launch SQL Shell, just use all the default values it displays except, enter your password, which you had selected at the time of installation. If everything goes fine, then you will be inside postgres database and a <b>postgress#</b> prompt will be displayed as shown below &minus;</p></li>
</ul>
<img src="images/postgresql-sqlshell-mac.jpg" width="500" alt="Postgresql SQL Shell on Mac" />
<p>Congratulations!!! Now you have your environment ready to start with PostgreSQL database programming.</p> 
<h1>PostgreSQL - Syntax</h1>
<p>This chapter provides a list of the PostgreSQL SQL commands, followed by the precise syntax rules for each of these commands. This set of commands is taken from the psql command-line tool. Now that you have Postgres installed, open the psql as &minus;</p>
<p><b>Program Files &rarr; PostgreSQL 9.2 &rarr; SQL Shell(psql).</b></p>
<p>Using psql, you can generate a complete list of commands by using the \help command. For the syntax of a specific command, use the following command &minus;</p>
<pre class="result notranslate">
 postgres-# \help &lt;command_name&gt;
</pre>
<h2>The SQL Statement</h2>
<p>An SQL statement is comprised of tokens where each token can represent either a keyword, identifier, quoted identifier, constant, or special character symbol. The table given below uses a simple SELECT statement to illustrate a basic, but complete, SQL statement and its components.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th></th>
<th style="text-align:center;">SELECT</th>
<th style="text-align:center;">id, name</th>
<th style="text-align:center;">FROM</th>
<th style="text-align:center;">states</th>
</tr>
<tr>
<td>Token Type</td>
<td>Keyword</td>
<td>Identifiers</td>
<td>Keyword</td>
<td>Identifier</td>
</tr>
<tr>
<td>Description</td>
<td>Command</td>
<td>Id and name columns</td>
<td>Clause</td>
<td>Table name</td>
</tr>
</table>
<h2>PostgreSQL SQL commands</h2>
<h3>ABORT</h3>
<p>Abort the current transaction.</p>
<pre class="prettyprint notranslate">
ABORT [ WORK | TRANSACTION ]
</pre>
<h3>ALTER AGGREGATE</h3>
<p>Change the definition of an aggregate function.</p>
<pre class="prettyprint notranslate">
ALTER AGGREGATE name ( type ) RENAME TO new_name
ALTER AGGREGATE name ( type ) OWNER TO new_owner
</pre>
<h3>ALTER CONVERSION</h3>
<p>Change the definition of a conversion.</p>
<pre class="prettyprint notranslate">
ALTER CONVERSION name RENAME TO new_name
ALTER CONVERSION name OWNER TO new_owner
</pre>
<h3>ALTER DATABASE</h3>
<p>Change a database specific parameter.</p>
<pre class="prettyprint notranslate">
ALTER DATABASE name SET parameter { TO | = } { value | DEFAULT }
ALTER DATABASE name RESET parameter
ALTER DATABASE name RENAME TO new_name
ALTER DATABASE name OWNER TO new_owner
</pre>
<h3>ALTER DOMAIN</h3>
<p>Change the definition of a domain specific parameter.</p>
<pre class="prettyprint notranslate">
ALTER DOMAIN name { SET DEFAULT expression | DROP DEFAULT }
ALTER DOMAIN name { SET | DROP } NOT NULL
ALTER DOMAIN name ADD domain_constraint
ALTER DOMAIN name DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]
ALTER DOMAIN name OWNER TO new_owner
</pre>
<h3>ALTER FUNCTION</h3>
<p>Change the definition of a function.</p>
<pre class="prettyprint notranslate">
ALTER FUNCTION name ( [ type [, ...] ] ) RENAME TO new_name
ALTER FUNCTION name ( [ type [, ...] ] ) OWNER TO new_owner
</pre>
<h3>ALTER GROUP</h3>
<p>Change a user group.</p>
<pre class="prettyprint notranslate">
ALTER GROUP groupname ADD USER username [, ... ]
ALTER GROUP groupname DROP USER username [, ... ]
ALTER GROUP groupname RENAME TO new_name
</pre>
<h3>ALTER INDEX</h3>
<p>Change the definition of an index.</p>
<pre class="prettyprint notranslate">
ALTER INDEX name OWNER TO new_owner
ALTER INDEX name SET TABLESPACE indexspace_name
ALTER INDEX name RENAME TO new_name
</pre>
<h3>ALTER LANGUAGE</h3>
<p>Change the definition of a procedural language.</p>
<pre class="prettyprint notranslate">
ALTER LANGUAGE name RENAME TO new_name
</pre>
<h3>ALTER OPERATOR</h3>
<p>Change the definition of an operator.</p>
<pre class="prettyprint notranslate">
ALTER OPERATOR name ( { lefttype | NONE }, { righttype | NONE } )
OWNER TO new_owner
</pre>
<h3>ALTER OPERATOR CLASS</h3>
<p>Change the definition of an operator class.</p>
<pre class="prettyprint notranslate">
ALTER OPERATOR CLASS name USING index_method RENAME TO new_name
ALTER OPERATOR CLASS name USING index_method OWNER TO new_owner
</pre>
<h3>ALTER SCHEMA</h3>
<p>Change the definition of a schema.</p>
<pre class="prettyprint notranslate">
ALTER SCHEMA name RENAME TO new_name
ALTER SCHEMA name OWNER TO new_owner
</pre>
<h3>ALTER SEQUENCE</h3>
<p>Change the definition of a sequence generator.</p>
<pre class="prettyprint notranslate">
ALTER SEQUENCE name [ INCREMENT [ BY ] increment ]
[ MINVALUE minvalue | NO MINVALUE ]
[ MAXVALUE maxvalue | NO MAXVALUE ]
[ RESTART [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]
</pre>
<h3>ALTER TABLE</h3>
<p>Change the definition of a table.</p>
<pre class="prettyprint notranslate">
ALTER TABLE [ ONLY ] name [ * ]
action [, ... ]
ALTER TABLE [ ONLY ] name [ * ]
RENAME [ COLUMN ] column TO new_column
ALTER TABLE name
RENAME TO new_name
</pre>
<p>Where <i>action</i> is one of the following lines &minus;</p>
<pre class="prettyprint notranslate">
ADD [ COLUMN ] column_type [ column_constraint [ ... ] ]
DROP [ COLUMN ] column [ RESTRICT | CASCADE ]
ALTER [ COLUMN ] column TYPE type [ USING expression ]
ALTER [ COLUMN ] column SET DEFAULT expression
ALTER [ COLUMN ] column DROP DEFAULT
ALTER [ COLUMN ] column { SET | DROP } NOT NULL
ALTER [ COLUMN ] column SET STATISTICS integer
ALTER [ COLUMN ] column SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
ADD table_constraint
DROP CONSTRAINT constraint_name [ RESTRICT | CASCADE ]
CLUSTER ON index_name
SET WITHOUT CLUSTER
SET WITHOUT OIDS
OWNER TO new_owner
SET TABLESPACE tablespace_name
</pre>
<h3>ALTER TABLESPACE</h3>
<p>Change the definition of a tablespace.</p>
<pre class="prettyprint notranslate">
ALTER TABLESPACE name RENAME TO new_name
ALTER TABLESPACE name OWNER TO new_owner
</pre>
<h3>ALTER TRIGGER</h3>
<p>Change the definition of a trigger.</p>
<pre class="prettyprint notranslate">
ALTER TRIGGER name ON table RENAME TO new_name
</pre>
<h3>ALTER TYPE</h3>
<p>Change the definition of a type.</p>
<pre class="prettyprint notranslate">
ALTER TYPE name OWNER TO new_owner
</pre>
<h3>ALTER USER</h3>
<p>Change a database user account.</p>
<pre class="prettyprint notranslate">
ALTER USER name [ [ WITH ] option [ ... ] ]
ALTER USER name RENAME TO new_name
ALTER USER name SET parameter { TO | = } { value | DEFAULT }
ALTER USER name RESET parameter
</pre>
<p>Where <i>option</i> can be &minus;</p>
<pre class="prettyprint notranslate">
[ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'
| CREATEDB | NOCREATEDB
| CREATEUSER | NOCREATEUSER
| VALID UNTIL 'abstime'
</pre>
<h3>ANALYZE</h3>
<p>Collect statistics about a database.</p>
<pre class="prettyprint notranslate">
ANALYZE [ VERBOSE ] [ table [ (column [, ...] ) ] ]
</pre>
<h3>BEGIN</h3>
<p>Start a transaction block.</p>
<pre class="prettyprint notranslate">
BEGIN [ WORK | TRANSACTION ] [ transaction_mode [, ...] ]
</pre>
<p>Where <i>transaction_mode</i> is one of &minus;</p>
<pre class="prettyprint notranslate">
ISOLATION LEVEL { 
   SERIALIZABLE | REPEATABLE READ | READ COMMITTED
   | READ UNCOMMITTED
}
READ WRITE | READ ONLY
</pre>
<h3>CHECKPOINT</h3>
<p>Force a transaction log checkpoint.</p>
<pre class="prettyprint notranslate">
CHECKPOINT
</pre>
<h3>CLOSE</h3>
<p>Close a cursor.</p>
<pre class="prettyprint notranslate">
CLOSE name
</pre>
<h3>CLUSTER</h3>
<p>Cluster a table according to an index.</p>
<pre class="prettyprint notranslate">
CLUSTER index_name ON table_name
CLUSTER table_name
CLUSTER
</pre>
<h3>COMMENT</h3>
<p>Define or change the comment of an object.</p>
<pre class="prettyprint notranslate">
COMMENT ON {
   TABLE object_name |
   COLUMN table_name.column_name |
   AGGREGATE agg_name (agg_type) |
   CAST (source_type AS target_type) |
   CONSTRAINT constraint_name ON table_name |
   CONVERSION object_name |
   DATABASE object_name |
   DOMAIN object_name |
   FUNCTION func_name (arg1_type, arg2_type, ...) |
   INDEX object_name |
   LARGE OBJECT large_object_oid |
   OPERATOR op (left_operand_type, right_operand_type) |
   OPERATOR CLASS object_name USING index_method |
   [ PROCEDURAL ] LANGUAGE object_name |
   RULE rule_name ON table_name |
   SCHEMA object_name |
   SEQUENCE object_name |
   TRIGGER trigger_name ON table_name |
   TYPE object_name |
   VIEW object_name
} 
IS 'text'
</pre>
<h3>COMMIT</h3>
<p>Commit the current transaction.</p>
<pre class="prettyprint notranslate">
COMMIT [ WORK | TRANSACTION ]
</pre>
<h3>COPY</h3>
<p>Copy data between a file and a table.</p>
<pre class="prettyprint notranslate">
COPY table_name [ ( column [, ...] ) ]
FROM { 'filename' | STDIN }
[ WITH ]
[ BINARY ]
[ OIDS ]
[ DELIMITER [ AS ] 'delimiter' ]
[ NULL [ AS ] 'null string' ]
[ CSV [ QUOTE [ AS ] 'quote' ]
[ ESCAPE [ AS ] 'escape' ]
[ FORCE NOT NULL column [, ...] ]
COPY table_name [ ( column [, ...] ) ]
TO { 'filename' | STDOUT }
[ [ WITH ]
[ BINARY ]
[ OIDS ]
[ DELIMITER [ AS ] 'delimiter' ]
[ NULL [ AS ] 'null string' ]
[ CSV [ QUOTE [ AS ] 'quote' ]
[ ESCAPE [ AS ] 'escape' ]
[ FORCE QUOTE column [, ...] ]
</pre>
<h3>CREATE AGGREGATE</h3>
<p>Define a new aggregate function.</p>
<pre class="prettyprint notranslate">
CREATE AGGREGATE name (
   BASETYPE = input_data_type,
   SFUNC = sfunc,
   STYPE = state_data_type
   [, FINALFUNC = ffunc ]
   [, INITCOND = initial_condition ]
)
</pre>
<h3>CREATE CAST</h3>
<p>Define a new cast.</p>
<pre class="prettyprint notranslate">
CREATE CAST (source_type AS target_type)
WITH FUNCTION func_name (arg_types)
[ AS ASSIGNMENT | AS IMPLICIT ]
CREATE CAST (source_type AS target_type)
WITHOUT FUNCTION
[ AS ASSIGNMENT | AS IMPLICIT ]
</pre>
<h3>CREATE CONSTRAINT TRIGGER</h3>
<p>Define a new constraint trigger.</p>
<pre class="prettyprint notranslate">
CREATE CONSTRAINT TRIGGER name
AFTER events ON
table_name constraint attributes
FOR EACH ROW EXECUTE PROCEDURE func_name ( args )
</pre>
<h3>CREATE CONVERSION</h3>
<p>Define a new conversion.</p>
<pre class="prettyprint notranslate">
CREATE [DEFAULT] CONVERSION name
FOR source_encoding TO dest_encoding FROM func_name
</pre>
<h3>CREATE DATABASE</h3>
<p>Create a new database.</p>
<pre class="prettyprint notranslate">
CREATE DATABASE name
[ [ WITH ] [ OWNER [=] db_owner ]
   [ TEMPLATE [=] template ]
   [ ENCODING [=] encoding ]
   [ TABLESPACE [=] tablespace ] 
]
</pre>
<h3>CREATE DOMAIN</h3>
<p>Define a new domain.</p>
<pre class="prettyprint notranslate">
CREATE DOMAIN name [AS] data_type
[ DEFAULT expression ]
[ constraint [ ... ] ]
</pre>
<p>Where <i>constraint</i> is &minus;</p>
<pre class="prettyprint notranslate">
[ CONSTRAINT constraint_name ]
{ NOT NULL | NULL | CHECK (expression) }
</pre>
<h3>CREATE FUNCTION</h3>
<p>Define a new function.</p>
<pre class="prettyprint notranslate">
CREATE [ OR REPLACE ] FUNCTION name ( [ [ arg_name ] arg_type [, ...] ] )
RETURNS ret_type
{ LANGUAGE lang_name
   | IMMUTABLE | STABLE | VOLATILE
   | CALLED ON NULL INPUT | RETURNS NULL ON NULL INPUT | STRICT
   | [ EXTERNAL ] SECURITY INVOKER | [ EXTERNAL ] SECURITY DEFINER
   | AS 'definition'
   | AS 'obj_file', 'link_symbol'
} ...
[ WITH ( attribute [, ...] ) ]
</pre>
<h3>CREATE GROUP</h3>
<p>Define a new user group.</p>
<pre class="prettyprint notranslate">
CREATE GROUP name [ [ WITH ] option [ ... ] ]
Where option can be:
SYSID gid
| USER username [, ...]
</pre>
<h3>CREATE INDEX</h3>
<p>Define a new index.</p>
<pre class="prettyprint notranslate">
CREATE [ UNIQUE ] INDEX name ON table [ USING method ]
( { column | ( expression ) } [ opclass ] [, ...] )
[ TABLESPACE tablespace ]
[ WHERE predicate ]
</pre>
<h3>CREATE LANGUAGE</h3>
<p>Define a new procedural language.</p>
<pre class="prettyprint notranslate">
CREATE [ TRUSTED ] [ PROCEDURAL ] LANGUAGE name
HANDLER call_handler [ VALIDATOR val_function ]
</pre>
<h3>CREATE OPERATOR</h3>
<p>Define a new operator.</p>
<pre class="prettyprint notranslate">
CREATE OPERATOR name (
   PROCEDURE = func_name
   [, LEFTARG = left_type ] [, RIGHTARG = right_type ]
   [, COMMUTATOR = com_op ] [, NEGATOR = neg_op ]
   [, RESTRICT = res_proc ] [, JOIN = join_proc ]
   [, HASHES ] [, MERGES ]
   [, SORT1 = left_sort_op ] [, SORT2 = right_sort_op ]
   [, LTCMP = less_than_op ] [, GTCMP = greater_than_op ]
)
</pre>
<h3>CREATE OPERATOR CLASS</h3>
<p>Define a new operator class.</p>
<pre class="prettyprint notranslate">
CREATE OPERATOR CLASS name [ DEFAULT ] FOR TYPE data_type
USING index_method AS
{ OPERATOR strategy_number operator_name [ ( op_type, op_type ) ] [ RECHECK ]
   | FUNCTION support_number func_name ( argument_type [, ...] )
   | STORAGE storage_type
} [, ... ]
</pre>
<h3>CREATE RULE</h3>
<p>Define a new rewrite rule.</p>
<pre class="prettyprint notranslate">
CREATE [ OR REPLACE ] RULE name AS ON event
TO table [ WHERE condition ]
DO [ ALSO | INSTEAD ] { NOTHING | command | ( command ; command ... ) }
</pre>
<h3>CREATE SCHEMA</h3>
<p>Define a new schema.</p>
<pre class="prettyprint notranslate">
CREATE SCHEMA schema_name
[ AUTHORIZATION username ] [ schema_element [ ... ] ]
CREATE SCHEMA AUTHORIZATION username
[ schema_element [ ... ] ]
</pre>
<h3>CREATE SEQUENCE</h3>
<p>Define a new sequence generator.</p>
<pre class="prettyprint notranslate">
CREATE [ TEMPORARY | TEMP ] SEQUENCE name
[ INCREMENT [ BY ] increment ]
[ MINVALUE minvalue | NO MINVALUE ]
[ MAXVALUE maxvalue | NO MAXVALUE ]
[ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]
</pre>
<h3>CREATE TABLE</h3>
<p>Define a new table.</p>
<pre class="prettyprint notranslate">
CREATE [ [ GLOBAL | LOCAL ] { 
   TEMPORARY | TEMP } ] TABLE table_name ( { 
      column_name data_type [ DEFAULT default_expr ] [ column_constraint [ ... ] ]
      | table_constraint
      | LIKE parent_table [ { INCLUDING | EXCLUDING } DEFAULTS ] 
   } [, ... ]
)
[ INHERITS ( parent_table [, ... ] ) ]
[ WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE tablespace ]
</pre>
<p>Where <i>column_constraint</i> is &minus;</p>
<pre class="prettyprint notranslate">
[ CONSTRAINT constraint_name ] { 
   NOT NULL |
   NULL |
   UNIQUE [ USING INDEX TABLESPACE tablespace ] |
   PRIMARY KEY [ USING INDEX TABLESPACE tablespace ] |
   CHECK (expression) |
   REFERENCES ref_table [ ( ref_column ) ]
   [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
   [ ON DELETE action ] [ ON UPDATE action ] 
}
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</pre>
<p>And <i>table_constraint</i> is &minus;</p>
<pre class="prettyprint notranslate">
[ CONSTRAINT constraint_name ]
{ UNIQUE ( column_name [, ... ] ) [ USING INDEX TABLESPACE tablespace ] |
PRIMARY KEY ( column_name [, ... ] ) [ USING INDEX TABLESPACE tablespace ] |
CHECK ( expression ) |
FOREIGN KEY ( column_name [, ... ] )
REFERENCES ref_table [ ( ref_column [, ... ] ) ]
[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
[ ON DELETE action ] [ ON UPDATE action ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
</pre>
<h3>CREATE TABLE AS</h3>
<p>Define a new table from the results of a query.</p>
<pre class="prettyprint notranslate">
CREATE [ [ GLOBAL | LOCAL ] { TEMPORARY | TEMP } ] TABLE table_name
[ (column_name [, ...] ) ] [ [ WITH | WITHOUT ] OIDS ]
AS query
</pre>
<h3>CREATE TABLESPACE</h3>
<p>Define a new tablespace.</p>
<pre class="prettyprint notranslate">
CREATE TABLESPACE tablespace_name [ OWNER username ] LOCATION 'directory'
</pre>
<h3>CREATE TRIGGER</h3>
<p>Define a new trigger.</p>
<pre class="prettyprint notranslate">
CREATE TRIGGER name { BEFORE | AFTER } { event [ OR ... ] }
ON table [ FOR [ EACH ] { ROW | STATEMENT } ]
EXECUTE PROCEDURE func_name ( arguments )
</pre>
<h3>CREATE TYPE</h3>
<p>Define a new data type.</p>
<pre class="prettyprint notranslate">
CREATE TYPE name AS
( attribute_name data_type [, ... ] )
CREATE TYPE name (
INPUT = input_function,
OUTPUT = output_function
[, RECEIVE = receive_function ]
[, SEND = send_function ]
[, ANALYZE = analyze_function ]
[, INTERNALLENGTH = { internal_length | VARIABLE } ]
[, PASSEDBYVALUE ]
[, ALIGNMENT = alignment ]
[, STORAGE = storage ]
[, DEFAULT = default ]
[, ELEMENT = element ]
[, DELIMITER = delimiter ]
)
</pre>
<h3>CREATE USER</h3>
<p>Define a new database user account.</p>
<pre class="prettyprint notranslate">
CREATE USER name [ [ WITH ] option [ ... ] ]
</pre>
<p>Where <i>option</i> can be &minus;</p>
<pre class="prettyprint notranslate">
SYSID uid
| [ ENCRYPTED | UNENCRYPTED ] PASSWORD 'password'
| CREATEDB | NOCREATEDB
| CREATEUSER | NOCREATEUSER
| IN GROUP group_name [, ...]
| VALID UNTIL 'abs_time'
</pre>
<h3>CREATE VIEW</h3>
<p>Define a new view.</p>
<pre class="prettyprint notranslate">
CREATE [ OR REPLACE ] VIEW name [ ( column_name [, ...] ) ] AS query
</pre>
<h3>DEALLOCATE</h3>
<p>Deallocate a prepared statement.</p>
<pre class="prettyprint notranslate">
DEALLOCATE [ PREPARE ] plan_name
</pre>
<h3>DECLARE</h3>
<p>Define a cursor.</p>
<pre class="prettyprint notranslate">
DECLARE name [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
CURSOR [ { WITH | WITHOUT } HOLD ] FOR query
[ FOR { READ ONLY | UPDATE [ OF column [, ...] ] } ]
</pre>
<h3>DELETE</h3>
<p>Delete rows of a table.</p>
<pre class="prettyprint notranslate">
DELETE FROM [ ONLY ] table [ WHERE condition ]
</pre>
<h3>DROP AGGREGATE</h3>
<p>Remove an aggregate function.</p>
<pre class="prettyprint notranslate">
DROP AGGREGATE name ( type ) [ CASCADE | RESTRICT ]
</pre>
<h3>DROP CAST</h3>
<p>Remove a cast.</p>
<pre class="prettyprint notranslate">
DROP CAST (source_type AS target_type) [ CASCADE | RESTRICT ]
</pre>
<h3>DROP CONVERSION</h3>
<p>Remove a conversion.</p>
<pre class="prettyprint notranslate">
DROP CONVERSION name [ CASCADE | RESTRICT ]
</pre>
<h3>DROP DATABASE</h3>
<p>Remove a database.</p>
<pre class="prettyprint notranslate">
DROP DATABASE name
</pre>
<h3>DROP DOMAIN</h3>
<p>Remove a domain.</p>
<pre class="prettyprint notranslate">
DROP DOMAIN name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>DROP FUNCTION</h3>
<p>Remove a function.</p>
<pre class="prettyprint notranslate">
DROP FUNCTION name ( [ type [, ...] ] ) [ CASCADE | RESTRICT ]
</pre>
<h3>DROP GROUP</h3>
<p>Remove a user group.</p>
<pre class="prettyprint notranslate">
DROP GROUP name
</pre>
<h3>DROP INDEX</h3>
<p>Remove an index.</p>
<pre class="prettyprint notranslate">
DROP INDEX name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>DROP LANGUAGE</h3>
<p>Remove a procedural language.</p>
<pre class="prettyprint notranslate">
DROP [ PROCEDURAL ] LANGUAGE name [ CASCADE | RESTRICT ]
</pre>
<h3>DROP OPERATOR</h3>
<p>Remove an operator.</p>
<pre class="prettyprint notranslate">
DROP OPERATOR name ( { left_type | NONE }, { right_type | NONE } )
[ CASCADE | RESTRICT ]
</pre>
<h3>DROP OPERATOR CLASS</h3>
<p>Remove an operator class.</p>
<pre class="prettyprint notranslate">
DROP OPERATOR CLASS name USING index_method [ CASCADE | RESTRICT ]
</pre>
<h3>DROP RULE</h3>
<p>Remove a rewrite rule.</p>
<pre class="prettyprint notranslate">
DROP RULE name ON relation [ CASCADE | RESTRICT ]
</pre>
<h3>DROP SCHEMA</h3>
<p>Remove a schema.</p>
<pre class="prettyprint notranslate">
DROP SCHEMA name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>DROP SEQUENCE</h3>
<p>Remove a sequence.</p>
<pre class="prettyprint notranslate">
DROP SEQUENCE name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>DROP TABLE</h3>
<p>Remove a table.</p>
<pre class="prettyprint notranslate">
DROP TABLE name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>DROP TABLESPACE</h3>
<p>Remove a tablespace.</p>
<pre class="prettyprint notranslate">
DROP TABLESPACE tablespace_name
</pre>
<h3>DROP TRIGGER</h3>
<p>Remove a trigger.</p>
<pre class="prettyprint notranslate">
DROP TRIGGER name ON table [ CASCADE | RESTRICT ]
</pre>
<h3>DROP TYPE</h3>
<p>Remove a data type.</p>
<pre class="prettyprint notranslate">
DROP TYPE name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>DROP USER</h3>
<p>Remove a database user account.</p>
<pre class="prettyprint notranslate">
DROP USER name
</pre>
<h3>DROP VIEW</h3>
<p>Remove a view.</p>
<pre class="prettyprint notranslate">
DROP VIEW name [, ...] [ CASCADE | RESTRICT ]
</pre>
<h3>END</h3>
<p>Commit the current transaction.</p>
<pre class="prettyprint notranslate">
END [ WORK | TRANSACTION ]
</pre>
<h3>EXECUTE</h3>
<p>Execute a prepared statement.</p>
<pre class="prettyprint notranslate">
EXECUTE plan_name [ (parameter [, ...] ) ]
</pre>
<h3>EXPLAIN</h3>
<p>Show the execution plan of a statement.</p>
<pre class="prettyprint notranslate">
EXPLAIN [ ANALYZE ] [ VERBOSE ] statement
</pre>
<h3>FETCH</h3>
<p>Retrieve rows from a query using a cursor.</p>
<pre class="prettyprint notranslate">
FETCH [ direction { FROM | IN } ] cursor_name
</pre>
<p>Where <i>direction</i> can be empty or one of &minus;</p>
<pre class="prettyprint notranslate">
NEXT
PRIOR
FIRST
LAST
ABSOLUTE count
RELATIVE count
count
ALL
FORWARD
FORWARD count
FORWARD ALL
BACKWARD
BACKWARD count
BACKWARD ALL
</pre>
<h3>GRANT</h3>
<p>Define access privileges.</p>
<pre class="prettyprint notranslate">
GRANT { { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }
[,...] | ALL [ PRIVILEGES ] }
ON [ TABLE ] table_name [, ...]
TO { username | GROUP group_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { { CREATE | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }
ON DATABASE db_name [, ...]
TO { username | GROUP group_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { CREATE | ALL [ PRIVILEGES ] }
ON TABLESPACE tablespace_name [, ...]
TO { username | GROUP group_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { EXECUTE | ALL [ PRIVILEGES ] }
ON FUNCTION func_name ([type, ...]) [, ...]
TO { username | GROUP group_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] }
ON LANGUAGE lang_name [, ...]
TO { username | GROUP group_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]

GRANT { { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }
ON SCHEMA schema_name [, ...]
TO { username | GROUP group_name | PUBLIC } [, ...] [ WITH GRANT OPTION ]
</pre>
<h3>INSERT</h3>
<p>Create new rows in a table.</p>
<pre class="prettyprint notranslate">
INSERT INTO table [ ( column [, ...] ) ]
{ DEFAULT VALUES | VALUES ( { expression | DEFAULT } [, ...] ) | query }
</pre>
<h3>LISTEN</h3>
<p>Listen for a notification.</p>
<pre class="prettyprint notranslate">
LISTEN name
</pre>
<h3>LOAD</h3>
<p>Load or reload a shared library file.</p>
<pre class="prettyprint notranslate">
LOAD 'filename'
</pre>
<h3>LOCK</h3>
<p>Lock a table.</p>
<pre class="prettyprint notranslate">
LOCK [ TABLE ] name [, ...] [ IN lock_mode MODE ] [ NOWAIT ]
</pre>
<p>Where <i>lock_mode</i> is one of &minus;</p>
<pre class="prettyprint notranslate">
ACCESS SHARE | ROW SHARE | ROW EXCLUSIVE | SHARE UPDATE EXCLUSIVE
| SHARE | SHARE ROW EXCLUSIVE | EXCLUSIVE | ACCESS EXCLUSIVE
</pre>
<h3>MOVE</h3>
<p>Position a cursor.</p>
<pre class="prettyprint notranslate">
MOVE [ direction { FROM | IN } ] cursor_name
</pre>
<h3>NOTIFY</h3>
<p>Generate a notification.</p>
<pre class="prettyprint notranslate">
NOTIFY name
</pre>
<h3>PREPARE</h3>
<p>Prepare a statement for execution.</p>
<pre class="prettyprint notranslate">
PREPARE plan_name [ (data_type [, ...] ) ] AS statement
</pre>
<h3>REINDEX</h3>
<p>Rebuild indexes.</p>
<pre class="prettyprint notranslate">
REINDEX { DATABASE | TABLE | INDEX } name [ FORCE ]
</pre>
<h3>RELEASE SAVEPOINT</h3>
<p>Destroy a previously defined savepoint.</p>
<pre class="prettyprint notranslate">
RELEASE [ SAVEPOINT ] savepoint_name
</pre>
<h3>RESET</h3>
<p>Restore the value of a runtime parameter to the default value.</p>
<pre class="prettyprint notranslate">
RESET name
RESET ALL
</pre>
<h3>REVOKE</h3>
<p>Remove access privileges.</p>
<pre class="prettyprint notranslate">
REVOKE [ GRANT OPTION FOR ]
{ { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }
[,...] | ALL [ PRIVILEGES ] }
ON [ TABLE ] table_name [, ...]
FROM { username | GROUP group_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { CREATE | TEMPORARY | TEMP } [,...] | ALL [ PRIVILEGES ] }
ON DATABASE db_name [, ...]
FROM { username | GROUP group_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ CREATE | ALL [ PRIVILEGES ] }
ON TABLESPACE tablespace_name [, ...]
FROM { username | GROUP group_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ EXECUTE | ALL [ PRIVILEGES ] }
ON FUNCTION func_name ([type, ...]) [, ...]
FROM { username | GROUP group_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ USAGE | ALL [ PRIVILEGES ] }
ON LANGUAGE lang_name [, ...]
FROM { username | GROUP group_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ]

REVOKE [ GRANT OPTION FOR ]
{ { CREATE | USAGE } [,...] | ALL [ PRIVILEGES ] }
ON SCHEMA schema_name [, ...]
FROM { username | GROUP group_name | PUBLIC } [, ...]
[ CASCADE | RESTRICT ]
</pre>
<h3>ROLLBACK</h3>
<p>Abort the current transaction.</p>
<pre class="prettyprint notranslate">
ROLLBACK [ WORK | TRANSACTION ]
</pre>
<h3>ROLLBACK TO SAVEPOINT</h3>
<p>Roll back to a savepoint.</p>
<pre class="prettyprint notranslate">
ROLLBACK [ WORK | TRANSACTION ] TO [ SAVEPOINT ] savepoint_name
</pre>

<h3>SAVEPOINT</h3>
<p>Define a new savepoint within the current transaction.</p>
<pre class="prettyprint notranslate">
SAVEPOINT savepoint_name
</pre>

<h3>SELECT</h3>
<p>Retrieve rows from a table or view.</p>
<pre class="prettyprint notranslate">
SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
* | expression [ AS output_name ] [, ...]
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY expression [, ...] ]
[ HAVING condition [, ...] ]
[ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [, ...] ]
[ LIMIT { count | ALL } ]
[ OFFSET start ]
[ FOR UPDATE [ OF table_name [, ...] ] ]
</pre>
Where <i>from_item</i> can be one of:
<pre class="prettyprint notranslate">
[ ONLY ] table_name [ * ] [ [ AS ] alias [ ( column_alias [, ...] ) ] ]
( select ) [ AS ] alias [ ( column_alias [, ...] ) ]
function_name ( [ argument [, ...] ] )
[ AS ] alias [ ( column_alias [, ...] | column_definition [, ...] ) ]
function_name ( [ argument [, ...] ] ) AS ( column_definition [, ...] )
from_item [ NATURAL ] join_type from_item
[ ON join_condition | USING ( join_column [, ...] ) ]
</pre>

<h3>SELECT INTO</h3>
<p>Define a new table from the results of a query.</p>
<pre class="prettyprint notranslate">
SELECT [ ALL | DISTINCT [ ON ( expression [, ...] ) ] ]
* | expression [ AS output_name ] [, ...]
INTO [ TEMPORARY | TEMP ] [ TABLE ] new_table
[ FROM from_item [, ...] ]
[ WHERE condition ]
[ GROUP BY expression [, ...] ]
[ HAVING condition [, ...] ]
[ { UNION | INTERSECT | EXCEPT } [ ALL ] select ]
[ ORDER BY expression [ ASC | DESC | USING operator ] [, ...] ]
[ LIMIT { count | ALL } ]
[ OFFSET start ]
[ FOR UPDATE [ OF table_name [, ...] ] ]
</pre>
<h3>SET</h3>
<p>Change a runtime parameter.</p>
<pre class="prettyprint notranslate">
SET [ SESSION | LOCAL ] name { TO | = } { value | 'value' | DEFAULT }
SET [ SESSION | LOCAL ] TIME ZONE { time_zone | LOCAL | DEFAULT }
</pre>
<h3>SET CONSTRAINTS</h3>
<p>Set constraint checking modes for the current transaction.</p>
<pre class="prettyprint notranslate">
SET CONSTRAINTS { ALL | name [, ...] } { DEFERRED | IMMEDIATE }
</pre>
<h3>SET SESSION AUTHORIZATION</h3>
<p>Set the session user identifier and the current user identifier of the current session.</p>
<pre class="prettyprint notranslate">
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION username
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT
RESET SESSION AUTHORIZATION
</pre>
<h3>SET TRANSACTION</h3>
<p>Set the characteristics of the current transaction.</p>
<pre class="prettyprint notranslate">
SET TRANSACTION transaction_mode [, ...]
SET SESSION CHARACTERISTICS AS TRANSACTION transaction_mode [, ...]
</pre>
<p>Where <i>transaction_mode</i> is one of &minus;</p>
<pre class="prettyprint notranslate">
ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED
| READ UNCOMMITTED }
READ WRITE | READ ONLY
</pre>
<h3>SHOW</h3>
<p>Show the value of a runtime parameter.</p>
<pre class="prettyprint notranslate">
SHOW name
SHOW ALL
</pre>
<h3>START TRANSACTION</h3>
<p>Start a transaction block.</p>
<pre class="prettyprint notranslate">
START TRANSACTION [ transaction_mode [, ...] ]
</pre>
<p>Where <i>transaction_mode</i> is one of &minus;</p>
<pre class="prettyprint notranslate">
ISOLATION LEVEL { SERIALIZABLE | REPEATABLE READ | READ COMMITTED
| READ UNCOMMITTED }
READ WRITE | READ ONLY
</pre>
<h3>TRUNCATE</h3>
<p>Empty a table.</p>
<pre class="prettyprint notranslate">
TRUNCATE [ TABLE ] name
</pre>
<h3>UNLISTEN</h3>
<p>Stop listening for a notification.</p>
<pre class="prettyprint notranslate">
UNLISTEN { name | * }
</pre>
<h3>UPDATE</h3>
<p>Update rows of a table.</p>
<pre class="prettyprint notranslate">
UPDATE [ ONLY ] table SET column = { expression | DEFAULT } [, ...]
[ FROM from_list ]
[ WHERE condition ]
</pre>
<h3>VACUUM</h3>
<p>Garbage-collect and optionally analyze a database.</p>
<pre class="prettyprint notranslate">
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table ]
VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] ANALYZE [ table [ (column [, ...] ) ] ]
</pre>
<h1>PostgreSQL - Data Type</h1>
<p>In this chapter, we will discuss about the data types used in PostgreSQL. While creating table, for each column, you specify a data type, i.e., what kind of data you want to store in the table fields.</p>
<p>This enables several benefits &minus;</p>
<ul class="list" >
<li><p><b>Consistency</b> &minus; Operations against columns of same data type give consistent results and are usually the fastest.</p>
</li>
<li><p><b>Validation</b> &minus; Proper use of data types implies format validation of data and rejection of data outside the scope of data type.</p></li>
<li><p><b>Compactness</b> &minus; As a column can store a single type of value, it is stored in a compact way.</p></li>
<li><p><b>Performance</b> &minus; Proper use of data types gives the most efficient storage of data. The values stored can be processed quickly, which enhances the performance.</p></li>
</ul>
<p>PostgreSQL supports a wide set of Data Types. Besides, users can create their own custom data type using <i>CREATE TYPE</i> SQL command. There are different categories of data types in PostgreSQL. They are discussed below.</p>
<h2>Numeric Types</h2>
<p>Numeric types consist of two-byte, four-byte, and eight-byte integers, four-byte and eight-byte floating-point numbers, and selectable-precision decimals. The following table lists the available types.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;width:20%">Storage Size</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Range</th>
</tr>
<tr>
<td style="vertical-align:middle;">smallint</td>
<td style="vertical-align:middle;">2 bytes</td>
<td style="vertical-align:middle;">small-range integer</td>
<td style="vertical-align:middle;">-32768 to +32767</td>
</tr>
<tr>
<td style="vertical-align:middle;">integer</td>
<td style="vertical-align:middle;">4 bytes</td>
<td style="vertical-align:middle;">typical choice for integer</td>
<td style="vertical-align:middle;">-2147483648 to +2147483647</td>
</tr>
<tr>
<td style="vertical-align:middle;">bigint</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">large-range integer</td>
<td style="vertical-align:middle;">-9223372036854775808 to 9223372036854775807</td>
</tr>
<tr>
<td style="vertical-align:middle;">decimal</td>
<td style="vertical-align:middle;">variable</td>
<td style="vertical-align:middle;">user-specified precision,exact</td>
<td>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</td>
</tr>
<tr>
<td style="vertical-align:middle;">numeric</td>
<td style="vertical-align:middle;">variable</td>
<td style="vertical-align:middle;">user-specified precision,exact</td>
<td>up to 131072 digits before the decimal point; up to 16383 digits after the decimal point</td>
</tr>
<tr>
<td style="vertical-align:middle;">real</td>
<td style="vertical-align:middle;">4 bytes</td>
<td style="vertical-align:middle;">variable-precision,inexact</td>
<td style="vertical-align:middle;">6 decimal digits precision</td>
</tr>
<tr>
<td style="vertical-align:middle;">double precision</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">variable-precision,inexact</td>
<td style="vertical-align:middle;">15 decimal digits precision</td>
</tr>
<tr>
<td style="vertical-align:middle;">smallserial</td>
<td style="vertical-align:middle;">2 bytes</td>
<td style="vertical-align:middle;">small autoincrementing integer</td>
<td style="vertical-align:middle;">1 to 32767</td>
</tr>
<tr>
<td style="vertical-align:middle;">serial</td>
<td style="vertical-align:middle;">4 bytes</td>
<td style="vertical-align:middle;">autoincrementing integer</td>
<td style="vertical-align:middle;">1 to 2147483647</td>
</tr>
<tr>
<td style="vertical-align:middle;">bigserial</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">large autoincrementing integer</td>
<td style="vertical-align:middle;">1 to 9223372036854775807</td>
</tr>
</table>
<h2>Monetary Types</h2>
<p>The <i>money</i> type stores a currency amount with a fixed fractional precision. Values of the <i>numeric, int, and bigint</i> data types can be cast to <i>money</i>. Using Floating point numbers is not recommended to handle money due to the potential for rounding errors.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;width:20%">Storage Size</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Range</th>
</tr>
<tr>
<td style="vertical-align:middle;">money</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">currency amount</td>
<td>-92233720368547758.08 to +92233720368547758.07</td>
</tr>
</table>
<h2>Character Types</h2>
<p>The table given below lists the general-purpose character types available in PostgreSQL.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>character varying(n), varchar(n)</b></p>
<p>variable-length with limit</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>character(n), char(n)</b></p>
<p>fixed-length, blank padded</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>text</b></p>
<p>variable unlimited length</p></td>
</tr>
</table>
<h2>Binary Data Types</h2>
<p>The <i>bytea</i> data type allows storage of binary strings as in the table given below.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;">Storage Size</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="vertical-align:middle;">bytea</td>
<td style="vertical-align:middle;">1 or 4 bytes plus the actual binary string</td>
<td style="vertical-align:middle;">variable-length binary string</td>
</tr>
</table>
<h2>Date/Time Types</h2>
<p>PostgreSQL supports a full set of SQL date and time types, as shown in table below. Dates are counted according to the Gregorian calendar. Here, all the types have resolution of <b>1 microsecond / 14 digits</b> except <b>date</b> type, whose resolution is <b>day</b>.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;width:20%">Storage Size</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Low Value</th>
<th style="text-align:center;width:20%">High Value</th>
</tr>
<tr>
<td style="vertical-align:middle;">timestamp [(p)] [without time zone ]</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">both date and time (no time zone)</td>
<td style="vertical-align:middle;">4713 BC</td>
<td style="vertical-align:middle;">294276 AD</td>
</tr>
<tr>
<td style="vertical-align:middle;">timestamp [(p) ] with time zone</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">both date and time, with time zone</td>
<td style="vertical-align:middle;">4713 BC</td>
<td style="vertical-align:middle;">294276 AD</td>
</tr>
<tr>
<td style="vertical-align:middle;">date</td>
<td style="vertical-align:middle;">4 bytes</td>
<td style="vertical-align:middle;">date (no time of day)</td>
<td style="vertical-align:middle;">4713 BC</td>
<td style="vertical-align:middle;">5874897 AD</td>
</tr>
<tr>
<td style="vertical-align:middle;">time [ (p)] [ without time zone ]</td>
<td style="vertical-align:middle;">8 bytes</td>
<td style="vertical-align:middle;">time of day (no date)</td>
<td style="vertical-align:middle;">00:00:00</td>
<td style="vertical-align:middle;">24:00:00</td>
</tr>
<tr>
<td style="vertical-align:middle;">time [ (p)] with time zone</td>
<td style="vertical-align:middle;">12 bytes</td>
<td style="vertical-align:middle;">times of day only, with time zone</td>
<td style="vertical-align:middle;">00:00:00+1459</td>
<td style="vertical-align:middle;">24:00:00-1459</td>
</tr>
<tr>
<td style="vertical-align:middle;">interval [fields ] [(p) ]</td>
<td style="vertical-align:middle;">12 bytes</td>
<td style="vertical-align:middle;">time interval</td>
<td style="vertical-align:middle;">-178000000 years</td>
<td style="vertical-align:middle;">178000000 years</td>
</tr>
</table>
<h2>Boolean Type</h2>
<p>PostgreSQL provides the standard SQL type Boolean. The Boolean data type can have the states <i>true</i>, <i>false</i>, and a third state, <i>unknown</i>, which is represented by the SQL null value.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;">Storage Size</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="vertical-align:middle;">boolean</td>
<td style="vertical-align:middle;">1 byte</td>
<td style="vertical-align:middle;">state of true or false</td>
</tr>
</table>
<h2>Enumerated Type</h2>
<p>Enumerated (enum) types are data types that comprise a static, ordered set of values. They are equivalent to the enum types supported in a number of programming languages.</p>
<p>Unlike other types, Enumerated Types need to be created using CREATE TYPE command. This type is used to store a static, ordered set of values. For example compass directions, i.e., NORTH, SOUTH, EAST, and WEST or days of the week as shown below &minus;</p>
<pre class="prettyprint notranslate">
CREATE TYPE week AS ENUM ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');
</pre>
<p>Enumerated, once created, can be used like any other types.</p>
<h2>Geometric Type</h2>
<p>Geometric data types represent two-dimensional spatial objects. The most fundamental type, the point, forms the basis for all of the other types.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;width:20%">Storage Size</th>
<th style="text-align:center;">Representation</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="vertical-align:middle;">point</td>
<td style="vertical-align:middle;">16 bytes</td>
<td>Point on a plane</td>
<td style="vertical-align:middle;">(x,y)</td>
</tr>
<tr>
<td style="vertical-align:middle;">line</td>
<td style="vertical-align:middle;">32 bytes</td>
<td>Infinite line (not fully implemented)</td>
<td>((x1,y1),(x2,y2))</td>
</tr>
<tr>
<td style="vertical-align:middle;">lseg</td>
<td style="vertical-align:middle;">32 bytes</td>
<td>Finite line segment</td>
<td>((x1,y1),(x2,y2))</td>
</tr>
<tr>
<td style="vertical-align:middle;">box</td>
<td style="vertical-align:middle;">32 bytes</td>
<td>Rectangular box</td>
<td>((x1,y1),(x2,y2))</td>
</tr>
<tr>
<td style="vertical-align:middle;">path</td>
<td style="vertical-align:middle;">16+16n bytes</td>
<td>Closed path (similar to polygon)</td>
<td style="vertical-align:middle;">((x1,y1),...)</td>
</tr>
<tr>
<td style="vertical-align:middle;">path</td>
<td style="vertical-align:middle;">16+16n bytes</td>
<td style="vertical-align:middle;">Open path</td>
<td style="vertical-align:middle;">[(x1,y1),...]</td>
</tr>
<tr>
<td style="vertical-align:middle;">polygon</td>
<td style="vertical-align:middle;">40+16n</td>
<td>Polygon (similar to closed path)</td>
<td style="vertical-align:middle;">((x1,y1),...)</td>
</tr>
<tr>
<td style="vertical-align:middle;">circle</td>
<td style="vertical-align:middle;">24 bytes</td>
<td style="vertical-align:middle;">Circle</td>
<td>&lt;(x,y),r&gt; (center point and radius)</td>
</tr>
</table>
<h2>Network Address Type</h2>
<p>PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses. It is better to use these types instead of plain text types to store network addresses, because these types offer input error checking and specialized operators and functions.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;">Storage Size</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="vertical-align:middle;">cidr</td>
<td style="vertical-align:middle;">7 or 19 bytes</td>
<td>IPv4 and IPv6 networks</td>
</tr>
<tr>
<td style="vertical-align:middle;">inet</td>
<td style="vertical-align:middle;">7 or 19 bytes</td>
<td>IPv4 and IPv6 hosts and networks</td>
</tr>
<tr>
<td style="vertical-align:middle;">macaddr</td>
<td style="vertical-align:middle;">6 bytes</td>
<td>MAC addresses</td>
</tr>
</table>
<h2>Bit String Type</h2>
<p>Bit String Types are used to store bit masks. They are either 0 or 1. There are two SQL bit types: <b>bit(n)</b> and <b>bit varying(n)</b>, where n is a positive integer.</p>
<h2>Text Search Type</h2>
<p>This type supports full text search, which is the activity of searching through a collection of natural-language documents to locate those that best match a query. There are two Data Types for this  &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>tsvector</b></p>
<p>This is a sorted list of distinct words that have been normalized to merge different variants of the same word, called as "lexemes".</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>tsquery</b></p>
<p>This stores lexemes that are to be searched for, and combines them honoring the Boolean operators &amp; (AND), | (OR), and ! (NOT). Parentheses can be used to enforce grouping of the operators.</p></td>
</tr>
</table>
<h2>UUID Type</h2>
<p>A UUID (Universally Unique Identifiers) is written as a sequence of lower-case hexadecimal digits, in several groups separated by hyphens, specifically a group of eight digits, followed by three groups of four digits, followed by a group of 12 digits, for a total of 32 digits representing the 128 bits.</p>
<p>An example of a UUID is &minus; 550e8400-e29b-41d4-a716-446655440000</p>
<h2>XML Type</h2>
<p>The XML data type can be used to store XML data. For storing XML data, first you have to create XML values using the function xmlparse as follows &minus;</p>
<pre class="prettyprint notranslate">
XMLPARSE (DOCUMENT '&lt;?xml version="1.0"?&gt;
&lt;tutorial&gt;
&lt;title&gt;PostgreSQL Tutorial &lt;/title&gt;
   &lt;topics&gt;...&lt;/topics&gt;
&lt;/tutorial&gt;')

XMLPARSE (CONTENT 'xyz&lt;foo&gt;bar&lt;/foo&gt;&lt;bar&gt;foo&lt;/bar&gt;')
</pre>
<h2>JSON Type</h2>
<p>The <i>json</i> data type can be used to store JSON (JavaScript Object Notation) data. Such data can also be stored as <i>text</i>, but the <i>json</i> data type has the advantage of checking that each stored value is a valid JSON value. There are also related support functions available, which can be used directly to handle JSON data type as follows.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Example</th>
<th style="text-align:center;">Example Result</th>
</tr>
<tr>
<td>array_to_json('{{1,5},{99,100}}'::int[])</td>
<td>[[1,5],[99,100]]</td>
</tr>
<tr>
<td>row_to_json(row(1,'foo'))</td>
<td>{"f1":1,"f2":"foo"}</td>
</tr>
</table>
<h2>Array Type</h2>
<p>PostgreSQL gives the opportunity to define a column of a table as a variable length multidimensional array. Arrays of any built-in or user-defined base type, enum type, or composite type can be created.</p>
<h3>Declaration of Arrays</h3>
<p>Array type can be declared as</p>
<pre class="prettyprint notranslate">
CREATE TABLE monthly_savings (
   name text,
   saving_per_quarter integer[],
   scheme text[][]
);
</pre>
<p>or by using the keyword "ARRAY" as</p>
<pre class="prettyprint notranslate">
CREATE TABLE monthly_savings (
   name text,
   saving_per_quarter integer ARRAY[4],
   scheme text[][]
);
</pre>
<h3>Inserting values</h3>
<p>Array values can be inserted as a literal constant, enclosing the element values within curly braces and separating them by commas. An example is shown below &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO monthly_savings 
VALUES (‘Manisha’, 
‘{20000, 14600, 23500, 13250}’, 
‘{{“FD”, “MF”}, {“FD”, “Property”}}’); 
</pre>
<h3>Accessing Arrays</h3>
<p>An example for accessing Arrays is shown below. The command given below will select the persons whose savings are more in second quarter than fourth quarter.</p>
<pre class="prettyprint notranslate">
SELECT name FROM monhly_savings WHERE saving_per_quarter[2] &gt; saving_per_quarter[4];
</pre>
<h3>Modifying Arrays</h3>
<p>An example of modifying arrays is as shown below.</p>
<pre class="prettyprint notranslate">
UPDATE monthly_savings SET saving_per_quarter = '{25000,25000,27000,27000}'
WHERE name = 'Manisha';
</pre>
<p>or using the ARRAY expression syntax &minus;</p>
<pre class="prettyprint notranslate">
UPDATE monthly_savings SET saving_per_quarter = ARRAY[25000,25000,27000,27000]
WHERE name = 'Manisha';
</pre>
<h3>Searching Arrays</h3>
<p>An example of searching arrays is as shown below.</p>
<pre class="prettyprint notranslate">
SELECT * FROM monthly_savings WHERE saving_per_quarter[1] = 10000 OR
saving_per_quarter[2] = 10000 OR
saving_per_quarter[3] = 10000 OR
saving_per_quarter[4] = 10000;
</pre>
<p>If the size of array is known, the search method given above can be used. Else, the following example shows how to search when the size is not known.</p>
<pre class="prettyprint notranslate">
SELECT * FROM monthly_savings WHERE 10000 = ANY (saving_per_quarter);
</pre>
<h2>Composite Types</h2>
<p>This type represents a list of field names and their data types, i.e., structure of a row or record of a table.</p>
<h3>Declaration of Composite Types</h3>
<p>The following example shows how to declare a composite type</p>
<pre class="prettyprint notranslate">
CREATE TYPE inventory_item AS (
   name text,
   supplier_id integer,
   price numeric
);
</pre>
<p>This data type can be used in the create tables as below &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE on_hand (
   item inventory_item,
   count integer
);
</pre>
<h3>Composite Value Input</h3>
<p>Composite values can be inserted as a literal constant, enclosing the field values within parentheses and separating them by commas. An example is shown below &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);
</pre>
<p>This is valid for the <i>inventory_item</i> defined above. The ROW keyword is actually optional as long as you have more than one field in the expression.</p>
<h3>Accessing Composite Types</h3>
<p>To access a field of a composite column, use a dot followed by the field name, much like selecting a field from a table name. For example, to select some subfields from our on_hand example table, the query would be as shown below &minus;</p>
<pre class="prettyprint notranslate">
SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;
</pre>
<p>You can even use the table name as well (for instance in a multitable query), like this &minus;</p>
<pre class="prettyprint notranslate">
SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;
</pre>
<h2>Range Types</h2>
<p>Range types represent data types that uses a range of data. Range type can be discrete ranges (e.g., all integer values 1 to 10) or continuous ranges (e.g., any point in time between 10:00am and 11:00am).</p>
<p>The built-in range types available include the following ranges &minus;</p>
<ul class="list">
<li><p><b>int4range</b> &minus;  Range of integer</p></li>
<li><p><b>int8range</b> &minus;  Range of bigint</p></li>
<li><p><b>numrange</b> &minus;  Range of numeric</p></li>
<li><p><b>tsrange</b> &minus;  Range of timestamp without time zone</p></li>
<li><p><b>tstzrange</b> &minus;  Range of timestamp with time zone</p></li>
<li><p><b>daterange</b> &minus;  Range of date</p></li>
</ul>
<p>Custom range types can be created to make new types of ranges available, such as IP address ranges using the inet type as a base, or float ranges using the float data type as a base.</p>
<p>Range types support inclusive and exclusive range boundaries using the [ ] and ( ) characters, respectively. For example '[4,9)' represents all the integers starting from and including 4 up to but not including 9.</p>
<h2>Object Identifier Types</h2>
<p>Object identifiers (OIDs) are used internally by PostgreSQL as primary keys for various system tables. If <i> WITH OIDS</i> is specified or <i>default_with_oids</i> configuration variable is enabled, only then, in such cases OIDs are added to user-created tables. The following table lists several alias types. The OID alias types have no operations of their own except for specialized input and output routines.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;">References</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Value Example</th>
</tr>
<tr>
<td style="vertical-align:middle;">oid</td>
<td style="vertical-align:middle;">any</td>
<td>numeric object identifier</td>
<td style="vertical-align:middle;">564182</td>
</tr>
<tr>
<td style="vertical-align:middle;">regproc</td>
<td style="vertical-align:middle;">pg_proc</td>
<td>function name</td>
<td style="vertical-align:middle;">sum</td>
</tr>
<tr>
<td style="vertical-align:middle;">regprocedure</td>
<td style="vertical-align:middle;">pg_proc</td>
<td>function with argument types</td>
<td style="vertical-align:middle;">sum(int4)</td>
</tr>
<tr>
<td style="vertical-align:middle;">regoper</td>
<td style="vertical-align:middle;">pg_operator</td>
<td>operator name</td>
<td style="vertical-align:middle;">+</td>
</tr>
<tr>
<td style="vertical-align:middle;">regoperator</td>
<td style="vertical-align:middle;">pg_operator</td>
<td>operator with argument types</td>
<td>*(integer,integer) or -(NONE,integer)</td>
</tr>
<tr>
<td style="vertical-align:middle;">regclass</td>
<td style="vertical-align:middle;">pg_class</td>
<td style="vertical-align:middle;">relation name</td>
<td style="vertical-align:middle;">pg_type</td>
</tr>
<tr>
<td style="vertical-align:middle;">regtype</td>
<td style="vertical-align:middle;">pg_type</td>
<td>data type name</td>
<td style="vertical-align:middle;">integer</td>
</tr>
<tr>
<td style="vertical-align:middle;">regconfig</td>
<td style="vertical-align:middle;">pg_ts_config</td>
<td>text search configuration</td>
<td style="vertical-align:middle;">English</td>
</tr>
<tr>
<td style="vertical-align:middle;">regdictionary</td>
<td style="vertical-align:middle;">pg_ts_dict</td>
<td>text search dictionary</td>
<td style="vertical-align:middle;">simple</td>
</tr>
</table>
<h2>Pseudo Types</h2>
<p>The PostgreSQL type system contains a number of special-purpose entries that are collectively called pseudo-types. A pseudo-type cannot be used as a column data type, but it can be used to declare a function's argument or result type.</p>
<p>The table given below lists the existing pseudo-types.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Name &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>any</b></p>
<p>Indicates that a function accepts any input data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>anyelement</b></p>
<p>Indicates that a function accepts any data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>anyarray</b></p>
<p>Indicates that a function accepts any array data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>anynonarray</b></p>
<p>Indicates that a function accepts any non-array data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>anyenum</b></p>
<p>Indicates that a function accepts any enum data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>anyrange</b></p>
<p>Indicates that a function accepts any range data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>cstring</b></p>
<p>Indicates that a function accepts or returns a null-terminated C string.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>internal</b></p>
<p>Indicates that a function accepts or returns a server-internal data type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>language_handler</b></p>
<p>A procedural language call handler is declared to return language_handler.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">10</td>
<td><p><b>fdw_handler</b></p>
<p>A foreign-data wrapper handler is declared to return fdw_handler.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">11</td>
<td><p><b>record</b></p>
<p>Identifies a function returning an unspecified row type.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">12</td>
<td><p><b>trigger</b></p>
<p>A trigger function is declared to return trigger.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">13</td>
<td><p><b>void</b></p>
<p>Indicates that a function returns no value.</p></td>
</tr>
</table>
<h1>PostgreSQL - CREATE Database</h1>
<p>This chapter discusses about how to create a new database in your PostgreSQL. PostgreSQL provides two ways of creating a new database &minus;</p>
<ul class="list">
<li>Using  CREATE DATABASE, an SQL command.</li>
<li>Using <i>createdb</i> a command-line executable.</li>
</ul>
<h2>Using CREATE DATABASE</h2>
<p>This command will create a database from PostgreSQL shell prompt, but you should have appropriate privilege to create a database. By default, the new database will be created by cloning the standard system database <i>template1</i>.</p>
<h3>Syntax</h3>
<p>The basic syntax of CREATE DATABASE statement is as follows &minus;</p>
<pre class="result notranslate">
CREATE DATABASE dbname;
</pre>
<p>where <i>dbname</i> is the name of a database to create.</p>
<h3>Example</h3>
<p>The following is a simple example, which will create <b>testdb</b> in your PostgreSQL schema</p>
<pre class="prettyprint notranslate">
postgres=# CREATE DATABASE testdb;
postgres-# 
</pre>
<h2>Using createdb Command</h2>
<p>PostgreSQL command line executable <i>createdb</i> is a wrapper around the SQL command <i>CREATE DATABASE</i>. The only difference  between this command and SQL command <i>CREATE DATABASE</i> is that the former can be directly run from the command line and it allows a comment to be added into the database, all in one command.</p>
<h3>Syntax</h3>
<p>The syntax for <i>createdb</i> is as shown below &minus;</p>
<pre class="result notranslate">
createdb [option...] [dbname [description]]
</pre>
<h3>Parameters</h3>
<p>The table given below lists the parameters with their descriptions.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Parameter &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>dbname</b></p>
<p>The name of a database to create.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>description</b></p>
<p>Specifies a comment to be associated with the newly created database.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>options</b></p>
<p>command-line arguments, which createdb accepts.</p></td>
</tr>
</table>
<h3>Options</h3>
<p>The following table lists the command line arguments createdb accepts &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%;">S. No.</th>
<th style="text-align:center;">Option &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>-D tablespace</b></p>
<p>Specifies the default tablespace for the database.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>-e</b></p>
<p>Echo the commands that createdb generates and sends to the server.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>-E encoding</b></p>
<p>Specifies the character encoding scheme to be used in this database.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>-l locale</b></p>
<p>Specifies the locale to be used in this database.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>-T template</b></p>
<p>Specifies the template database from which to build this database.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>--help</b></p>
<p>Show help about createdb command line arguments, and exit.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>-h host</b></p>
<p>Specifies the host name of the machine on which the server is running.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>-p port</b></p>
<p>Specifies the TCP port or the local Unix domain socket file extension on which the server is listening for connections.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>-U username</b></p>
<p>User name to connect as.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">10</td>
<td><p><b>-w</b></p>
<p>Never issue a password prompt.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">11</td>
<td><p><b>-W</b></p>
<p>Force createdb to prompt for a password before connecting to a database.</p></td>
</tr>
</table>
<p>Open the command prompt and go to the directory where PostgreSQL is installed. Go to the bin directory and execute the following command to create a database.</p>
<pre class="prettyprint notranslate">
createdb -h localhost -p 5432 -U postgres testdb
password ******
</pre>
<p>The above given command will prompt you for password of the PostgreSQL admin user, which is <b>postgres</b>, by default. Hence, provide a password and proceed to create your new database</p>
<p>Once a database is created using either of the above-mentioned methods, you can check it in the list of databases using <b>\l</b>, i.e., backslash el command as follows &minus;</p>
<pre class="prettyprint notranslate">
postgres-# \l
                             List of databases
   Name    |  Owner   | Encoding | Collate | Ctype |   Access privileges   
-----------+----------+----------+---------+-------+-----------------------
 postgres  | postgres | UTF8     | C       | C     | 
 template0 | postgres | UTF8     | C       | C     | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 template1 | postgres | UTF8     | C       | C     | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 testdb    | postgres | UTF8     | C       | C     | 
(4 rows)

postgres-# 
</pre>
<h1>PostgreSQL - SELECT Database</h1>
<p>This chapter explains various methods of accessing the database. Assume that we have already created a database in our previous chapter. You can select the database using either of the following methods &minus;</p>
<ul class="list">
<li>Database SQL Prompt</li>
<li>OS Command Prompt</li>
</ul>
<h2>Database SQL Prompt</h2>
<p>Assume you have already launched your PostgreSQL client and you have landed at the following SQL prompt &minus;</p>
<pre class="result notranslate">
postgres=#
</pre>
<p>You can check the available database list using <b>\l</b>, i.e., backslash el command as follows &minus;</p>
<pre class="prettyprint notranslate">
postgres-# \l
                             List of databases
   Name    |  Owner   | Encoding | Collate | Ctype |   Access privileges   
-----------+----------+----------+---------+-------+-----------------------
 postgres  | postgres | UTF8     | C       | C     | 
 template0 | postgres | UTF8     | C       | C     | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 template1 | postgres | UTF8     | C       | C     | =c/postgres          +
           |          |          |         |       | postgres=CTc/postgres
 testdb    | postgres | UTF8     | C       | C     | 
(4 rows)

postgres-# 
</pre>
<p>Now, type the following command to connect/select a desired database; here, we will connect to the <i>testdb </i> database.</p>
<pre class="prettyprint notranslate">
postgres=# \c testdb;
psql (9.2.4)
Type "help" for help.
You are now connected to database "testdb" as user "postgres".
testdb=# 
</pre>
<h2>OS Command Prompt</h2>
<p>You can select your database from the command prompt itself at the time when you login to your database. Following is a simple example &minus;</p>
<pre class="prettyprint notranslate">
psql -h localhost -p 5432 -U postgress testdb
Password for user postgress: ****
psql (9.2.4)
Type "help" for help.
You are now connected to database "testdb" as user "postgres".
testdb=# 
</pre>
<p>You are now logged into PostgreSQL testdb and ready to execute your commands inside testdb. To exit from the database, you can use the command \q.</p>
<h1>PostgreSQL - DROP Database</h1>
<p>In this chapter, we will discuss how to delete the database in PostgreSQL. There are two options to delete a database &minus;</p>
<ul class="list">
<li>Using DROP DATABASE, an SQL command.</li>
<li>Using <i>dropdb</i> a command-line executable.</li>
</ul>
<blockquote>Be careful before using this operation because deleting an existing database would result in loss of complete information stored in the database.</blockquote>
<h3>Using DROP DATABASE</h3>
<p>This command drops a database. It removes the catalog entries for the database and deletes the directory containing the data. It can only be executed by the database owner. This command cannot be executed while you or anyone else is connected to the target database (connect to postgres or any other database to issue this command).</p>
<h3>Syntax</h3>
<p>The syntax for DROP DATABASE is given below &minus;</p>
<pre class="result notranslate">
DROP DATABASE [ IF EXISTS ] name
</pre>
<h3>Parameters</h3>
<p>The table lists the parameters with their descriptions.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Parameter &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>IF EXISTS</b></p>
<p>Do not throw an error if the database does not exist. A notice is issued in this case.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>name</b></p>
<p>The name of the database to remove.</p></td>
</tr>
</table>
<blockquote>We cannot drop a database that has any open connections, including our own connection from <i> psql</i> or <i>pgAdmin III</i>. We must switch to another database or <i>template1</i> if we want to delete the database we are currently connected to. Thus, it might be more convenient to use the program <i>dropdb</i> instead, which is a wrapper around this command.</blockquote>
<h3>Example</h3>
<p>The following is a simple example, which will delete <b>testdb</b> from your PostgreSQL schema &minus;</p>
<pre class="prettyprint notranslate">
postgres=# DROP DATABASE testdb;
postgres-# 
</pre>
<h2>Using dropdb Command</h2>
<p>PostgresSQL command line executable <b>dropdb</b> is a command-line wrapper around the SQL command <i>DROP DATABASE</i>. There is no effective difference between dropping databases via this utility and via other methods for accessing the server. dropdb destroys an existing PostgreSQL database. The user, who executes this command must be a database super user or the owner of the database.</p>
<h3>Syntax</h3>
<p>The syntax for <i>dropdb</i> is as shown below &minus;</p>
<pre class="result notranslate">
dropdb  [option...] dbname
</pre>
<h3>Parameters</h3>
<p>The following table lists the parameters with their descriptions</p>
<table class="table table-bordered">
<tr>
<th style="width:11%;">S. No.</th>
<th style="text-align:center;">Parameter &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>dbname</b></p>
<p>The name of a database to be deleted.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>option</b></p>
<p>command-line arguments, which dropdb accepts.</p></td>
</tr>
</table>
<h3>Options</h3>
<p>The following table lists the command-line arguments dropdb accepts &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%;">S. No.</th>
<th style="text-align:center;">Option &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>-e</b></p>
<p>Shows the commands being sent to the server.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>-i</b></p>
<p>Issues a verification prompt before doing anything destructive.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>-V</b></p>
<p>Print the dropdb version and exit.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>--if-exists</b></p>
<p>Do not throw an error if the database does not exist. A notice is issued in this case.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>--help</b></p>
<p>Show help about dropdb command-line arguments, and exit.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>-h host</b></p>
<p>Specifies the host name of the machine on which the server is running.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>-p port</b></p>
<p>Specifies the TCP port or the local UNIX domain socket file extension on which the server is listening for connections.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>-U username</b></p>
<p>User name to connect as.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>-w</b></p>
<p>Never issue a password prompt.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">10</td>
<td><p><b>-W</b></p>
<p>Force dropdb to prompt for a password before connecting to a database.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">11</td>
<td>
<p><b>--maintenance-db=dbname</b></p>
<p>Specifies the name of the database to connect to in order to drop the target database.</p></td>
</tr>
</table>
<h2>Example</h2>
<p>The following example demonstrates deleting a database from OS command prompt &minus;</p>
<pre class="prettyprint notranslate">
dropdb -h localhost -p 5432 -U postgress testdb
Password for user postgress: ****
</pre>
<p>The above command drops the database <b>testdb</b>. Here, I have used the <b>postgres</b> (found under the pg_roles of template1) username to drop the database.</p>
<h1>PostgreSQL - CREATE Table</h1>
<p>The PostgreSQL CREATE TABLE statement is used to create a new table in any of the given database.</p>
<h2>Syntax</h2>
<p>Basic syntax of CREATE TABLE  statement is as follows &minus;</p>
<pre class="result notranslate">
CREATE TABLE table_name(
   column1 datatype,
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
   PRIMARY KEY( one or more columns )
);
</pre>
<p>CREATE TABLE is a keyword, telling the database system to create a new table. The unique name or identifier for the table follows the CREATE TABLE statement. Initially, the empty table in the current database is owned by the user issuing the command.</p>
<p>Then, in brackets, comes the list, defining each column in the table and what sort of data type it is. The syntax will become clear with an example given below.</p>
<h2>Examples</h2>
<p>The following is an example, which creates a COMPANY table with ID as primary key and NOT NULL are the constraints showing that these fields cannot be NULL while creating records in this table &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<p>Let us create one more table, which we will use in our exercises in subsequent chapters &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE DEPARTMENT(
   ID INT PRIMARY KEY      NOT NULL,
   DEPT           CHAR(50) NOT NULL,
   EMP_ID         INT      NOT NULL
);
</pre>
<p>You can verify if your table has been created successfully using <b>\d</b> command, which will be used to list down all the tables in an attached database.</p>
<pre class="prettyprint notranslate">
testdb-# \d
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
           List of relations
 Schema |    Name    | Type  |  Owner
--------+------------+-------+----------
 public | company    | table | postgres
 public | department | table | postgres
(2 rows)
</pre>
<p>Use <b>\d <i>tablename</i></b> to describe each table as shown below &minus;</p>
<pre class="prettyprint notranslate">
testdb-# \d company
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
        Table "public.company"
  Column   |     Type      | Modifiers
-----------+---------------+-----------
 id        | integer       | not null
 name      | text          | not null
 age       | integer       | not null
 address   | character(50) |
 salary    | real          |
 join_date | date          |
Indexes:
    "company_pkey" PRIMARY KEY, btree (id)
</pre>
<h1>PostgreSQL - DROP Table</h1>
<p>The PostgreSQL DROP TABLE statement is used to remove a table definition and all associated data, indexes, rules, triggers, and constraints for that table.</p>
<blockquote>You have to be careful while using this command because once a table is deleted then all the information available in the table would also be lost forever.</blockquote>
<h2>Syntax</h2>
<p>Basic syntax of DROP TABLE statement is as follows &minus;</p>
<pre class="result notranslate">
DROP TABLE table_name;
</pre>
<h2>Example</h2>
<p>We had created the tables DEPARTMENT and COMPANY in the previous chapter. First, verify these tables (use <b>\d</b> to list the tables) &minus;</p>
<pre class="prettyprint notranslate">
testdb-# \d
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
           List of relations
 Schema |    Name    | Type  |  Owner
--------+------------+-------+----------
 public | company    | table | postgres
 public | department | table | postgres
(2 rows)
</pre>
<p>This means DEPARTMENT and COMPANY tables are present. So let us drop them as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# drop table department, company;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
DROP TABLE
testdb=# \d
relations found.
testdb=# 
</pre>
<p>The message returned DROP TABLE indicates that drop command is executed successfully.</p>
<h1>PostgreSQL - Schema</h1>
<p>A <b>schema</b> is a named collection of tables. A schema can also contain views, indexes, sequences, data types, operators, and functions. Schemas are analogous to directories at the operating system level, except that schemas cannot be nested. PostgreSQL statement CREATE SCHEMA creates a schema.</p>
<h3>Syntax</h3>
<p>The basic syntax of CREATE SCHEMA is as follows &minus;</p>
<pre class="result notranslate">
CREATE SCHEMA name;
</pre>
<p>Where <i>name</i> is the name of the schema.</p>
<h2>Syntax to Create Table in Schema</h2>
<p>The basic syntax to create table in schema is as follows &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE myschema.mytable (
...
);
</pre>
<h3>Example</h3>
<p>Let us see an example for creating a schema. Connect to the database <i>testdb</i> and create a schema <i> myschema</i> as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# create schema myschema;
CREATE SCHEMA
</pre>
<p>The message "CREATE SCHEMA" signifies that the schema is created successfully.</p>
<p>Now, let us create a table in the above schema as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# create table myschema.company(
   ID   INT              NOT NULL,
   NAME VARCHAR (20)     NOT NULL,
   AGE  INT              NOT NULL,
   ADDRESS  CHAR (25),
   SALARY   DECIMAL (18, 2),
   PRIMARY KEY (ID)
);
</pre>
<p>This will create an empty table. You can verify the table created with the command given below &minus;</p>
<pre class="prettyprint notranslate">
testdb=# select * from myschema.company;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name | age | address | salary
----+------+-----+---------+--------
(0 rows)
</pre>
<h2>Syntax to Drop Schema</h2>
<p>To drop a schema if it is empty (all objects in it have been dropped), use the command &minus;</p>
<pre class="prettyprint notranslate">
DROP SCHEMA myschema;
</pre>
<p>To drop a schema including all contained objects, use the command &minus;</p>
<pre class="prettyprint notranslate">
DROP SCHEMA myschema CASCADE;
</pre>
<h3>Advantages of using a Schema</h3>
<ul class="list">
<li><p>It allows many users to use one database without interfering with each other.</p></li>
<li><p>It organizes database objects into logical groups to make them more manageable.</p></li>
<li><p>Third-party applications can be put into separate schemas so they do not collide with the names of other objects.</p></li>
</ul>
<h1>PostgreSQL - INSERT Query</h1>
<p>The PostgreSQL <b>INSERT INTO</b> statement allows one to insert new rows into a table. One can insert a single row at a time or several rows as a result of a query.</p>
<h2>Syntax</h2>
<p>Basic syntax of INSERT INTO statement is as follows &minus;</p>
<pre class="result notranslate">
INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)
VALUES (value1, value2, value3,...valueN);
</pre>
<ul class="list">
<li><p>Here, column1, column2,...columnN are the names of the columns in the table into which you want to insert data.</p></li>
<li><p>The target column names can be listed in any order. The values supplied by the VALUES clause or query are associated with the explicit or implicit column list left-to-right.</p></li>
</ul>
<p>You may not need to specify the column(s) name in the SQL query if you are adding values for all the columns of the table. However, make sure the order of the values is in the same order as the columns in the table. The SQL INSERT INTO syntax would be as follows &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);
</pre>
<h2>Output</h2>
<p>The following table summarizes the output messages and their meaning &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%;">S. No.</th>
<th style="text-align:center;">Output Message &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>INSERT oid 1</b></p>
<p>Message returned if only one row was inserted. oid is the numeric OID of the inserted row.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>INSERT 0 #</b></p>
<p>Message returned if more than one rows were inserted. # is the number of rows inserted.</p></td>
</tr>
</table>
<h2>Examples</h2>
<p>Let us create COMPANY table in <b>testdb</b> as follows &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL,
   JOIN_DATE	  DATE
);
</pre>
<p>The following example inserts a row into the COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) VALUES (1, 'Paul', 32, 'California', 20000.00,'2001-07-13');
</pre>
<p>The following example is to insert a row; here <i>salary</i> column is omitted and therefore it will have the default value &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,JOIN_DATE) VALUES (2, 'Allen', 25, 'Texas', '2007-12-13');
</pre>
<p>The following example uses the DEFAULT clause for the ADDRESS columns rather than specifying a value &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) VALUES (3, 'Teddy', 23, 'Norway', 20000.00, DEFAULT );
</pre>
<p>The following example inserts multiple rows using the multirow VALUES syntax &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00, '2007-12-13' ), (5, 'David', 27, 'Texas', 85000.00, '2007-12-13');
</pre>
<p>All the above statements would create the following records in COMPANY table. The next chapter will teach you how to display all these records from a table.</p>
<pre class="result notranslate">

ID        NAME        AGE        ADDRESS     SALARY	  JOIN_DATE
----      ----------  -----      ----------  -------      --------
1         Paul        32         California  20000.0      2001-07-13
2         Allen       25         Texas                    2007-12-13
3         Teddy       23         Norway      20000.0
4         Mark        25         Rich-Mond   65000.0      2007-12-13
5         David       27         Texas       85000.0      2007-12-13

</pre>
<h1>PostgreSQL - SELECT Query</h1>
<p>PostgreSQL <b>SELECT</b> statement is used to fetch the data from a  database table, which returns data in the form of result table.  These result tables are called result-sets.</p>
<h2>Syntax</h2>
<p>The basic syntax of SELECT statement is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN FROM table_name;
</pre>
<p>Here, column1, column2...are the fields of a table, whose values you want to fetch. If you want to fetch all the fields available in the field then you can use the following syntax &minus;</p>
<pre class="prettyprint notranslate">
SELECT * FROM table_name;
</pre>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which would fetch ID, Name and Salary fields of the customers available in CUSTOMERS table &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT ID, NAME, SALARY FROM COMPANY ;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
  id | name  | salary
 ----+-------+--------
   1 | Paul  |  20000
   2 | Allen |  15000
   3 | Teddy |  20000
   4 | Mark  |  65000
   5 | David |  85000
   6 | Kim   |  45000
   7 | James |  10000
(7 rows)
</pre>
<p>If you want to fetch all the fields of CUSTOMERS table, then use the following query &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<h1>PostgreSQL - Operators</h1>
<h3>What is an Operator in PostgreSQL?</h3>
<p>An operator is a reserved word or a character used primarily in a PostgreSQL statement's WHERE clause to perform operation(s), such as comparisons and arithmetic operations.</p>
<p>Operators are used to specify conditions in a PostgreSQL statement and to serve as conjunctions for multiple conditions in a statement.</p>
<ul class="list">
<li>Arithmetic operators</li>
<li>Comparison operators</li>
<li>Logical operators</li>
<li>Bitwise operators</li>
</ul>
<h2>PostgreSQL Arithmetic Operators</h2>
<p>Assume variable <b>a</b> holds 2 and variable <b>b</b> holds 3, then &minus;</p>
<p><a href="postgresql_arithmetic-operators.html">Example</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Operator</th>
<th style="text-align:center;width:45%">Description</th>
<th style="text-align:center">Example</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td>Addition - Adds values on either side of the operator</td>
<td style="text-align:center;vertical-align:middle;">a + b will give 5</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td>Subtraction - Subtracts right hand operand from left hand operand</td>
<td style="text-align:center;vertical-align:middle;">a - b will give -1</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">*</td>
<td>Multiplication - Multiplies values on either side of the operator</td>
<td style="text-align:center;vertical-align:middle;">a * b will give 6</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">/</td>
<td>Division - Divides left hand operand by right hand operand</td>
<td style="text-align:center;vertical-align:middle;">b / a will give 1</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">%</td>
<td>Modulus - Divides left hand operand by right hand operand and returns remainder</td>
<td style="text-align:center;vertical-align:middle;">b % a will give 1</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">^</td>
<td>Exponentiation - This gives the exponent value of the right hand operand</td>
<td style="text-align:center;vertical-align:middle;">a ^ b will give 8</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">|/</td>
<td style="text-align:center;vertical-align:middle;">square root</td>
<td style="text-align:center;vertical-align:middle;">|/ 25.0 will give 5</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">||/</td>
<td style="text-align:center;vertical-align:middle;">Cube root</td>
<td style="text-align:center;vertical-align:middle;">||/ 27.0 will give 3</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">!</td>
<td style="text-align:center;vertical-align:middle;">factorial</td>
<td style="text-align:center;vertical-align:middle;">5 ! will give 120</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">!!</td>
<td style="text-align:center;vertical-align:middle;">factorial (prefix operator)</td>
<td style="text-align:center;vertical-align:middle;">!! 5 will give 120</td>
</tr>
</tr>
</table>
<h2>PostgreSQL Comparison Operators</h2>
<p>Assume variable a holds 10 and variable b holds 20, then &minus;</p>
<p><a href="postgresql_comparison-operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Operator</th>
<th style="text-align:center;width:55%">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">=</td>
<td>Checks if the values of two operands are equal or not, if yes then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a = b) is not true.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">!=</td>
<td>Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a != b) is true.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&lt;&gt;</td>
<td>Checks if the values of two operands are equal or not, if values are not equal then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a &lt;&gt; b) is true.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&gt;</td>
<td>Checks if the value of left  operand is greater than the value of right operand, if yes then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a &gt; b) is not true.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&lt;</td>
<td>Checks if the value of left  operand is less than the value of right operand, if yes then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a &lt; b) is true.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&gt;=</td>
<td>Checks if the value of left  operand is greater than or equal to the value of right operand, if yes then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a &gt;= b) is not true.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&lt;=</td>
<td>Checks if the value of left  operand is less than or equal to the value of right operand, if yes then condition becomes true.</td>
<td style="text-align:center;vertical-align:middle;">(a &lt;= b) is true.</td>
</tr>
</table>
<h2>PostgreSQL Logical Operators</h2>
<p>Here is a list of all the logical operators available in PostgresSQL.</p>
<p><a href="postgresql_logical-operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Operator &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>AND</b></p>
<p>The AND operator allows the existence of multiple conditions in a PostgresSQL statement's WHERE clause.</p></td>
</tr>
<tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>NOT</b></p>
<p>The NOT operator reverses the meaning of the logical operator with which it is used. Eg. NOT EXISTS, NOT BETWEEN, NOT IN etc. <b>This is negate operator</b>.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>OR</b></p>
<p>The OR operator is used to combine multiple conditions in a PostgresSQL statement's WHERE clause.</p></td>
</tr>
</table>
<h2>PostgreSQL Bit String Operators</h2>
<p>Bitwise operator works on bits and performs bit-by-bit operation. The truth table for &amp; and | is as follows &minus;</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">p</th>
<th style="text-align:center;">q</th>
<th style="text-align:center;">p &amp; q</th>
<th style="text-align:center;">p | q</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</table>
<p>Assume if A = 60; and B = 13; now in binary format they will be as follows &minus;</p>
<p>A = 0011 1100</p>
<p>B = 0000 1101</p>
<p>-----------------</p>
<p>A&amp;B = 0000 1100</p>
<p>A|B = 0011 1101</p>
<p>~A&nbsp; = 1100 0011</p>
<p><a href="postgresql_bitwise-operators.html">Show Examples</a></p>
<p>The Bitwise operators supported by PostgreSQL are listed in the following table &minus;</p>
<table class="table table-bordered">
<tr>
<th  style="text-align:center;width:10%">Operator</th>
<th style="text-align:center;width:45%">Description</th>
<th style="text-align:center;">Example</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&amp;</td>
<td>Binary AND Operator copies a bit to the result if it exists in both operands.</td>
<td style="text-align:center;vertical-align:middle;">(A &amp; B) will give 12 which is 0000 1100</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">|</td>
<td>Binary OR Operator copies a bit if it exists in either operand.</td>
<td style="text-align:center;vertical-align:middle;">(A | B) will give 61 which is 0011 1101</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">~</td>
<td style="vertical-align:middle;">Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.</td>
<td>(~A ) will give -61 which is 1100 0011 in 2's complement form due to a signed binary number.</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&lt;&lt;</td>
<td>Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.</td>
<td style="text-align:center;vertical-align:middle;">A &lt;&lt; 2 will give 240 which is 1111 0000</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">&gt;&gt;</td>
<td>Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.</td>
<td style="text-align:center;vertical-align:middle;">A &gt;&gt; 2 will give 15 which is 0000 1111</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">#</td>
<td style="text-align:center;vertical-align:middle;">bitwise XOR.</td>
<td style="text-align:center;vertical-align:middle;">A # B  will give 49 which is 0100 1001</td>
</tr>
</table>
<h1>PostgreSQL - Expressions</h1>
<p>An expression is a combination of one or more values, operators, and PostgresSQL functions that evaluate to a value.</p>
<p>PostgreSQL EXPRESSIONS are like formulas and they are written in query language. You can also use to query the database for specific set of data.</p>
<h3>Syntax</h3>
<p>Consider the basic syntax of the SELECT statement as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN
FROM table_name
WHERE [CONDITION | EXPRESSION];
</pre>
<p>There are different types of PostgreSQL expressions, which are mentioned below &minus;</p>
<h2>PostgreSQL - Boolean Expressions</h2>
<p>PostgreSQL Boolean Expressions fetch the data on the basis of matching single value. Following is the syntax &minus;</p>
<pre class="prettyprint notranslate">
SELECT column1, column2, columnN
FROM table_name
WHERE SINGLE VALUE MATCHTING EXPRESSION;
</pre>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Here is the simple example showing usage of PostgreSQL Boolean Expressions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE SALARY = 10000;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address  | salary
----+-------+-----+----------+--------
  7 | James |  24 | Houston  |  10000
(1 row)
</pre>
<h2>PostgreSQL - Numeric Expression</h2>
<p>These expressions are used to perform any mathematical operation in any query. Following is the syntax &minus;</p>
<pre class="prettyprint notranslate">
SELECT numerical_expression as  OPERATION_NAME
[FROM table_name WHERE CONDITION] ;
</pre>
<p>Here numerical_expression is used for mathematical expression or any formula. Following is a simple example showing usage of SQL Numeric Expressions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT (15 + 6) AS ADDITION ;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 addition
----------
       21
(1 row)
</pre>
<p>There are several built-in functions like avg(), sum(), count() to perform what is known as aggregate data calculations against a table or a specific table column.</p>
<pre class="prettyprint notranslate">
testdb=# SELECT COUNT(*) AS "RECORDS" FROM COMPANY;
</pre>
<p>The above given  PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 RECORDS
---------
       7
(1 row)
</pre>
<h2>PostgreSQL - Date Expressions</h2>
<p>Date Expressions return the current system date and time values and these expressions are used in various data manipulations.</p>
<pre class="prettyprint notranslate">
testdb=#  SELECT CURRENT_TIMESTAMP;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
              now
-------------------------------
 2013-05-06 14:38:28.078+05:30
(1 row)
</pre>
<h1>PostgreSQL - WHERE Clause</h1>
<p>The PostgreSQL WHERE clause is used to specify a condition while fetching the data from single table or joining with multiple tables.</p>
<p>If the given condition is satisfied, only then it returns specific value from the table. You can filter out rows that you do not want included in the result-set by using the WHERE clause.</p>
<p>The WHERE clause not only is used in SELECT statement, but it is also used in UPDATE, DELETE statement, etc., which we would examine in subsequent chapters.</p>
<h2>Syntax</h2>
<p>The basic syntax of SELECT statement with WHERE clause is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN
FROM table_name
WHERE [search_condition]
</pre>
<p>You can specify a <i>search_condition</i> using <a href="postgresql_operators.html">comparison or logical operators.</a> like &gt;, &lt;, =, LIKE, NOT, etc. The following examples would make this concept clear.</p>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Here are simple examples showing usage of PostgreSQL Logical Operators. Following SELECT statement will list down all the records where AGE is greater than or equal to 25 <b>AND</b> salary is greater than or equal to 65000.00 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age |  address   | salary
----+-------+-----+------------+--------
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
(2 rows)
 </pre>
<p>The following SELECT statement lists down all the records where AGE is greater than or equal to 25 <b>OR</b> salary is greater than or equal to 65000.00 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  1 | Paul  |  32 | California  |  20000
  2 | Allen |  25 | Texas       |  15000
  4 | Mark  |  25 | Rich-Mond   |  65000
  5 | David |  27 | Texas       |  85000
(4 rows)
</pre>
<p>The following SELECT statement lists down all the records where AGE is not NULL which means all the records, because none of the record has AGE equal to NULL &minus;</p>
<pre class="prettyprint notranslate">
testdb=#  SELECT * FROM COMPANY WHERE AGE IS NOT NULL;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
  id | name  | age | address    | salary
 ----+-------+-----+------------+--------
   1 | Paul  |  32 | California |  20000
   2 | Allen |  25 | Texas      |  15000
   3 | Teddy |  23 | Norway     |  20000
   4 | Mark  |  25 | Rich-Mond  |  65000
   5 | David |  27 | Texas      |  85000
   6 | Kim   |  22 | South-Hall |  45000
   7 | James |  24 | Houston    |  10000
(7 rows)
</pre>
<p>The following SELECT statement lists down all the records where NAME starts with 'Pa', does not matter what comes after 'Pa'.</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE NAME LIKE 'Pa%';
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name | age |address    | salary
----+------+-----+-----------+--------
  1 | Paul |  32 | California|  20000
</pre>
<p>The following SELECT statement lists down all the records where AGE value is either 25 or 27 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  2 | Allen |  25 | Texas      |  15000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
(3 rows)
</pre>
<p>The following SELECT statement lists down all the records where AGE value is neither 25 nor 27 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  3 | Teddy |  23 | Norway     |  20000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
(4 rows)
</pre>
<p>The following SELECT statement lists down all the records where AGE value is in BETWEEN 25 AND 27 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  2 | Allen |  25 | Texas      |  15000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
(3 rows)
</pre>
<p>The following SELECT statement makes use of SQL subquery where subquery finds all the  records with AGE field having SALARY &gt; 65000 and later WHERE clause is being used along with EXISTS operator to list down all the records where AGE from the outside query exists in the result returned by sub-query &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT AGE FROM COMPANY
        WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 age
-----
  32
  25
  23
  25
  27
  22
  24
(7 rows)
</pre>
<p>The following SELECT statement makes use of SQL subquery where subquery finds all the records with AGE field having SALARY &gt; 65000 and later WHERE clause is being used along with &gt; operator to list down all the records where AGE from outside query is greater than the age in the result returned by sub-query &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY
        WHERE AGE &gt; (SELECT AGE FROM COMPANY WHERE SALARY &gt; 65000);
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name | age | address    | salary
----+------+-----+------------+--------
  1 | Paul |  32 | California |  20000
</pre>
<h1>AND and OR Conjunctive Operators</h1>
<p>The PostgreSQL <b>AND</b> and <b>OR</b> operators are used to combine multiple conditions to narrow down selected data in a PostgreSQL statement. These two operators are called conjunctive operators.</p>
<p>These operators provide a means to make multiple comparisons with different operators in the same PostgreSQL statement.</p>
<h2>The AND Operator</h2>
<p>The <b>AND</b> operator allows the existence of multiple conditions in a PostgreSQL statement's WHERE clause. While using AND operator, complete condition will be assumed true when all the conditions are true. For example [condition1] AND [condition2] will be true only when both condition1 and condition2 are true.</p>
<h3>Syntax</h3>
<p>The basic syntax of AND operator with WHERE clause is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN
FROM table_name
WHERE [condition1] AND [condition2]...AND [conditionN];
</pre>
<p>You can combine N number of conditions using AND operator. For an action to be taken by the PostgreSQL statement, whether it be a transaction or query, all conditions separated by the AND must be TRUE.</p>
<h3>Example</h3>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following SELECT statement lists down all the records where AGE is greater than or equal to 25 <b>AND</b> salary is greater than or equal to 65000.00 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE &gt;= 25 AND SALARY &gt;= 65000;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
(2 rows)
</pre>
<h2>The OR Operator</h2>
<p>The OR operator is also used to combine multiple conditions in a PostgreSQL statement's WHERE clause. While using OR operator, complete condition will be assumed true when at least any of the conditions is true. For example [condition1] OR [condition2] will be true if either condition1 or condition2 is true.</p>
<h3>Syntax</h3>
<p>The basic syntax of OR operator with WHERE clause is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN
FROM table_name
WHERE [condition1] OR [condition2]...OR [conditionN]
</pre>
<p>You can combine N number of conditions using OR operator. For an action to be taken by the PostgreSQL statement, whether it be a transaction or query, only any ONE of the conditions separated by the OR must be TRUE.</p>
<h3>Example</h3>
<p>Consider the <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table, having the following records &minus;</p>
<pre class="prettyprint notranslate">
 # select * from COMPANY;
  id | name  | age | address   | salary
 ----+-------+-----+-----------+--------
   1 | Paul  |  32 | California|  20000
   2 | Allen |  25 | Texas     |  15000
   3 | Teddy |  23 | Norway    |  20000
   4 | Mark  |  25 | Rich-Mond |  65000
   5 | David |  27 | Texas     |  85000
   6 | Kim   |  22 | South-Hall|  45000
   7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following SELECT statement lists down all the records where AGE is greater than or equal to 25 <b>OR</b> salary is greater than or equal to 65000.00 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE &gt;= 25 OR SALARY &gt;= 65000;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
(4 rows)
</pre>
<h1>PostgreSQL - UPDATE Query</h1>
<p>The PostgreSQL <b>UPDATE</b> Query is used to modify the existing records in a table. You can use WHERE clause with UPDATE query to update the selected rows. Otherwise, all the rows would be updated.</p>
<h2>Syntax</h2>
<p>The basic syntax of UPDATE query with WHERE clause is as follows &minus;</p>
<pre class="result notranslate">
UPDATE table_name
SET column1 = value1, column2 = value2...., columnN = valueN
WHERE [condition];
</pre>
<p>You can combine N number of conditions using AND or OR operators.</p>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a>, having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which would update ADDRESS for a customer, whose ID is 6 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# UPDATE COMPANY SET SALARY = 15000 WHERE ID = 3;
</pre>
<p>Now, COMPANY table would have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
  3 | Teddy |  23 | Norway     |  15000
(7 rows)
</pre>
<p>If you want to modify all ADDRESS and SALARY column values in COMPANY table, you do not need to use WHERE clause and UPDATE query would be as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# UPDATE COMPANY SET ADDRESS = 'Texas', SALARY=20000;
</pre>
<p>Now, COMPANY table will have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address | salary
----+-------+-----+---------+--------
  1 | Paul  |  32 | Texas   |  20000
  2 | Allen |  25 | Texas   |  20000
  4 | Mark  |  25 | Texas   |  20000
  5 | David |  27 | Texas   |  20000
  6 | Kim   |  22 | Texas   |  20000
  7 | James |  24 | Texas   |  20000
  3 | Teddy |  23 | Texas   |  20000
(7 rows)
</pre>
<h1>PostgreSQL - DELETE Query</h1>
<p>The PostgreSQL <b>DELETE</b> Query is used to delete the existing records from a table. You can use WHERE clause with DELETE query to delete the selected rows. Otherwise, all the records would be deleted.</p>
<h2>Syntax</h2>
<p>The basic syntax of DELETE query with WHERE clause is as follows &minus;</p>
<pre class="result notranslate">
DELETE FROM table_name
WHERE [condition];
</pre>
<p>You can combine N number of conditions using AND or OR operators.</p>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a>, having records as follows &minus;</p>
<pre class="prettyprint notranslate">
# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which would DELETE a customer whose ID is 7 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DELETE FROM COMPANY WHERE ID = 2;
</pre>
<p>Now, COMPANY table will have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  1 | Paul  |  32 | California  |  20000
  3 | Teddy |  23 | Norway      |  20000
  4 | Mark  |  25 | Rich-Mond   |  65000
  5 | David |  27 | Texas       |  85000
  6 | Kim   |  22 | South-Hall  |  45000
  7 | James |  24 | Houston     |  10000
(6 rows)
</pre>
<p>If you want to DELETE all the records from COMPANY table, you do not need to use WHERE clause with DELETE queries, which would be as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DELETE FROM COMPANY;
</pre>
<p>Now, COMPANY table does not have any record because all the records have been deleted by the DELETE statement.</p>
<h1>PostgreSQL - LIKE Clause</h1>
<p>The PostgreSQL <b>LIKE</b> operator is used to match text values against a pattern using wildcards. If the search expression can be matched to the pattern expression, the LIKE operator will return true, which is <b>1</b>.</p>
<p>There are two wildcards used in conjunction with the LIKE operator &minus;</p>
<ul class="list">
<li>The percent sign (%)</li>
<li>The underscore (_)</li>
</ul>
<p>The percent sign represents zero, one, or multiple numbers or characters. The underscore represents a single number or character. These symbols can be used in combinations.</p>
<p>If either of these two signs is not used in conjunction with the LIKE clause, then the LIKE acts like the equals operator.</p>
<h2>Syntax</h2>
<p>The basic syntax of % and _ is as follows &minus;</p>
<pre class="result notranslate">
SELECT FROM table_name
WHERE column LIKE 'XXXX%'

or

SELECT FROM table_name
WHERE column LIKE '%XXXX%'

or

SELECT FROM table_name
WHERE column LIKE 'XXXX_'

or

SELECT FROM table_name
WHERE column LIKE '_XXXX'

or

SELECT FROM table_name
WHERE column LIKE '_XXXX_'
</pre>
<p>You can combine N number of conditions using AND or OR operators. Here XXXX could be any numeric or string value.</p>
<h2>Example</h2>
<p>Here are number of examples showing WHERE part having different LIKE clause with '%' and '_' operators &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Statement &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>WHERE SALARY::text LIKE '200%'</b></p>
<p>Finds any values that start with 200</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>WHERE SALARY::text LIKE '%200%'</b></p>
<p>Finds any values that have 200 in any position</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>WHERE SALARY::text LIKE '_00%'</b></p>
<p>Finds any values that have 00 in the second and third positions</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>WHERE SALARY::text LIKE '2_%_%'</b></p>
<p>Finds any values that start with 2 and are at least 3 characters in length</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>WHERE SALARY::text LIKE '%2'</b></p>
<p>Finds any values that end with 2</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>WHERE SALARY::text LIKE '_2%3'</b></p>
<p>Finds any values that have 2 in the second position and end with a 3</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>WHERE SALARY::text LIKE '2___3'</b></p>
<p>Finds any values in a five-digit number that start with 2 and end with 3</p></td>
</tr>
</table>
<blockquote>Postgres LIKE is String compare only. Hence, we need to explicitly cast the integer column to string as in the examples above.</blockquote>
<p>Let us take a real example, consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a>, having records as follows &minus;</p>
<pre class="prettyprint notranslate">
# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which would display all the records from COMPANY table where AGE starts with 2 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE AGE::text LIKE '2%';
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  2 | Allen |  25 | Texas       |  15000
  3 | Teddy |  23 | Norway      |  20000
  4 | Mark  |  25 | Rich-Mond   |  65000
  5 | David |  27 | Texas       |  85000
  6 | Kim   |  22 | South-Hall  |  45000
  7 | James |  24 | Houston     |  10000
  8 | Paul  |  24 | Houston     |  20000
(7 rows)
</pre>
<p>The following is an example, which would display all the records from COMPANY table where ADDRESS will have a hyphen (-) inside the text &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY WHERE ADDRESS  LIKE '%-%';
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name | age |                      address              | salary
----+------+-----+-------------------------------------------+--------
  4 | Mark |  25 | Rich-Mond                                 |  65000
  6 | Kim  |  22 | South-Hall                                |  45000
(2 rows)
</pre>
<h1>PostgreSQL - LIMIT Clause</h1>
<p>The PostgreSQL <b>LIMIT</b> clause is used to  limit the data amount returned by the SELECT statement.</p>
<h2>Syntax</h2>
<p>The basic syntax of SELECT statement with LIMIT clause is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN
FROM table_name
LIMIT [no of rows]
</pre>
<p>The following is the syntax of LIMIT clause when it is used along with OFFSET clause &minus;</p>
<pre class="result notranslate">
SELECT column1, column2, columnN
FROM table_name
LIMIT [no of rows] OFFSET [row num]
</pre>
<p>LIMIT and OFFSET allow you to retrieve just a portion of the rows that are generated by the rest of the query.</p>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which limits the row in the table according to the number of rows you want to fetch from table &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY LIMIT 4;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  1 | Paul  |  32 | California  |  20000
  2 | Allen |  25 | Texas       |  15000
  3 | Teddy |  23 | Norway      |  20000
  4 | Mark  |  25 | Rich-Mond   |  65000
(4 rows)
</pre>
<p>However, in certain situation, you may need to pick up a set of records from a particular offset. Here is an example, which picks up three records starting from the third position &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY LIMIT 3 OFFSET 2;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
(3 rows)
</pre>
<h1>PostgreSQL - ORDER BY Clause</h1>
<p>The PostgreSQL <b>ORDER BY</b> clause is used to sort the data in ascending or descending order, based on one or more columns.</p>
<h2>Syntax</h2>
<p>The basic syntax of ORDER BY clause is as follows &minus;</p>
<pre class="result notranslate">
SELECT column-list
FROM table_name
[WHERE condition]
[ORDER BY column1, column2, .. columnN] [ASC | DESC];
</pre>
<p>You can use more than one column in the ORDER BY clause. Make sure whatever column you are using to sort, that column should be available in column-list.</p>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which would sort the result in ascending order by SALARY &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY ORDER BY AGE ASC;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
  id | name  | age | address    | salary
 ----+-------+-----+------------+--------
   6 | Kim   |  22 | South-Hall |  45000
   3 | Teddy |  23 | Norway     |  20000
   7 | James |  24 | Houston    |  10000
   8 | Paul  |  24 | Houston    |  20000
   4 | Mark  |  25 | Rich-Mond  |  65000
   2 | Allen |  25 | Texas      |  15000
   5 | David |  27 | Texas      |  85000
   1 | Paul  |  32 | California |  20000
   9 | James |  44 | Norway     |   5000
  10 | James |  45 | Texas      |   5000
(10 rows)
</pre>
<p>The following is an example, which would sort the result in ascending order by NAME and SALARY &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address      | salary
----+-------+-----+--------------+--------
  2 | Allen |  25 | Texas        |  15000
  5 | David |  27 | Texas        |  85000
 10 | James |  45 | Texas        |   5000
  9 | James |  44 | Norway       |   5000
  7 | James |  24 | Houston      |  10000
  6 | Kim   |  22 | South-Hall   |  45000
  4 | Mark  |  25 | Rich-Mond    |  65000
  1 | Paul  |  32 | California   |  20000
  8 | Paul  |  24 | Houston      |  20000
  3 | Teddy |  23 | Norway       |  20000
(10 rows)
</pre>
<p>The following is an example, which would sort the result in descending order by NAME &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY ORDER BY NAME DESC;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  3 | Teddy |  23 | Norway     |  20000
  1 | Paul  |  32 | California |  20000
  8 | Paul  |  24 | Houston    |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
  9 | James |  44 | Norway     |   5000
 10 | James |  45 | Texas      |   5000
  5 | David |  27 | Texas      |  85000
  2 | Allen |  25 | Texas      |  15000
(10 rows)
</pre>
<h1>PostgreSQL - GROUP BY</h1>
<p>The PostgreSQL <b>GROUP BY</b> clause is used in collaboration with the SELECT statement to group together those rows in a table that have identical data. This is done to eliminate redundancy in the output and/or compute aggregates that apply to these groups.</p>
<p>The GROUP BY clause follows the WHERE clause in a SELECT statement and precedes the ORDER BY clause.</p>
<h2>Syntax</h2>
<p>The basic syntax of GROUP BY clause is given below. The GROUP BY clause must follow the conditions in the WHERE clause and must precede the ORDER BY clause if one is used.</p>
<pre class="result notranslate">
SELECT column-list
FROM table_name
WHERE [ conditions ]
GROUP BY column1, column2....columnN
ORDER BY column1, column2....columnN
</pre>
<p>You can use more than one column in the GROUP BY clause. Make sure whatever column you are using to group, that column should be available in column-list.</p>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>If you want to know the total amount of salary of each customer, then GROUP BY query would be as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
  name  |  sum
 -------+-------
  Teddy | 20000
  Paul  | 20000
  Mark  | 65000
  David | 85000
  Allen | 15000
  Kim   | 45000
  James | 10000
(7 rows)
</pre>
<p>Now, let us create three more records in COMPANY table using the following INSERT statements &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY VALUES (8, 'Paul', 24, 'Houston', 20000.00);
INSERT INTO COMPANY VALUES (9, 'James', 44, 'Norway', 5000.00);
INSERT INTO COMPANY VALUES (10, 'James', 45, 'Texas', 5000.00);
</pre>
<p>Now, our table has the following records with duplicate names &minus;</p>
<pre class="prettyprint notranslate">
  id | name  | age | address      | salary
 ----+-------+-----+--------------+--------
   1 | Paul  |  32 | California   |  20000
   2 | Allen |  25 | Texas        |  15000
   3 | Teddy |  23 | Norway       |  20000
   4 | Mark  |  25 | Rich-Mond    |  65000
   5 | David |  27 | Texas        |  85000
   6 | Kim   |  22 | South-Hall   |  45000
   7 | James |  24 | Houston      |  10000
   8 | Paul  |  24 | Houston      |  20000
   9 | James |  44 | Norway       |   5000
  10 | James |  45 | Texas        |   5000
(10 rows)
</pre>
<p>Again, let us use the same statement to group-by all the records using NAME column as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME ORDER BY NAME;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 name  |  sum
-------+-------
 Allen | 15000
 David | 85000
 James | 20000
 Kim   | 45000
 Mark  | 65000
 Paul  | 40000
 Teddy | 20000
(7 rows)
</pre>
<p>Let us use ORDER BY clause along with GROUP BY clause as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=#  SELECT NAME, SUM(SALARY)
         FROM COMPANY GROUP BY NAME ORDER BY NAME DESC;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 name  |  sum
-------+-------
 Teddy | 20000
 Paul  | 40000
 Mark  | 65000
 Kim   | 45000
 James | 20000
 David | 85000
 Allen | 15000
(7 rows)
</pre>
<h1>PostgreSQL - WITH Clause</h1>
<p>In PostgreSQL, the WITH query provides a way to write auxiliary statements for use in a larger query. It helps in breaking down complicated and large queries into simpler forms, which are easily readable. These statements often referred to as Common Table Expressions or CTEs, can be thought of as defining temporary tables that exist just for one query.</p>
<p>The WITH query being CTE query, is particularly useful when subquery is executed multiple times. It is equally helpful in place of temporary tables. It computes the aggregation once and allows us to reference it by its name (may be multiple times) in the queries.</p>
<p>The WITH clause must be defined before it is used in the query.</p>
<h3>Syntax</h3>
<p>The basic syntax of WITH query is as follows &minus;</p>
<pre class="result notranslate">
WITH
   name_for_summary_data AS (
      SELECT Statement)
   SELECT columns
   FROM name_for_summary_data
   WHERE conditions &lt;=&gt; (
      SELECT column
      FROM name_for_summary_data)
   [ORDER BY columns]
</pre>
<p>Where <i>name_for_summary_data</i> is the name given to the WITH clause. The name_for_summary_data can be the same as an existing table name and will take precedence.</p>
<p>You can use data-modifying statements (INSERT, UPDATE or DELETE) in WITH. This allows you to perform several different operations in the same query.</p>
<h2>Recursive WITH</h2>
Recursive WITH or Hierarchical queries, is a form of CTE where a CTE can reference to itself, i.e., a WITH query can refer to its own output, hence the name recursive.
<h3>Example</h3>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Now, let us write a query using the WITH clause to select the records from the above table, as follows &minus;</p>
<pre class="prettyprint notranslate">
With CTE AS
(Select
 ID
, NAME
, AGE
, ADDRESS
, SALARY
FROM COMPANY )
Select * From CTE;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Now, let us write a query using the RECURSIVE keyword along with the WITH clause, to find the sum of the salaries less than 20000, as follows &minus;</p>
<pre class="prettyprint notranslate">
WITH RECURSIVE t(n) AS (
   VALUES (0)
   UNION ALL
   SELECT SALARY FROM COMPANY WHERE SALARY &lt; 20000
)
SELECT sum(n) FROM t;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
  sum
-------
 25000
(1 row)
</pre>
<p>Let us write a query using data modifying statements along with the WITH clause, as shown below.</p>
<p>First, create a table COMPANY1 similar to the table COMPANY. The query in the example effectively moves rows from COMPANY to COMPANY1. The DELETE in WITH deletes the specified rows from COMPANY, returning their contents by means of its RETURNING clause; and then the primary query reads that output and inserts it into COMPANY1 TABLE &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY1(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

WITH moved_rows AS (
   DELETE FROM COMPANY
   WHERE
      SALARY &gt;= 30000
   RETURNING *
)
INSERT INTO COMPANY1 (SELECT * FROM moved_rows);
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
INSERT 0 3
</pre>
<p>Now, the records in the tables COMPANY and COMPANY1 are as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY;
 id | name  | age |  address   | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  7 | James |  24 | Houston    |  10000
(4 rows)


testdb=# SELECT * FROM COMPANY1;
 id | name  | age | address | salary
----+-------+-----+-------------+--------
  4 | Mark  |  25 | Rich-Mond   |  65000
  5 | David |  27 | Texas       |  85000
  6 | Kim   |  22 | South-Hall  |  45000
(3 rows)
</pre>
<h1>PostgreSQL - HAVING Clause</h1>
<p>The HAVING clause allows us to pick out particular rows where the function's result meets some condition.</p>
<p>The WHERE clause places conditions on the selected columns, whereas the HAVING clause places conditions on groups created by the GROUP BY clause.</p>
<h2>Syntax</h2>
<p>The following is the position of the HAVING clause in a SELECT query &minus;</p>
<pre class="result notranslate">
SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
</pre>
<p>The HAVING clause must follow the GROUP BY clause in a query and must also precede the ORDER BY clause if used. The following is the syntax of the SELECT statement, including the HAVING clause &minus;</p>
<pre class="result notranslate">
SELECT column1, column2
FROM table1, table2
WHERE [ conditions ]
GROUP BY column1, column2
HAVING [ conditions ]
ORDER BY column1, column2
</pre>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following is an example, which would display record for which the name count is less than 2 &minus;</p>
<pre class="prettyprint notranslate">
testdb-# SELECT NAME FROM COMPANY GROUP BY name HAVING count(name) &lt; 2;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
  name
 -------
  Teddy
  Paul
  Mark
  David
  Allen
  Kim
  James
(7 rows)
</pre>
<p>Now, let us create three more records in COMPANY table using the following INSERT statements &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY VALUES (8, 'Paul', 24, 'Houston', 20000.00);
INSERT INTO COMPANY VALUES (9, 'James', 44, 'Norway', 5000.00);
INSERT INTO COMPANY VALUES (10, 'James', 45, 'Texas', 5000.00);
</pre>
<p>Now, our table has the following records with duplicate names &minus;</p>
<pre class="prettyprint notranslate">
  id | name  | age | address      | salary
 ----+-------+-----+--------------+--------
   1 | Paul  |  32 | California   |  20000
   2 | Allen |  25 | Texas        |  15000
   3 | Teddy |  23 | Norway       |  20000
   4 | Mark  |  25 | Rich-Mond    |  65000
   5 | David |  27 | Texas        |  85000
   6 | Kim   |  22 | South-Hall   |  45000
   7 | James |  24 | Houston      |  10000
   8 | Paul  |  24 | Houston      |  20000
   9 | James |  44 | Norway       |   5000
  10 | James |  45 | Texas        |   5000
(10 rows)
</pre>
<p>The following is the example, which would display record for which the name count is greater than 1 &minus;</p>
<pre class="prettyprint notranslate">
testdb-# SELECT NAME FROM COMPANY GROUP BY name HAVING count(name) &gt; 1;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 name
-------
 Paul
 James
(2 rows)
</pre>
<h1>PostgreSQL - DISTINCT Keyword</h1>
<p>The PostgreSQL <b>DISTINCT</b> keyword is used in conjunction with SELECT statement to eliminate all the duplicate records and fetching only unique records.</p>
<p>There may be a situation when you have multiple duplicate records in a table. While fetching such records, it makes more sense to fetch only unique records instead of fetching duplicate records.</p>
<h2>Syntax</h2>
<p>The basic syntax of DISTINCT keyword to eliminate duplicate records is as follows &minus;</p>
<pre class="result notranslate">
SELECT DISTINCT column1, column2,.....columnN
FROM table_name
WHERE [condition]
</pre>
<h2>Example</h2>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Let us add two more records to this table as follows &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (8, 'Paul', 32, 'California', 20000.00 );

INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (9, 'Allen', 25, 'Texas', 15000.00 );
</pre>
<p>Now, the records in the COMPANY table would be &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
  8 | Paul  |  32 | California |  20000
  9 | Allen |  25 | Texas      |  15000
(9 rows)
</pre>
<p>First, let us see how the following SELECT query returns duplicate salary records &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT name FROM COMPANY;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 name
-------
 Paul
 Allen
 Teddy
 Mark
 David
 Kim
 James
 Paul
 Allen
(9 rows)
</pre>
<p>Now, let us use <b>DISTINCT</b> keyword with the above SELECT query and see the result &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT DISTINCT name FROM COMPANY;
</pre>
<p>This would produce the following result where we do not have any duplicate entry &minus;</p>
<pre class="result notranslate">
 name
-------
 Teddy
 Paul
 Mark
 David
 Allen
 Kim
 James
(7 rows)
</pre>
<h1>PostgreSQL - CONSTRAINTS</h1>
<p>Constraints are the rules enforced on data columns on table. These are used to prevent invalid data from being entered into the database. This ensures the accuracy and reliability of the data in the database.</p>
<p>Constraints could be column level or table level. Column level constraints are applied only to one column whereas table level constraints are applied to the whole table. Defining a data type for a column is a constraint in itself. For example, a column of type DATE constrains the column to valid dates.</p>
<p>The following are commonly used constraints available in PostgreSQL.</p>
<ul class="list">
<li><p><b>NOT NULL Constraint</b> &minus; Ensures that a column cannot have NULL value.</p></li>
<li><p><b>UNIQUE Constraint</b> &minus; Ensures that all values in a column are different.</p></li>
<li><p><b>PRIMARY Key</b> &minus; Uniquely identifies each row/record in a database table.</p></li>
<li><p><b>FOREIGN Key</b> &minus; Constrains data based on columns in other tables.</p></li>
<li><p><b>CHECK Constraint</b> &minus; The CHECK constraint ensures that all values in a column satisfy certain conditions.</p></li>
<li><p><b>EXCLUSION Constraint</b> &minus; The EXCLUDE constraint ensures that if any two rows are compared on the specified column(s) or expression(s) using the specified operator(s), not all of these comparisons will return TRUE.</p></li>
</ul>
<h2>NOT NULL Constraint</h2>
<p>By default, a column can hold NULL values. If you do not want a column to have a NULL value, then you need to define such constraint on this column specifying that NULL is now not allowed for that column. A NOT NULL constraint is always written as a column constraint.</p>
<p>A NULL is not the same as no data; rather, it represents unknown data.</p>
<h3>Example</h3>
<p>For example, the following PostgreSQL statement creates a new table called COMPANY1 and adds five columns, three of which, ID and NAME and AGE, specify not to accept NULL values &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY1(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<h2>UNIQUE Constraint</h2>
<p>The UNIQUE Constraint prevents two records from having identical values in a particular column. In the COMPANY table, for example, you might want to prevent two or more people from having identical age.</p>
<h3>Example</h3>
<p>For example, the following PostgreSQL statement creates a new table called COMPANY3 and adds five columns. Here, AGE column is set to UNIQUE, so that you cannot have two records with same age &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY3(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL UNIQUE,
   ADDRESS        CHAR(50),
   SALARY         REAL    DEFAULT 50000.00
);
</pre>
<h2>PRIMARY KEY Constraint</h2>
<p>The PRIMARY KEY constraint uniquely identifies each record in a database table. There can be more UNIQUE columns, but only one primary key in a table. Primary keys are important when designing the database tables. Primary keys are unique ids.</p>
<p> We use them to refer to table rows. Primary keys become foreign keys in other tables, when creating relations among tables. Due to a 'longstanding coding oversight', primary keys can be NULL in SQLite. This is not the case with other databases</p>
<p>A primary key is a field in a table, which uniquely identifies each row/record in a database table. Primary keys must contain unique values. A primary key column cannot have NULL values.</p>
<p>A table can have only one primary key, which may consist of single or multiple fields. When multiple fields are used as a primary key, they are called a <b>composite key</b>.</p>
<p>If a table has a primary key defined on any field(s), then you cannot have two records having the same value of that field(s).</p>
<h3>Example</h3>
<p>You already have seen various examples above where we have created COMAPNY4 table with ID as primary key &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY4(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<h2>FOREIGN KEY Constraint</h2>
<p>A foreign key constraint specifies that the values in a column (or a group of columns) must match the values appearing in some row of another table. We say this maintains the referential integrity between two related tables. They are called foreign keys because the constraints are foreign; that is, outside the table. Foreign keys are sometimes called a referencing key.</p>
<h3>Example</h3>
<p>For example, the following PostgreSQL statement creates a new table called COMPANY5 and adds five columns.</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY6(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<p>For example, the following PostgreSQL statement creates a new table called DEPARTMENT1, which adds three columns. The column EMP_ID is the foreign key and references the ID field of the table COMPANY6.</p>
<pre class="prettyprint notranslate">
CREATE TABLE DEPARTMENT1(
   ID INT PRIMARY KEY      NOT NULL,
   DEPT           CHAR(50) NOT NULL,
   EMP_ID         INT      references COMPANY6(ID)
);
</pre>
<h2>CHECK Constraint</h2>
<p>The CHECK Constraint enables a condition to check the value being entered into a record. If the condition evaluates to false, the record violates the constraint and is not entered into the table.</p>
<h3>Example</h3>
<p>For example, the following PostgreSQL statement creates a new table called COMPANY5 and adds five columns. Here, we add a CHECK with SALARY column, so that you cannot have any SALARY as Zero.</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY5(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL    CHECK(SALARY &gt; 0)
);
</pre>
<h2>EXCLUSION Constraint</h2>
<p>Exclusion constraints ensure that if any two rows are compared on the specified columns or expressions using the specified operators, at least one of these operator comparisons will return false or null.</p>
<h3>Example</h3>
<p>For example, the following PostgreSQL statement creates a new table called COMPANY7 and adds five columns. Here, we add an EXCLUDE constraint &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE COMPANY7(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT,
   AGE            INT  ,
   ADDRESS        CHAR(50),
   SALARY         REAL,
   EXCLUDE USING gist
   (NAME WITH =,
   AGE WITH <>)
);
</pre>
<p>Here, <i>USING gist</i> is the type of index to build and use for enforcement.</p>
<blockquote>You need to execute the command <i>CREATE EXTENSION btree_gist</i>, once per database. This will install the btree_gist extension, which defines the exclusion constraints on plain scalar data types.</blockquote>
<p>As we have enforced the age has to be same, let us see this by inserting records to the table &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY7 VALUES(1, 'Paul', 32, 'California', 20000.00 );
INSERT INTO COMPANY7 VALUES(2, 'Paul', 32, 'Texas', 20000.00 );
INSERT INTO COMPANY7 VALUES(3, 'Allen', 42, 'California', 20000.00 );
</pre>
<p>For the first two INSERT statements, the records are added to the COMPANY7 table. For the third INSERT statement, the following error is displayed &minus;</p>
<pre class="prettyprint notranslate">
ERROR:  duplicate key value violates unique constraint "company7_pkey"
DETAIL:  Key (id)=(3) already exists.
</pre>
<h2>Dropping Constraints</h2>
<p>To remove a constraint you need to know its name. If the name is known, it is easy to drop. Else, you need to find out the system-generated name. The psql command \d table name can be helpful here. The general syntax is &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name DROP CONSTRAINT some_name;
</pre>
<h1>PostgreSQL - JOINS</h1>
<p>The PostgreSQL <b>Joins</b> clause is used to combine records from two or more tables in a database. A JOIN is a means for combining fields from two tables by using values common to each.</p>
<p>Join Types in PostgreSQL are &minus;</p>
<ul class="list">
<li>The CROSS JOIN</li>
<li>The INNER JOIN</li>
<li>The LEFT OUTER JOIN</li>
<li>The RIGHT OUTER JOIN</li>
<li>The FULL OUTER JOIN</li>
</ul>
<p>Before we proceed, let us consider two tables, COMPANY and DEPARTMENT. We already have seen INSERT statements to populate COMPANY table. So just let us assume the list of records available in COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary | join_date
----+-------+-----+-----------+--------+-----------
  1 | Paul  |  32 | California|  20000 | 2001-07-13
  3 | Teddy |  23 | Norway    |  20000 |
  4 | Mark  |  25 | Rich-Mond |  65000 | 2007-12-13
  5 | David |  27 | Texas     |  85000 | 2007-12-13
  2 | Allen |  25 | Texas     |        | 2007-12-13
  8 | Paul  |  24 | Houston   |  20000 | 2005-07-13
  9 | James |  44 | Norway    |   5000 | 2005-07-13
 10 | James |  45 | Texas     |   5000 | 2005-07-13
</pre>
<p>Another table is DEPARTMENT, has the following definition &minus;</p>
<pre class="prettyprint notranslate">
CREATE TABLE DEPARTMENT(
   ID INT PRIMARY KEY      NOT NULL,
   DEPT           CHAR(50) NOT NULL,
   EMP_ID         INT      NOT NULL
);
</pre>
<p>Here is the list of INSERT statements to populate DEPARTMENT table &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO DEPARTMENT (ID, DEPT, EMP_ID)
VALUES (1, 'IT Billing', 1 );

INSERT INTO DEPARTMENT (ID, DEPT, EMP_ID)
VALUES (2, 'Engineering', 2 );

INSERT INTO DEPARTMENT (ID, DEPT, EMP_ID)
VALUES (3, 'Finance', 7 );
</pre>
<p>Finally, we have the following list of records available in DEPARTMENT table &minus;</p>
<pre class="prettyprint notranslate">
 id | dept        | emp_id
----+-------------+--------
  1 | IT Billing  |  1
  2 | Engineering |  2
  3 | Finance     |  7
</pre>
<h2>The CROSS JOIN</h2>
<p>A CROSS JOIN matches every row of the first table with every row of the second table. If the input tables have x and y columns, respectively, the resulting table will have x+y columns. Because CROSS JOINs have the potential to generate extremely large tables, care must be taken to use them only when appropriate.</p>
<p>The following is the syntax of CROSS JOIN &minus;</p>
<pre class="result notranslate">
SELECT ... FROM table1 CROSS JOIN table2 ...
</pre>
<p>Based on the above tables, we can write a CROSS JOIN as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT;
</pre>
<p>The above given query will produce the following result &minus;</p>
<pre class="result notranslate">
emp_id| name  |  dept
------|-------|--------------
    1 | Paul  | IT Billing
    1 | Teddy | IT Billing
    1 | Mark  | IT Billing
    1 | David | IT Billing
    1 | Allen | IT Billing
    1 | Paul  | IT Billing
    1 | James | IT Billing
    1 | James | IT Billing
    2 | Paul  | Engineering
    2 | Teddy | Engineering
    2 | Mark  | Engineering
    2 | David | Engineering
    2 | Allen | Engineering
    2 | Paul  | Engineering
    2 | James | Engineering
    2 | James | Engineering
    7 | Paul  | Finance
    7 | Teddy | Finance
    7 | Mark  | Finance
    7 | David | Finance
    7 | Allen | Finance
    7 | Paul  | Finance
    7 | James | Finance
    7 | James | Finance
</pre>
<h2>The INNER JOIN</h2>
<p>A INNER JOIN creates a new result table by combining column values of two tables (table1 and table2) based upon the join-predicate. The query compares each row of table1 with each row of table2 to find all pairs of rows, which satisfy the join-predicate. When the join-predicate is satisfied, column values for each matched pair of rows of table1 and table2 are combined into a result row.</p>
<p>An INNER JOIN is the most common type of join and is the default type of join. You can use INNER keyword optionally.</p>
<p>The following is the syntax of INNER JOIN &minus;</p>
<pre class="prettyprint notranslate">
SELECT table1.column1, table2.column2...
FROM table1
INNER JOIN table2
ON table1.common_filed = table2.common_field;
</pre>
<p>Based on the above tables, we can write an INNER JOIN as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT
        ON COMPANY.ID = DEPARTMENT.EMP_ID;
</pre>
<p>The above given query will produce the following result &minus;</p>
<pre class="result notranslate">
 emp_id | name  | dept
--------+-------+------------
      1 | Paul  | IT Billing
      2 | Allen | Engineering
</pre>
<h2>The LEFT OUTER JOIN</h2>
<p>The OUTER JOIN is an extension of the INNER JOIN. SQL standard defines three types of OUTER JOINs: LEFT, RIGHT, and FULL and  PostgreSQL  supports all of these.</p>
<p>In case of LEFT OUTER JOIN, an inner join is performed first. Then, for each row in table T1 that does not satisfy the join condition with any row in table T2, a joined row is added with null values in columns of T2. Thus, the joined table always has at least one row for each row in T1.</p>
<p>The following is the syntax of LEFT OUTER JOIN &minus;</p>
<pre class="result notranslate">
SELECT ... FROM table1 LEFT OUTER JOIN table2 ON conditional_expression ...
</pre>
<p>Based on the above tables, we can write an inner join as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT
   ON COMPANY.ID = DEPARTMENT.EMP_ID;
</pre>
<p>The above given query will produce the following result &minus;</p>
<pre class="result notranslate">
 emp_id | name  | dept
--------+-------+------------
      1 | Paul  | IT Billing
      2 | Allen | Engineering
        | James |
        | David |
        | Paul  |
        | Mark  |
        | Teddy |
        | James |
</pre>
<h2>The RIGHT OUTER JOIN</h2>
<p>First, an inner join is performed. Then, for each row in table T2 that does not satisfy the join condition with any row in  table T1, a joined row is added with null values in columns of T1. This is the converse of a left join; the result table will always have a row for each row in T2.</p>
<p>The following is the syntax of RIGHT OUTER JOIN &minus;</p>
<pre class="result notranslate">
SELECT ... FROM table1 RIGHT OUTER JOIN table2 ON conditional_expression ...
</pre>
<p>Based on the above tables, we can write an inner join as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY RIGHT OUTER JOIN DEPARTMENT
   ON COMPANY.ID = DEPARTMENT.EMP_ID;
</pre>
<p>The above given query will produce the following result &minus;</p>
<pre class="result notranslate">
 emp_id | name  | dept
--------+-------+--------
      1 | Paul  | IT Billing
      2 | Allen | Engineering
      7 |       | Finance
</pre>
<h2>The FULL OUTER JOIN</h2>
<p>First, an inner join is performed. Then, for each row in table T1 that does not satisfy the join condition with any row in table T2, a joined row is added with null values in columns of T2. In addition, for each row of T2 that does not satisfy the join condition with any row in T1, a joined row with null values in the columns of T1 is added.</p>
<p>The following is the syntax of FULL OUTER JOIN &minus;</p>
<pre class="result notranslate">
SELECT ... FROM table1 FULL OUTER JOIN table2 ON conditional_expression ...
</pre>
<p>Based on the above tables, we can write an inner join as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY FULL OUTER JOIN DEPARTMENT
   ON COMPANY.ID = DEPARTMENT.EMP_ID;
</pre>
<p>The above given query will produce the following result &minus;</p>
<pre class="result notranslate">
 emp_id | name  | dept
--------+-------+---------------
      1 | Paul  | IT Billing
      2 | Allen | Engineering
      7 |       | Finance
        | James |
        | David |
        | Paul  |
        | Mark  |
        | Teddy |
        | James |
</pre>
<h1>PostgreSQL - UNIONS Clause</h1>
<p>The PostgreSQL <b>UNION</b> clause/operator is used to combine the results of two or more SELECT statements without returning any duplicate rows.</p>
<p>To use UNION, each SELECT must have the same number of columns selected, the same number of column expressions, the same data type, and have them in the same order but they do not have to be the same length.</p>
<h2>Syntax</h2>
<p>The basic syntax of <b>UNION</b> is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
</pre>
<p>Here, given condition could be any given expression based on your requirement.</p>
<h2>Example</h2>
<p>Consider the following two tables, (a) <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table is as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>(b) Another table is <a href="department.sql" alt="DEPARTMENT Table" target="_blank">DEPARTMENT</a> as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * from DEPARTMENT;
 id | dept        | emp_id
----+-------------+--------
  1 | IT Billing  |      1
  2 | Engineering |      2
  3 | Finance     |      7
  4 | Engineering |      3
  5 | Finance     |      4
  6 | Engineering |      5
  7 | Finance     |      6
(7 rows)
</pre>
<p>Now let us join these two tables using SELECT statement along with UNION clause as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT
   ON COMPANY.ID = DEPARTMENT.EMP_ID
   UNION
      SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT
         ON COMPANY.ID = DEPARTMENT.EMP_ID;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 emp_id | name  |  dept
--------+-------+--------------
      5 | David | Engineering
      6 | Kim   | Finance
      2 | Allen | Engineering
      3 | Teddy | Engineering
      4 | Mark  | Finance
      1 | Paul  | IT Billing
      7 | James | Finance
(7 rows)
</pre>
<h2>The UNION ALL Clause</h2>
<p>The UNION ALL operator is used to combine the results of two SELECT statements including duplicate rows. The same rules that apply to UNION apply to the UNION ALL operator as well.</p>
<h3>Syntax</h3>
<p>The basic syntax of <b>UNION ALL</b> is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]

UNION ALL

SELECT column1 [, column2 ]
FROM table1 [, table2 ]
[WHERE condition]
</pre>
<p>Here, given condition could be any given expression based on your requirement.</p>
<h3>Example</h3>
<p>Now, let us join above-mentioned two tables in our SELECT statement as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT
   ON COMPANY.ID = DEPARTMENT.EMP_ID
   UNION ALL
      SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT
         ON COMPANY.ID = DEPARTMENT.EMP_ID;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 emp_id | name  | dept
--------+-------+--------------
      1 | Paul  | IT Billing
      2 | Allen | Engineering
      7 | James | Finance
      3 | Teddy | Engineering
      4 | Mark  | Finance
      5 | David | Engineering
      6 | Kim   | Finance
      1 | Paul  | IT Billing
      2 | Allen | Engineering
      7 | James | Finance
      3 | Teddy | Engineering
      4 | Mark  | Finance
      5 | David | Engineering
      6 | Kim   | Finance
(14 rows)
</pre>
<h1>PostgreSQL - NULL Values</h1>
<p>The PostgreSQL <b>NULL</b> is the term used to represent a missing value. A NULL value in a table is a value in a field that appears to be blank.</p>
<p>A field with a NULL value is a field with no value. It is very important to understand that a NULL value is different from a zero value or a field that contains spaces.</p>
<h2>Syntax</h2>
<p>The basic syntax of using <b>NULL</b> while creating a table is as follows &minus;</p>
<pre class="result notranslate">
CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<p>Here, <b>NOT NULL</b> signifies that  column should always accept an explicit value of the given data type. There are two columns where we did not use NOT NULL. Hence, this means these columns could be NULL.</>
<p>A field with a NULL value is one that has been left blank during record creation.</p>
<h2>Example</h2>
<p>The NULL value can cause problems when selecting data, because when comparing an unknown value to any other value, the result is always unknown and not included in the final results. Consider the following table, <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having the following records &minus;</p>
<pre class="prettyprint notranslate">
ID          NAME        AGE         ADDRESS     SALARY
----------  ----------  ----------  ----------  ----------
1           Paul        32          California  20000.0
2           Allen       25          Texas       15000.0
3           Teddy       23          Norway      20000.0
4           Mark        25          Rich-Mond   65000.0
5           David       27          Texas       85000.0
6           Kim         22          South-Hall  45000.0
7           James       24          Houston     10000.0
</pre>
<p>Let us use the UPDATE statement to set few nullable values as NULL as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# UPDATE COMPANY SET ADDRESS = NULL, SALARY = NULL where ID IN(6,7);
</pre>
<p>Now, COMPANY table should have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  1 | Paul  |  32 | California  |  20000
  2 | Allen |  25 | Texas       |  15000
  3 | Teddy |  23 | Norway      |  20000
  4 | Mark  |  25 | Rich-Mond   |  65000
  5 | David |  27 | Texas       |  85000
  6 | Kim   |  22 |             |
  7 | James |  24 |             |
(7 rows)
</pre>
<p>Next, let us see the usage of <b>IS NOT NULL</b> operator to list down all the records where SALARY is not NULL &minus;</p>
<pre class="prettyprint notranslate">
testdb=#  SELECT  ID, NAME, AGE, ADDRESS, SALARY
   FROM COMPANY
   WHERE SALARY IS NOT NULL;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
(5 rows)
</pre>
<p>The following is the usage of  <b>IS NULL</b> operator which will list down all the records where SALARY is NULL &minus;</p>
<pre class="prettyprint notranslate">
testdb=#  SELECT  ID, NAME, AGE, ADDRESS, SALARY
        FROM COMPANY
        WHERE SALARY IS NULL;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age | address | salary
----+-------+-----+---------+--------
  6 | Kim   |  22 |         |
  7 | James |  24 |         |
(2 rows)
</pre>
<h1>PostgreSQL - ALIAS Syntax</h1>
<p>You can rename a table or a column temporarily by giving another name, which is known as <b>ALIAS</b>. The use of table aliases means to rename a table in a particular PostgreSQL statement. Renaming is a temporary change and the actual table name does not change in the database.</p>
<p>The column aliases are used to rename a table's columns for the purpose of a particular PostgreSQL query.</p>
<h2>Syntax</h2>
<p>The basic syntax of <b>table</b> alias is as follows &minus;</p>
<pre class="result notranslate">
SELECT column1, column2....
FROM table_name AS alias_name
WHERE [condition];
</pre>
<p>The basic syntax of <b>column</b> alias is as follows &minus;</p>
<pre class="result notranslate">
SELECT column_name AS alias_name
FROM table_name
WHERE [condition];
</pre>
<h2>Example</h2>
<p>Consider the following two tables, (a) <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table is as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>(b) Another table is <a href="department.sql" alt="DEPARTMENT Table" target="_blank">DEPARTMENT</a> as follows &minus;</p>
<pre class="prettyprint notranslate">
 id | dept         | emp_id
----+--------------+--------
  1 | IT Billing   |      1
  2 | Engineering  |      2
  3 | Finance      |      7
  4 | Engineering  |      3
  5 | Finance      |      4
  6 | Engineering  |      5
  7 | Finance      |      6
(7 rows)
</pre>
<p>Now, following is the usage of <b>TABLE ALIAS</b> where we use C and D as aliases for COMPANY and DEPARTMENT tables, respectively &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT C.ID, C.NAME, C.AGE, D.DEPT
   FROM COMPANY AS C, DEPARTMENT AS D
   WHERE  C.ID = D.EMP_ID;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age |  dept
----+-------+-----+------------
  1 | Paul  |  32 | IT Billing
  2 | Allen |  25 | Engineering
  7 | James |  24 | Finance
  3 | Teddy |  23 | Engineering
  4 | Mark  |  25 | Finance
  5 | David |  27 | Engineering
  6 | Kim   |  22 | Finance
(7 rows)
</pre>
<p>Let us see an example for the usage of <b>COLUMN ALIAS</b> where COMPANY_ID is an alias of ID column and COMPANY_NAME is an alias of name column &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT C.ID AS COMPANY_ID, C.NAME AS COMPANY_NAME, C.AGE, D.DEPT
   FROM COMPANY AS C, DEPARTMENT AS D
   WHERE  C.ID = D.EMP_ID;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="result notranslate">
 company_id | company_name | age | dept
------------+--------------+-----+------------
      1     | Paul         |  32 | IT Billing
      2     | Allen        |  25 | Engineering
      7     | James        |  24 | Finance
      3     | Teddy        |  23 | Engineering
      4     | Mark         |  25 | Finance
      5     | David        |  27 | Engineering
      6     | Kim          |  22 | Finance
(7 rows)
</pre>
<h1>PostgreSQL - TRIGGERS</h1>
<p>PostgreSQL <b>Triggers</b> are database callback functions, which are automatically performed/invoked when a specified database event occurs.</p>
<p>The following are important points about PostgreSQL triggers &minus;</p>
<ul class="list">
<li><p>PostgreSQL trigger can be specified to fire</p>
<ul class="list">
<li><p>Before the operation is attempted on a row (before constraints are checked and the INSERT, UPDATE or DELETE is attempted)</p></li>
<li><p>After the operation has completed (after constraints are checked and the INSERT, UPDATE, or DELETE has completed)</p></li>
<li><p>Instead of the operation (in the case of inserts, updates or deletes on a view)</p>
</ul>
</li>
<li><p>A trigger that is marked FOR EACH ROW is called once for every row that the operation modifies. In contrast, a trigger that is marked FOR EACH STATEMENT only executes once for any given operation, regardless of how many rows it modifies.</p></li>
<li><p>Both, the WHEN clause and the trigger actions, may access elements of the row being inserted, deleted or updated using references of the form <b>NEW.column-name</b> and <b>OLD.column-name</b>, where column-name is the name of a column from the table that the trigger is associated with.</p></li>
<li><p>If a WHEN clause is supplied, the PostgreSQL statements specified are only executed for rows for which the WHEN clause is true. If no WHEN clause is supplied, the PostgreSQL statements are executed for all rows.</p></li>
<li><p>If multiple triggers of the same kind are defined for the same event, they will be fired in alphabetical order by name.</p></li>
<li><p>The BEFORE, AFTER or INSTEAD OF keyword determines when the trigger actions will be executed relative to the insertion, modification or removal of the associated row.</p></li>
<li><p>Triggers are automatically dropped when the table that they are associated with is dropped.</p></li>
<li><p>The table to be modified must exist in the same database as the table or view to which the trigger is attached and one must use just <b>tablename</b>, not <b>database.tablename</b>.</p></li>
<li><p>A CONSTRAINT option when specified creates a <i>constraint trigger</i>. This is the same as a regular trigger except that the timing of the trigger firing can be adjusted using SET CONSTRAINTS. Constraint triggers are expected to raise an exception when the constraints they implement are violated.</p></li>
</ul>
<h2>Syntax</h2>
<p>The basic syntax of creating a <b>trigger</b> is as follows &minus;</p>
<pre class="result notranslate">
CREATE  TRIGGER trigger_name [BEFORE|AFTER|INSTEAD OF] event_name
ON table_name
[
 -- Trigger logic goes here....
];
</pre>
<p>Here, <b>event_name</b> could be <i>INSERT, DELETE,</i> <i>UPDATE,</i> and <i>TRUNCATE</i> database operation on the mentioned table <b>table_name</b>. You can optionally specify FOR EACH ROW after table name.</p>
<p>The following is the syntax of creating a trigger on an UPDATE operation on one or more specified columns of a table as follows &minus;</p>
<pre class="prettyprint notranslate">
CREATE  TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_name
ON table_name
[
 -- Trigger logic goes here....
];
</pre>
<h2>Example</h2>
<p>Let us consider a case where we want to keep audit trial for every record being inserted in COMPANY table, which we will create newly as follows (Drop COMPANY table if you already have it).</p>
<pre class="prettyprint notranslate">
testdb=# CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<p>To keep audit trial, we will create a new table called AUDIT where log messages will be inserted whenever there is an entry in COMPANY table for a new record &minus;</p>
<pre class="prettyprint notranslate">
testdb=# CREATE TABLE AUDIT(
   EMP_ID INT NOT NULL,
   ENTRY_DATE TEXT NOT NULL
);
</pre>
<p>Here, ID is the AUDIT record ID, and EMP_ID is the ID, which will come from COMPANY table, and DATE will keep timestamp when the record will be created in COMPANY table. So now, let us create a trigger on COMPANY table as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# CREATE TRIGGER example_trigger AFTER INSERT ON COMPANY
FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();
</pre>
<p>Where auditlogfunc() is a PostgreSQL <b>procedure</b> and has the following definition &minus;</p>
<pre class="prettyprint notranslate">
CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
   BEGIN
      INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
      RETURN NEW;
   END;
$example_table$ LANGUAGE plpgsql;
</pre>
<p>Now, we will start the actual work. Let us start inserting record in COMPANY table which should result in creating an audit log record in AUDIT table. So let us create one record in COMPANY table as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
VALUES (1, 'Paul', 32, 'California', 20000.00 );
</pre>
<p>This will create one record in COMPANY table, which is as follows &minus;</p>
<pre class="prettyprint notranslate">
 id | name | age | address      | salary
----+------+-----+--------------+--------
  1 | Paul |  32 | California   |  20000</pre>
<p>Same time, one record will be created in AUDIT table. This record is the result of a trigger, which we have created on INSERT operation on COMPANY table. Similarly, you can create your triggers on UPDATE and DELETE operations based on your requirements.</p>
<pre class="prettyprint notranslate">
 emp_id |          entry_date
--------+-------------------------------
      1 | 2013-05-05 15:49:59.968+05:30
(1 row)
</pre>
<h2>Listing TRIGGERS</h2>
<p>You can list down all the triggers in the current database from <b>pg_trigger</b> table as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM pg_trigger;
</pre>
<p>The above given PostgreSQL statement will list down all triggers.</p>
<p>If you want to list the triggers on a particular table, then use AND clause with table name as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT tgname FROM pg_trigger, pg_class WHERE tgrelid=pg_class.oid AND relname='company';
</pre>
<p>The above given PostgreSQL statement will also list down only one entry as follows &minus;</p>
<pre class="prettyprint notranslate">
     tgname
-----------------
 example_trigger
(1 row)
</pre>
<h2>Dropping TRIGGERS</h2>
<p>The following is the DROP command, which can be used to drop an existing trigger &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DROP TRIGGER trigger_name;
</pre>
<h1>PostgreSQL - INDEXES</h1>
<p>Indexes are special lookup tables that the database search engine can use to speed up data retrieval. Simply put, an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book.</p>
<p>For example, if you want to reference all pages in a book that discusses a certain topic, you have to first refer to the index, which lists all topics alphabetically and then refer to one or more specific page numbers.</p>
<p>An index helps to speed up SELECT queries and WHERE clauses; however, it slows down data input, with UPDATE and INSERT statements. Indexes can be created or dropped with no effect on the data.</p>
<p>Creating an index involves the CREATE INDEX statement, which allows you to name the index, to specify the table and which column or columns to index, and to indicate whether the index is in ascending or descending order.</p>
<p>Indexes can also be unique, similar to the UNIQUE constraint, in that the index prevents duplicate entries in the column or combination of columns on which there's an index.</p>
<h3>The CREATE INDEX Command</h3>
<p>The basic syntax of <b>CREATE INDEX</b> is as follows &minus;</p>
<pre class="result notranslate">
CREATE INDEX index_name ON table_name;
</pre>
<h2>Index Types</h2>
<p>PostgreSQL provides several index types: B-tree, Hash, GiST, SP-GiST and GIN. Each Index type uses a different algorithm that is best suited to different types of queries. By default, the CREATE INDEX command creates B-tree indexes, which fit the most common situations.</p>
<h3>Single-Column Indexes</h3>
<p>A single-column index is one that is created based on only one table column. The basic syntax is as follows &minus;</p>
<pre class="result notranslate">
CREATE INDEX index_name
ON table_name (column_name);
</pre>
<h3>Multicolumn Indexes</h3>
<p>A multicolumn index is defined on more than one column of a table. The basic syntax is as follows &minus;</p>
<pre class="result notranslate">
CREATE INDEX index_name
ON table_name (column1_name, column2_name);
</pre>
<p>Whether to create a single-column index or a multicolumn index, take into consideration the column(s) that you may use very frequently in a query's WHERE clause as filter conditions.</p>
<p>Should there be only one column used, a single-column index should be the choice. Should there be two or more columns that are frequently used in the WHERE clause as filters, the multicolumn index would be the best choice.</p>
<h3>Unique Indexes</h3>
<p>Unique indexes are used not only for performance, but also for data integrity. A unique index does not allow any duplicate values to be inserted into the table. The basic syntax is as follows &minus;</p>
<pre class="result notranslate">
CREATE UNIQUE INDEX index_name
on table_name (column_name);
</pre>
<h2>Partial Indexes</h2>
<p>A partial index is an index built over a subset of a table; the subset is defined by a conditional expression (called the predicate of the partial index). The index contains entries only for those table rows that satisfy the predicate. The basic syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
CREATE INDEX index_name
on table_name (conditional_expression);
</pre>
<h2>Implicit Indexes</h2>
<p>Implicit indexes are indexes that are automatically created by the database server when an object is created. Indexes are automatically created for primary key constraints and unique constraints.</p>
<h3>Example</h3>
<p>The following is an example where we will create an index on <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table for salary column &minus;</p>
<pre class="prettyprint notranslate">
# CREATE INDEX salary_index ON COMPANY (salary);
</pre>
<p>Now, let us list down all the indices available on COMPANY table using <b>\d company</b> command.</p>
<pre class="prettyprint notranslate">
# \d company
</pre>
<p>This will produce the following result, where <i>company_pkey</i> is an implicit index, which got created when the table was created.</p>
<pre class="prettyprint notranslate">
       Table "public.company"
 Column  |     Type      | Modifiers
---------+---------------+-----------
 id      | integer       | not null
 name    | text          | not null
 age     | integer       | not null
 address | character(50) |
 salary  | real          |
Indexes:
    "company_pkey" PRIMARY KEY, btree (id)
    "salary_index" btree (salary)
</pre>
<p>You can list down the entire indexes database wide using the <b>\di</b> command &minus;</p>
<h2>The DROP INDEX Command</h2>
<p>An index can be dropped using PostgreSQL <b>DROP</b> command. Care should be taken when dropping an index because performance may be slowed or improved.</p>
<p>The basic syntax is as follows &minus;</p>
<pre class="result notranslate">
DROP INDEX index_name;
</pre>
<p>You can use following statement to delete previously created index &minus;</p>
<pre class="prettyprint notranslate">
# DROP INDEX salary_index;
</pre>
<h2>When Should Indexes be Avoided?</h2>
<p>Although indexes are intended to enhance a database's performance, there are times when they  should be avoided. The following guidelines indicate when the use of an index should be reconsidered &minus;</p>
<ul class="list">
<li><p>Indexes should not be used on small tables.</p></li>
<li><p>Tables that have frequent, large batch update  or insert operations.</p></li>
<li><p>Indexes should not be used on columns that contain a high number of NULL values.</p></li>
<li><p>Columns that are frequently manipulated should not be indexed.</p></li>
</ul>
<h1>PostgreSQL - ALTER TABLE Command</h1>
<p>The PostgreSQL <b>ALTER TABLE</b> command is used to add, delete or modify columns in an existing table.</p>
<p>You would also use ALTER TABLE command to add and drop various constraints on an existing table.</p>
<h2>Syntax</h2>
<p>The basic syntax of <b>ALTER TABLE</b> to add a new column in an existing table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name ADD column_name datatype;
</pre>
<p>The basic syntax of ALTER TABLE to <b>DROP COLUMN</b> in an existing table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name DROP COLUMN column_name;
</pre>
<p>The basic syntax of ALTER TABLE to change the <b>DATA TYPE</b> of a column in a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name ALTER COLUMN column_name TYPE datatype;
</pre>
<p>The basic syntax of ALTER TABLE to add a <b>NOT NULL</b> constraint to a column in a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name MODIFY column_name datatype NOT NULL;
</pre>
<p>The basic syntax of ALTER TABLE to <b>ADD UNIQUE CONSTRAINT</b> to a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
ADD CONSTRAINT MyUniqueConstraint UNIQUE(column1, column2...);
</pre>
<p>The basic syntax of ALTER TABLE to <b>ADD CHECK CONSTRAINT</b> to a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
ADD CONSTRAINT MyUniqueConstraint CHECK (CONDITION);
</pre>
<p>The basic syntax of ALTER TABLE to <b>ADD PRIMARY KEY</b> constraint to a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
ADD CONSTRAINT MyPrimaryKey PRIMARY KEY (column1, column2...);
</pre>
<p>The basic syntax of ALTER TABLE to <b>DROP CONSTRAINT</b> from a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
DROP CONSTRAINT MyUniqueConstraint;
</pre>
<p>If you are using MySQL, the code is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
DROP INDEX MyUniqueConstraint;
</pre>
<p>The basic syntax of ALTER TABLE to <b>DROP PRIMARY KEY</b> constraint from a table is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
DROP CONSTRAINT MyPrimaryKey;
</pre>
<p>If you are using MySQL, the code is as follows &minus;</p>
<pre class="result notranslate">
ALTER TABLE table_name
DROP PRIMARY KEY;
</pre>
<h2>Example</h2>
<p>Consider our <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table has the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
</pre>
<p>The following is the example to ADD a new column in an existing table &minus;</p>
<pre class="prettyprint notranslate">
testdb=# ALTER TABLE COMPANY ADD GENDER char(1);
</pre>
<p>Now, COMPANY table is changed and the following would be the output from SELECT statement &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address     | salary | gender
----+-------+-----+-------------+--------+--------
  1 | Paul  |  32 | California  |  20000 |
  2 | Allen |  25 | Texas       |  15000 |
  3 | Teddy |  23 | Norway      |  20000 |
  4 | Mark  |  25 | Rich-Mond   |  65000 |
  5 | David |  27 | Texas       |  85000 |
  6 | Kim   |  22 | South-Hall  |  45000 |
  7 | James |  24 | Houston     |  10000 |
(7 rows)
</pre>
<p>The following is the example to DROP  gender column from existing table &minus;</p>
<pre class="result notranslate">
testdb=# ALTER TABLE COMPANY DROP GENDER;
</pre>
<p>Now, COMPANY table is changed and the following would be the output from SELECT statement &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
</pre>
<h1>PostgreSQL - TRUNCATE TABLE Command</h1>
<p>The PostgreSQL <b>TRUNCATE TABLE</b> command is used to delete complete data from an existing table. You can also use DROP TABLE command to delete complete table but it would remove complete table structure from the database and you would need to re-create this table once again if you wish to store some data.</p>
<p>It has the same effect as DELETE on each table, but since it does not actually scan the tables, it is faster. Furthermore, it reclaims disk space immediately, rather than requiring a subsequent VACUUM operation. This is most useful on large tables.</p>
<h2>Syntax</h2>
<p>The basic syntax of <b>TRUNCATE TABLE</b> is as follows &minus;</p>
<pre class="result notranslate">
TRUNCATE TABLE  table_name;
</pre>
<h2>Example</h2>
<p>Consider the COMPANY table has the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
(7 rows)
</pre>
<p>The following is the example to truncate &minus;</p>
<pre class="prettyprint notranslate">
testdb=# TRUNCATE TABLE COMPANY;
</pre>
<p>Now, COMPANY table is truncated and the following would be the output of SELECT statement &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM CUSTOMERS;
 id | name | age | address | salary
----+------+-----+---------+--------
(0 rows)
</pre>
<h1>PostgreSQL - VIEWS</h1>
<p>Views are pseudo-tables. That is, they are not real tables; nevertheless appear as ordinary tables to SELECT. A view can represent a subset of a real table, selecting certain columns or certain rows from an ordinary table. A view can even represent joined tables. Because views are assigned separate permissions, you can use them to restrict table access so that the users see only specific rows or columns of a table.</p>
<p>A view can contain all rows of a table or selected rows from one or more tables. A view can be created from one or many tables, which depends on the written PostgreSQL query to create a view.</p>
<p>Views, which are kind of virtual tables, allow users to do the following &minus;</p>
<ul class="list">
<li><p>Structure data in a way that users or classes of users find natural or intuitive.</p></li>
<li><p>Restrict access to the data such that a user can only see limited data instead of complete table.</p></li>
<li><p>Summarize data from various tables, which can be used to generate reports.</p></li>
</ul>
<p>Since views are not ordinary tables, you may not be able to execute a DELETE, INSERT, or UPDATE statement on a view. However, you can create a RULE to correct this problem of using DELETE, INSERT or UPDATE on a view.</p>
<h2>Creating Views</h2>
<p>The PostgreSQL views are created using the <b>CREATE VIEW</b> statement. The PostgreSQL views can be created from a single table, multiple tables, or another view.</p>
<p>The basic CREATE VIEW syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
CREATE [TEMP | TEMPORARY] VIEW view_name AS
SELECT column1, column2.....
FROM table_name
WHERE [condition];
</pre>
<p>You can include multiple tables in your SELECT statement in very similar way as you use them in normal PostgreSQL SELECT query. If the optional TEMP or TEMPORARY keyword is present, the view will be created in the temporary space. Temporary views are automatically dropped at the end of the current session.</p>
<h3>Example</h3>
<p>Consider, the <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table is having the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
</pre>
<p>Now, following is an example to create a view from COMPANY table. This view would be used to have only few columns from COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
testdb=# CREATE VIEW COMPANY_VIEW AS
SELECT ID, NAME, AGE
FROM  COMPANY;
</pre>
<p>Now, you can query COMPANY_VIEW in a similar way as you query an actual table. Following is the example &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT * FROM COMPANY_VIEW;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age
----+-------+-----
  1 | Paul  |  32
  2 | Allen |  25
  3 | Teddy |  23
  4 | Mark  |  25
  5 | David |  27
  6 | Kim   |  22
  7 | James |  24
(7 rows)
</pre>
<h2>Dropping Views</h2>
<p>To drop a view, simply use the DROP VIEW statement with the <b>view_name</b>. The basic DROP VIEW syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DROP VIEW view_name;
</pre>
<p>The following command will delete COMPANY_VIEW view, which we created in the last section &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DROP VIEW COMPANY_VIEW;
</pre>
<h1>PostgreSQL - TRANSACTIONS</h1>
<p>A transaction is a unit of work that is performed against a database. Transactions are units or sequences of work accomplished in a logical order, whether in a manual fashion by a user or automatically by some sort of a database program.</p>
<p>A transaction is the propagation of one or more changes to the database. For example, if you are creating a record, updating a record, or deleting a record from the table, then you are performing transaction on the table. It is important to control transactions to ensure data integrity and to handle database errors.</p>
<p>Practically, you will club many PostgreSQL queries into a group and you will execute all of them together as a part of a transaction.</p>
<h3>Properties of Transactions</h3>
<p>Transactions have the following four standard properties, usually referred to by the acronym ACID &minus;</p>
<ul class="list">
<li><p><b>Atomicity</b> &minus; Ensures that all operations within the work unit are completed successfully; otherwise, the transaction is aborted at the point of failure and previous operations are rolled back to their former state.</p></li>
<li><p><b>Consistency</b> &minus; Ensures that the database properly changes states upon a successfully committed transaction.</p></li>
<li><p><b>Isolation</b> &minus; Enables transactions to operate independently of and transparent to each other.</p></li>
<li><p><b>Durability</b> &minus; Ensures that the result or effect of a committed transaction persists in case of a system failure.</p></li>
</ul>
<h2>Transaction Control</h2>
<p>The following commands are used to control transactions &minus;</p>
<ul class="list">
<li><p><b>BEGIN TRANSACTION</b> &minus; To start a transaction.</p></li>
<li><p><b>COMMIT</b> &minus; To save the changes, alternatively you can use <b>END TRANSACTION</b> command.</p></li>
<li><p><b>ROLLBACK</b> &minus; To rollback the changes.</p></li>
</ul>
<p>Transactional control commands are only used with the DML commands INSERT, UPDATE and DELETE only. They cannot be used while creating tables or dropping them because these operations are automatically committed in the database.</p>
<h3>The BEGIN TRANSACTION Command</h3>
<p>Transactions can be started using BEGIN TRANSACTION or simply BEGIN command. Such transactions usually persist until the next COMMIT or ROLLBACK command is encountered. But a transaction will also ROLLBACK if the database is closed or if an error occurs.</p>
<p>The following is the simple syntax to start a transaction &minus;</p>
<pre class="result notranslate">
BEGIN;

or

BEGIN TRANSACTION;
</pre>
<h2>The COMMIT Command</h2>
<p>The COMMIT command is the transactional command used to save changes invoked by a transaction to the database.</p>
<p>The COMMIT command saves all transactions to the database since the last COMMIT or ROLLBACK command.</p>
<p>The syntax for COMMIT command is as follows &minus;</p>
<pre class="result notranslate">
COMMIT;

or

END TRANSACTION;
</pre>
<h2>The ROLLBACK Command</h2>
<p>The ROLLBACK command is the transactional command used to undo transactions that have not already been saved to the database.</p>
<p>The ROLLBACK command can only be used to undo transactions since the last COMMIT or ROLLBACK command was issued.</p>
<p>The syntax for ROLLBACK command is as follows &minus;</p>
<pre class="result notranslate">
ROLLBACK;
</pre>
<h2>Example</h2>
<p>Consider the <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table is having the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
</pre>
<p>Now, let us start a transaction and delete records from the table having age = 25 and finally we use ROLLBACK command to undo all the changes.</p>
<pre class="prettyprint notranslate">
testdb=# BEGIN;
DELETE FROM COMPANY WHERE AGE = 25;
ROLLBACK;
</pre>
<p>If you will check COMPANY table is still having the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
</pre>
<p>Now, let us start another transaction and delete records from the table having age = 25 and finally we use COMMIT command to commit all the changes.</p>
<pre class="prettyprint notranslate">
testdb=# BEGIN;
DELETE FROM COMPANY WHERE AGE = 25;
COMMIT;
</pre>
<p>If you will check the COMPANY table, it still has the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  3 | Teddy |  23 | Norway     |  20000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
(5 rows)
</pre>
<h1>PostgreSQL - LOCKS</h1>
<p><i>Locks</i> or <i>Exclusive Locks</i> or <i>Write Locks</i> prevent users from modifying a row or an entire table. Rows modified by UPDATE and DELETE are then exclusively locked automatically for the duration of the transaction. This prevents other users from changing the row until the transaction is either committed or rolled back.</p>
<p>The only time when users must wait for other users is when they are trying to modify the same row. If they modify different rows, no waiting is necessary. SELECT queries never have to wait.</p>
<p>The database performs locking automatically. In certain cases, however, locking must be controlled manually. Manual locking can be done by using the LOCK command. It allows specification of a transaction's lock type and scope.</p>
<h3>Syntax for LOCK command</h3>
<p>The basic syntax for LOCK command is as follows &minus;</p>
<pre class="result notranslate">
LOCK [ TABLE ]
name
 IN
lock_mode
</pre>
<ul class="list">
<li><p><b>name</b> &minus; The name (optionally schema-qualified) of an existing table to lock. If ONLY is specified before the table name, only that table is locked. If ONLY is not specified, the table and all its descendant tables (if any) are locked.</p></li>
<li><p><b>lock_mode</b> &minus; The lock mode specifies which locks this lock conflicts with. If no lock mode is specified, then ACCESS EXCLUSIVE, the most restrictive mode, is used. Possible values are: ACCESS SHARE, ROW SHARE, ROW EXCLUSIVE, SHARE UPDATE EXCLUSIVE, SHARE, SHARE ROW EXCLUSIVE, EXCLUSIVE, ACCESS EXCLUSIVE.</p></li>
</ul>
<blockquote>Once obtained, the lock is held for the remainder of the current transaction. There is no UNLOCK TABLE command; locks are always released at the transaction end.</blockquote>
<h2>DeadLocks</h2>
<p> Deadlocks can occur when two transactions are waiting for each other to finish their operations. While PostgreSQL can detect them and end them with a ROLLBACK, deadlocks can still be inconvenient. To prevent your applications from running into this problem, make sure to design them in such a way that they will lock objects in the same order.</p>
<h2>Advisory Locks</h2>
<p>PostgreSQL provides means for creating locks that have application-defined meanings. These are called <i>advisory locks</i>. As the system does not enforce their use, it is up to the application to use them correctly. Advisory locks can be useful for locking strategies that are an awkward fit for the MVCC model.</p>
<p>For example, a common use of advisory locks is to emulate pessimistic locking strategies typical of the so-called "flat file" data management systems. While a flag stored in a table could be used for the same purpose, advisory locks are faster, avoid table bloat, and are automatically cleaned up by the server at the end of the session.</p>
<h3>Example</h3>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>The following example locks the COMPANY table within the testdb database in ACCESS EXCLUSIVE mode. The LOCK statement works only in a transaction mode &minus;</p>
<pre class="prettyprint notranslate">
testdb=#BEGIN;
LOCK TABLE company1 IN ACCESS EXCLUSIVE MODE;
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="prettyprint notranslate">
LOCK TABLE
</pre>
<p>The above message indicates that the table is locked until the transaction ends and to finish the transaction you will have to either rollback or commit the transaction.</p>
<h1>PostgreSQL - Sub Queries</h1>
<p>A subquery or Inner query or Nested query is a query within another PostgreSQL query and embedded within the WHERE clause.</p>
<p>A subquery is used to return data that will be used in the main query as a condition to further restrict the data to be retrieved.</p>
<p>Subqueries can be used with the SELECT, INSERT, UPDATE and DELETE statements along with the operators like =, &lt;, &gt;, &gt;=, &lt;=, IN, etc.</p>
<p>There are a few rules that subqueries must follow &minus;</p>
<ul class="list">
<li><p>Subqueries must be enclosed within parentheses.</p></li>
<li><p>A subquery can have only one column in the SELECT clause, unless multiple columns are in the main query for the subquery to compare its selected columns.</p></li>
<li><p>An ORDER BY cannot be used in a subquery, although the main query can use an ORDER BY. The GROUP BY can be used to perform the same function as the ORDER BY in a subquery.</p></li>
<li><p>Subqueries that return more than one row can only be used with multiple value operators, such as the IN, EXISTS, NOT IN, ANY/SOME, ALL operator.</p></li>
<li><p>The BETWEEN operator cannot be used with a subquery; however, the BETWEEN can be used within the subquery.</p></li>
</ul>
<h2>Subqueries with the SELECT Statement</h2>
<p>Subqueries are most frequently used with the SELECT statement. The basic syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
SELECT column_name [, column_name ]
FROM   table1 [, table2 ]
WHERE  column_name OPERATOR
      (SELECT column_name [, column_name ]
      FROM table1 [, table2 ]
      [WHERE])
</pre>
<h3>Example</h3>
<p>Consider the <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table having the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Now, let us check the following sub-query with SELECT statement &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT *
   FROM COMPANY
   WHERE ID IN (SELECT ID
      FROM COMPANY
      WHERE SALARY &gt; 45000) ;
</pre>
<p>This would produce the following result &minus;</p>
<pre class="result notranslate">
 id | name  | age |  address    | salary
----+-------+-----+-------------+--------
  4 | Mark  |  25 | Rich-Mond   |  65000
  5 | David |  27 | Texas       |  85000
(2 rows)
</pre>
<h2>Subqueries with the INSERT Statement</h2>
<p>Subqueries also can be used  with INSERT statements. The INSERT statement uses the data returned from the subquery to insert into another table. The selected data in the subquery can be modified with any of the character, date, or number functions.</p>
<p>The basic syntax is as follows &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO table_name [ (column1 [, column2 ]) ]
   SELECT [ *|column1 [, column2 ] ]
   FROM table1 [, table2 ]
   [ WHERE VALUE OPERATOR ]
</pre>
<h3>Example</h3>
<p>Consider a table COMPANY_BKP, with similar structure as COMPANY table and can be created using the same CREATE TABLE using COMPANY_BKP as the table name. Now, to copy complete COMPANY table into COMPANY_BKP, following is the syntax &minus;</p>
<pre class="prettyprint notranslate">
testdb=# INSERT INTO COMPANY_BKP
   SELECT * FROM COMPANY
   WHERE ID IN (SELECT ID
      FROM COMPANY) ;
</pre>
<h2>Subqueries with the UPDATE Statement</h2>
<p>The subquery can be used in conjunction with the UPDATE statement. Either single or multiple columns in a table can be updated when using a subquery with the UPDATE statement.</p>
<p>The basic syntax is as follows &minus;</p>
<pre class="result notranslate">
UPDATE table
SET column_name = new_value
[ WHERE OPERATOR [ VALUE ]
   (SELECT COLUMN_NAME
   FROM TABLE_NAME)
   [ WHERE) ]
</pre>
<h3>Example</h3>
<p>Assuming, we have COMPANY_BKP table available, which is backup of the COMPANY table.</p>
<p>The following example updates SALARY by 0.50 times in the COMPANY table for all the customers, whose AGE is greater than or equal to 27 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# UPDATE COMPANY
   SET SALARY = SALARY * 0.50
   WHERE AGE IN (SELECT AGE FROM COMPANY_BKP
      WHERE AGE &gt;= 27 );
</pre>
<p>This would affect two rows and finally the COMPANY table would have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  2 | Allen |  25 | Texas       |  15000
  3 | Teddy |  23 | Norway      |  20000
  4 | Mark  |  25 | Rich-Mond   |  65000
  6 | Kim   |  22 | South-Hall  |  45000
  7 | James |  24 | Houston     |  10000
  1 | Paul  |  32 | California  |  10000
  5 | David |  27 | Texas       |  42500
(7 rows)
</pre>
<h2>Subqueries with the DELETE Statement</h2>
<p>The subquery can be used in conjunction with the DELETE statement like with any other statements mentioned above.</p>
<p>The basic syntax is as follows &minus;</p>
<pre class="result notranslate">
DELETE FROM TABLE_NAME
[ WHERE OPERATOR [ VALUE ]
   (SELECT COLUMN_NAME
   FROM TABLE_NAME)
   [ WHERE) ]
</pre>
<h3>Example</h3>
<p>Assuming, we have COMPANY_BKP table available, which is a backup of the COMPANY table.</p>
<p>The following example deletes records from the COMPANY table for all the customers, whose AGE is greater than or equal to 27 &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DELETE FROM COMPANY
   WHERE AGE IN (SELECT AGE FROM COMPANY_BKP
      WHERE AGE &gt; 27 );
</pre>
<p>This would affect two rows and finally the COMPANY table would have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address     | salary
----+-------+-----+-------------+--------
  2 | Allen |  25 | Texas       |  15000
  3 | Teddy |  23 | Norway      |  20000
  4 | Mark  |  25 | Rich-Mond   |  65000
  6 | Kim   |  22 | South-Hall  |  45000
  7 | James |  24 | Houston     |  10000
  5 | David |  27 | Texas       |  42500
(6 rows)
</pre>
<h1>PostgreSQL - AUTO INCREMENT</h1>
<p>PostgreSQL has the data types <i>smallserial</i>, </i>serial</i> and <i>bigserial</i>; these are not true types, but merely a notational convenience for creating unique identifier columns. These are similar to AUTO_INCREMENT property supported by some other databases.</p>
<p>If you wish a <i>serial</i> column to have a unique constraint or be a primary key, it must now be specified, just like any other data type.</p>
<p>The type name <i>serial</i> creates an <i>integer</i> columns. The type name <i>bigserial</i> creates a <i>bigint</i> column. <i>bigserial</i> should be used if you anticipate the use of more than 231 identifiers over the lifetime of the table. The type name <i>smallserial</i> creates a <i>smallint</i> column.</p>
<h2>Syntax</h2>
<p>The basic usage of <b>SERIAL</b> dataype is as follows &minus;</p>
<pre class="result notranslate">
CREATE TABLE tablename (
   colname SERIAL
);
</pre>
<h2>Example</h2>
<p>Consider the COMPANY table to be created as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# CREATE TABLE COMPANY(
   ID  SERIAL PRIMARY KEY,
   NAME           TEXT      NOT NULL,
   AGE            INT       NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);
</pre>
<p>Now, insert the following records into table COMPANY &minus;</p>
<pre class="prettyprint notranslate">
INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'Paul', 32, 'California', 20000.00 );

INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ('Allen', 25, 'Texas', 15000.00 );

INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ('Teddy', 23, 'Norway', 20000.00 );

INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'Mark', 25, 'Rich-Mond ', 65000.00 );

INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'David', 27, 'Texas', 85000.00 );


INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'Kim', 22, 'South-Hall', 45000.00 );

INSERT INTO COMPANY (NAME,AGE,ADDRESS,SALARY)
VALUES ( 'James', 24, 'Houston', 10000.00 );
</pre>
<p>This will insert seven tuples into the table COMPANY and COMPANY will have the following records &minus;</p>
<pre class="prettyprint notranslate">
 id | name  | age | address    | salary
----+-------+-----+------------+--------
  1 | Paul  |  32 | California |  20000
  2 | Allen |  25 | Texas      |  15000
  3 | Teddy |  23 | Norway     |  20000
  4 | Mark  |  25 | Rich-Mond  |  65000
  5 | David |  27 | Texas      |  85000
  6 | Kim   |  22 | South-Hall |  45000
  7 | James |  24 | Houston    |  10000
</pre>
<h1>PostgreSQL - PRIVILEGES</h1>
<p>Whenever an object is created in a database, an owner is assigned to it. The owner is usually the one who executed the creation statement. For most kinds of objects, the initial state is that only the owner (or a superuser) can modify or delete the object. To allow other roles or users to use it, <i>privileges</i> or permission must be granted.</p>
<p>Different kinds of privileges in PostgreSQL are &minus;</p>
<ul class="list">
<li>SELECT,</li>
<li>INSERT,</li>
<li>UPDATE,</li>
<li>DELETE,</li>
<li>TRUNCATE,</li>
<li>REFERENCES,</li>
<li>TRIGGER,</li>
<li>CREATE,</li>
<li>CONNECT,</li>
<li>TEMPORARY,</li>
<li>EXECUTE, and</li>
<li>USAGE</li>
</ul>
<p>Depending on the type of the object (table, function, etc.,), privileges are applied to the object. To assign privileges to the users, the GRANT command is used.</p>
<h2>Syntax for GRANT</h2>
<p>Basic syntax for GRANT command is as follows &minus;</p>
<pre class="result notranslate">
GRANT privilege [, ...]
ON object [, ...]
TO { PUBLIC | GROUP group | username }
</pre>
<ul class="list">
<li><p><b>privilege</b> &minus; values could be: SELECT, INSERT, UPDATE, DELETE, RULE, ALL.</p></li>
<li><p><b>object</b> &minus; The name of an object to which to grant access. The possible objects are: table, view, sequence</p></li>
<li><p><b>PUBLIC</b> &minus; A short form representing all users.</p></li>
<li><p>GROUP <b>group</b> &minus; A group to whom to grant privileges.</p></li>
<li><p><b>username</b> &minus; The name of a user to whom to grant privileges. PUBLIC is a short form representing all users.</p></li>
</ul>
<p>The privileges can be revoked using the REVOKE command.</p>
<h2>Syntax for REVOKE</h2>
<p>Basic syntax for REVOKE command is as follows &minus;</p>
<pre class="result notranslate">
REVOKE privilege [, ...]
ON object [, ...]
FROM { PUBLIC | GROUP groupname | username }
</pre>
<ul class="list">
<li><p><b>privilege</b> &minus; values could be: SELECT, INSERT, UPDATE, DELETE, RULE, ALL.</p></li>
<li><p><b>object</b> &minus; The name of an object to which to grant access. The possible objects are: table, view, sequence</p></li>
<li><p><b>PUBLIC</b> &minus; A short form representing all users.</p></li>
<li><p>GROUP <b>group</b> &minus; A group to whom to grant privileges.</p></li>
<li><p><b>username</b> &minus; The name of a user to whom to grant privileges. PUBLIC is a short form representing all users.</p></li>
</ul>
<h2>Example</h2>
<p>To understand the privileges, let us first create a USER as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# CREATE USER manisha WITH PASSWORD 'password';
CREATE ROLE
</pre>
<p>The message CREATE ROLE indicates that the USER "manisha" is created.</p>
<p>Consider the table <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> having records as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Next, let us grant all privileges on a table COMPANY to the user "manisha" as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# GRANT ALL ON COMPANY TO manisha;
GRANT
</pre>
<p>The message GRANT indicates that all privileges are assigned to the USER.</p>
<p>Next, let us revoke the privileges from the USER "manisha" as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# REVOKE ALL ON COMPANY FROM manisha;
REVOKE
</pre>
<p>The message REVOKE indicates that all privileges are revoked from the USER.</p>
<p>You can even delete the user as follows &minus;</p>
<pre class="prettyprint notranslate">
testdb=# DROP USER manisha;
DROP ROLE
</pre>
<p>The message DROP ROLE indicates USER ‘Manisha’ is deleted from the database.</p>
<h1>PostgreSQL - DATE/TIME Functions and Operators</h1>
<p>We had discussed about the Date/Time data types in the chapter <a href="postgresql_data_types.html">Data Types</a>. Now, let us see the Date/Time operators and Functions.</p>
<p>The following table lists the behaviors of the basic arithmetic operators &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operator</th>
<th style="text-align:center;width:50%">Example</th>
<th style="text-align:center;">Result</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td style="text-align:center;vertical-align:middle;">date '2001-09-28' + integer '7'</td>
<td style="text-align:center;vertical-align:middle;">date '2001-10-05'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td style="text-align:center;vertical-align:middle;">date '2001-09-28' + interval '1 hour'</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-28 01:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td style="text-align:center;vertical-align:middle;">date '2001-09-28' + time '03:00'</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-28 03:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td style="text-align:center;vertical-align:middle;">interval '1 day' + interval '1 hour'</td>
<td style="text-align:center;vertical-align:middle;">interval '1 day 01:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-28 01:00' + interval '23 hours'</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-29 00:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">+</td>
<td style="text-align:center;vertical-align:middle;">time '01:00' + interval '3 hours'</td>
<td style="text-align:center;vertical-align:middle;">time '04:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">- interval '23 hours'</td>
<td style="text-align:center;vertical-align:middle;">interval '-23:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">date '2001-10-01' - date '2001-09-28'</td>
<td style="text-align:center;vertical-align:middle;">integer '3' (days)</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">date '2001-10-01' - integer '7'</td>
<td style="text-align:center;vertical-align:middle;">date '2001-09-24'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">date '2001-09-28' - interval '1 hour'</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-27 23:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">time '05:00' - time '03:00'</td>
<td style="text-align:center;vertical-align:middle;">interval '02:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">time '05:00' - interval '2 hours'</td>
<td style="text-align:center;vertical-align:middle;">time '03:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-28 23:00' - interval '23 hours'</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-28 00:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">interval '1 day' - interval '1 hour'</td>
<td style="text-align:center;vertical-align:middle;">interval '1 day -01:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">-</td>
<td style="text-align:center;vertical-align:middle;">timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</td>
<td style="text-align:center;vertical-align:middle;">interval '1 day 15:00:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">*</td>
<td style="text-align:center;vertical-align:middle;">900 * interval '1 second'</td>
<td style="text-align:center;vertical-align:middle;">interval '00:15:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">*</td>
<td style="text-align:center;vertical-align:middle;">21 * interval '1 day'</td>
<td style="text-align:center;vertical-align:middle;">interval '21 days'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">*</td>
<td style="text-align:center;vertical-align:middle;">double precision '3.5' * interval '1 hour'</td>
<td style="text-align:center;vertical-align:middle;">interval '03:30:00'</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">/</td>
<td style="text-align:center;vertical-align:middle;">interval '1 hour' / double precision '1.5'</td>
<td style="text-align:center;vertical-align:middle;">interval '00:40:00'</td>
</tr>
</table>
<p>The following is the list of all important Date and Time related functions available.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><a href="postgresql_date_time.html#function_age">AGE()</a>
<p>Subtract arguments</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><a href="postgresql_date_time.html#function_currentdatetime">CURRENT DATE/TIME()</a>
<p>Current date and time</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><a href="postgresql_date_time.html#function_datepart">DATE_PART()</a>
<p>Get subfield (equivalent to extract)</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><a href="postgresql_date_time.html#function_extract">EXTRACT()</a>
<p>Get subfield</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><a href="postgresql_date_time.html#function_isfinite">ISFINITE()</a>
<p>Test for finite date, time and interval (not +/-infinity)</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><a href="postgresql_date_time.html#function_justify">JUSTIFY</a>
<p>Adjust interval</p></td>
</tr>
</table>
<a name="function_age"></a>
<h2>AGE(timestamp, timestamp), AGE(timestamp)</h2>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>AGE(timestamp, timestamp)</b></p>
<p>When invoked with the TIMESTAMP form of the second argument, AGE() subtract arguments, producing a "symbolic" result that uses years and months and is of type INTERVAL.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>AGE(timestamp)</b></p>
<p>When invoked with only the TIMESTAMP as argument, AGE() subtracts from the current_date (at midnight).</p></td>
</tr>
</table>
<p>Example of the function AGE(timestamp, timestamp) is &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT AGE(timestamp '2001-04-10', timestamp '1957-06-13');
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="prettyprint notranslate">
           age
-------------------------
 43 years 9 mons 27 days
</pre>
<p>Example of the function AGE(timestamp) is &minus;</p>
<pre class="prettyprint notranslate">
testdb=# select age(timestamp '1957-06-13');
</pre>
<p>The above given PostgreSQL statement will produce the following result &minus;</p>
<pre class="prettyprint notranslate">
           age
--------------------------
 55 years 10 mons 22 days
</pre>
<a name="function_currentdatetime"></a>
<h2>CURRENT DATE/TIME()</h2>
<p>PostgreSQL provides a number of functions that return values related to the current date and time. Following are some functions &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>CURRENT_DATE</b></p>
<p>Delivers current date.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>CURRENT_TIME</b></p>
<p>Delivers values with time zone.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>CURRENT_TIMESTAMP</b></p>
<p>Delivers values with time zone.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>CURRENT_TIME(precision)</b></p>
<p>Optionally takes a precision parameter, which causes the result to be rounded to that many fractional digits in the seconds field.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>CURRENT_TIMESTAMP(precision)</b></p>
<p>Optionally takes a precision parameter, which causes the result to be rounded to that many fractional digits in the seconds field.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>LOCALTIME</b></p>
<p>Delivers values without time zone.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>LOCALTIMESTAMP</b></p>
<p>Delivers values without time zone.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>LOCALTIME(precision)</b></p>
<p>Optionally takes a precision parameter, which causes the result to be rounded to that many fractional digits in the seconds field.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>LOCALTIMESTAMP(precision)</b></p>
<p>Optionally takes a precision parameter, which causes the result to be rounded to that many fractional digits in the seconds field.</p></td>
</tr>
</table>
<p>Examples using the functions from the table above &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT CURRENT_TIME;
       timetz
--------------------
 08:01:34.656+05:30
(1 row)


testdb=# SELECT CURRENT_DATE;
    date
------------
 2013-05-05
(1 row)


testdb=# SELECT CURRENT_TIMESTAMP;
              now
-------------------------------
 2013-05-05 08:01:45.375+05:30
(1 row)


testdb=# SELECT CURRENT_TIMESTAMP(2);
         timestamptz
------------------------------
 2013-05-05 08:01:50.89+05:30
(1 row)


testdb=# SELECT LOCALTIMESTAMP;
       timestamp
------------------------
 2013-05-05 08:01:55.75
(1 row)
</pre>
<p>PostgreSQL also provides functions that return the start time of the current statement, as well as the actual current time at the instant the function is called. These functions are &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>transaction_timestamp()</b></p>
<p>It is equivalent to CURRENT_TIMESTAMP, but is named to clearly reflect what it returns.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>statement_timestamp()</b></p>
<p> It returns the start time of the current statement.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>clock_timestamp()</b></p>
<p>It returns the actual current time, and therefore its value changes even within a single SQL command.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>timeofday()</b></p>
<p>It returns the actual current time, but as a formatted text string rather than a timestamp with time zone value.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>now()</b></p>
<p>It is a traditional PostgreSQL equivalent to transaction_timestamp().</p></td>
</tr>
</table>
<a name="function_datepart"></a>
<h2>DATE_PART(text, timestamp), DATE_PART(text, interval), DATE_TRUNC(text, timestamp)</h2>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>DATE_PART('field', source)</b></p>
<p>These functions get the subfields. The <i>field</i> parameter needs to be a string value, not a name.</p>
<p>The valid field names are: <i>century, day, decade, dow, doy, epoch, hour, isodow, isoyear, microseconds, millennium, milliseconds, minute, month, quarter, second, timezone, timezone_hour, timezone_minute, week, year.</i></p></td>
</tr>
<tr>
<td  style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>DATE_TRUNC('field', source)</b></p>
<p>This function is conceptually similar to the <i>trunc</i> function for numbers. <i>source</i> is a value expression of type timestamp or interval. <i>field</i> selects to which precision to truncate the input value. The return value is of type <i>timestamp</i> or <i>interval</i>.</p>
<p>The valid values for <i>field</i> are : <i>microseconds, milliseconds, second, minute, hour, day, week, month, quarter, year, decade, century, millennium</i></p></td>
</tr>
</table>
<p>The following are examples for DATE_PART(<i>'field'</i>, source) functions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');
 date_part
-----------
        16
(1 row)


testdb=# SELECT date_part('hour', INTERVAL '4 hours 3 minutes');
 date_part
-----------
         4
(1 row)
</pre>
<p>The following are examples for DATE_TRUNC(<i>'field'</i>, source) functions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');
     date_trunc
---------------------
 2001-02-16 20:00:00
(1 row)


testdb=# SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');
     date_trunc
---------------------
 2001-01-01 00:00:00
(1 row)
</pre>
<a name="function_extract"></a>
<h2>EXTRACT(field from timestamp), EXTRACT(field from interval)</h2>
<p>The <b>EXTRACT(field FROM source)</b> function retrieves subfields such as year or hour from date/time values. The <i>source</i> must be a value expression of type <i>timestamp, time, or interval</i>. The <i>field</i> is an identifier or string that selects what field to extract from the source value. The EXTRACT function returns values of type <i>double precision</i>.</p>
<p>The following are valid field names (similar to DATE_PART function field names): century, day, decade, dow, doy, epoch, hour, isodow, isoyear, microseconds, millennium, milliseconds, minute, month, quarter, second, timezone, timezone_hour, timezone_minute, week, year.</p>
<p>The following are examples of EXTRACT(<i>'field'</i>, source) functions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');
 date_part
-----------
        20
(1 row)


testdb=# SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');
 date_part
-----------
        16
(1 row)
</pre>
<a name="function_isfinite"></a>
<h2>ISFINITE(date), ISFINITE(timestamp), ISFINITE(interval)</h2>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>ISFINITE(date)</b></p>
<p>Tests for finite date.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>ISFINITE(timestamp)</b></p>
<p>Tests for finite time stamp.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>ISFINITE(interval)</b></p>
<p>Tests for finite interval.</p></td>
</tr>
</table>
<p>The following are the examples of the ISFINITE() functions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT isfinite(date '2001-02-16');
 isfinite
----------
 t
(1 row)


testdb=# SELECT isfinite(timestamp '2001-02-16 21:28:30');
 isfinite
----------
 t
(1 row)


testdb=# SELECT isfinite(interval '4 hours');
 isfinite
----------
 t
(1 row)
</pre>
<a name="function_justify"></a>
<h2>JUSTIFY_DAYS(interval), JUSTIFY_HOURS(interval), JUSTIFY_INTERVAL(interval)</h2>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">Function &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>JUSTIFY_DAYS(interval)</b></p>
<p>Adjusts interval so 30-day time periods are represented as months. Return the <b>interval</b> type</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>JUSTIFY_HOURS(interval)</b></p>
<p>Adjusts interval so 24-hour time periods are represented as days. Return the <b>interval</b> type</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>JUSTIFY_INTERVAL(interval)</b></p>
<p>Adjusts interval using JUSTIFY_DAYS and JUSTIFY_HOURS, with additional sign adjustments. Return the <b>interval</b> type</p></td>
</tr>
</table>
<p>The following are the examples for the ISFINITE() functions &minus;</p>
<pre class="prettyprint notranslate">
testdb=# SELECT justify_days(interval '35 days');
 justify_days
--------------
 1 mon 5 days
(1 row)


testdb=# SELECT justify_hours(interval '27 hours');
 justify_hours
----------------
 1 day 03:00:00
(1 row)


testdb=# SELECT justify_interval(interval '1 mon -1 hour');
 justify_interval
------------------
 29 days 23:00:00
(1 row)
</pre>
<h1>PostgreSQL - Functions</h1>
<p>PostgreSQL <b>functions</b>, also known as Stored Procedures, allow you to carry out operations that would normally take several queries and round trips in a single function within the database. Functions allow database reuse as other applications can interact directly with your stored procedures instead of a middle-tier or duplicating code.</p>
<p>Functions can be created in a language of your choice like SQL, PL/pgSQL, C, Python, etc.</p>
<h2>Syntax</h2>
<p>The basic syntax to create a function is as follows &minus;</p>
<pre class="result notranslate">
CREATE [OR REPLACE] FUNCTION function_name (arguments) 
RETURNS return_datatype AS $variable_name$
   DECLARE
      declaration;
      [...]
   BEGIN
      &lt; function_body &gt;
      [...]
      RETURN { variable_name | value }
   END; LANGUAGE plpgsql;
</pre>
<p>Where,</p>
<ul class="list">
<li><p><b>function-name</b> specifies the name of the function.</p></li>
<li><p>[OR REPLACE] option allows modifying an existing function.</p></li>
<li><p>The function must contain a <b>return</b> statement.</p></li>
<li><p><b>RETURN</b> clause  specifies that data type you are going to return from the function. The <b>return_datatype</b> can be a base, composite, or domain type, or can reference the type of a table column.</p></li>
<li><p><b>function-body</b> contains the executable part.</p></li>
<li><p>The AS keyword is used for creating a standalone function.</p></li>
<li><p><b>plpgsql</b> is the name of the language that the function is implemented in. Here, we use this option for PostgreSQL, it Can be SQL, C, internal, or the name of a user-defined procedural language. For backward compatibility, the name can be enclosed by single quotes.</p></li>
</ul>
<h2>Example</h2>
<p>The following example illustrates creating and calling a standalone function. This function returns the total number of records in the COMPANY table. We will use the <a href="company.sql" alt="COMPANY Table" target="_blank">COMPANY</a> table, which has the following records &minus;</p>
<pre class="prettyprint notranslate">
testdb# select * from COMPANY;
 id | name  | age | address   | salary
----+-------+-----+-----------+--------
  1 | Paul  |  32 | California|  20000
  2 | Allen |  25 | Texas     |  15000
  3 | Teddy |  23 | Norway    |  20000
  4 | Mark  |  25 | Rich-Mond |  65000
  5 | David |  27 | Texas     |  85000
  6 | Kim   |  22 | South-Hall|  45000
  7 | James |  24 | Houston   |  10000
(7 rows)
</pre>
<p>Function totalRecords() is as follows &minus;</p>
<pre class="prettyprint notranslate">
CREATE OR REPLACE FUNCTION totalRecords ()
RETURNS integer AS $total$
declare
	total integer;
BEGIN
   SELECT count(*) into total FROM COMPANY;
   RETURN total;
END;
$total$ LANGUAGE plpgsql;
</pre>
<p>When the above query is executed, the result would be &minus;</p>
<pre class="result notranslate">
testdb# CREATE FUNCTION
</pre>
<p>Now, let us execute a call to this function and check the records in the COMPANY table</p>
<pre class="prettyprint notranslate">
testdb=# select totalRecords();
</pre>
<p>When the above query is executed, the result would be &minus;</p>
<pre class="result notranslate">
 totalrecords
--------------
      7
(1 row)
</pre>
<h1>PostgreSQL - Useful Functions</h1>
<p>PostgreSQL built-in functions, also called as Aggregate functions, are used for performing processing on string or numeric data.</p>
<p>The following is the list of all general-purpose PostgreSQL built-in functions &minus;</p>
<ul class="list">
<li><p><a href="postgresql_count_function.html">PostgreSQL COUNT Function</a> &minus; The PostgreSQL COUNT aggregate function is used to count the number of rows in a database table.</p></li>
<li><p><a href="postgresql_max_function.html">PostgreSQL MAX Function</a> &minus; The PostgreSQL MAX aggregate function allows us to select the highest (maximum) value for a certain column.</p></li>
<li><p><a href="postgresql_min_function.html">PostgreSQL MIN Function</a> &minus; The PostgreSQL MIN aggregate function allows us to select the lowest (minimum) value for a certain column.</p></li>
<li><p><a href="postgresql_avg_function.html">PostgreSQL AVG Function</a> &minus; The PostgreSQL AVG aggregate function selects the average value for certain table column.</p></li>
<li><p><a href="postgresql_sum_function.html">PostgreSQL SUM Function</a> &minus; The PostgreSQL SUM aggregate function allows selecting the total for a numeric column.</p></li>
<li><p><a href="postgresql_array_functions.html">PostgreSQL ARRAY Functions</a> &minus; The PostgreSQL ARRAY aggregate function puts input values, including nulls, concatenated into an array.</p></li>
<li><p><a href="postgresql_numeric_functions.html">PostgreSQL Numeric Functions</a> &minus; Complete list of PostgreSQL functions required to manipulate numbers in SQL.</p></li>
<li><p><a href="postgresql_string_functions.html">PostgreSQL String Functions</a> &minus; Complete list of PostgreSQL functions required to manipulate strings in PostgreSQL.</p></li>
</ul>
<h1>PostgreSQL - C/C++ Interface</h1>
<p>This tutorial is going to use <b>libpqxx</b> library, which is the official C++ client API for PostgreSQL. The source code for libpqxx is available under the BSD license, so you are free to download it, pass it on to others, change it, sell it, include it in your own code, and share your changes with anyone you choose.</p>
<h2>Installation</h2>
<p>The the latest version of libpqxx is available to be downloaded from the link <a href="http://pqxx.org/download/software/libpqxx/" target="_blank" rel="nofollow">Download Libpqxx</a>. So download the latest version and follow the following steps &minus;</p>
<pre class="prettyprint notranslate">
wget http://pqxx.org/download/software/libpqxx/libpqxx-4.0.tar.gz
tar xvfz libpqxx-4.0.tar.gz
cd libpqxx-4.0
./configure
make
make install
</pre>
<p>Before you start using C/C++ PostgreSQL interface, find the <b>pg_hba.conf</b> file in your PostgreSQL installation directory and add the following line &minus;</p>
<pre class="prettyprint notranslate">
# IPv4 local connections:
host    all         all         127.0.0.1/32          md5
</pre>
<p>You can start/restart postgres server in case it is not running using the following command &minus;</p>
<pre class="prettyprint notranslate">
[root@host]# service postgresql restart
Stopping postgresql service:                               [  OK  ]
Starting postgresql service:                               [  OK  ]
</pre>
<h2>C/C++ Interface APIs</h2>
<p>The following are important interface routines which can sufice your requirement to work with PostgreSQL database from your C/C++ program. If you are looking for a more sophisticated application then you can look into the libpqxx official documentation, or you can use commercially available APIs.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">API &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>pqxx::connection C( const std::string &amp; dbstring )</b></p>
<p>This is a typedef which will be used to connect to the database. Here, dbstring provides required parameters to connect to the datbase, for example <b>dbname = testdb user = postgres password=pass123 hostaddr=127.0.0.1 port=5432</b>.</p>
<p>If connection is setup successfully then it creates C with connection object which provides various useful function public function.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>C.is_open()</b></p>
<p>The method is_open() is a public method of connection object and returns boolean value. If connection is active, then this method returns true otherwise it returns false.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>C.disconnect()</b></p>
<p>This method is used to disconnect an opened database connection.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>pqxx::work W( C )</b></p>
<p>This is a typedef which will be used to create a transactional object using connection C, which ultimately will be used to execute SQL statements in transactional mode.</p>
<p>If transaction object gets created successfully, then it is assigned to variable W which will be used to access public methods related to transactional object.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td>
<p><b>W.exec(const std::string &amp; sql)</b></p>
<p>This public method from transactional object will be used to execute SQL statement.</p></p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td>
<p><b>W.commit()</b></p>
<p>This public method from transactional object will be used to commit the transaction.</p></p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td>
<p><b>W.abort()</b></p>
<p>This public method from transactional object will be used to rollback the transaction.</p></p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>pqxx::nontransaction N( C )</b></p>
<p>This is a typedef which will be used to create a non-transactional object using connection C, which ultimately will be used to execute SQL statements in non-transactional mode.</p>
<p>If transaction object gets created successfully, then it is assigned to variable N which will be used to access public methods related to non-transactional object.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>N.exec(const std::string &amp; sql)</b></p>
<p>This public method from non-transactional object will be used to execute SQL statement and returns a result object which is actually an interator holding all the returned records.</p>
</td>
</tr>
</table>
<h2>Connecting To Database</h2>
<p>The following C code segment shows how to connect to an existing database running on local machine at port 5432. Here, I used backslash \ for line continuation.</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt; 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   try {
      connection C("dbname = testdb user = postgres password = cohondob \
      hostaddr = 127.0.0.1 port = 5432");
      if (C.is_open()) {
         cout &lt;&lt; "Opened database successfully: " &lt;&lt; C.dbname() &lt;&lt; endl;
      } else {
         cout &lt;&lt; "Can't open database" &lt;&lt; endl;
         return 1;
      }
      C.disconnect ();
   } catch (const std::exception &amp;e) {
      cerr &lt;&lt; e.what() &lt;&lt; std::endl;
      return 1;
   }
}
</pre>
<p>Now, let us compile and run the above program to connect to our database <b>testdb</b>, which is already available in your schema and can be accessed using user <i>postgres</i> and password <i>pass123</i>.</p>
<p>You can use the user ID and password based on your database setting. Remember to keep the -lpqxx and -lpq in the given order! Otherwise, the linker will complain bitterly about the missing functions with names starting with "PQ."</p>
<pre class="prettyprint notranslate">
$g++ test.cpp -lpqxx -lpq
$./a.out
Opened database successfully: testdb
</pre>
<h2>Create a Table</h2>
<p>The following C code segment will be used to create a table in previously created database &minus;</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt; 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = cohondob \
      hostaddr = 127.0.0.1 port = 5432");
      if (C.is_open()) {
         cout &lt;&lt; "Opened database successfully: " &lt;&lt; C.dbname() &lt;&lt; endl;
      } else {
         cout &lt;&lt; "Can't open database" &lt;&lt; endl;
         return 1;
      }

      /* Create SQL statement */
      sql = "CREATE TABLE COMPANY("  \
      "ID INT PRIMARY KEY     NOT NULL," \
      "NAME           TEXT    NOT NULL," \
      "AGE            INT     NOT NULL," \
      "ADDRESS        CHAR(50)," \
      "SALARY         REAL );";

      /* Create a transactional object. */
      work W(C);
      
      /* Execute SQL query */
      W.exec( sql );
      W.commit();
      cout &lt;&lt; "Table created successfully" &lt;&lt; endl;
      C.disconnect ();
   } catch (const std::exception &amp;e) {
      cerr &lt;&lt; e.what() &lt;&lt; std::endl;
      return 1;
   }

   return 0;
}
</pre>
<p>When the above given program is compiled and executed, it will create COMPANY table in your testdb database and will display the following statements &minus;</p>
<pre class="result notranslate">
Opened database successfully: testdb
Table created successfully
</pre>
<h2>INSERT Operation</h2>
<p>The following C code segment shows how we can create records in our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt; 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = cohondob \
      hostaddr = 127.0.0.1 port = 5432");
      if (C.is_open()) {
         cout &lt;&lt; "Opened database successfully: " &lt;&lt; C.dbname() &lt;&lt; endl;
      } else {
         cout &lt;&lt; "Can't open database" &lt;&lt; endl;
         return 1;
      }

      /* Create SQL statement */
      sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) "  \
         "VALUES (1, 'Paul', 32, 'California', 20000.00 ); " \
         "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) "  \
         "VALUES (2, 'Allen', 25, 'Texas', 15000.00 ); "     \
         "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)" \
         "VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );" \
         "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)" \
         "VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );";

      /* Create a transactional object. */
      work W(C);
      
      /* Execute SQL query */
      W.exec( sql );
      W.commit();
      cout &lt;&lt; "Records created successfully" &lt;&lt; endl;
      C.disconnect ();
   } catch (const std::exception &amp;e) {
      cerr &lt;&lt; e.what() &lt;&lt; std::endl;
      return 1;
   }

   return 0;
}
</pre>
<p>When the above given program is compiled and executed, it will create given records in COMPANY table and will display the following two lines &minus;</p>
<pre class="result notranslate">
Opened database successfully: testdb
Records created successfully
</pre>
<h2>SELECT Operation</h2>
<p>The following C code segment shows how we can fetch and display records from our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt; 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = cohondob \
      hostaddr = 127.0.0.1 port = 5432");
      if (C.is_open()) {
         cout &lt;&lt; "Opened database successfully: " &lt;&lt; C.dbname() &lt;&lt; endl;
      } else {
         cout &lt;&lt; "Can't open database" &lt;&lt; endl;
         return 1;
      }

      /* Create SQL statement */
      sql = "SELECT * from COMPANY";

      /* Create a non-transactional object. */
      nontransaction N(C);
      
      /* Execute SQL query */
      result R( N.exec( sql ));
      
      /* List down all the records */
      for (result::const_iterator c = R.begin(); c != R.end(); ++c) {
         cout &lt;&lt; "ID = " &lt;&lt; c[0].as&lt;int&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Name = " &lt;&lt; c[1].as&lt;string&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Age = " &lt;&lt; c[2].as&lt;int&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Address = " &lt;&lt; c[3].as&lt;string&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Salary = " &lt;&lt; c[4].as&lt;float&gt;() &lt;&lt; endl;
      }
      cout &lt;&lt; "Operation done successfully" &lt;&lt; endl;
      C.disconnect ();
   } catch (const std::exception &amp;e) {
      cerr &lt;&lt; e.what() &lt;&lt; std::endl;
      return 1;
   }

   return 0;
}
</pre>
<p>When the above given program is compiled and executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully: testdb
ID = 1
Name = Paul
Age = 32
Address = California
Salary = 20000
ID = 2
Name = Allen
Age = 25
Address = Texas
Salary = 15000
ID = 3
Name = Teddy
Age = 23
Address = Norway
Salary = 20000
ID = 4
Name = Mark
Age = 25
Address = Rich-Mond
Salary = 65000
Operation done successfully
</pre>
<h2>UPDATE Operation</h2>
<p>The following C code segment shows how we can use the UPDATE statement to update any record and then fetch and display updated records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt; 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = cohondob \
      hostaddr = 127.0.0.1 port = 5432");
      if (C.is_open()) {
         cout &lt;&lt; "Opened database successfully: " &lt;&lt; C.dbname() &lt;&lt; endl;
      } else {
         cout &lt;&lt; "Can't open database" &lt;&lt; endl;
         return 1;
      }
      
      /* Create a transactional object. */
      work W(C);
      /* Create  SQL UPDATE statement */
      sql = "UPDATE COMPANY set SALARY = 25000.00 where ID=1";
      /* Execute SQL query */
      W.exec( sql );
      W.commit();
      cout &lt;&lt; "Records updated successfully" &lt;&lt; endl;
      
      /* Create SQL SELECT statement */
      sql = "SELECT * from COMPANY";

      /* Create a non-transactional object. */
      nontransaction N(C);
      
      /* Execute SQL query */
      result R( N.exec( sql ));
      
      /* List down all the records */
      for (result::const_iterator c = R.begin(); c != R.end(); ++c) {
         cout &lt;&lt; "ID = " &lt;&lt; c[0].as&lt;int&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Name = " &lt;&lt; c[1].as&lt;string&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Age = " &lt;&lt; c[2].as&lt;int&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Address = " &lt;&lt; c[3].as&lt;string&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Salary = " &lt;&lt; c[4].as&lt;float&gt;() &lt;&lt; endl;
      }
      cout &lt;&lt; "Operation done successfully" &lt;&lt; endl;
      C.disconnect ();
   } catch (const std::exception &amp;e) {
      cerr &lt;&lt; e.what() &lt;&lt; std::endl;
      return 1;
   }

   return 0;
}
</pre>
<p>When the above given program is compiled and executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully: testdb
Records updated successfully
ID = 2
Name = Allen
Age = 25
Address = Texas
Salary = 15000
ID = 3
Name = Teddy
Age = 23
Address = Norway
Salary = 20000
ID = 4
Name = Mark
Age = 25
Address = Rich-Mond
Salary = 65000
ID = 1
Name = Paul
Age = 32
Address = California
Salary = 25000
Operation done successfully
</pre>
<h2>DELETE Operation</h2>
<p>The following C code segment shows how we can use the DELETE statement to delete any record and then fetch and display remaining records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
#include &lt;iostream&gt;
#include &lt;pqxx/pqxx&gt; 

using namespace std;
using namespace pqxx;

int main(int argc, char* argv[]) {
   char * sql;
   
   try {
      connection C("dbname = testdb user = postgres password = cohondob \
      hostaddr = 127.0.0.1 port = 5432");
      if (C.is_open()) {
         cout &lt;&lt; "Opened database successfully: " &lt;&lt; C.dbname() &lt;&lt; endl;
      } else {
         cout &lt;&lt; "Can't open database" &lt;&lt; endl;
         return 1;
      }
      
      /* Create a transactional object. */
      work W(C);
      /* Create  SQL DELETE statement */
      sql = "DELETE from COMPANY where ID = 2";
      /* Execute SQL query */
      W.exec( sql );
      W.commit();
      cout &lt;&lt; "Records deleted successfully" &lt;&lt; endl;
      
      /* Create SQL SELECT statement */
      sql = "SELECT * from COMPANY";

      /* Create a non-transactional object. */
      nontransaction N(C);
      
      /* Execute SQL query */
      result R( N.exec( sql ));
      
      /* List down all the records */
      for (result::const_iterator c = R.begin(); c != R.end(); ++c) {
         cout &lt;&lt; "ID = " &lt;&lt; c[0].as&lt;int&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Name = " &lt;&lt; c[1].as&lt;string&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Age = " &lt;&lt; c[2].as&lt;int&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Address = " &lt;&lt; c[3].as&lt;string&gt;() &lt;&lt; endl;
         cout &lt;&lt; "Salary = " &lt;&lt; c[4].as&lt;float&gt;() &lt;&lt; endl;
      }
      cout &lt;&lt; "Operation done successfully" &lt;&lt; endl;
      C.disconnect ();
   } catch (const std::exception &amp;e) {
      cerr &lt;&lt; e.what() &lt;&lt; std::endl;
      return 1;
   }

   return 0;
}
</pre>
<p>When the above given program is compiled and executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully: testdb
Records deleted successfully
ID = 3
Name = Teddy
Age = 23
Address = Norway
Salary = 20000
ID = 4
Name = Mark
Age = 25
Address = Rich-Mond
Salary = 65000
ID = 1
Name = Paul
Age = 32
Address = California
Salary = 25000
Operation done successfully
</pre>
<h1>PostgreSQL - JAVA Interface</h1>
<h2>Installation</h2>
<p>Before we start using PostgreSQL in our Java programs, we need to make sure that we have PostgreSQL JDBC and Java set up on the machine. You can check Java tutorial for Java installation on your machine. Now let us check how to set up PostgreSQL JDBC driver.</p>
<ul class="list">
<li><p>Download the latest version of <i>postgresql-(VERSION).jdbc.jar</i> from <a target="_blank" href="https://jdbc.postgresql.org/download.html" rel="nofollow">postgresql-jdbc</a> repository.</p></li>
<li><p>Add downloaded jar file <i>postgresql-(VERSION).jdbc.jar</i> in your class path, or you can use it along with -classpath option as explained below in the examples.</p></li>
</ul>
<p>The following section assumes you have little knowledge about Java JDBC concepts. If you do not have, then it is suggested to spent half and hour with <a target="_blank" href="../jdbc/jdbc-create-database.html">JDBC Tutorial</a> to become comfortable with concepts explained below.</p>
<h2>Connecting To Database</h2>
<p>The following Java code shows how to connect to an existing database. If the database does not exist, then it will be created and finally a database object will be returned.</p>
<pre class="prettyprint notranslate">
import java.sql.Connection;
import java.sql.DriverManager;

public class PostgreSQLJDBC {
   public static void main(String args[]) {
      Connection c = null;
      try {
         Class.forName("org.postgresql.Driver");
         c = DriverManager
            .getConnection("jdbc:postgresql://localhost:5432/testdb",
            "postgres", "123");
      } catch (Exception e) {
         e.printStackTrace();
         System.err.println(e.getClass().getName()+": "+e.getMessage());
         System.exit(0);
      }
      System.out.println("Opened database successfully");
   }
}
</pre>
<p>Before you compile and run above program, find <b>pg_hba.conf</b> file in your PostgreSQL installation directory and add the following line &minus;</p>
<pre class="prettyprint notranslate">
# IPv4 local connections:
host    all         all         127.0.0.1/32          md5
</pre>
<p>You can start/restart the postgres server in case it is not running using the following command &minus;</p>
<pre class="prettyprint notranslate">
[root@host]# service postgresql restart
Stopping postgresql service:                               [  OK  ]
Starting postgresql service:                               [  OK  ]
</pre>
<p>Now, let us compile and run the above program to connect with testdb. Here, we are using <b>postgres</b> as user ID and <b>123</b> as password to access the database. You can change this as per your database configuration and setup. We are also assuming current version of JDBC driver <b>postgresql-9.2-1002.jdbc3.jar</b> is available in the current path.</p>
<pre class="prettyprint notranslate">
C:\JavaPostgresIntegration&gt;javac PostgreSQLJDBC.java
C:\JavaPostgresIntegration&gt;java -cp c:\tools\postgresql-9.2-1002.jdbc3.jar;C:\JavaPostgresIntegration PostgreSQLJDBC
Open database successfully
</pre>
<h2>Create a Table</h2>
<p>The following Java program will be used to create a table in previously opened database. Make sure you do not have this table already in your target database.</p>
<pre class="prettyprint notranslate">
import java.sql.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;


public class PostgreSQLJDBC {
   public static void main( String args[] ) {
      Connection c = null;
      Statement stmt = null;
      try {
         Class.forName("org.postgresql.Driver");
         c = DriverManager
            .getConnection("jdbc:postgresql://localhost:5432/testdb",
            "manisha", "123");
         System.out.println("Opened database successfully");

         stmt = c.createStatement();
         String sql = "CREATE TABLE COMPANY " +
            "(ID INT PRIMARY KEY     NOT NULL," +
            " NAME           TEXT    NOT NULL, " +
            " AGE            INT     NOT NULL, " +
            " ADDRESS        CHAR(50), " +
            " SALARY         REAL)";
         stmt.executeUpdate(sql);
         stmt.close();
         c.close();
      } catch ( Exception e ) {
         System.err.println( e.getClass().getName()+": "+ e.getMessage() );
         System.exit(0);
      }
      System.out.println("Table created successfully");
   }
}
</pre>
<p>When a program is compiled and executed, it will create the COMPANY table in <b>testdb</b> database and  will display the following two lines &minus;</p>
<pre class="result notranslate">
Opened database successfully
Table created successfully
</pre>
<h2>INSERT Operation</h2>
<p>The following Java program shows how we can create records in our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;

public class PostgreSQLJDBC {
   public static void main(String args[]) {
      Connection c = null;
      Statement stmt = null;
      try {
         Class.forName("org.postgresql.Driver");
         c = DriverManager
            .getConnection("jdbc:postgresql://localhost:5432/testdb",
            "manisha", "123");
         c.setAutoCommit(false);
         System.out.println("Opened database successfully");

         stmt = c.createStatement();
         String sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) "
            + "VALUES (1, 'Paul', 32, 'California', 20000.00 );";
         stmt.executeUpdate(sql);

         sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) "
            + "VALUES (2, 'Allen', 25, 'Texas', 15000.00 );";
         stmt.executeUpdate(sql);

         sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) "
            + "VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );";
         stmt.executeUpdate(sql);

         sql = "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) "
            + "VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );";
         stmt.executeUpdate(sql);

         stmt.close();
         c.commit();
         c.close();
      } catch (Exception e) {
         System.err.println( e.getClass().getName()+": "+ e.getMessage() );
         System.exit(0);
      }
      System.out.println("Records created successfully");
   }
}
</pre>
<p>When the above program is compiled and executed, it will create given records in COMPANY table and will display the following two lines &minus;</p>
<pre class="result notranslate">
Opened database successfully
Records created successfully
</pre>
<h2>SELECT Operation</h2>
<p>The following Java program shows how we can fetch and display records from our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;


public class PostgreSQLJDBC {
   public static void main( String args[] ) {
      Connection c = null;
      Statement stmt = null;
      try {
         Class.forName("org.postgresql.Driver");
         c = DriverManager
            .getConnection("jdbc:postgresql://localhost:5432/testdb",
            "manisha", "123");
         c.setAutoCommit(false);
         System.out.println("Opened database successfully");

         stmt = c.createStatement();
         ResultSet rs = stmt.executeQuery( "SELECT * FROM COMPANY;" );
         while ( rs.next() ) {
            int id = rs.getInt("id");
            String  name = rs.getString("name");
            int age  = rs.getInt("age");
            String  address = rs.getString("address");
            float salary = rs.getFloat("salary");
            System.out.println( "ID = " + id );
            System.out.println( "NAME = " + name );
            System.out.println( "AGE = " + age );
            System.out.println( "ADDRESS = " + address );
            System.out.println( "SALARY = " + salary );
            System.out.println();
         }
         rs.close();
         stmt.close();
         c.close();
      } catch ( Exception e ) {
         System.err.println( e.getClass().getName()+": "+ e.getMessage() );
         System.exit(0);
      }
      System.out.println("Operation done successfully");
   }
}
</pre>
<p>When the program is compiled and executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
ID = 1
NAME = Paul
AGE = 32
ADDRESS = California
SALARY = 20000.0

ID = 2
NAME = Allen
AGE = 25
ADDRESS = Texas
SALARY = 15000.0

ID = 3
NAME = Teddy
AGE = 23
ADDRESS = Norway
SALARY = 20000.0

ID = 4
NAME = Mark
AGE = 25
ADDRESS = Rich-Mond
SALARY = 65000.0

Operation done successfully
</pre>
<h2>UPDATE Operation</h2>
<p>The following Java code shows how we can use the UPDATE statement to update any record and then fetch and display updated records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;


public class PostgreSQLJDBC {
   public static void main( String args[] ) {
      Connection c = null;
      Statement stmt = null;
      try {
         Class.forName("org.postgresql.Driver");
         c = DriverManager
            .getConnection("jdbc:postgresql://localhost:5432/testdb",
            "manisha", "123");
         c.setAutoCommit(false);
         System.out.println("Opened database successfully");

         stmt = c.createStatement();
         String sql = "UPDATE COMPANY set SALARY = 25000.00 where ID=1;";
         stmt.executeUpdate(sql);
         c.commit();

         ResultSet rs = stmt.executeQuery( "SELECT * FROM COMPANY;" );
         while ( rs.next() ) {
            int id = rs.getInt("id");
            String  name = rs.getString("name");
            int age  = rs.getInt("age");
            String  address = rs.getString("address");
            float salary = rs.getFloat("salary");
            System.out.println( "ID = " + id );
            System.out.println( "NAME = " + name );
            System.out.println( "AGE = " + age );
            System.out.println( "ADDRESS = " + address );
            System.out.println( "SALARY = " + salary );
            System.out.println();
         }
         rs.close();
         stmt.close();
         c.close();
      } catch ( Exception e ) {
         System.err.println( e.getClass().getName()+": "+ e.getMessage() );
         System.exit(0);
      }
      System.out.println("Operation done successfully");
   }
}
</pre>
<p>When the program is compiled and executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
ID = 2
NAME = Allen
AGE = 25
ADDRESS = Texas
SALARY = 15000.0

ID = 3
NAME = Teddy
AGE = 23
ADDRESS = Norway
SALARY = 20000.0

ID = 4
NAME = Mark
AGE = 25
ADDRESS = Rich-Mond
SALARY = 65000.0

ID = 1
NAME = Paul
AGE = 32
ADDRESS = California
SALARY = 25000.0

Operation done successfully
</pre>
<h2>DELETE Operation</h2>
<p>The following Java code shows how we can use the DELETE statement to delete any record and then fetch and display remaining records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;


public class PostgreSQLJDBC6 {
   public static void main( String args[] ) {
      Connection c = null;
      Statement stmt = null;
      try {
         Class.forName("org.postgresql.Driver");
         c = DriverManager
            .getConnection("jdbc:postgresql://localhost:5432/testdb",
            "manisha", "123");
         c.setAutoCommit(false);
         System.out.println("Opened database successfully");

         stmt = c.createStatement();
         String sql = "DELETE from COMPANY where ID = 2;";
         stmt.executeUpdate(sql);
         c.commit();

         ResultSet rs = stmt.executeQuery( "SELECT * FROM COMPANY;" );
         while ( rs.next() ) {
            int id = rs.getInt("id");
            String  name = rs.getString("name");
            int age  = rs.getInt("age");
            String  address = rs.getString("address");
            float salary = rs.getFloat("salary");
            System.out.println( "ID = " + id );
            System.out.println( "NAME = " + name );
            System.out.println( "AGE = " + age );
            System.out.println( "ADDRESS = " + address );
            System.out.println( "SALARY = " + salary );
            System.out.println();
         }
         rs.close();
         stmt.close();
         c.close();
      } catch ( Exception e ) {
         System.err.println( e.getClass().getName()+": "+ e.getMessage() );
         System.exit(0);
      }
      System.out.println("Operation done successfully");
   }
}
</pre>
<p>When the program is compiled and executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
ID = 3
NAME = Teddy
AGE = 23
ADDRESS = Norway
SALARY = 20000.0

ID = 4
NAME = Mark
AGE = 25
ADDRESS = Rich-Mond
SALARY = 65000.0

ID = 1
NAME = Paul
AGE = 32
ADDRESS = California
SALARY = 25000.0
Operation done successfully
</pre>
<h1>PostgreSQL - PHP Interface</h1>
<h2>Installation</h2>
<p>The PostgreSQL extension is enabled by default in the latest releases of PHP 5.3.x. It is possible to disable it by using <b>--without-pgsql</b> at compile time. Still you can use yum command to install PHP -PostgreSQL interface &minus;</p>
<pre class="prettyprint notranslate">
yum install php-pgsql
</pre>
<p>Before you start using the PHP PostgreSQL interface, find the <b>pg_hba.conf</b> file in your PostgreSQL installation directory and add the following line &minus;</p>
<pre class="prettyprint notranslate">
# IPv4 local connections:
host    all         all         127.0.0.1/32          md5
</pre>
<p>You can start/restart the postgres server, in case it is not running, using the following command &minus;</p>
<pre class="prettyprint notranslate">
[root@host]# service postgresql restart
Stopping postgresql service:                               [  OK  ]
Starting postgresql service:                               [  OK  ]
</pre>
<p>Windows users must enable php_pgsql.dll in order to use this extension. This DLL is included with Windows distributions in the latest releases of PHP 5.3.x</p>
<p>For detailed installation instructions, kindly check our PHP tutorial and its official website.</p>
<h2>PHP Interface APIs</h2>
<p>The following are important PHP routines, which can suffice your requirement to work with PostgreSQL database from your PHP program. If you are looking for a more sophisticated application, then you can look into the PHP official documentation.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">API &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>resource pg_connect ( string $connection_string [, int $connect_type ] )</b></p>
<p>This opens a connection to a PostgreSQL database specified by the connection_string.</p>
<p>If PGSQL_CONNECT_FORCE_NEW is passed as connect_type, then a new connection is created in case of a second call to pg_connect(), even if the connection_string is identical to an existing connection.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>bool pg_connection_reset ( resource $connection )</b></p>
<p>This routine resets the connection. It is useful for error recovery. Returns TRUE on success or FALSE on failure.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>int pg_connection_status ( resource $connection )</b></p>
<p>This routine returns the status of the specified connection. Returns PGSQL_CONNECTION_OK or PGSQL_CONNECTION_BAD.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>string pg_dbname ([ resource $connection ] )</b></p>
<p>This routine returns the name of the database that the given PostgreSQL connection resource.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>resource pg_prepare ([ resource $connection ], string $stmtname, string $query )</b></p>
<p>This submits a request to create a prepared statement with the given parameters and waits for completion.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>resource pg_execute ([ resource $connection ], string $stmtname, array $params )</b></p>
<p>This routine sends a request to execute a prepared statement with given parameters and waits for the result.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>resource pg_query ([ resource $connection ], string $query )</b></p>
<p>This routine executes the query on the specified database connection.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>array pg_fetch_row ( resource $result [, int $row ] )</b></p>
<p>This routine fetches one row of data from the result associated with the specified result resource.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>array pg_fetch_all ( resource $result )</b></p>
<p>This routine returns an array that contains all rows (records) in the result resource.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">10</td>
<td><p><b>int pg_affected_rows ( resource $result )</b></p>
<p>This routine returns the number of rows affected by INSERT, UPDATE, and DELETE queries.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">11</td>
<td><p><b>int pg_num_rows ( resource $result )</b></p>
<p>This routine returns the number of rows in a PostgreSQL result resource for example number of rows returned by SELECT statement.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">12</td>
<td><p><b>bool pg_close ([ resource $connection ] )</b></p>
<p>This routine closes the non-persistent connection to a PostgreSQL database associated with the given connection resource.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">13</td>
<td><p><b>string pg_last_error ([ resource $connection ] )</b></p>
<p>This routine  returns the last error message for a given connection.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">14</td>
<td><p><b>string pg_escape_literal ([ resource $connection ], string $data )</b></p>
<p>This routine escapes a literal for insertion into a text field.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">15</td>
<td><p><b>string pg_escape_string ([ resource $connection ], string $data )</b></p>
<p>This routine escapes a string for querying the database.</p>
</td>
</tr>
</table>
<h2>Connecting to Database</h2>
<p>The following PHP code shows how to connect to an existing database on a local machine and finally a database connection object will be returned.</p>
<pre class="prettyprint notranslate">
&lt;?php
   $host        = "host = 127.0.0.1";
   $port        = "port = 5432";
   $dbname      = "dbname = testdb";
   $credentials = "user = postgres password=pass123";

   $db = pg_connect( "$host $port $dbname $credentials"  );
   if(!$db) {
      echo "Error : Unable to open database\n";
   } else {
      echo "Opened database successfully\n";
   }
?&gt;
</pre>
<p>Now, let us run the above given program to open our database <b>testdb</b>: if the database is successfully opened, then it will give the following message &minus;</p>
<pre class="result notranslate">
Opened database successfully
</pre>
<h2>Create a Table</h2>
<p>The following PHP program will be used to create a table in a previously created database &minus;</p>
<pre class="prettyprint notranslate">
&lt;?php
   $host        = "host = 127.0.0.1";
   $port        = "port = 5432";
   $dbname      = "dbname = testdb";
   $credentials = "user = postgres password=pass123";

   $db = pg_connect( "$host $port $dbname $credentials"  );
   if(!$db) {
      echo "Error : Unable to open database\n";
   } else {
      echo "Opened database successfully\n";
   }
   
   $sql =&lt;&lt;&lt;EOF
      CREATE TABLE COMPANY
      (ID INT PRIMARY KEY     NOT NULL,
      NAME           TEXT    NOT NULL,
      AGE            INT     NOT NULL,
      ADDRESS        CHAR(50),
      SALARY         REAL);
EOF;

   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
   } else {
      echo "Table created successfully\n";
   }
   pg_close($db);
?&gt;
</pre>
<p>When the above given program is executed, it will create COMPANY table in your <b>testdb</b> and it will display the following messages &minus;</p>
<pre class="result notranslate">
Opened database successfully
Table created successfully
</pre>
<h2>INSERT Operation</h2>
<p>The following PHP program shows how we can create records in our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
&lt;?php
   $host        = "host=127.0.0.1";
   $port        = "port=5432";
   $dbname      = "dbname = testdb";
   $credentials = "user = postgres password=pass123";

   $db = pg_connect( "$host $port $dbname $credentials"  );
   if(!$db) {
      echo "Error : Unable to open database\n";
   } else {
      echo "Opened database successfully\n";
   }

   $sql =&lt;&lt;&lt;EOF
      INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
      VALUES (1, 'Paul', 32, 'California', 20000.00 );

      INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
      VALUES (2, 'Allen', 25, 'Texas', 15000.00 );

      INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
      VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );

      INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
      VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );
EOF;

   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
   } else {
      echo "Records created successfully\n";
   }
   pg_close($db);
?&gt;
</pre>
<p>When the above given program is executed, it will create the given records in COMPANY table and will display the following two lines &minus;</p>
<pre class="result notranslate">
Opened database successfully
Records created successfully
</pre>
<h2>SELECT Operation</h2>
<p>The following PHP program shows how we can fetch and display records from our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
&lt;?php
   $host        = "host = 127.0.0.1";
   $port        = "port = 5432";
   $dbname      = "dbname = testdb";
   $credentials = "user = postgres password=pass123";

   $db = pg_connect( "$host $port $dbname $credentials"  );
   if(!$db) {
      echo "Error : Unable to open database\n";
   } else {
      echo "Opened database successfully\n";
   }

   $sql =&lt;&lt;&lt;EOF
      SELECT * from COMPANY;
EOF;

   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
      exit;
   } 
   while($row = pg_fetch_row($ret)) {
      echo "ID = ". $row[0] . "\n";
      echo "NAME = ". $row[1] ."\n";
      echo "ADDRESS = ". $row[2] ."\n";
      echo "SALARY =  ".$row[4] ."\n\n";
   }
   echo "Operation done successfully\n";
   pg_close($db);
?&gt;
</pre>
<p>When the above given program is executed, it will produce the following result. Keep a note that fields are returned in the sequence they were used while creating table.</p>
<pre class="result notranslate">
Opened database successfully
ID = 1
NAME = Paul
ADDRESS = California
SALARY =  20000

ID = 2
NAME = Allen
ADDRESS = Texas
SALARY =  15000

ID = 3
NAME = Teddy
ADDRESS = Norway
SALARY =  20000

ID = 4
NAME = Mark
ADDRESS = Rich-Mond
SALARY =  65000

Operation done successfully
</pre>
<h2>UPDATE Operation</h2>
<p>The following PHP code shows how we can use the UPDATE statement to update any record and then fetch and display updated records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
&lt;?php
   $host        = "host=127.0.0.1";
   $port        = "port=5432";
   $dbname      = "dbname = testdb";
   $credentials = "user = postgres password=pass123";

   $db = pg_connect( "$host $port $dbname $credentials"  );
   if(!$db) {
      echo "Error : Unable to open database\n";
   } else {
      echo "Opened database successfully\n";
   }
   $sql =&lt;&lt;&lt;EOF
      UPDATE COMPANY set SALARY = 25000.00 where ID=1;
EOF;
   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
      exit;
   } else {
      echo "Record updated successfully\n";
   }
   
   $sql =&lt;&lt;&lt;EOF
      SELECT * from COMPANY;
EOF;

   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
      exit;
   } 
   while($row = pg_fetch_row($ret)) {
      echo "ID = ". $row[0] . "\n";
      echo "NAME = ". $row[1] ."\n";
      echo "ADDRESS = ". $row[2] ."\n";
      echo "SALARY =  ".$row[4] ."\n\n";
   }
   echo "Operation done successfully\n";
   pg_close($db);
?&gt;
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
Record updated successfully
ID = 2
NAME = Allen
ADDRESS = 25
SALARY =  15000

ID = 3
NAME = Teddy
ADDRESS = 23
SALARY =  20000

ID = 4
NAME = Mark
ADDRESS = 25
SALARY =  65000

ID = 1
NAME = Paul
ADDRESS = 32
SALARY =  25000

Operation done successfully
</pre>
<h2>DELETE Operation</h2>
<p>The following PHP code shows how we can use the DELETE statement to delete any record and then fetch and display the remaining records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
&lt;?php
   $host        = "host = 127.0.0.1";
   $port        = "port = 5432";
   $dbname      = "dbname = testdb";
   $credentials = "user = postgres password=pass123";

   $db = pg_connect( "$host $port $dbname $credentials"  );
   if(!$db) {
      echo "Error : Unable to open database\n";
   } else {
      echo "Opened database successfully\n";
   }
   $sql =&lt;&lt;&lt;EOF
      DELETE from COMPANY where ID=2;
EOF;
   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
      exit;
   } else {
      echo "Record deleted successfully\n";
   }
   
   $sql =&lt;&lt;&lt;EOF
      SELECT * from COMPANY;
EOF;

   $ret = pg_query($db, $sql);
   if(!$ret) {
      echo pg_last_error($db);
      exit;
   } 
   while($row = pg_fetch_row($ret)) {
      echo "ID = ". $row[0] . "\n";
      echo "NAME = ". $row[1] ."\n";
      echo "ADDRESS = ". $row[2] ."\n";
      echo "SALARY =  ".$row[4] ."\n\n";
   }
   echo "Operation done successfully\n";
   pg_close($db);
?&gt;
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
Record deleted successfully
ID = 3
NAME = Teddy
ADDRESS = 23
SALARY =  20000

ID = 4
NAME = Mark
ADDRESS = 25
SALARY =  65000

ID = 1
NAME = Paul
ADDRESS = 32
SALARY =  25000

Operation done successfully
</pre>
<h1>PostgreSQL - Perl Interface</h1>
<h2>Installation</h2>
<p>The PostgreSQL can be integrated with Perl using Perl DBI module, which is a database access module for the Perl programming language. It defines a set of methods, variables and conventions that provide a standard database interface.</p>
<p>Here are simple steps to install DBI module on your Linux/Unix machine &minus;</p>
<pre class="prettyprint notranslate">
$ wget http://search.cpan.org/CPAN/authors/id/T/TI/TIMB/DBI-1.625.tar.gz
$ tar xvfz DBI-1.625.tar.gz
$ cd DBI-1.625
$ perl Makefile.PL
$ make
$ make install
</pre>
<p>If you need to install SQLite driver for DBI, then it can be installed as follows &minus;</p>
<pre class="prettyprint notranslate">
$ wget http://search.cpan.org/CPAN/authors/id/T/TU/TURNSTEP/DBD-Pg-2.19.3.tar.gz
$ tar xvfz DBD-Pg-2.19.3.tar.gz
$ cd DBD-Pg-2.19.3
$ perl Makefile.PL
$ make
$ make install
</pre>
<p>Before you start using Perl PostgreSQL interface, find the <b>pg_hba.conf</b> file in your PostgreSQL installation directory and add the following line &minus;</p>
<pre class="prettyprint notranslate">
# IPv4 local connections:
host    all         all         127.0.0.1/32          md5
</pre>
<p>You can start/restart the postgres server, in case it is not running, using the following command &minus;</p>
<pre class="prettyprint notranslate">
[root@host]# service postgresql restart
Stopping postgresql service:                               [  OK  ]
Starting postgresql service:                               [  OK  ]
</pre>
<h2>DBI Interface APIs</h2>
<p>Following are the important DBI routines, which can suffice your requirement to work with SQLite database from your Perl program. If you are looking for a more sophisticated application, then you can look into Perl DBI official documentation.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">API &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>DBI&rarr;connect($data_source, "userid", "password", \%attr)</b></p>
<p>Establishes a database connection, or session, to the requested $data_source. Returns a database handle object if the connection succeeds.</p>
<p>Datasource has the form like : <b>DBI:Pg:dbname=$database;host=127.0.0.1;port=5432</b> Pg is PostgreSQL driver name and testdb is the name of database.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>$dbh&rarr;do($sql)</b></p>
<p>This routine prepares and executes a single SQL statement. Returns the number of rows affected or undef on error. A return value of -1 means the number of rows is not known, not applicable, or not available. Here $dbh is a handle returned by DBI&rarr;connect() call.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>$dbh&rarr;prepare($sql)</b></p>
<p>This routine prepares a statement for later execution by the database engine and returns a reference to a statement handle object.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>$sth&rarr;execute()</b></p>
<p>This routine performs whatever processing is necessary to execute the prepared statement. An undef is returned if an error occurs. A successful execute always returns true regardless of the number of rows affected. Here $sth is a statement handle returned by $dbh&rarr;prepare($sql) call.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>$sth&rarr;fetchrow_array()</b></p>
<p>This routine fetches the next row of data and returns it as a list containing the field values. Null fields are returned as undef values in the list.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>$DBI::err</b></p>
<p>This is equivalent to $h&rarr;err, where $h is  any of the handle types like $dbh, $sth, or $drh. This returns native database engine error code from the last driver method called.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>$DBI::errstr</b></p>
<p>This is equivalent to $h&rarr;errstr, where $h is  any of the handle types like $dbh, $sth, or $drh. This returns the native database engine error message from the last DBI method called.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>$dbh-&gt;disconnect()</b></p>
<p>This routine closes a database connection previously opened by a call to DBI&rarr;connect().</p>
</td>
</tr>
</table>
<h2>Connecting to Database</h2>
<p>The following Perl code shows how to connect to an existing database. If the database does not exist, then it will be created and finally a database object will be returned.</p>
<pre class="prettyprint notranslate">
#!/usr/bin/perl

use DBI;
use strict;

my $driver  = "Pg"; 
my $database = "testdb";
my $dsn = "DBI:$driver:dbname = $database;host = 127.0.0.1;port = 5432";
my $userid = "postgres";
my $password = "pass123";
my $dbh = DBI-&gt;connect($dsn, $userid, $password, { RaiseError =&gt; 1 }) 
   or die $DBI::errstr;

print "Opened database successfully\n";
</pre>
<p>Now, let us run the above given program to open our database <b>testdb</b>; if the database is successfully opened then it will give the following message &minus;</p>
<pre class="result notranslate">
Open database successfully
</pre>
<h2>Create a Table</h2>
<p>The following Perl program will be used to create a table in previously created database &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/perl

use DBI;
use strict;

my $driver   = "Pg"; 
my $database = "testdb";
my $dsn = "DBI:$driver:dbname=$database;host=127.0.0.1;port=5432";
my $userid = "postgres";
my $password = "pass123";
my $dbh = DBI-&gt;connect($dsn, $userid, $password, { RaiseError =&gt; 1 })
   or die $DBI::errstr;
print "Opened database successfully\n";

my $stmt = qq(CREATE TABLE COMPANY
      (ID INT PRIMARY KEY     NOT NULL,
      NAME           TEXT    NOT NULL,
      AGE            INT     NOT NULL,
      ADDRESS        CHAR(50),
      SALARY         REAL););
my $rv = $dbh-&gt;do($stmt);
if($rv &lt; 0) {
   print $DBI::errstr;
} else {
   print "Table created successfully\n";
}
$dbh-&gt;disconnect();
</pre>
<p>When the above given program is executed, it will create COMPANY table in your <b>testdb</b> and it will display the following messages &minus;</p>
<pre class="result notranslate">
Opened database successfully
Table created successfully
</pre>
<h2>INSERT Operation</h2>
<p>The following Perl program shows how we can create records in our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/perl

use DBI;
use strict;

my $driver   = "Pg"; 
my $database = "testdb";
my $dsn = "DBI:$driver:dbname = $database;host = 127.0.0.1;port = 5432";
my $userid = "postgres";
my $password = "pass123";
my $dbh = DBI-&gt;connect($dsn, $userid, $password, { RaiseError =&gt; 1 })
   or die $DBI::errstr;
print "Opened database successfully\n";

my $stmt = qq(INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
   VALUES (1, 'Paul', 32, 'California', 20000.00 ));
my $rv = $dbh-&gt;do($stmt) or die $DBI::errstr;

$stmt = qq(INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
   VALUES (2, 'Allen', 25, 'Texas', 15000.00 ));
$rv = $dbh-&gt;do($stmt) or die $DBI::errstr;

$stmt = qq(INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
   VALUES (3, 'Teddy', 23, 'Norway', 20000.00 ));
$rv = $dbh-&gt;do($stmt) or die $DBI::errstr;

$stmt = qq(INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)
   VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 ););
$rv = $dbh-&gt;do($stmt) or die $DBI::errstr;

print "Records created successfully\n";
$dbh-&gt;disconnect();
</pre>
<p>When the above given program is executed, it will create given records in COMPANY table and will display the following two lines &minus;</p>
<pre class="result notranslate">
Opened database successfully
Records created successfully
</pre>
<h2>SELECT Operation</h2>
<p>The following Perl program shows how we can fetch and display records from our COMPANY table created in above example &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/perl

use DBI;
use strict;

my $driver   = "Pg"; 
my $database = "testdb";
my $dsn = "DBI:$driver:dbname = $database;host = 127.0.0.1;port = 5432";
my $userid = "postgres";
my $password = "pass123";
my $dbh = DBI-&gt;connect($dsn, $userid, $password, { RaiseError =&gt; 1 })
   or die $DBI::errstr;
print "Opened database successfully\n";

my $stmt = qq(SELECT id, name, address, salary  from COMPANY;);
my $sth = $dbh-&gt;prepare( $stmt );
my $rv = $sth-&gt;execute() or die $DBI::errstr;
if($rv &lt; 0) {
   print $DBI::errstr;
}
while(my @row = $sth-&gt;fetchrow_array()) {
      print "ID = ". $row[0] . "\n";
      print "NAME = ". $row[1] ."\n";
      print "ADDRESS = ". $row[2] ."\n";
      print "SALARY =  ". $row[3] ."\n\n";
}
print "Operation done successfully\n";
$dbh-&gt;disconnect();
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
ID = 1
NAME = Paul
ADDRESS = California
SALARY =  20000

ID = 2
NAME = Allen
ADDRESS = Texas
SALARY =  15000

ID = 3
NAME = Teddy
ADDRESS = Norway
SALARY =  20000

ID = 4
NAME = Mark
ADDRESS = Rich-Mond
SALARY =  65000

Operation done successfully
</pre>
<h2>UPDATE Operation</h2>
<p>The following Perl code shows how we can use the UPDATE statement to update any record and then fetch and display updated records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/perl

use DBI;
use strict;

my $driver   = "Pg"; 
my $database = "testdb";
my $dsn = "DBI:$driver:dbname = $database;host = 127.0.0.1;port = 5432";
my $userid = "postgres";
my $password = "pass123";
my $dbh = DBI-&gt;connect($dsn, $userid, $password, { RaiseError =&gt; 1 })
   or die $DBI::errstr;
print "Opened database successfully\n";

my $stmt = qq(UPDATE COMPANY set SALARY = 25000.00 where ID=1;);
my $rv = $dbh-&gt;do($stmt) or die $DBI::errstr;
if( $rv &lt; 0 ) {
   print $DBI::errstr;
}else{
   print "Total number of rows updated : $rv\n";
}
$stmt = qq(SELECT id, name, address, salary  from COMPANY;);
my $sth = $dbh-&gt;prepare( $stmt );
$rv = $sth-&gt;execute() or die $DBI::errstr;
if($rv &lt; 0) {
   print $DBI::errstr;
}
while(my @row = $sth-&gt;fetchrow_array()) {
      print "ID = ". $row[0] . "\n";
      print "NAME = ". $row[1] ."\n";
      print "ADDRESS = ". $row[2] ."\n";
      print "SALARY =  ". $row[3] ."\n\n";
}
print "Operation done successfully\n";
$dbh-&gt;disconnect();
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
Total number of rows updated : 1
ID = 1
NAME = Paul
ADDRESS = California
SALARY =  25000

ID = 2
NAME = Allen
ADDRESS = Texas
SALARY =  15000

ID = 3
NAME = Teddy
ADDRESS = Norway
SALARY =  20000

ID = 4
NAME = Mark
ADDRESS = Rich-Mond
SALARY =  65000

Operation done successfully
</pre>
<h2>DELETE Operation</h2>
<p>The following Perl code shows how we can use the DELETE statement to delete any record and then fetch and display the remaining records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/perl

use DBI;
use strict;

my $driver   = "Pg"; 
my $database = "testdb";
my $dsn = "DBI:$driver:dbname = $database;host = 127.0.0.1;port = 5432";
my $userid = "postgres";
my $password = "pass123";
my $dbh = DBI-&gt;connect($dsn, $userid, $password, { RaiseError =&gt; 1 })
   or die $DBI::errstr;
print "Opened database successfully\n";

my $stmt = qq(DELETE from COMPANY where ID=2;);
my $rv = $dbh-&gt;do($stmt) or die $DBI::errstr;
if( $rv &lt; 0 ) {
   print $DBI::errstr;
} else{
   print "Total number of rows deleted : $rv\n";
}
$stmt = qq(SELECT id, name, address, salary  from COMPANY;);
my $sth = $dbh-&gt;prepare( $stmt );
$rv = $sth-&gt;execute() or die $DBI::errstr;
if($rv &lt; 0) {
   print $DBI::errstr;
}
while(my @row = $sth-&gt;fetchrow_array()) {
      print "ID = ". $row[0] . "\n";
      print "NAME = ". $row[1] ."\n";
      print "ADDRESS = ". $row[2] ."\n";
      print "SALARY =  ". $row[3] ."\n\n";
}
print "Operation done successfully\n";
$dbh-&gt;disconnect();
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
Total number of rows deleted : 1
ID = 1
NAME = Paul
ADDRESS = California
SALARY =  25000

ID = 3
NAME = Teddy
ADDRESS = Norway
SALARY =  20000

ID = 4
NAME = Mark
ADDRESS = Rich-Mond
SALARY =  65000

Operation done successfully
</pre>
<h1>PostgreSQL - Python Interface</h1>
<h2>Installation</h2>
<p>The PostgreSQL can be integrated with Python using psycopg2 module. sycopg2 is a PostgreSQL database adapter for the Python programming language. psycopg2 was written with the aim of being very small and fast, and stable as a rock. You do not need to install this module separately because it is shipped, by default, along with Python version 2.5.x onwards.</p> 
<p>If you do not have it installed on your machine then you can use yum command to install it as follows &minus;</p>
<pre class="prettyprint notranslate">
$yum install python-psycopg2
</pre>
<p>To use psycopg2 module, you must first create a Connection object that represents the database and then optionally you can create cursor object which will help you in executing all the SQL statements.</p>
<h2>Python psycopg2 module APIs</h2>
<p>The following are important psycopg2 module routines, which can suffice your requirement to work with PostgreSQL database from your Python program. If you are looking for a more sophisticated application, then you can look into Python psycopg2 module's official documentation.</p>
<table class="table table-bordered">
<tr>
<th style="width:11%">S. No.</th>
<th style="text-align:center;">API &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">1</td>
<td><p><b>psycopg2.connect(database="testdb", user="postgres", password="cohondob", host="127.0.0.1", port="5432")</b></p>
<p>This API opens a connection to the PostgreSQL database. If database is opened successfully, it returns a connection object.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">2</td>
<td><p><b>connection.cursor()</b></p>
<p>This routine creates a <b>cursor</b> which will be used throughout of your database programming with Python.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">3</td>
<td><p><b>cursor.execute(sql [, optional parameters])</b></p>
<p>This routine executes an SQL statement. The SQL statement may be parameterized (i.e., placeholders instead of SQL literals). The psycopg2 module supports placeholder using %s sign</p>
<p>For example:cursor.execute("insert into people values (%s, %s)", (who, age))</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">4</td>
<td><p><b>cursor.executemany(sql, seq_of_parameters)</b></p>
<p>This routine executes an SQL command against all parameter sequences or mappings found in the sequence sql.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">5</td>
<td><p><b>cursor.callproc(procname[, parameters])</b></p>
<p>This routine executes a stored database procedure with the given name. The sequence of parameters must contain one entry for each argument that the procedure expects.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">6</td>
<td><p><b>cursor.rowcount</b></p>
<p>This read-only attribute which returns the total number of database rows that have been modified, inserted, or deleted by the last last execute*().</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">7</td>
<td><p><b>connection.commit()</b></p>
<p>This method commits the current transaction. If you do not call this method, anything you did since the last call to commit() is not visible from other database connections.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">8</td>
<td><p><b>connection.rollback()</b></p>
<p>This method rolls back any changes to the database since the last call to commit().</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">9</td>
<td><p><b>connection.close()</b></p>
<p>This method closes the database connection. Note that this does not automatically call commit(). If you just close your database connection without calling commit() first, your changes will be lost!</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">10</td>
<td><p><b>cursor.fetchone()</b></p>
<p>This method fetches the next row of a query result set, returning a single sequence, or None when no more data is available.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">11</td>
<td><p><b>cursor.fetchmany([size=cursor.arraysize])</b></p>
<p>This routine fetches the next set of rows of a query result, returning a list. An empty list is returned when no more rows are available. The method tries to fetch as many rows as indicated by the size parameter.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle;">12</td>
<td><p><b>cursor.fetchall()</b></p>
<p>This routine fetches all (remaining) rows of a query result, returning a list. An empty list is returned when no rows are available.</p>
</td>
</tr>
</table>
<h2>Connecting to Database</h2>
<p>The following Python code shows how to connect to an existing database. If the database does not exist, then it will be created and finally a database object will be returned.</p>
<pre class="prettyprint notranslate">
#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database="testdb", user = "postgres", password = "pass123", host = "127.0.0.1", port = "5432")

print "Opened database successfully"
</pre>
<p>Here, you can also supply database <b>testdb</b> as name  and if database is successfully opened, then it will give the following message &minus;</p>
<pre class="result notranslate">
Open database successfully
</pre>
<h2>Create a Table</h2>
<p>The following Python program will be used to create a table in previously created database &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database = "testdb", user = "postgres", password = "pass123", host = "127.0.0.1", port = "5432")
print "Opened database successfully"

cur = conn.cursor()
cur.execute('''CREATE TABLE COMPANY
      (ID INT PRIMARY KEY     NOT NULL,
      NAME           TEXT    NOT NULL,
      AGE            INT     NOT NULL,
      ADDRESS        CHAR(50),
      SALARY         REAL);''')
print "Table created successfully"

conn.commit()
conn.close()
</pre>
<p>When the above given program is executed, it will create COMPANY table in your <b>test.db</b> and it will display the following messages &minus;</p>
<pre class="result notranslate">
Opened database successfully
Table created successfully
</pre>
<h2>INSERT Operation</h2>
<p>The following Python program shows how we can create records in our COMPANY table created in the above example &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database = "testdb", user = "postgres", password = "pass123", host = "127.0.0.1", port = "5432")
print "Opened database successfully"

cur = conn.cursor()

cur.execute("INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (1, 'Paul', 32, 'California', 20000.00 )");

cur.execute("INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (2, 'Allen', 25, 'Texas', 15000.00 )");

cur.execute("INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (3, 'Teddy', 23, 'Norway', 20000.00 )");

cur.execute("INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) \
      VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 )");

conn.commit()
print "Records created successfully";
conn.close()
</pre>
<p>When the above given program is executed, it will create given records in COMPANY table and will display the following two lines &minus;</p>
<pre class="result notranslate">
Opened database successfully
Records created successfully
</pre>
<h2>SELECT Operation</h2>
<p>The following Python program shows how we can fetch and display records from our COMPANY table created in the above example &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database = "testdb", user = "postgres", password = "pass123", host = "127.0.0.1", port = "5432")
print "Opened database successfully"

cur = conn.cursor()

cur.execute("SELECT id, name, address, salary  from COMPANY")
rows = cur.fetchall()
for row in rows:
   print "ID = ", row[0]
   print "NAME = ", row[1]
   print "ADDRESS = ", row[2]
   print "SALARY = ", row[3], "\n"

print "Operation done successfully";
conn.close()
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
ID =  1
NAME =  Paul
ADDRESS =  California
SALARY =  20000.0

ID =  2
NAME =  Allen
ADDRESS =  Texas
SALARY =  15000.0

ID =  3
NAME =  Teddy
ADDRESS =  Norway
SALARY =  20000.0

ID =  4
NAME =  Mark
ADDRESS =  Rich-Mond
SALARY =  65000.0

Operation done successfully
</pre>
<h2>UPDATE Operation</h2>
<p>The following Python code shows how we can use the UPDATE statement to update any record and then fetch and display updated records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database = "testdb", user = "postgres", password = "pass123", host = "127.0.0.1", port = "5432")
print "Opened database successfully"

cur = conn.cursor()

cur.execute("UPDATE COMPANY set SALARY = 25000.00 where ID = 1")
conn.commit
print "Total number of rows updated :", cur.rowcount

cur.execute("SELECT id, name, address, salary  from COMPANY")
rows = cur.fetchall()
for row in rows:
   print "ID = ", row[0]
   print "NAME = ", row[1]
   print "ADDRESS = ", row[2]
   print "SALARY = ", row[3], "\n"

print "Operation done successfully";
conn.close()
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
Total number of rows updated : 1
ID =  1
NAME =  Paul
ADDRESS =  California
SALARY =  25000.0

ID =  2
NAME =  Allen
ADDRESS =  Texas
SALARY =  15000.0

ID =  3
NAME =  Teddy
ADDRESS =  Norway
SALARY =  20000.0

ID =  4
NAME =  Mark
ADDRESS =  Rich-Mond
SALARY =  65000.0

Operation done successfully
</pre>
<h2>DELETE Operation</h2>
<p>The following Python code shows how we can use the DELETE statement to delete any record and then fetch and display the remaining records from our COMPANY table &minus;</p>
<pre class="prettyprint notranslate">
#!/usr/bin/python

import psycopg2

conn = psycopg2.connect(database = "testdb", user = "postgres", password = "pass123", host = "127.0.0.1", port = "5432")
print "Opened database successfully"

cur = conn.cursor()

cur.execute("DELETE from COMPANY where ID=2;")
conn.commit
print "Total number of rows deleted :", cur.rowcount

cur.execute("SELECT id, name, address, salary  from COMPANY")
rows = cur.fetchall()
for row in rows:
   print "ID = ", row[0]
   print "NAME = ", row[1]
   print "ADDRESS = ", row[2]
   print "SALARY = ", row[3], "\n"

print "Operation done successfully";
conn.close()
</pre>
<p>When the above given program is executed, it will produce the following result &minus;</p>
<pre class="result notranslate">
Opened database successfully
Total number of rows deleted : 1
ID =  1
NAME =  Paul
ADDRESS =  California
SALARY =  20000.0

ID =  3
NAME =  Teddy
ADDRESS =  Norway
SALARY =  20000.0

ID =  4
NAME =  Mark
ADDRESS =  Rich-Mond
SALARY =  65000.0

Operation done successfully
</pre>
<hr />
<div class="pre-btn">
<a href="postgresql_python.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="../cgi-bin/printpage.html" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="postgresql_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="../images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="../index-2.html" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="../scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="../about/tutorials_writing.html">Write for us</a></li>
         <li><a href="../about/faq.html">FAQ's</a></li>
         <li><a href="../about/about_helping.html">Helping</a></li>
         <li><a href="../about/contact_us.html">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="../theme/js/custom-min7b30.js?v=4"></script>
<script src="../../www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/postgresql/postgresql_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 15:31:39 GMT -->
</html>
