<!doctype html> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]> <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]> <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]> <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en"><!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:25:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8">
<title>Python Pandas Quick Guide</title>
<meta name="description" content="Python Pandas Quick Guide - Learn Python Pandas in simple and easy steps starting from basic to advanced concepts with examples including Introduction, Environment Setup, Introduction to Data Structures, Series, DataFrame, Panel, Basic Functionality, Descriptive Statistics, Function Application, Reindexing, Iteration, Sorting, Working with Text Data, Options and Customization, Indexing and Selecting Data, Statistical Functions, Window Functions, Aggregations, Missing Data, GroupBy, Merging/Joining, Concatenation, Date Functionality, Timedelta, Categorical Data, Visualization, IO Tools, Sparse Data, Caveats & Gotchas, Comparison with SQL." />
<meta name="keywords" content="Python Pandas, Tutorial, Learning, Introduction, Environment Setup, Introduction to Data Structures, Series, DataFrame, Panel, Basic Functionality, Descriptive Statistics, Function Application, Reindexing, Iteration, Sorting, Working with Text Data, Options and Customization, Indexing and Selecting Data, Statistical Functions, Window Functions, Aggregations, Missing Data, GroupBy, Merging/Joining, Concatenation, Date Functionality, Timedelta, Categorical Data, Visualization, IO Tools, Sparse Data, Caveats & Gotchas, Comparison with SQL." />
<base  />
<link rel="shortcut icon" href="https://www.tutorialspoint.com/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="https://www.tutorialspoint.com/theme/css/style-min.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
pre.prettyprint.tryit {min-height:37px; background: #eee url(https://www.tutorialspoint.com/python_pandas/images/try-it.jpg) top right no-repeat !important}select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #036db0 url(https://www.tutorialspoint.com/images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #036db0 !important;}
.submenu-item{ border-bottom: 2px solid #036db0 !important; border-top: 2px solid #036db0 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="https://www.tutorialspoint.com/images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="https://www.tutorialspoint.com/index.htm" title="tutorialspoint">
      <img alt="tutorialspoint" src="https://www.tutorialspoint.com/python_pandas/images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="https://www.tutorialspoint.com/about/about_careers.htm" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="https://www.tutorialspoint.com/whiteboard.htm"><img src="https://www.tutorialspoint.com/theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="https://www.tutorialspoint.com/netmeeting.php"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="https://www.tutorialspoint.com/online_dev_tools.htm"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="https://www.tutorialspoint.com/articles/index.php"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="https://www.tutorialspoint.com/index.htm"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/codingground.htm"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/tutor_connect/index.php"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="https://www.tutorialspoint.com/python_pandas/images/python-pandas-mini-logo.jpg" alt="Python Pandas Tutorial" />
</div>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Python Pandas Tutorial</li>
<li><a href="https://www.tutorialspoint.com/python_pandas/index.htm">Python Pandas - Home</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_introduction.htm">Python Pandas - Introduction</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_environment_setup.htm">Python Pandas - Environment Setup</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_introduction_to_data_structures.htm">Introduction to Data Structures</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_series.htm">Python Pandas - Series</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_dataframe.htm">Python Pandas - DataFrame</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_panel.htm">Python Pandas - Panel</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_basic_functionality.htm">Python Pandas - Basic Functionality</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_descriptive_statistics.htm">Descriptive Statistics</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_function_application.htm">Function Application</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_reindexing.htm">Python Pandas - Reindexing</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_iteration.htm">Python Pandas - Iteration</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_sorting.htm">Python Pandas - Sorting</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_working_with_text_data.htm">Working with Text Data</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_options_and_customization.htm">Options &amp; Customization</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_indexing_and_selecting_data.htm">Indexing &amp; Selecting Data</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_statistical_functions.htm">Statistical Functions</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_window_functions.htm">Python Pandas - Window Functions</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_aggregations.htm">Python Pandas - Aggregations</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_missing_data.htm">Python Pandas - Missing Data</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_groupby.htm">Python Pandas - GroupBy</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_merging_joining.htm">Python Pandas - Merging/Joining</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_concatenation.htm">Python Pandas - Concatenation</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_date_functionality.htm">Python Pandas - Date Functionality</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_timedelta.htm">Python Pandas - Timedelta</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_categorical_data.htm">Python Pandas - Categorical Data</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_visualization.htm">Python Pandas - Visualization</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_io_tool.htm">Python Pandas - IO Tools</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_sparse_data.htm">Python Pandas - Sparse Data</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_caveats_and_gotchas.htm">Python Pandas - Caveats &amp; Gotchas</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_comparison_with_sql.htm">Comparison with SQL</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Python Pandas Useful Resources</li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm">Python Pandas - Quick Guide</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_useful_resources.htm">Python Pandas - Useful Resources</a></li>
<li><a href="https://www.tutorialspoint.com/python_pandas/python_pandas_discussion.htm">Python Pandas - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="https://www.tutorialspoint.com/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>Python Pandas - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/python_pandas/python_pandas_comparison_with_sql.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/python_pandas/python_pandas_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>Python Pandas - Introduction</h1>
<p>Pandas is an open-source Python Library providing high-performance data manipulation and analysis tool using its powerful data structures. The name Pandas is derived from the word Panel Data – an Econometrics from Multidimensional data.</p>
<p>In 2008, developer Wes McKinney started developing pandas when in need of high performance, flexible tool for analysis of data.</p>
<p>Prior to Pandas, Python was majorly used for data munging and preparation. It had very less contribution towards data analysis. Pandas solved this problem. Using Pandas, we can accomplish five typical steps in the processing and analysis of data, regardless of the origin of data — load, prepare, manipulate, model, and analyze.</p>
<p>Python with Pandas is used in a wide range of fields including academic and commercial domains including finance, economics, Statistics, analytics, etc.</p>
<h2>Key Features of Pandas</h2>
<ul class="list">
<li>Fast and efficient DataFrame object with default and customized indexing.</li>
<li>Tools for loading data into in-memory data objects from different file formats.</li>
<li>Data alignment and integrated handling of missing data.</li>
<li>Reshaping and pivoting of date sets.</li>
<li>Label-based slicing, indexing and subsetting of large data sets.</li>
<li>Columns from a data structure can be deleted or inserted.</li>
<li>Group by data for aggregation and transformations.</li>
<li>High performance merging and joining of data.</li>
<li>Time Series functionality.</li>
</ul> 
<h1>Python Pandas - Environment Setup</h1>
<p>Standard Python distribution doesn't come bundled with Pandas module. A lightweight alternative is to install NumPy using popular Python package installer, <b>pip.</b></p>
<pre class="result notranslate">
pip install pandas
</pre>
<p>If you install Anaconda Python package, Pandas will be installed by default with the following &minus;</p>
<h2>Windows</h2>
<ul class="list">
<li><p><b>Anaconda</b> (from <a rel="nofollow" target="_blank" href="https://www.continuum.io/">https://www.continuum.io</a>) is a free Python distribution for SciPy stack. It is also available for Linux and Mac.</p></li>
<li><p><b>Canopy</b> (<a rel="nofollow" target="_blank" href="https://www.enthought.com/products/canopy">https://www.enthought.com/products/canopy/</a>) is available as free as well as commercial distribution with full SciPy stack for Windows, Linux and Mac.</p></li>
<li><p><b>Python</b> (x,y) is a free Python distribution with SciPy stack and Spyder IDE for Windows OS. (Downloadable from <a rel="nofollow" target="_blank" href="http://python-xy.github.io/">http://python-xy.github.io/</a>)</p></li>
</ul>
<h2>Linux</h2>
<p>Package managers of respective Linux distributions are used to install one or more packages in SciPy stack.</p>
<p><b>For Ubuntu Users</b></p>
<pre class="result notranslate">
sudo apt-get install python-numpy python-scipy python-matplotlibipythonipythonnotebook
python-pandas python-sympy python-nose
</pre>
<p><b>For Fedora Users</b></p>
<pre class="result notranslate">
sudo yum install numpyscipy python-matplotlibipython python-pandas sympy
python-nose atlas-devel
</pre>
<h1>Introduction to Data Structures</h1>
<p>Pandas deals with the following three data structures &minus;</p>
<ul class="list">
<li>Series</li>
<li>DataFrame</li>
<li>Panel</li>
</ul>
<p>These data structures are built on top of Numpy array, which means they are fast.</p>
<h2>Dimension &amp; Description</h2>
<p>The best way to think of these data structures is that the higher dimensional data structure is a container of its lower dimensional data structure. For example, DataFrame is a container of Series, Panel is a container of DataFrame.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Data Structure</th>
<th style="text-align:center;">Dimensions</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">Series</td>
<td style="text-align:center;">1</td>
<td style="text-align:center;">1D labeled homogeneous array, sizeimmutable.</td>
</tr>
<tr>
<td style="text-align:center;">Data Frames</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">General 2D labeled, size-mutable tabular structure with potentially heterogeneously typed
columns.</td>
</tr>
<tr>
<td style="text-align:center;">Panel</td>
<td style="text-align:center;">3</td>
<td style="text-align:center;">General 3D labeled, size-mutable array.</td>
</tr>
</table> 
<p>Building and handling two or more dimensional arrays is a tedious task, burden is placed on the user to consider the orientation of the data set when writing functions. But using Pandas data structures, the mental effort of the user is reduced.</p>
<p>For example, with tabular data (DataFrame) it is more semantically helpful to think of the <b>index</b> (the rows) and the <b>columns</b> rather than axis 0 and axis 1.</p>
<h3>Mutability</h3>
<p>All Pandas data structures are value mutable (can be changed) and except Series all are size mutable. Series is size immutable.</p>
<p><b>Note</b> &minus; DataFrame is widely used and one of the most important data structures. Panel is
very less used.</p>
<h2>Series</h2>
<p>Series is a one-dimensional array like structure with homogeneous data. For example, the following series is a collection of integers 10, 23, 56, …</p>
<table class="table table-bordered">
<tr>
<td style="text-align:center;">10</td>
<td style="text-align:center;">23</td>
<td style="text-align:center;">56</td>
<td style="text-align:center;">17</td>
<td style="text-align:center;">52</td>
<td style="text-align:center;">61</td>
<td style="text-align:center;">73</td>
<td style="text-align:center;">90</td>
<td style="text-align:center;">26</td>
<td style="text-align:center;">72</td>
</tr>
</table>
<h3>Key Points</h3>
<ul class="list">
<li>Homogeneous data</li>
<li>Size Immutable</li>
<li>Values of Data Mutable</li>
</ul>
<h2>DataFrame</h2>
<p>DataFrame is a two-dimensional array with heterogeneous data. For example,</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Name</th>
<th style="text-align:center;">Age</th>
<th style="text-align:center;">Gender</th>
<th style="text-align:center;">Rating</th>
</tr>
<tr>
<td style="text-align:center;">Steve</td>
<td style="text-align:center;">32</td>
<td style="text-align:center;">Male</td>
<td style="text-align:center;">3.45</td>
</tr>
<tr>
<td style="text-align:center;">Lia</td>
<td style="text-align:center;">28</td>
<td style="text-align:center;">Female</td>
<td style="text-align:center;">4.6</td>
</tr>
<tr>
<td style="text-align:center;">Vin</td>
<td style="text-align:center;">45</td>
<td style="text-align:center;">Male</td>
<td style="text-align:center;">3.9</td>
</tr>
<tr>
<td style="text-align:center;">Katie</td>
<td style="text-align:center;">38</td>
<td style="text-align:center;">Female</td>
<td style="text-align:center;">2.78</td>
</tr>
</table>
<p>The table represents the data of a sales team of an organization with their overall performance rating. The data is represented in rows and columns. Each column represents an attribute and each row represents a person.</p>
<h2>Data Type of Columns</h2>
<p>The data types of the four columns are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Column</th>
<th style="text-align:center;">Type</th>
</tr>
<tr>
<td style="text-align:center;">Name</th>
<td style="text-align:center;">String</th>
</tr>
<tr>
<td style="text-align:center;">Age</th>
<td style="text-align:center;">Integer</th>
</tr>
<tr>
<td style="text-align:center;">Gender</th>
<td style="text-align:center;">String</th>
</tr>
<tr>
<td style="text-align:center;">Rating</th>
<td style="text-align:center;">Float</th>
</tr>
</table>
<h3>Key Points</h3>
<ul class="list">
<li>Heterogeneous data</li>
<li>Size Mutable</li>
<li>Data Mutable</li>
</ul>
<h2>Panel</h2>
<p>Panel is a three-dimensional data structure with heterogeneous data. It is hard to represent the panel in graphical representation. But a panel can be illustrated as a container of DataFrame.</p>
<h3>Key Points</h3>
<ul class="list">
<li>Heterogeneous data</li>
<li>Size Mutable</li>
<li>Data Mutable</li>
</ul>
<h1>Python Pandas - Series</h1>
<p>Series is a one-dimensional labeled array capable of holding data of any type (integer, string, float, python objects, etc.). The axis labels are collectively called index.</p>
<h2>pandas.Series</h2>
<p>A pandas Series can be created using the following constructor &minus;</p>
<pre class = "result notranslate">
pandas.DataFrame( data, index, dtype, copy)
</pre>
<p>The parameters of the constructor are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Parameter &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">
<p><b>data</b></p>
<p>data takes various forms like ndarray, list, constants</p>
</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">
<p><b>index</b></p>
<p>Index values must be unique and hashable, same length as data. Default <b>np.arrange(n)</b> if no index is passed.</p>
</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">
<p><b>dtype</b></p>
<p>dtype is for data type. If None, data type will be inferred</p>
</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">
<p><b>copy</b></p>
<p>Copy data. Default False</p>
</td>
</tr>
</table>
<p>A series can be created using various inputs like &minus;</p>
<ul class="list">
<li>Array</li>
<li>Dict</li>
<li>Scalar value or constant</li>
</ul>
<h2>Create an Empty Series</h2>
<p>A basic series, which can be created is an Empty Series.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
s = pd.Series()
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Series([], dtype: float64)
</pre>
<h2>Create a Series from ndarray</h2>
<p>If data is an ndarray, then index passed must be of the same length. If no index is passed, then by default index will be <b>range(n)</b> where <b>n</b> is array length, i.e., [0,1,2,3…. <b>range(len(array))-1].</b></p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
import numpy as np
data = np.array(['a','b','c','d'])
s = pd.Series(data)
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   a
1   b
2   c
3   d
dtype: object
</pre>
<p>We did not pass any index, so by default, it assigned the indexes ranging from 0 to <b>len(data)-1</b>, i.e., 0 to 3.</p>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
import numpy as np
data = np.array(['a','b','c','d'])
s = pd.Series(data,index=[100,101,102,103])
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
100  a
101  b
102  c
103  d
dtype: object
</pre>
<p>We passed the index values here. Now we can see the customized indexed values in the output.</p>
<h2>Create a Series from dict</h2>
<p>A <b>dict</b> can be passed as input and if no index is specified, then the dictionary keys are taken in a sorted order to construct index. If <b>index</b> is passed, the values in data corresponding to the labels in the index will be pulled out.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
import numpy as np
data = {'a' : 0., 'b' : 1., 'c' : 2.}
s = pd.Series(data)
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a 0.0
b 1.0
c 2.0
dtype: float64
</pre>
<p><b>Observe</b> &minus; Dictionary keys are used to construct index.</p>
<h3>Example 2</h3>
<pre class="prettyprint notranslate">
#import the pandas library and aliasing as pd
import pandas as pd
import numpy as np
data = {'a' : 0., 'b' : 1., 'c' : 2.}
s = pd.Series(data,index=['b','c','d','a'])
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
b 1.0
c 2.0
d NaN
a 0.0
dtype: float64
</pre>
<p><b>Observe</b> &minus; Index order is persisted and the missing element is filled with NaN (Not a
Number).</p>
<h2>Create a Series from Scalar</h2>
<p>If data is a scalar value, an index must be provided. The value will be repeated to match
the length of <b>index</b></p>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
import numpy as np
s = pd.Series(5, index=[0, 1, 2, 3])
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  5
1  5
2  5
3  5
dtype: int64
</pre>
<h2>Accessing Data from Series with Position</h2>
<p>Data in the series can be accessed similar to that in an <b>ndarray.</b></p>
<h3>Example 1</h3>
<p>Retrieve the first element. As we already know, the counting starts from zero for the array,
which means the first element is stored at zeroth position and so on.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])

#retrieve the first element
print s[0]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
1
</pre>
<h3>Example 2</h3>
<p>Retrieve the first three elements in the Series. If a : is inserted in front of it, all items from that index onwards will be extracted. If two parameters (with : between them) is used, items between the two indexes (not including the stop index)</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])

#retrieve the first three element
print s[:3]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a  1
b  2
c  3
dtype: int64
</pre>
<h3>Example 3</h3>
<p>Retrieve the last three elements.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])

#retrieve the last three element
print s[-3:]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
c  3
d  4
e  5
dtype: int64
</pre>
<h2>Retrieve Data Using Label (Index)</h2>
<p>A Series is like a fixed-size <b>dict</b> in that you can get and set values by index label.</p>
<h3>Example 1</h3>
<p>Retrieve a single element using index label value.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])

#retrieve a single element
print s['a']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
1
</pre>
<h3>Example 2</h3>
<p>Retrieve multiple elements using a list of index label values.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])

#retrieve multiple elements
print s[['a','c','d']]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a  1
c  3
d  4
dtype: int64
</pre>
<h3>Example 3</h3>
<p>If a label is not contained, an exception is raised.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series([1,2,3,4,5],index = ['a','b','c','d','e'])

#retrieve multiple elements
print s['f']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
…
KeyError: 'f'
</pre>
<h1>Python Pandas - DataFrame</h1>
<p>A Data frame is a two-dimensional data structure, i.e., data is aligned in a tabular fashion in rows and columns.</p>
<h3>Features of DataFrame</h3>
<ul class="list">
<li>Potentially columns are of different types</li>
<li>Size – Mutable</li>
<li>Labeled axes (rows and columns)</li>
<li>Can Perform Arithmetic operations on rows and columns</li>
</ul>
<h3>Structure</h3>
<p>Let us assume that we are creating a data frame with student’s data.</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/structure_table.jpg" alt="Structure Table" />
<p>You can think of it as an SQL table or a spreadsheet data representation.</p>
<h2>pandas.DataFrame</h2>
<p>A pandas DataFrame can be created using the following constructor &minus;</p>
<pre class="result notranslate">
pandas.DataFrame( data, index, columns, dtype, copy)
</pre>
<p>The parameters of the constructor are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Parameter &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">
<p><b>data</b></p>
<p>data takes various forms like ndarray, series, map, lists, dict, constants and also another DataFrame.</p>
</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">
<p><b>index</b></p>
<p>For the row labels, the Index to be used for the resulting frame is Optional Default np.arrange(n) if no index is passed.</p>
</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">
<p><b>columns</b></p>
<p>For column labels, the optional default syntax is - np.arrange(n). This is only true if no index is passed.</p>
</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">
<p><b>dtype</b></p>
<p>Data type of each column.</p>
</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">
<p><b>copy</b></p>
<p>This command (or whatever it is) is used for copying of data, if the default is False.</p>
</td>
</tr>
</table>
<h2>Create DataFrame</h2>
<p>A pandas DataFrame can be created using various inputs like &minus;</p>
<ul class="list">
<li>Lists</li>
<li>dict</li>
<li>Series</li>
<li>Numpy ndarrays</li>
<li>Another DataFrame</li>
</ul>
<p>In the subsequent sections of this chapter, we will see how to create a DataFrame using these inputs.</p>
<h2>Create an Empty DataFrame</h2>
<p>A basic DataFrame, which can be created is an Empty Dataframe.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
df = pd.DataFrame()
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Empty DataFrame
Columns: []
Index: []
</pre>
<h2>Create a DataFrame from Lists</h2>
<p>The DataFrame can be created using a single list or a list of lists.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = [1,2,3,4,5]
df = pd.DataFrame(data)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
     0
0    1
1    2
2    3
3    4
4    5
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = [['Alex',10],['Bob',12],['Clarke',13]]
df = pd.DataFrame(data,columns=['Name','Age'])
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      Name      Age
0     Alex      10
1     Bob       12
2     Clarke    13
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = [['Alex',10],['Bob',12],['Clarke',13]]
df = pd.DataFrame(data,columns=['Name','Age'],dtype=float)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      Name     Age
0     Alex     10.0
1     Bob      12.0
2     Clarke   13.0
</pre>
<p><b>Note</b> &minus; Observe, the <b>dtype</b> parameter changes the type of Age column to floating point.</p>
<h2>Create a DataFrame from Dict of ndarrays / Lists</h2>
<p>All the <b>ndarrays</b> must be of same length. If index is passed, then the length of the index should equal to the length of the arrays.</p>
<p>If no index is passed, then by default, index will be range(n), where <b>n</b> is the array length.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]}
df = pd.DataFrame(data)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      Age      Name
0     28        Tom
1     34       Jack
2     29      Steve
3     42      Ricky
</pre>
<p><b>Note</b> &minus; Observe the values 0,1,2,3. They are the default index assigned to each using the function range(n).</p>
<h3>Example 2</h3>
<p>Let us now create an indexed DataFrame using arrays.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = {'Name':['Tom', 'Jack', 'Steve', 'Ricky'],'Age':[28,34,29,42]}
df = pd.DataFrame(data, index=['rank1','rank2','rank3','rank4'])
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         Age    Name
rank1    28      Tom
rank2    34     Jack
rank3    29    Steve
rank4    42    Ricky
</pre>
<p><b>Note</b> &minus; Observe, the <b>index</b> parameter assigns an index to each row.</p>
<h2>Create a DataFrame from List of Dicts</h2>
<p>List of Dictionaries can be passed as input data to create a DataFrame. The dictionary keys are by default taken as column names.</p>
<h3>Example 1</h3>
<p>The following example shows how to create a DataFrame by passing a list of dictionaries.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]
df = pd.DataFrame(data)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    a    b      c
0   1   2     NaN
1   5   10   20.0
</pre>
<p><b>Note</b> &minus; Observe, NaN (Not a Number) is appended in missing areas.</p>
<h3>Example 2</h3>
<p>The following example shows how to create a DataFrame by passing a list of dictionaries and the row indices.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]
df = pd.DataFrame(data, index=['first', 'second'])
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
        a   b       c
first   1   2     NaN
second  5   10   20.0
</pre>
<h3>Example 3</h3>
<p>The following example shows how to create a DataFrame with a list of dictionaries, row indices, and column indices.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
data = [{'a': 1, 'b': 2},{'a': 5, 'b': 10, 'c': 20}]

#With two column indices, values same as dictionary keys
df1 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b'])

#With two column indices with one index with other name
df2 = pd.DataFrame(data, index=['first', 'second'], columns=['a', 'b1'])
print df1
print df2
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
#df1 output
         a  b
first    1  2
second   5  10

#df2 output
         a  b1
first    1  NaN
second   5  NaN
</pre>
<p><b>Note</b> &minus; Observe, df2 DataFrame is created with a column index other than the dictionary key; thus, appended the NaN’s in place. Whereas, df1 is created with column indices same as dictionary keys, so NaN’s appended.</p>
<h2>Create a DataFrame from Dict of Series</h2>
<p>Dictionary of Series can be passed to form a DataFrame. The resultant index is the union of all the series indexes passed.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
      'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      one    two
a     1.0    1
b     2.0    2
c     3.0    3
d     NaN    4
</pre>
<p><b>Note</b> &minus; Observe, for the series one, there is no label <b>‘d’</b> passed, but in the result, for the <b>d</b> label, NaN is appended with NaN.</p>
<p>Let us now understand <b>column selection, addition</b>, and <b>deletion</b> through examples.</p>
<h2>Column Selection</h2>
<p>We will understand this by selecting a column from the DataFrame.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
      'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print df ['one']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a     1.0
b     2.0
c     3.0
d     NaN
Name: one, dtype: float64
</pre>
<h2>Column Addition</h2>
<p>We will understand this by adding a new column to an existing data frame.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
      'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)

# Adding a new column to an existing DataFrame object with column label by passing new series

print ("Adding a new column by passing as Series:")
df['three']=pd.Series([10,20,30],index=['a','b','c'])
print df

print ("Adding a new column using the existing columns in DataFrame:")
df['four']=df['one']+df['three']

print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Adding a new column by passing as Series:
     one   two   three
a    1.0    1    10.0
b    2.0    2    20.0
c    3.0    3    30.0
d    NaN    4    NaN

Adding a new column using the existing columns in DataFrame:
      one   two   three    four
a     1.0    1    10.0     11.0
b     2.0    2    20.0     22.0
c     3.0    3    30.0     33.0
d     NaN    4     NaN     NaN
</pre>
<h2>Column Deletion</h2>
<p>Columns can be deleted or popped; let us take an example to understand how.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
# Using the previous DataFrame, we will delete a column
# using del function
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd']), 
     'three' : pd.Series([10,20,30], index=['a','b','c'])}

df = pd.DataFrame(d)
print ("Our dataframe is:")
print df

# using del function
print ("Deleting the first column using DEL function:")
del df['one']
print df

# using pop function
print ("Deleting another column using POP function:")
df.pop('two')
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our dataframe is:
      one   three  two
a     1.0    10.0   1
b     2.0    20.0   2
c     3.0    30.0   3
d     NaN     NaN   4

Deleting the first column using DEL function:
      three    two
a     10.0     1
b     20.0     2
c     30.0     3
d     NaN      4

Deleting another column using POP function:
   three
a  10.0
b  20.0
c  30.0
d  NaN
</pre>
<h2>Row Selection, Addition, and Deletion</h2>
<p>We will now understand row selection, addition and deletion through examples. Let us begin with the concept of selection.</p>
<h3>Selection by Label</h3>
Rows can be selected by passing row label to a <b>loc</b> function.
<pre class="prettyprint notranslate tryit">
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print df.loc['b']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
one 2.0
two 2.0
Name: b, dtype: float64
</pre>
<p>The result is a series with labels as column names of the DataFrame. And, the Name of the series is the label with which it is retrieved.</p>
<h3>Selection by integer location</h3>
<p>Rows can be selected by passing integer location to an <b>iloc</b> function.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']),
     'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print df.iloc[2]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
one   3.0
two   3.0
Name: c, dtype: float64
</pre>
<h3>Slice Rows</h3>
<p>Multiple rows can be selected using ‘ : ’ operator.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

d = {'one' : pd.Series([1, 2, 3], index=['a', 'b', 'c']), 
    'two' : pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])}

df = pd.DataFrame(d)
print df[2:4]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      one    two
c     3.0     3
d     NaN     4
</pre>
<h3>Addition of Rows</h3>
<p>Add new rows to a DataFrame using the <b>append</b> function. This function will append the rows at the end.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

df = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])
df2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])

df = df.append(df2)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   a  b
0  1  2
1  3  4
0  5  6
1  7  8
</pre>
<h3>Deletion of Rows</h3>
<p>Use index label to delete or drop rows from a DataFrame. If label is duplicated, then multiple rows will be dropped.</p>
<p>If you observe, in the above example, the labels are duplicate. Let us drop a label and will see how many rows will get dropped.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

df = pd.DataFrame([[1, 2], [3, 4]], columns = ['a','b'])
df2 = pd.DataFrame([[5, 6], [7, 8]], columns = ['a','b'])

df = df.append(df2)

# Drop rows with label 0
df = df.drop(0)

print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
  a b
1 3 4
1 7 8
</pre>
<p>In the above example, two rows were dropped because those two contain the same label 0.</p>
<h1>Python Pandas - Panel</h1>
<p>A <b>panel</b> is a 3D container of data. The term <b>Panel data</b> is derived from econometrics and is partially responsible for the name pandas &minus; <b>pan(el)-da(ta)</b>-s.</p>
<p>The names for the 3 axes are intended to give some semantic meaning to describing operations involving panel data. They are &minus;</p>
<ul class="list">
<li><p><b>items</b> &minus; axis 0, each item corresponds to a DataFrame contained inside.</p></li>
<li><p><b>major_axis</b> &minus; axis 1, it is the index (rows) of each of the DataFrames.</p></li>
<li><p><b>minor_axis</b> &minus; axis 2, it is the columns of each of the DataFrames.</p></li>
</ul>
<h2>pandas.Panel()</h2>
<p>A Panel can be created using the following constructor &minus;</p>
<pre class="result notranslate">
pandas.Panel(data, items, major_axis, minor_axis, dtype, copy)
</pre>
<p>The parameters of the constructor are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Parameter</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">data</td>
<td>Data takes various forms like ndarray, series, map, lists, dict, constants and also another DataFrame</td>
</tr>
<tr>
<td style="text-align:center;">items</td>
<td>axis=0</td>
</tr>
<tr>
<td style="text-align:center;">major_axis</td>
<td>axis=1</td>
</tr>
<tr>
<td style="text-align:center;">minor_axis</td>
<td>axis=2</td>
</tr>
<tr>
<td style="text-align:center;">dtype</td>
<td>Data type of each column</td>
</tr>
<tr>
<td style="text-align:center;">copy</td>
<td>Copy data. Default, <b>false</b></td>
</tr>
</table>
<h2>Create Panel</h2>
<p>A Panel can be created using multiple ways like &minus;</p>
<ul class="list">
<li>From ndarrays</li>
<li>From dict of DataFrames</li>
</ul>
<h3>From 3D ndarray</h3>
<pre class="prettyprint notranslate tryit">
# creating an empty panel
import pandas as pd
import numpy as np

data = np.random.rand(2,4,5)
p = pd.Panel(data)
print p
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)
Items axis: 0 to 1
Major_axis axis: 0 to 3
Minor_axis axis: 0 to 4
</pre>
<p><b>Note</b> &minus; Observe the dimensions of the empty panel and the above panel, all the objects are different.</p>
<h3>From dict of DataFrame Objects</h3>
<pre class="prettyprint notranslate tryit">
#creating an empty panel
import pandas as pd
import numpy as np

data = {'Item1' : pd.DataFrame(np.random.randn(4, 3)), 
        'Item2' : pd.DataFrame(np.random.randn(4, 2))}
p = pd.Panel(data)
print p
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 2 (items) x 4 (major_axis) x 5 (minor_axis)
Items axis: 0 to 1
Major_axis axis: 0 to 3
Minor_axis axis: 0 to 4
</pre>
<h3>Create an Empty Panel</h3>
<p>An empty panel can be created using the Panel constructor as follows &minus;</p>
<pre class="prettyprint notranslate tryit">
#creating an empty panel
import pandas as pd
p = pd.Panel()
print p
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
&lt;class 'pandas.core.panel.Panel'&gt;
Dimensions: 0 (items) x 0 (major_axis) x 0 (minor_axis)
Items axis: None
Major_axis axis: None
Minor_axis axis: None
</pre>
<h2>Selecting the Data from Panel</h2>
<p>Select the data from the panel using &minus;</p>
<ul class="list">
<li>Items</li>
<li>Major_axis</li>
<li>Minor_axis</li>
</ul>
<h3>Using Items</h3>
<pre class="prettyprint notranslate tryit">
# creating an empty panel
import pandas as pd
import numpy as np
data = {'Item1' : pd.DataFrame(np.random.randn(4, 3)), 
        'Item2' : pd.DataFrame(np.random.randn(4, 2))}
p = pd.Panel(data)
print p['Item1']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
            0          1          2
0    0.488224  -0.128637   0.930817
1    0.417497   0.896681   0.576657
2   -2.775266   0.571668   0.290082
3   -0.400538  -0.144234   1.110535
</pre>
<p>We have two items, and we retrieved item1. The result is a DataFrame with 4 rows and 3 columns, which are the <b>Major_axis</b> and <b>Minor_axis</b> dimensions.</p>
<h3>Using major_axis</h3>
<p>Data can be accessed using the method <b>panel.major_axis(index)</b>.</p>
<pre class="prettyprint notranslate tryit">
# creating an empty panel
import pandas as pd
import numpy as np
data = {'Item1' : pd.DataFrame(np.random.randn(4, 3)), 
        'Item2' : pd.DataFrame(np.random.randn(4, 2))}
p = pd.Panel(data)
print p.major_xs(1)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      Item1       Item2
0   0.417497    0.748412
1   0.896681   -0.557322
2   0.576657       NaN
</pre>
<h3>Using minor_axis</h3>
<p>Data can be accessed using the method <b>panel.minor_axis(index).</b></p>
<pre class="prettyprint notranslate tryit">
# creating an empty panel
import pandas as pd
import numpy as np
data = {'Item1' : pd.DataFrame(np.random.randn(4, 3)), 
        'Item2' : pd.DataFrame(np.random.randn(4, 2))}
p = pd.Panel(data)
print p.minor_xs(1)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
       Item1       Item2
0   -0.128637   -1.047032
1    0.896681   -0.557322
2    0.571668    0.431953
3   -0.144234    1.302466
</pre>
<p><b>Note</b> &minus; Observe the changes in the dimensions.</p>
<h1>Python Pandas - Basic Functionality</h1>
<p>By now, we learnt about the three Pandas DataStructures and how to create them. We will majorly focus on the DataFrame objects because of its importance in the real time data processing and also discuss a few other DataStructures.</p>
<h2>Series Basic Functionality</h2>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No.</th>
<th style="text-align:center;">Attribute or
Method</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">axes</td>
<td>Returns a list of the row axis labels.</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">dtype</td>
<td>Returns the dtype of the object.</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">empty</td>
<td>Returns True if series is empty.</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">ndim</td>
<td>Returns the number of dimensions of the underlying data, by
definition 1.</td>
</tr>
<tr>
<td style="text-align:center;">5</td>
<td style="text-align:center;">size</td>
<td>Returns the number of elements in the underlying data.</td>
</tr>
<tr>
<td style="text-align:center;">6</td>
<td style="text-align:center;">values</td>
<td>Returns the Series as ndarray.</td>
</tr>
<tr>
<td style="text-align:center;">7</td>
<td style="text-align:center;">head()</td>
<td>Returns the first n rows.</td>
</tr>
<tr>
<td style="text-align:center;">8</td>
<td style="text-align:center;">tail()</td>
<td>Returns the last n rows.</td>
</tr>
</table>
<p>Let us now create a Series and see all the above tabulated attributes operation.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 100 random numbers
s = pd.Series(np.random.randn(4))
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   0.967853
1  -0.148368
2  -1.395906
3  -1.758394
dtype: float64
</pre>
<h3>axes</h3>
<p>Returns the list of the labels of the series.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 100 random numbers
s = pd.Series(np.random.randn(4))
print ("The axes are:")
print s.axes
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
The axes are:
[RangeIndex(start=0, stop=4, step=1)]
</pre>
<p>The above result is a compact format of a list of values from 0 to 5, i.e., [0,1,2,3,4].</p>
<h3>empty</h3>
<p>Returns the Boolean value saying whether the Object is empty or not. True indicates that the object is empty.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 100 random numbers
s = pd.Series(np.random.randn(4))
print ("Is the Object empty?")
print s.empty
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Is the Object empty?
False
</pre>
<h3>ndim</h3>
<p>Returns the number of dimensions of the object. By definition, a Series is a 1D data structure, so it returns </p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 4 random numbers
s = pd.Series(np.random.randn(4))
print s

print ("The dimensions of the object:")
print s.ndim
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   0.175898
1   0.166197
2  -0.609712
3  -1.377000
dtype: float64

The dimensions of the object:
1
</pre>
<h3>size</h3>
<p>Returns the size(length) of the series.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 4 random numbers
s = pd.Series(np.random.randn(2))
print s
print ("The size of the object:")
print s.size
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   3.078058
1  -1.207803
dtype: float64

The size of the object:
2
</pre>
<h3>values</h3>
<p>Returns the actual data in the series as an array.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 4 random numbers
s = pd.Series(np.random.randn(4))
print s

print ("The actual data series is:")
print s.values
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   1.787373
1  -0.605159
2   0.180477
3  -0.140922
dtype: float64

The actual data series is:
[ 1.78737302 -0.60515881 0.18047664 -0.1409218 ]
</pre>
<h3>Head &amp; Tail</h3>
<p>To view a small sample of a Series or the DataFrame object, use the head() and the tail() methods.</p>
<p><b>head()</b> returns the first <b>n</b> rows(observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 4 random numbers
s = pd.Series(np.random.randn(4))
print ("The original series is:")
print s

print ("The first two rows of the data series:")
print s.head(2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
The original series is:
0   0.720876
1  -0.765898
2   0.479221
3  -0.139547
dtype: float64

The first two rows of the data series:
0   0.720876
1  -0.765898
dtype: float64
</pre>
<p><b>tail()</b> returns the last <b>n</b> rows(observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a series with 4 random numbers
s = pd.Series(np.random.randn(4))
print ("The original series is:")
print s

print ("The last two rows of the data series:")
print s.tail(2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
The original series is:
0 -0.655091
1 -0.881407
2 -0.608592
3 -2.341413
dtype: float64

The last two rows of the data series:
2 -0.608592
3 -2.341413
dtype: float64
</pre>
<h2>DataFrame Basic Functionality</h2>
<p>Let us now understand what DataFrame Basic Functionality is. The following tables lists down the important attributes or methods that help in DataFrame Basic Functionality.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No.</th>
<th style="text-align:center;">Attribute or
Method</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">T</td>
<td>Transposes rows and columns.</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">axes</td>
<td>Returns a list with the row axis labels and column axis labels as the only members.</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">dtypes</td>
<td>Returns the dtypes in this object.</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">empty</td>
<td>True if NDFrame is entirely empty [no items]; if any of the axes are of length 0.</td>
</tr>
<tr>
<td style="text-align:center;">5</td>
<td style="text-align:center;">ndim</td>
<td>Number of axes / array dimensions.</td>
</tr>
<tr>
<td style="text-align:center;">6</td>
<td style="text-align:center;">shape</td>
<td>Returns a tuple representing the dimensionality of the DataFrame.</td>
</tr>
<tr>
<td style="text-align:center;">7</td>
<td style="text-align:center;">size</td>
<td>Number of elements in the NDFrame.</td>
</tr>
<tr>
<td style="text-align:center;">8</td>
<td style="text-align:center;">values</td>
<td>Numpy representation of NDFrame.</td>
</tr>
<tr>
<td style="text-align:center;">9</td>
<td style="text-align:center;">head()</td>
<td>Returns the last n rows.</td>
</tr>
<tr>
<td style="text-align:center;">10</td>
<td style="text-align:center;">tail()</td>
<td>Returns last n rows.</td>
</tr>
</table>
<p>Let us now create a DataFrame and see all how the above mentioned attributes operate.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}

#Create a DataFrame
df = pd.DataFrame(d)
print ("Our data series is:")
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our data series is:
    Age   Name    Rating
0   25    Tom     4.23
1   26    James   3.24
2   25    Ricky   3.98
3   23    Vin     2.56
4   30    Steve   3.20
5   29    Smith   4.60
6   23    Jack    3.80
</pre>
<h3>T (Transpose)</h3>
<p>Returns the transpose of the DataFrame. The rows and columns will interchange.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
# Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}

# Create a DataFrame
df = pd.DataFrame(d)
print ("The transpose of the data series is:")
print df.T
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
The transpose of the data series is:
         0     1       2      3      4      5       6
Age      25    26      25     23     30     29      23
Name     Tom   James   Ricky  Vin    Steve  Smith   Jack
Rating   4.23  3.24    3.98   2.56   3.2    4.6     3.8
</pre>
<h3>axes</h3>
<p>Returns the list of row axis labels and column axis labels.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}

#Create a DataFrame
df = pd.DataFrame(d)
print ("Row axis labels and column axis labels are:")
print df.axes
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Row axis labels and column axis labels are:

[RangeIndex(start=0, stop=7, step=1), Index([u'Age', u'Name', u'Rating'],
dtype='object')]
</pre>
<h3>dtypes</h3>
<p>Returns the data type of each column.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}

#Create a DataFrame
df = pd.DataFrame(d)
print ("The data types of each column are:")
print df.dtypes
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
The data types of each column are:
Age     int64
Name    object
Rating  float64
dtype: object
</pre>
<h3>empty</h3>
<p>Returns the Boolean value saying whether the Object is empty or not; True indicates that the object is empty.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
 
#Create a DataFrame
df = pd.DataFrame(d)
print ("Is the object empty?")
print df.empty
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Is the object empty?
False
</pre>
<h3>ndim</h3>
<p>Returns the number of dimensions of the object. By definition, DataFrame is a 2D object.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}

#Create a DataFrame
df = pd.DataFrame(d)
print ("Our object is:")
print df
print ("The dimension of the object is:")
print df.ndim
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our object is:
      Age    Name     Rating
0     25     Tom      4.23
1     26     James    3.24
2     25     Ricky    3.98
3     23     Vin      2.56
4     30     Steve    3.20
5     29     Smith    4.60
6     23     Jack     3.80

The dimension of the object is:
2
</pre>
<h3>shape</h3>
<p>Returns a tuple representing the dimensionality of the DataFrame. Tuple (a,b), where a represents the number of rows and <b>b</b> represents the number of columns.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
 
#Create a DataFrame
df = pd.DataFrame(d)
print ("Our object is:")
print df
print ("The shape of the object is:")
print df.shape
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our object is:
   Age   Name    Rating
0  25    Tom     4.23
1  26    James   3.24
2  25    Ricky   3.98
3  23    Vin     2.56
4  30    Steve   3.20
5  29    Smith   4.60
6  23    Jack    3.80

The shape of the object is:
(7, 3)
</pre>
<h3>size</h3>
<p>Returns the number of elements in the DataFrame.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
 
#Create a DataFrame
df = pd.DataFrame(d)
print ("Our object is:")
print df
print ("The total number of elements in our object is:")
print df.size
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our object is:
    Age   Name    Rating
0   25    Tom     4.23
1   26    James   3.24
2   25    Ricky   3.98
3   23    Vin     2.56
4   30    Steve   3.20
5   29    Smith   4.60
6   23    Jack    3.80

The total number of elements in our object is:
21
</pre>
<h3>values</h3>
<p>Returns the actual data in the DataFrame as an <b>NDarray.</b></p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
 
#Create a DataFrame
df = pd.DataFrame(d)
print ("Our object is:")
print df
print ("The actual data in our data frame is:")
print df.values
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our object is:
    Age   Name    Rating
0   25    Tom     4.23
1   26    James   3.24
2   25    Ricky   3.98
3   23    Vin     2.56
4   30    Steve   3.20
5   29    Smith   4.60
6   23    Jack    3.80
The actual data in our data frame is:
[[25 'Tom' 4.23]
[26 'James' 3.24]
[25 'Ricky' 3.98]
[23 'Vin' 2.56]
[30 'Steve' 3.2]
[29 'Smith' 4.6]
[23 'Jack' 3.8]]
</pre>
<h3>Head &amp; Tail</h3>
<p>To view a small sample of a DataFrame object, use the <b>head()</b> and tail() methods. <b>head()</b> returns the first <b>n</b> rows (observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}

#Create a DataFrame
df = pd.DataFrame(d)
print ("Our data frame is:")
print df
print ("The first two rows of the data frame is:")
print df.head(2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our data frame is:
    Age   Name    Rating
0   25    Tom     4.23
1   26    James   3.24
2   25    Ricky   3.98
3   23    Vin     2.56
4   30    Steve   3.20
5   29    Smith   4.60
6   23    Jack    3.80

The first two rows of the data frame is:
   Age   Name   Rating
0  25    Tom    4.23
1  26    James  3.24
</pre>
<p><b>tail()</b> returns the last <b>n</b> rows (observe the index values). The default number of elements to display is five, but you may pass a custom number.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack']),
   'Age':pd.Series([25,26,25,23,30,29,23]), 
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8])}
 
#Create a DataFrame
df = pd.DataFrame(d)
print ("Our data frame is:")
print df
print ("The last two rows of the data frame is:")
print df.tail(2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Our data frame is:
    Age   Name    Rating
0   25    Tom     4.23
1   26    James   3.24
2   25    Ricky   3.98
3   23    Vin     2.56
4   30    Steve   3.20
5   29    Smith   4.60
6   23    Jack    3.80

The last two rows of the data frame is:
    Age   Name    Rating
5   29    Smith    4.6
6   23    Jack     3.8
</pre>
<h1>Python Pandas - Descriptive Statistics</h1>
<p>A large number of methods collectively compute descriptive statistics and other related operations on DataFrame. Most of these are aggregations like <b>sum(), mean(),</b> but some of them, like <b>sumsum()</b>, produce an object of the same size. Generally speaking, these methods take an <b>axis</b> argument, just like <i>ndarray.{sum, std, ...},</i> but the axis can be specified by name or integer</p>
<ul class="list">
<li><p><b>DataFrame</b> &minus; “index” (axis=0, default), “columns” (axis=1)</p></li>
</ul>
<p>Let us create a DataFrame and use this object throughout this chapter for all the operations.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Age  Name   Rating
0   25   Tom     4.23
1   26   James   3.24
2   25   Ricky   3.98
3   23   Vin     2.56
4   30   Steve   3.20
5   29   Smith   4.60
6   23   Jack    3.80
7   34   Lee     3.78
8   40   David   2.98
9   30   Gasper  4.80
10  51   Betina  4.10
11  46   Andres  3.65
</pre>
<h3>sum()</h3>
<p>Returns the sum of the values for the requested axis. By default, axis is index (axis=0).</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df.sum()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Age                                                    382
Name     TomJamesRickyVinSteveSmithJackLeeDavidGasperBe...
Rating                                               44.92
dtype: object
</pre>
<p>Each individual column is added individually (Strings are appended).</p>
<h3>axis=1</h3>
<p>This syntax will give the output as shown below.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}
 
#Create a DataFrame
df = pd.DataFrame(d)
print df.sum(1)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0    29.23
1    29.24
2    28.98
3    25.56
4    33.20
5    33.60
6    26.80
7    37.78
8    42.98
9    34.80
10   55.10
11   49.65
dtype: float64
</pre>
<h3>mean()</h3>
<p>Returns the average value</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df.mean()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Age       31.833333
Rating     3.743333
dtype: float64
</pre>
<h3>std()</h3>
<p>Returns the Bressel standard deviation of the numerical columns.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df.std()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Age       9.232682
Rating    0.661628
dtype: float64
</pre>
<h2>Functions &amp; Description</h2>
<p>Let us now understand the functions under Descriptive Statistics in Python Pandas. The following table list down the important functions &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No.</th>
<th style="text-align:center;">Function</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">count()</td>
<td>Number of non-null observations</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">sum()</td>
<td>Sum of values</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">mean()</td>
<td>Mean of Values</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">median()</td>
<td>Median of Values</td>
</tr>
<tr>
<td style="text-align:center;">5</td>
<td style="text-align:center;">mode()</td>
<td>Mode of values</td>
</tr>
<tr>
<td style="text-align:center;">6</td>
<td style="text-align:center;">std()</td>
<td>Standard Deviation of the Values</td>
</tr>
<tr>
<td style="text-align:center;">7</td>
<td style="text-align:center;">min()</td>
<td>Minimum Value</td>
</tr>
<tr>
<td style="text-align:center;">8</td>
<td style="text-align:center;">max()</td>
<td>Maximum Value</td>
</tr>
<tr>
<td style="text-align:center;">9</td>
<td style="text-align:center;">abs()</td>
<td>Absolute Value</td>
</tr>
<tr>
<td style="text-align:center;">10</td>
<td style="text-align:center;">prod()</td>
<td>Product of Values</td>
</tr>
<tr>
<td style="text-align:center;">11</td>
<td style="text-align:center;">cumsum()</td>
<td>Cumulative Sum</td>
</tr>
<tr>
<td style="text-align:center;">12</td>
<td style="text-align:center;">cumprod()</td>
<td>Cumulative Product</td>
</tr>
</table>
<p><b>Note</b> &minus; Since DataFrame is a Heterogeneous data structure. Generic operations don’t work with all functions.</p>
<ul class="list">
<li><p>Functions like <b>sum(), cumsum()</b> work with both numeric and character (or) string data elements without any error. Though <b>n</b> practice, character aggregations are never used generally, these functions do not throw any exception.</p></li>
<li><p>Functions like <b>abs(), cumprod()</b> throw exception when the DataFrame contains character or string data because such operations cannot be performed.</p></li>
</ul>
<h2>Summarizing Data</h2>
<p>The <b>describe()</b> function computes a summary of statistics pertaining to the DataFrame columns.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df.describe()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
               Age         Rating
count    12.000000      12.000000
mean     31.833333       3.743333
std       9.232682       0.661628
min      23.000000       2.560000
25%      25.000000       3.230000
50%      29.500000       3.790000
75%      35.500000       4.132500
max      51.000000       4.800000
</pre>
<p>This function gives the <b>mean, std</b> and <b>IQR</b> values. And, function excludes the character columns and given summary about numeric columns. <b>'include'</b> is the argument which is used to pass necessary information regarding what columns need to be considered for summarizing. Takes the list of values; by default, 'number'.</p>
<ul class="list">
<li><b>object</b> &minus; Summarizes String columns</li>
<li><b>number</b> &minus; Summarizes Numeric columns</li>
<li><b>all</b> &minus; Summarizes all columns together (Should not pass it as a list value)</li>
</ul>
<p>Now, use the following statement in the program and check the output &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df.describe(include=['object'])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
          Name
count       12
unique      12
top      Ricky
freq         1
</pre>
<p>Now, use the following statement and check the output &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

#Create a Dictionary of series
d = {'Name':pd.Series(['Tom','James','Ricky','Vin','Steve','Smith','Jack',
   'Lee','David','Gasper','Betina','Andres']),
   'Age':pd.Series([25,26,25,23,30,29,23,34,40,30,51,46]),
   'Rating':pd.Series([4.23,3.24,3.98,2.56,3.20,4.6,3.8,3.78,2.98,4.80,4.10,3.65])}

#Create a DataFrame
df = pd.DataFrame(d)
print df. describe(include='all')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
          Age          Name       Rating
count   12.000000        12    12.000000
unique        NaN        12          NaN
top           NaN     Ricky          NaN
freq          NaN         1          NaN
mean    31.833333       NaN     3.743333
std      9.232682       NaN     0.661628
min     23.000000       NaN     2.560000
25%     25.000000       NaN     3.230000
50%     29.500000       NaN     3.790000
75%     35.500000       NaN     4.132500
max     51.000000       NaN     4.800000
</pre>
<h1>Python Pandas - Function Application</h1>
<p>To apply your own or another library’s functions to Pandas objects, you should be aware of the three important methods. The methods have been discussed below. The appropriate method to use depends on whether your function expects to operate on an entire DataFrame, row- or column-wise, or element wise.</p>
<ul class="list">
<li>Table wise Function Application: pipe()</li>
<li>Row or Column Wise Function Application: apply()</li>
<li>Element wise Function Application: applymap()</li>
</ul>
<h2>Table-wise Function Application</h2>
<p>Custom operations can be performed by passing the function and the appropriate number of parameters as pipe arguments. Thus, operation is performed on the whole DataFrame.</p>
<p>For example, add a value 2 to all the elements in the DataFrame. Then,</p>
<h3>adder function</h3>
<p>The adder function adds two numeric values as parameters and returns the sum.</p>
<pre class="result notranslate">
def adder(ele1,ele2):
return ele1+ele2
</pre>
<p>We will now use the custom function to conduct operation on the DataFrame.</p>
<pre class="result notranslate">
df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])
df.pipe(adder,2)
</pre>
<p>Let’s see the full program &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

def adder(ele1,ele2):
   return ele1+ele2

df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])
df.pipe(adder,2)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
        col1       col2       col3
0   2.176704   2.219691   1.509360
1   2.222378   2.422167   3.953921
2   2.241096   1.135424   2.696432
3   2.355763   0.376672   1.182570
4   2.308743   2.714767   2.130288
</pre>
<h2>Row or Column Wise Function Application</h2>
<p>Arbitrary functions can be applied along the axes of a DataFrame or Panel using the <b>apply()</b> method, which, like the descriptive statistics methods, takes an optional axis argument. By default, the operation performs column wise, taking each column as an array-like.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])
df.apply(np.mean)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      col1       col2        col3                                                      
0   0.343569  -1.013287    1.131245 

1   0.508922  -0.949778   -1.600569 

2  -1.182331  -0.420703   -1.725400

3   0.860265   2.069038   -0.537648

4   0.876758  -0.238051    0.473992
</pre>
<p>By passing <b>axis</b> parameter, operations can be performed row wise.</p>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])
df.apply(np.mean,axis=1)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
     col1         col2         col3
	
0  0.543255    -1.613418    -0.500731   
           
1  0.976543    -1.135835    -0.719153   
                
2  0.184282    -0.721153    -2.876206    
              
3  0.447738     0.268062    -1.937888
                
4 -0.677673     0.177455     1.397360  
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])
df.apply(lambda x: x.max() - x.min())
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
       col1        col2      col3
                                                   
0   -0.585206   -0.104938   1.424115 
                                   
1   -0.326036   -1.444798   0.196849 
                                              
2   -2.033478    1.682253   1.223152  
                                            
3   -0.107015    0.499846   0.084127
         
4   -1.046964   -1.935617  -0.009919
</pre>
<h2>Element Wise Function Application</h2>
<p>Not all functions can be vectorized (neither the NumPy arrays which return another array nor any value), the methods <b>applymap()</b> on DataFrame and <b>analogously map()</b> on Series accept any Python function taking a single value and returning a single value.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])

# My custom function
df['col1'].map(lambda x:x*100)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
<pre class="result notranslate">
       col1      col2       col3    
		
0    0.629348  0.088467  -1.790702 
                                               
1   -0.592595  0.184113  -1.524998

2   -0.419298  0.262369  -0.178849

3   -1.036930  1.103169   0.941882 

4   -0.573333 -0.031056   0.315590
</pre>
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

# My custom function
df = pd.DataFrame(np.random.randn(5,3),columns=['col1','col2','col3'])
df.applymap(lambda x:x*100)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
output is as follows:
         col1         col2         col3
0   17.670426    21.969052    -49.064031
1   22.237846    42.216693     195.392124
2   24.109576   -86.457646     69.643171
3   35.576312   -162.332803   -81.743023
4   30.874333    71.476717     13.028751
</pre>
<h1>Python Pandas - Reindexing</h1>
<p><b>Reindexing</b> changes the row labels and column labels of a DataFrame. To reindex means to conform the data to match a given set of labels along a particular axis.</p>
<p>Multiple operations can be accomplished through indexing like &minus;</p>
<ul class="list">
<li><p>Reorder the existing data to match a new set of labels.</p></li>
<li><p>Insert missing value (NA) markers in label locations where no data for the label existed.</p></li>
</ul>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

N=20

df = pd.DataFrame({
   'A': pd.date_range(start='2016-01-01',periods=N,freq='D'),
   'x': np.linspace(0,stop=N-1,num=N),
   'y': np.random.rand(N),
   'C': np.random.choice(['Low','Medium','High'],N).tolist(),
   'D': np.random.normal(100, 10, size=(N)).tolist()
})

#reindex the DataFrame
df_reindexed = df.reindex(index=[0,2,5], columns=['A', 'C', 'B'])

print df_reindexed
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
            A    C     B
0  2016-01-01  Low   NaN
2  2016-01-03  High  NaN
5  2016-01-06  Low   NaN
</pre>
<h2>Reindex to Align with Other Objects</h2>
<p>You may wish to take an object and reindex its axes to be labeled the same as another object. Consider the following example to understand the same.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df1 = pd.DataFrame(np.random.randn(10,3),columns=['col1','col2','col3'])
df2 = pd.DataFrame(np.random.randn(7,3),columns=['col1','col2','col3'])

df1 = df1.reindex_like(df2)
print df1
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
          col1         col2         col3
0    -2.467652    -1.211687    -0.391761
1    -0.287396     0.522350     0.562512
2    -0.255409    -0.483250     1.866258
3    -1.150467    -0.646493    -0.222462
4     0.152768    -2.056643     1.877233
5    -1.155997     1.528719    -1.343719
6    -1.015606    -1.245936    -0.295275
</pre>
<p><b>Note</b> &minus; Here, the <b>df1</b> DataFrame is altered and reindexed like <b>df2</b>. The column names should be matched or else NAN will be added for the entire column label.</p>
<h2>Filling while ReIndexing</h2>
<p><b>reindex()</b> takes an optional parameter method which is a filling method with values as
follows &minus;</p>
<ul class="list">
<li><p><b>pad/ffill</b> &minus; Fill values forward</p></li>
<li><p><b>bfill/backfill</b> &minus; Fill values backward</p></li>
<li><p><b>nearest</b> &minus; Fill from the nearest index values</p></li>
</ul>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df1 = pd.DataFrame(np.random.randn(6,3),columns=['col1','col2','col3'])
df2 = pd.DataFrame(np.random.randn(2,3),columns=['col1','col2','col3'])

# Padding NAN's
print df2.reindex_like(df1)

# Now Fill the NAN's with preceding Values
print ("Data Frame with Forward Fill:")
print df2.reindex_like(df1,method='ffill')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         col1        col2       col3
0    1.311620   -0.707176   0.599863
1   -0.423455   -0.700265   1.133371
2         NaN         NaN        NaN
3         NaN         NaN        NaN
4         NaN         NaN        NaN
5         NaN         NaN        NaN

Data Frame with Forward Fill:
         col1        col2        col3
0    1.311620   -0.707176    0.599863
1   -0.423455   -0.700265    1.133371
2   -0.423455   -0.700265    1.133371
3   -0.423455   -0.700265    1.133371
4   -0.423455   -0.700265    1.133371
5   -0.423455   -0.700265    1.133371
</pre>
<p><b>Note</b> &minus; The last four rows are padded.</p>
<h2>Limits on Filling while Reindexing</h2>
<p>The limit argument provides additional control over filling while reindexing. Limit specifies the maximum count of consecutive matches. Let us consider the following example to understand the same &minus;</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
df1 = pd.DataFrame(np.random.randn(6,3),columns=['col1','col2','col3'])
df2 = pd.DataFrame(np.random.randn(2,3),columns=['col1','col2','col3'])

# Padding NAN's
print df2.reindex_like(df1)

# Now Fill the NAN's with preceding Values
print ("Data Frame with Forward Fill limiting to 1:")
print df2.reindex_like(df1,method='ffill',limit=1)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         col1        col2        col3
0    0.247784    2.128727    0.702576
1   -0.055713   -0.021732   -0.174577
2         NaN         NaN         NaN
3         NaN         NaN         NaN
4         NaN         NaN         NaN
5         NaN         NaN         NaN

Data Frame with Forward Fill limiting to 1:
         col1        col2        col3
0    0.247784    2.128727    0.702576
1   -0.055713   -0.021732   -0.174577
2   -0.055713   -0.021732   -0.174577
3         NaN         NaN         NaN
4         NaN         NaN         NaN
5         NaN         NaN         NaN
</pre>
<p><b>Note</b> &minus; Observe, only the 7th row is filled by the preceding 6th row. Then, the rows are left as they are.</p>
<h2>Renaming</h2>
<p>The rename() method allows you to relabel an axis based on some mapping (a dict or Series) or an arbitrary function.</p>
<p>Let us consider the following example to understand this &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df1 = pd.DataFrame(np.random.randn(6,3),columns=['col1','col2','col3'])
print df1

print ("After renaming the rows and columns:")
print df1.rename(columns={'col1' : 'c1', 'col2' : 'c2'},
index = {0 : 'apple', 1 : 'banana', 2 : 'durian'})
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         col1        col2        col3
0    0.486791    0.105759    1.540122
1   -0.990237    1.007885   -0.217896
2   -0.483855   -1.645027   -1.194113
3   -0.122316    0.566277   -0.366028
4   -0.231524   -0.721172   -0.112007
5    0.438810    0.000225    0.435479

After renaming the rows and columns:
                c1          c2        col3
apple     0.486791    0.105759    1.540122
banana   -0.990237    1.007885   -0.217896
durian   -0.483855   -1.645027   -1.194113
3        -0.122316    0.566277   -0.366028
4        -0.231524   -0.721172   -0.112007
5         0.438810    0.000225    0.435479
</pre>
<p>The rename() method provides an <b>inplace</b> named parameter, which by default is False and copies the underlying data. Pass <b>inplace=True</b> to rename the data in place.</p>
<h1>Python Pandas - Iteration</h1>
<p>The behavior of basic iteration over Pandas objects depends on the type. When iterating over a Series, it is regarded as array-like, and basic iteration produces the values. Other data structures, like DataFrame and Panel, follow the <b>dict-like</b> convention of iterating over the <b>keys</b> of the objects.</p>
<p>In short, basic iteration (for <b>i</b> in object) produces &minus;</p>
<ul class="list">
<li><p><b>Series</b> &minus; values</p></li>
<li><p><b>DataFrame</b> &minus; column labels</p></li>
<li><p><b>Panel</b> &minus; item labels</p></li>
</ul> 
<h2>Iterating a DataFrame</h2>
<p>Iterating a DataFrame gives column names. Let us consider the following example to understand the same.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
N=20

df = pd.DataFrame({
    'A': pd.date_range(start='2016-01-01',periods=N,freq='D'),
    'x': np.linspace(0,stop=N-1,num=N),
    'y': np.random.rand(N),
    'C': np.random.choice(['Low','Medium','High'],N).tolist(),
    'D': np.random.normal(100, 10, size=(N)).tolist()
    })

for col in df:
   print col
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
A
C
D
x
y
</pre>
<p>To iterate over the rows of the DataFrame, we can use the following functions &minus;</p>
<ul class="list">
<li><p><b>iteritems()</b> &minus; to iterate over the (key,value) pairs</p></li>
<li><p><b>iterrows()</b> &minus; iterate over the rows as (index,series) pairs</p></li>
<li><p><b>itertuples()</b> &minus; iterate over the rows as namedtuples</p></li>
</ul>
<h2>iteritems()</h2>
<p>Iterates over each column as key, value pair with label as key and column value as a Series object.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
df = pd.DataFrame(np.random.randn(4,3),columns = ['col1','col2','col3'])
for key,value in df.iteritems():
   print key,value
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
col1 0    0.802390
1    0.324060
2    0.256811
3    0.839186
Name: col1, dtype: float64

col2 0    1.624313
1   -1.033582
2    1.796663
3    1.856277
Name: col2, dtype: float64

col3 0   -0.022142
1   -0.230820
2    1.160691
3   -0.830279
Name: col3, dtype: float64
</pre>
<p>Observe, each column is iterated separately as a key-value pair in a Series.</p>
<h2>iterrows()</h2>
<p>iterrows() returns the iterator yielding each index value along with a series containing the data in each row.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df=pd.DataFrame(np.random.randn(4,3),columns=['col1','col2','col3'])
for row_index,row in df.iterrows():
   print row_index,row
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  col1    1.529759
   col2    0.762811
   col3   -0.634691
Name: 0, dtype: float64

1  col1   -0.944087
   col2    1.420919
   col3   -0.507895
Name: 1, dtype: float64
 
2  col1   -0.077287
   col2   -0.858556
   col3   -0.663385
Name: 2, dtype: float64
3  col1    -1.638578
   col2     0.059866
   col3     0.493482
Name: 3, dtype: float64
</pre>
<p><b>Note</b> &minus; Because <b>iterrows()</b> iterate over the rows, it doesn't preserve the data type across the row. 0,1,2 are the row indices and col1,col2,col3 are column indices.</p>
<h2>itertuples()</h2>
<p>itertuples() method will return an iterator yielding a named tuple for each row in the DataFrame. The first element of the tuple will be the row’s corresponding index value, while the remaining values are the row values.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(4,3),columns = ['col1','col2','col3'])
for row in df.itertuples():
   print row
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Pandas(Index=0, col1=1.5297586201375899, col2=0.76281127433814944, col3=-
0.6346908238310438)

Pandas(Index=1, col1=-0.94408735763808649, col2=1.4209186418359423, col3=-
0.50789517967096232)

Pandas(Index=2, col1=-0.07728664756791935, col2=-0.85855574139699076, col3=-
0.6633852507207626)

Pandas(Index=3, col1=0.65734942534106289, col2=-0.95057710432604969,
col3=0.80344487462316527)
</pre>
<p><b>Note</b> &minus; Do not try to modify any object while iterating. Iterating is meant for reading and the iterator returns a copy of the original object (a view), thus the changes will not reflect on the original object.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(4,3),columns = ['col1','col2','col3'])

for index, row in df.iterrows():
   row['a'] = 10
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
        col1       col2       col3
0  -1.739815   0.735595  -0.295589
1   0.635485   0.106803   1.527922
2  -0.939064   0.547095   0.038585
3  -1.016509  -0.116580  -0.523158
</pre>
<p>Observe, no changes reflected.</p>
<h1>Python Pandas - Sorting</h1>
<p>There are two kinds of sorting available in Pandas. They are &minus;</p>
<ul class="list">
<li>By label</li>
<li>By Actual Value</li>
</ul>
<p>Let us consider an example with an output.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

unsorted_df=pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu
mns=['col2','col1'])
print unsorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
        col2       col1
1  -2.063177   0.537527
4   0.142932  -0.684884
6   0.012667  -0.389340
2  -0.548797   1.848743
3  -1.044160   0.837381
5   0.385605   1.300185
9   1.031425  -1.002967
8  -0.407374  -0.435142
0   2.237453  -1.067139
7  -1.445831  -1.701035
</pre>
<p>In <b>unsorted_df</b>, the <b>labels</b> and the <b>values</b> are unsorted. Let us see how these can be sorted.</p>
<h2>By Label</h2>
<p>Using the <b>sort_index()</b> method, by passing the axis arguments and the order of sorting, DataFrame can be sorted. By default, sorting is done on row labels in ascending order.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

unsorted_df = pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu
   mns = ['col2','col1'])

sorted_df=unsorted_df.sort_index()
print sorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
        col2       col1
0   0.208464   0.627037
1   0.641004   0.331352
2  -0.038067  -0.464730
3  -0.638456  -0.021466
4   0.014646  -0.737438
5  -0.290761  -1.669827
6  -0.797303  -0.018737
7   0.525753   1.628921
8  -0.567031   0.775951
9   0.060724  -0.322425
</pre>
<h3>Order of Sorting</h3>
<p>By passing the Boolean value to ascending parameter, the order of the sorting can be controlled. Let us consider the following example to understand the same.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

unsorted_df = pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu
   mns = ['col2','col1'])

sorted_df = unsorted_df.sort_index(ascending=False)
print sorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         col2        col1
9    0.825697    0.374463
8   -1.699509    0.510373
7   -0.581378    0.622958
6   -0.202951    0.954300
5   -1.289321   -1.551250
4    1.302561    0.851385
3   -0.157915   -0.388659
2   -1.222295    0.166609
1    0.584890   -0.291048
0    0.668444   -0.061294
</pre>
<h3>Sort the Columns</h3>
<p>By passing the axis argument with a value 0 or 1, the sorting can be done on the column labels. By default, axis=0, sort by row. Let us consider the following example to understand the same.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np
 
unsorted_df = pd.DataFrame(np.random.randn(10,2),index=[1,4,6,2,3,5,9,8,0,7],colu
   mns = ['col2','col1'])
 
sorted_df=unsorted_df.sort_index(axis=1)

print sorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         col1        col2
1   -0.291048    0.584890
4    0.851385    1.302561
6    0.954300   -0.202951
2    0.166609   -1.222295
3   -0.388659   -0.157915
5   -1.551250   -1.289321
9    0.374463    0.825697
8    0.510373   -1.699509
0   -0.061294    0.668444
7    0.622958   -0.581378
</pre>
<h3>By Value</h3>
<p>Like index sorting, <b>sort_values()</b> is the method for sorting by values. It accepts a 'by' argument which will use the column name of the DataFrame with which the values are to be sorted.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

unsorted_df = pd.DataFrame({'col1':[2,1,1,1],'col2':[1,3,2,4]})
sorted_df = unsorted_df.sort_values(by='col1')

print sorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   col1  col2
1    1    3
2    1    2
3    1    4
0    2    1
</pre>
<p>Observe, col1 values are sorted and the respective col2 value and row index will alter along with col1. Thus, they look unsorted.</p>
<p><b>'by'</b> argument takes a list of column values.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

unsorted_df = pd.DataFrame({'col1':[2,1,1,1],'col2':[1,3,2,4]})
   sorted_df = unsorted_df.sort_values(by=['col1','col2'])

print sorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
  col1 col2
2   1   2
1   1   3
3   1   4
0   2   1
</pre>
<h2>Sorting Algorithm</h2>
<p><b>sort_values()</b> provides a provision to choose the algorithm from mergesort, heapsort and quicksort. Mergesort is the only stable algorithm.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

unsorted_df = pd.DataFrame({'col1':[2,1,1,1],'col2':[1,3,2,4]})
sorted_df = unsorted_df.sort_values(by='col1' ,kind='mergesort')

print sorted_df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
  col1 col2
1    1    3
2    1    2
3    1    4
0    2    1
</pre>
<h1>Python Pandas - Working with Text Data</h1>
<p>In this chapter, we will discuss the string operations with our basic Series/Index. In the subsequent chapters, we will learn how to apply these string functions on the DataFrame.</p>
<p>Pandas provides a set of string functions which make it easy to operate on string data. Most importantly, these functions ignore (or exclude) missing/NaN values.</p>
<p>Almost, all of these methods work with Python string functions (refer: <a rel="nofollow" target="_blank" href="https://docs.python.org/3/library/stdtypes.html#string-methods">https://docs.python.org/3/library/stdtypes.html#string-methods</a>). So, convert the Series Object to String Object and then perform the operation.</p>
<p>Let us now see how each operation performs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Function</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">1</td>
<td style="text-align:center;">lower()</td>
<td>Converts strings in the Series/Index to lower case.</td>
</tr>
<tr>
<td style="text-align:center;">2</td>
<td style="text-align:center;">upper()</td>
<td>Converts strings in the Series/Index to upper case.</td>
</tr>
<tr>
<td style="text-align:center;">3</td>
<td style="text-align:center;">len()</td>
<td>Computes String length().</td>
</tr>
<tr>
<td style="text-align:center;">4</td>
<td style="text-align:center;">strip()</td>
<td>Helps strip whitespace(including newline) from each string in the Series/index from both the sides.</td>
</tr>
<tr>
<td style="text-align:center;">5</td>
<td style="text-align:center;">split(' ')</td>
<td>Splits each string with the given pattern.</td>
</tr>
<tr>
<td style="text-align:center;">6</td>
<td style="text-align:center;">cat(sep=' ')</td>
<td>Concatenates the series/index elements with given separator.</td>
</tr>
<tr>
<td style="text-align:center;">7</td>
<td style="text-align:center;">get_dummies()</td>
<td>Returns the DataFrame with One-Hot Encoded values.</td>
</tr>
<tr>
<td style="text-align:center;">8</td>
<td style="text-align:center;">contains(pattern)</td>
<td>Returns a Boolean value True for each element if the substring contains in the element, else False.</td>
</tr>
<tr>
<td style="text-align:center;">9</td>
<td style="text-align:center;">replace(a,b)</td>
<td>Replaces the value <b>a</b> with the value <b>b</b>.</td>
</tr>
<tr>
<td style="text-align:center;">10</td>
<td style="text-align:center;">repeat(value)</td>
<td>Repeats each element with specified number of times.</td>
</tr>
<tr>
<td style="text-align:center;">11</td>
<td style="text-align:center;">count(pattern)</td>
<td>Returns count of appearance of pattern in each element.</td>
</tr>
<tr>
<td style="text-align:center;">12</td>
<td style="text-align:center;">startswith(pattern)</td>
<td>Returns true if the element in the Series/Index starts with the pattern.</td>
</tr>
<tr>
<td style="text-align:center;">13</td>
<td style="text-align:center;">endswith(pattern)</td>
<td>Returns true if the element in the Series/Index ends with the pattern.</td>
</tr>
<tr>
<td style="text-align:center;">14</td>
<td style="text-align:center;">find(pattern)</td>
<td>Returns the first position of the first occurrence of the pattern.</td>
</tr>
<tr>
<td style="text-align:center;">15</td>
<td style="text-align:center;">findall(pattern)</td>
<td>Returns a list of all occurrence of the pattern.</td>
</tr>
<tr>
<td style="text-align:center;">16</td>
<td style="text-align:center;">swapcase</td>
<td>Swaps the case lower/upper.</td>
</tr>
<tr>
<td style="text-align:center;">17</td>
<td style="text-align:center;">islower()</td>
<td>Checks whether all characters in each string in the Series/Index in lower case or not. Returns Boolean</td>
</tr>
<tr>
<td style="text-align:center;">18</td>
<td style="text-align:center;">isupper()</td>
<td>Checks whether all characters in each string in the Series/Index in upper case or not. Returns Boolean.</td>
</tr>
<tr>
<td style="text-align:center;">19</td>
<td style="text-align:center;">isnumeric()</td>
<td>Checks whether all characters in each string in the
Series/Index are numeric. Returns Boolean.</td>
</tr>
</table>
<p>Let us now create a Series and see how all the above functions work.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])

print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0            Tom
1   William Rick
2           John
3        Alber@t
4            NaN
5           1234
6    Steve Smith
dtype: object
</pre>
<h3>lower()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])

print s.str.lower()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0            tom
1   william rick
2           john
3        alber@t
4            NaN
5           1234
6    steve smith
dtype: object
</pre>
<h3>upper()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])

print s.str.upper()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0            TOM
1   WILLIAM RICK
2           JOHN
3        ALBER@T
4            NaN
5           1234
6    STEVE SMITH
dtype: object
</pre>
<h3>len()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t', np.nan, '1234','SteveSmith'])
print s.str.len()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0    3.0
1   12.0
2    4.0
3    7.0
4    NaN
5    4.0
6   10.0
dtype: float64
</pre>
<h3>strip()</h3>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np
s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])
print s
print ("After Stripping:")
print s.str.strip()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0            Tom
1   William Rick
2           John
3        Alber@t
dtype: object

After Stripping:
0            Tom
1   William Rick
2           John
3        Alber@t
dtype: object
</pre>
<h3>split(pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])
print s
print ("Split Pattern:")
print s.str.split(' ')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0            Tom
1   William Rick
2           John
3        Alber@t
dtype: object

Split Pattern:
0   [Tom, , , , , , , , , , ]
1   [, , , , , William, Rick]
2   [John]
3   [Alber@t]
dtype: object
</pre>
<h3>cat(sep=pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print s.str.cat(sep='_')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Tom _ William Rick_John_Alber@t
</pre>
<h3>get_dummies()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print s.str.get_dummies()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   William Rick   Alber@t   John   Tom
0             0         0      0     1
1             1         0      0     0
2             0         0      1     0
3             0         1      0     0
</pre>
<h3>contains ()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])
print s.str.contains(' ')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   True
1   True
2   False
3   False
dtype: bool
</pre>
<h3>replace(a,b)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])
print s
print ("After replacing @ with $:")
print s.str.replace('@','$')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   Tom
1   William Rick
2   John
3   Alber@t
dtype: object

After replacing @ with $:
0   Tom
1   William Rick
2   John
3   Alber$t
dtype: object
</pre>
<h3>repeat(value)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print s.str.repeat(2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   Tom            Tom
1   William Rick   William Rick
2                  JohnJohn
3                  Alber@tAlber@t
dtype: object
</pre>
<h3>count(pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
 
s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print ("The number of 'm's in each string:")
print s.str.count('m')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
The number of 'm's in each string:
0    1
1    1
2    0
3    0
</pre>
<h3>startswith(pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print ("Strings that start with 'T':")
print s.str. startswith ('T')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  True
1  False
2  False
3  False
dtype: bool
</pre>
<h3>endswith(pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])
print ("Strings that end with 't':")
print s.str.endswith('t')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Strings that end with 't':
0  False
1  False
2  False
3  True
dtype: bool
</pre>
<h3>find(pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print s.str.find('e')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  -1
1  -1
2  -1
3   3
dtype: int64
</pre>
<p>"-1" indicates that there no such pattern available in the element.</p>
<h3>findall(pattern)</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom ', ' William Rick', 'John', 'Alber@t'])

print s.str.findall('e')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0 []
1 []
2 []
3 [e]
dtype: object
</pre>
<p>Null list([ ]) indicates that there is no such pattern available in the element.</p>
<h3>swapcase()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t'])
print s.str.swapcase()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  tOM
1  wILLIAM rICK
2  jOHN
3  aLBER@T
dtype: object
</pre>
<h3>islower()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t'])
print s.str.islower()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  False
1  False
2  False
3  False
dtype: bool
</pre>
<h3>isupper()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t'])

print s.str.isupper()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  False
1  False
2  False
3  False
dtype: bool
</pre>
<h3>isnumeric()</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(['Tom', 'William Rick', 'John', 'Alber@t'])

print s.str.isnumeric()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  False
1  False
2  False
3  False
dtype: bool
</pre>
<h1>Python Pandas - Options and Customization</h1>
<p>Pandas provide API to customize some aspects of its behavior, display is being mostly used.</p>
<p>The API is composed of five relevant functions. They are &minus;</p>
<ul class="list">
<li>get_option()</li>
<li>set_option()</li>
<li>reset_option()</li>
<li>describe_option()</li>
<li>option_context()</li>
</ul>
<p>Let us now understand how the functions operate.</p>
<h2>get_option(param)</h2>
<p>get_option takes a single parameter and returns the value as given in the output below &minus;</p>
<h3>display.max_rows</h3>
<p>Displays the default number of value. Interpreter reads this value and displays the rows with this value as upper limit to display.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.get_option("display.max_rows")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
60
</pre>
<h3>display.max_columns</h3>
<p>Displays the default number of value. Interpreter reads this value and displays the rows with this value as upper limit to display.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.get_option("display.max_columns")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
20
</pre>
<p>Here, 60 and 20 are the default configuration parameter values.</p>
<h2>set_option(param,value)</h2>
<p>set_option takes two arguments and sets the value to the parameter as shown below &minus;</p>
<h3>display.max_rows</h3>
<p>Using <b>set_option()</b>, we can change the default number of rows to be displayed.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

pd.set_option("display.max_rows",80)

print pd.get_option("display.max_rows")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
80
</pre>
<h3>display.max_rows</h3>
<p>Using <b>set_option()</b>, we can change the default number of rows to be displayed.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

pd.set_option("display.max_columns",30)

print pd.get_option("display.max_columns")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
30
</pre>
<h2>reset_option(param)</h2>
<p><b>reset_option</b> takes an argument and sets the value back to the default value.</p>
<h3>display.max_rows</h3>
<p>Using reset_option(), we can change the value back to the default number of rows to be displayed.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

pd.reset_option("display.max_rows")
print pd.get_option("display.max_rows")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
60
</pre>
<h2>describe_option(param)</h2>
<p><b>describe_option</b>  prints the description of the argument.</p>
<h3>display.max_rows</h3>
<p>Using reset_option(), we can change the value back to the default number of rows to be displayed.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
pd.describe_option("display.max_rows")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
display.max_rows : int
   If max_rows is exceeded, switch to truncate view. Depending on
   'large_repr', objects are either centrally truncated or printed as
   a summary view. 'None' value means unlimited.

   In case python/IPython is running in a terminal and `large_repr`
   equals 'truncate' this can be set to 0 and pandas will auto-detect
   the height of the terminal and print a truncated object which fits
   the screen height. The IPython notebook, IPython qtconsole, or
   IDLE do not run in a terminal and hence it is not possible to do
   correct auto-detection.
   [default: 60] [currently: 60]
</pre>
<h2>option_context()</h2>
<p>option_context context manager is used to set the option in <b>with statement</b> temporarily. Option values are restored automatically when you exit the <b>with block</b> &minus;</p>
<h3>display.max_rows</h3>
<p>Using option_context(), we can set the value temporarily.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
with pd.option_context("display.max_rows",10):
   print(pd.get_option("display.max_rows"))
   print(pd.get_option("display.max_rows"))
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
10
10
</pre>
<p>See, the difference between the first and the second print statements. The first statement prints the value set by <b>option_context()</b> which is temporary within the <b>with context</b> itself. After the <b>with context</b>, the second print statement prints the configured value.</p>
<h3>Frequently used Parameters</h3>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Parameter</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td>1</td>
<td>display.max_rows</td>
<td>Displays maximum number of rows to display</td>
</tr>
<tr>
<td>2</td>
<td>2 display.max_columns</td>
<td>Displays maximum number of columns to display</td>
</tr>
<tr>
<td>3</td>
<td>display.expand_frame_repr</td>
<td>Displays DataFrames to Stretch Pages</td>
</tr>
<tr>
<td>4</td>
<td>display.max_colwidth</td>
<td>Displays maximum column width</td>
</tr>
<tr>
<td>5</td>
<td>display.precision</td>
<td>Displays precision for decimal numbers</td>
</tr>
</table>
<h1>Python Pandas - Indexing and Selecting Data</h1>
<p>In this chapter, we will discuss how to slice and dice the date and generally get the subset of pandas object.</p>
<p>The Python and NumPy indexing operators "[ ]" and attribute operator "." provide quick and easy access to Pandas data structures across a wide range of use cases. However, since the type of the data to be accessed isn’t known in advance, directly using standard operators has some optimization limits. For production code, we recommend that you take advantage of the optimized pandas data access methods explained in this chapter.</p>
<p>Pandas now supports three types of Multi-axes indexing; the three types are mentioned in the following table &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Indexing</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">.loc()</td>
<td>Label based</td>
</tr>
<tr>
<td style="text-align:center;">.iloc()</td>
<td>Integer based</td>
</tr>
<tr>
<td style="text-align:center;">.ix()</td>
<td>Both Label and Integer based</td>
</tr>
</table>
<h2>.loc()</h2>
<p>Pandas provide various methods to have purely <b>label based indexing</b>. When slicing, the start bound is also included. Integers are valid labels, but they refer to the label and not the position.</p>
<p><b>.loc()</b> has multiple access methods like &minus;</p>
<ul class="list">
<li>A single scalar label</li>
<li>A list of labels</li>
<li>A slice object</li>
<li>A Boolean array</li>
</ul>
<p><b>loc</b> takes two single/list/range operator separated by ','. The first one indicates the row and the second one indicates columns.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
#import the pandas library and aliasing as pd
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4),
index = ['a','b','c','d','e','f','g','h'], columns = ['A', 'B', 'C', 'D'])

#select all rows for a specific column
print df.loc[:,'A']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a   0.391548
b  -0.070649
c  -0.317212
d  -2.162406
e   2.202797
f   0.613709
g   1.050559
h   1.122680
Name: A, dtype: float64
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
# import the pandas library and aliasing as pd
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4),
index = ['a','b','c','d','e','f','g','h'], columns = ['A', 'B', 'C', 'D'])

# Select all rows for multiple columns, say list[]
print df.loc[:,['A','C']]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
            A           C
a    0.391548    0.745623
b   -0.070649    1.620406
c   -0.317212    1.448365
d   -2.162406   -0.873557
e    2.202797    0.528067
f    0.613709    0.286414
g    1.050559    0.216526
h    1.122680   -1.621420
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
# import the pandas library and aliasing as pd
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4),
index = ['a','b','c','d','e','f','g','h'], columns = ['A', 'B', 'C', 'D'])

# Select few rows for multiple columns, say list[]
print df.loc[['a','b','f','h'],['A','C']]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A          C
a   0.391548   0.745623
b  -0.070649   1.620406
f   0.613709   0.286414
h   1.122680  -1.621420
</pre>
<h3>Example 4</h3>
<pre class="prettyprint notranslate tryit">
# import the pandas library and aliasing as pd
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4),
index = ['a','b','c','d','e','f','g','h'], columns = ['A', 'B', 'C', 'D'])

# Select range of rows for all columns
print df.loc['a':'h']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
            A           B          C          D
a    0.391548   -0.224297   0.745623   0.054301
b   -0.070649   -0.880130   1.620406   1.419743
c   -0.317212   -1.929698   1.448365   0.616899
d   -2.162406    0.614256  -0.873557   1.093958
e    2.202797   -2.315915   0.528067   0.612482
f    0.613709   -0.157674   0.286414  -0.500517
g    1.050559   -2.272099   0.216526   0.928449
h    1.122680    0.324368  -1.621420  -0.741470
</pre>
<h3>Example 5</h3>
<pre class="prettyprint notranslate tryit">
# import the pandas library and aliasing as pd
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4),
index = ['a','b','c','d','e','f','g','h'], columns = ['A', 'B', 'C', 'D'])

# for getting values with a boolean array
print df.loc['a']>0
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
A  False
B  True
C  False
D  False
Name: a, dtype: bool
</pre>
<h2>.iloc()</h2>
<p>Pandas provide various methods in order to get purely integer based indexing. Like python and numpy, these are <b>0-based</b> indexing.</p>
<p>The various access methods are as follows &minus;</p>
<ul class="list">
<li>An Integer</li>
<li>A list of integers</li>
<li>A range of values</li>
</ul>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
# import the pandas library and aliasing as pd
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])

# select all rows for a specific column
print df.iloc[:4]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A          B           C           D
0   0.699435   0.256239   -1.270702   -0.645195
1  -0.685354   0.890791   -0.813012    0.631615
2  -0.783192  -0.531378    0.025070    0.230806
3   0.539042  -1.284314    0.826977   -0.026251
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])

# Integer slicing
print df.iloc[:4]
print df.iloc[1:5, 2:4]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A          B           C           D
0   0.699435   0.256239   -1.270702   -0.645195
1  -0.685354   0.890791   -0.813012    0.631615
2  -0.783192  -0.531378    0.025070    0.230806
3   0.539042  -1.284314    0.826977   -0.026251

           C          D
1  -0.813012   0.631615
2   0.025070   0.230806
3   0.826977  -0.026251
4   1.423332   1.130568
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])

# Slicing through list of values
print df.iloc[[1, 3, 5], [1, 3]]
print df.iloc[1:3, :]
print df.iloc[:,1:3]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           B           D
1   0.890791    0.631615
3  -1.284314   -0.026251
5  -0.512888   -0.518930

           A           B           C           D
1  -0.685354    0.890791   -0.813012    0.631615
2  -0.783192   -0.531378    0.025070    0.230806

           B           C
0   0.256239   -1.270702
1   0.890791   -0.813012
2  -0.531378    0.025070
3  -1.284314    0.826977
4  -0.460729    1.423332
5  -0.512888    0.581409
6  -1.204853    0.098060
7  -0.947857    0.641358
</pre>
<h2>.ix()</h2>
<p>Besides pure label based and integer based, Pandas provides a hybrid method for selections and subsetting the object using the .ix() operator.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])

# Integer slicing
print df.ix[:4]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A          B           C           D
0   0.699435   0.256239   -1.270702   -0.645195
1  -0.685354   0.890791   -0.813012    0.631615
2  -0.783192  -0.531378    0.025070    0.230806
3   0.539042  -1.284314    0.826977   -0.026251
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])
# Index slicing
print df.ix[:,'A']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   0.699435
1  -0.685354
2  -0.783192
3   0.539042
4  -1.044209
5  -1.415411
6   1.062095
7   0.994204
Name: A, dtype: float64
</pre>
<h2>Use of Notations</h2>
<p>Getting values from the Pandas object with Multi-axes indexing uses the following notation &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Object</th>
<th style="text-align:center;">Indexers</th>
<th style="text-align:center;">Return Type</th>
</tr>
<tr>
<td>Series</td>
<td>s.loc[indexer]</td>
<td>Scalar value</td>
</tr>
<tr>
<td>DataFrame</td>
<td>df.loc[row_index,col_index]</td>
<td>Series object</td>
</tr>
<tr>
<td>Panel</td>
<td>p.loc[item_index,major_index,
minor_index]</td>
<td>p.loc[item_index,major_index,
minor_index]</td>
</tr>
</table>
<p><b>Note &minus; .iloc() &amp; .ix()</b> applies the same indexing options and Return value.</p>
<p>Let us now see how each operation can be performed on the DataFrame object. We will use the basic indexing operator '[ ]' &minus;</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])
print df['A']
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  -0.478893
1   0.391931
2   0.336825
3  -1.055102
4  -0.165218
5  -0.328641
6   0.567721
7  -0.759399
Name: A, dtype: float64
</pre>
<p><b>Note</b> &minus; We can pass a list of values to [ ] to select those columns.</p>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])

print df[['A','B']]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A           B
0  -0.478893   -0.606311
1   0.391931   -0.949025
2   0.336825    0.093717
3  -1.055102   -0.012944
4  -0.165218    1.550310
5  -0.328641   -0.226363
6   0.567721   -0.312585
7  -0.759399   -0.372696
</pre>
<h3>Example 3</h3>
<pre class="prettyprint notranslate ">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])
print df[2:2]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Columns: [A, B, C, D]
Index: []
</pre>
<h3>Attribute Access</h3>
<p>Columns can be selected using the attribute operator '.'.</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(8, 4), columns = ['A', 'B', 'C', 'D'])

print df.A
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   -0.478893
1    0.391931
2    0.336825
3   -1.055102
4   -0.165218
5   -0.328641
6    0.567721
7   -0.759399
Name: A, dtype: float64
</pre>
<h1>Python Pandas - Statistical Functions</h1>
<p>Statistical methods help in the understanding and analyzing the behavior of data. We will now learn a few statistical functions, which we can apply on Pandas objects.</p>
<h2>Percent_change</h2>
<p>Series, DatFrames and Panel, all have the function <b>pct_change()</b>. This function compares every element with its prior element and computes the change percentage.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
s = pd.Series([1,2,3,4,5,4])
print s.pct_change()

df = pd.DataFrame(np.random.randn(5, 2))
print df.pct_change()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0        NaN
1   1.000000
2   0.500000
3   0.333333
4   0.250000
5  -0.200000
dtype: float64

            0          1
0         NaN        NaN
1  -15.151902   0.174730
2  -0.746374   -1.449088
3  -3.582229   -3.165836
4   15.601150  -1.860434
</pre>
<p>By default, the <b>pct_change()</b> operates on columns; if you want to apply the same row wise, then use <b>axis=1()</b> argument.</p>
<h2>Covariance</h2>
<p>Covariance is applied on series data. The Series object has a method cov to compute covariance between series objects. NA will be excluded automatically.</p>
<h3>Cov Series</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
s1 = pd.Series(np.random.randn(10))
s2 = pd.Series(np.random.randn(10))
print s1.cov(s2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
-0.12978405324
</pre>
<p>Covariance method when applied on a DataFrame, computes <b>cov</b> between all the columns.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
frame = pd.DataFrame(np.random.randn(10, 5), columns=['a', 'b', 'c', 'd', 'e'])
print frame['a'].cov(frame['b'])
print frame.cov()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
-0.58312921152741437

           a           b           c           d            e
a   1.780628   -0.583129   -0.185575    0.003679    -0.136558
b  -0.583129    1.297011    0.136530   -0.523719     0.251064
c  -0.185575    0.136530    0.915227   -0.053881    -0.058926
d   0.003679   -0.523719   -0.053881    1.521426    -0.487694
e  -0.136558    0.251064   -0.058926   -0.487694     0.960761
</pre>
<p><b>Note</b> &minus; Observe the <b>cov</b> between <b>a</b> and <b>b</b> column in the first statement and the same is the value returned by cov on DataFrame.</p>
<h2>Correlation</h2>
<p>Correlation shows the linear relationship between any two array of values (series). There are multiple methods to compute the correlation like pearson(default), spearman and kendall.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
frame = pd.DataFrame(np.random.randn(10, 5), columns=['a', 'b', 'c', 'd', 'e'])

print frame['a'].corr(frame['b'])

print frame.corr()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
-0.383712785514

           a          b          c          d           e
a   1.000000  -0.383713  -0.145368   0.002235   -0.104405
b  -0.383713   1.000000   0.125311  -0.372821    0.224908
c  -0.145368   0.125311   1.000000  -0.045661   -0.062840
d   0.002235  -0.372821  -0.045661   1.000000   -0.403380
e  -0.104405   0.224908  -0.062840  -0.403380    1.000000
</pre>
<p>If any non-numeric column is present in the DataFrame, it is excluded automatically.</p>
<h2>Data Ranking</h2>
<p>Data Ranking produces ranking for each element in the array of elements. In case of ties, assigns the mean rank.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
s = pd.Series(np.random.np.random.randn(5), index=list('abcde'))

s['d'] = s['b'] # so there's a tie

print s.rank()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a  1.0
b  3.5
c  2.0
d  3.5
e  5.0
dtype: float64
</pre>
<p>Rank optionally takes a parameter ascending which by default is true; when false, data is reverse-ranked, with larger values assigned a smaller rank.</p>
<p>Rank supports different tie-breaking methods, specified with the method parameter &minus;</p>
<ul class="list">
<li><p><b>average</b> &minus; average rank of tied group</p></li>
<li><p><b>min</b> &minus; lowest rank in the group</p></li>
<li><p><b>max</b> &minus; highest rank in the group</p></li>
<li><p><b>first</b> &minus; ranks assigned in the order they appear in the array</p></li>
</ul>
<h1>Python Pandas - Window Functions</h1>
<p>For working on numerical data, Pandas provide few variants like rolling, expanding and exponentially moving weights for window statistics. Among these are <b>sum, mean, median, variance, covariance, correlation,</b> etc.</p>
<p>We will now learn how each of these can be applied on DataFrame objects.</p>
<h2>.rolling() Function</h2>
<p>This function can be applied on a series of data. Specify the <b>window=n</b> argument and apply the appropriate statistical function on top of it.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
index = pd.date_range('1/1/2000', periods=10),
columns = ['A', 'B', 'C', 'D'])

print df.rolling(window=3).mean()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                    A           B           C           D
2000-01-01        NaN         NaN         NaN         NaN
2000-01-02        NaN         NaN         NaN         NaN
2000-01-03   0.434553   -0.667940   -1.051718   -0.826452
2000-01-04   0.628267   -0.047040   -0.287467   -0.161110
2000-01-05   0.398233    0.003517    0.099126   -0.405565
2000-01-06   0.641798    0.656184   -0.322728    0.428015
2000-01-07   0.188403    0.010913   -0.708645    0.160932
2000-01-08   0.188043   -0.253039   -0.818125   -0.108485
2000-01-09   0.682819   -0.606846   -0.178411   -0.404127
2000-01-10   0.688583    0.127786    0.513832   -1.067156
</pre>
<p><b>Note</b> &minus; Since the window size is 3, for first two elements there are nulls and from third the value will be the average of the <b>n</b>, <b>n-1</b> and <b>n-2</b> elements. Thus we can also apply various functions as mentioned above.</p>
<h2>.expanding() Function</h2>
<p>This function can be applied on a series of data. Specify the <b>min_periods=n</b> argument and apply the appropriate statistical function on top of it.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])
print df.expanding(min_periods=3).mean()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                   A           B           C           D
2000-01-01        NaN         NaN         NaN         NaN
2000-01-02        NaN         NaN         NaN         NaN
2000-01-03   0.434553   -0.667940   -1.051718   -0.826452
2000-01-04   0.743328   -0.198015   -0.852462   -0.262547
2000-01-05   0.614776   -0.205649   -0.583641   -0.303254
2000-01-06   0.538175   -0.005878   -0.687223   -0.199219
2000-01-07   0.505503   -0.108475   -0.790826   -0.081056
2000-01-08   0.454751   -0.223420   -0.671572   -0.230215
2000-01-09   0.586390   -0.206201   -0.517619   -0.267521
2000-01-10   0.560427   -0.037597   -0.399429   -0.376886
</pre>
<h2>.ewm() Function</h2>
<p><b>ewm</b> is applied on a series of data. Specify any of the com, span, <b>halflife</b> argument and apply the appropriate statistical function on top of it. It assigns the weights exponentially.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
df = pd.DataFrame(np.random.randn(10, 4),
   index = pd.date_range('1/1/2000', periods=10),
   columns = ['A', 'B', 'C', 'D'])
print df.ewm(com=0.5).mean()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                    A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   0.865131   -0.453626   -1.137961    0.058747
2000-01-03  -0.132245   -0.807671   -0.308308   -1.491002
2000-01-04   1.084036    0.555444   -0.272119    0.480111
2000-01-05   0.425682    0.025511    0.239162   -0.153290
2000-01-06   0.245094    0.671373   -0.725025    0.163310
2000-01-07   0.288030   -0.259337   -1.183515    0.473191
2000-01-08   0.162317   -0.771884   -0.285564   -0.692001
2000-01-09   1.147156   -0.302900    0.380851   -0.607976
2000-01-10   0.600216    0.885614    0.569808   -1.110113
</pre>
<p>Window functions are majorly used in finding the trends within the data graphically by smoothing the curve. If there is lot of variation in the everyday data and a lot of data points are available, then taking the samples and plotting is one method and applying the window computations and plotting the graph on the results is another method. By these methods, we can smooth the curve or the trend.</p>
<h1>Python Pandas - Aggregations</h1>
<p>Once the rolling, expanding and <b>ewm</b> objects are created, several methods are available to perform aggregations on data.</p>
<h2>Applying Aggregations on DataFrame</h2>
<p>Let us create a DataFrame and apply aggregations on it.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])

print df

r = df.rolling(window=3,min_periods=1)
print r
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                    A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   0.790670   -0.387854   -0.668132    0.267283
2000-01-03  -0.575523   -0.965025    0.060427   -2.179780
2000-01-04   1.669653    1.211759   -0.254695    1.429166
2000-01-05   0.100568   -0.236184    0.491646   -0.466081
2000-01-06   0.155172    0.992975   -1.205134    0.320958
2000-01-07   0.309468   -0.724053   -1.412446    0.627919
2000-01-08   0.099489   -1.028040    0.163206   -1.274331
2000-01-09   1.639500   -0.068443    0.714008   -0.565969
2000-01-10   0.326761    1.479841    0.664282   -1.361169

Rolling [window=3,min_periods=1,center=False,axis=0]                
</pre>
<p>We can aggregate by passing a function to the entire DataFrame, or select a column via the standard <b>get item</b> method.</p>
<h3>Apply Aggregation on a Whole Dataframe</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])
print df

r = df.rolling(window=3,min_periods=1)
print r.aggregate(np.sum)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                    A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   1.879182   -1.038796   -3.215581   -0.299575
2000-01-03   1.303660   -2.003821   -3.155154   -2.479355
2000-01-04   1.884801   -0.141119   -0.862400   -0.483331
2000-01-05   1.194699    0.010551    0.297378   -1.216695
2000-01-06   1.925393    1.968551   -0.968183    1.284044
2000-01-07   0.565208    0.032738   -2.125934    0.482797
2000-01-08   0.564129   -0.759118   -2.454374   -0.325454
2000-01-09   2.048458   -1.820537   -0.535232   -1.212381
2000-01-10   2.065750    0.383357    1.541496   -3.201469

                    A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   1.879182   -1.038796   -3.215581   -0.299575
2000-01-03   1.303660   -2.003821   -3.155154   -2.479355
2000-01-04   1.884801   -0.141119   -0.862400   -0.483331
2000-01-05   1.194699    0.010551    0.297378   -1.216695
2000-01-06   1.925393    1.968551   -0.968183    1.284044
2000-01-07   0.565208    0.032738   -2.125934    0.482797
2000-01-08   0.564129   -0.759118   -2.454374   -0.325454
2000-01-09   2.048458   -1.820537   -0.535232   -1.212381
2000-01-10   2.065750    0.383357    1.541496   -3.201469

</pre>
<h3>Apply Aggregation on a Single Column of a Dataframe</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])
print df
r = df.rolling(window=3,min_periods=1)
print r['A'].aggregate(np.sum)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                 A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   1.879182   -1.038796   -3.215581   -0.299575
2000-01-03   1.303660   -2.003821   -3.155154   -2.479355
2000-01-04   1.884801   -0.141119   -0.862400   -0.483331
2000-01-05   1.194699    0.010551    0.297378   -1.216695
2000-01-06   1.925393    1.968551   -0.968183    1.284044
2000-01-07   0.565208    0.032738   -2.125934    0.482797
2000-01-08   0.564129   -0.759118   -2.454374   -0.325454
2000-01-09   2.048458   -1.820537   -0.535232   -1.212381
2000-01-10   2.065750    0.383357    1.541496   -3.201469
2000-01-01   1.088512
2000-01-02   1.879182
2000-01-03   1.303660
2000-01-04   1.884801
2000-01-05   1.194699
2000-01-06   1.925393
2000-01-07   0.565208
2000-01-08   0.564129
2000-01-09   2.048458
2000-01-10   2.065750
Freq: D, Name: A, dtype: float64
</pre>
<h3>Apply Aggregation on Multiple Columns of a DataFrame</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])
print df
r = df.rolling(window=3,min_periods=1)
print r[['A','B']].aggregate(np.sum)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                 A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   1.879182   -1.038796   -3.215581   -0.299575
2000-01-03   1.303660   -2.003821   -3.155154   -2.479355
2000-01-04   1.884801   -0.141119   -0.862400   -0.483331
2000-01-05   1.194699    0.010551    0.297378   -1.216695
2000-01-06   1.925393    1.968551   -0.968183    1.284044
2000-01-07   0.565208    0.032738   -2.125934    0.482797
2000-01-08   0.564129   -0.759118   -2.454374   -0.325454
2000-01-09   2.048458   -1.820537   -0.535232   -1.212381
2000-01-10   2.065750    0.383357    1.541496   -3.201469

                    A           B
2000-01-01   1.088512   -0.650942
2000-01-02   1.879182   -1.038796
2000-01-03   1.303660   -2.003821
2000-01-04   1.884801   -0.141119
2000-01-05   1.194699    0.010551
2000-01-06   1.925393    1.968551
2000-01-07   0.565208    0.032738
2000-01-08   0.564129   -0.759118
2000-01-09   2.048458   -1.820537
2000-01-10   2.065750    0.383357
</pre>
<h3>Apply Multiple Functions on a Single Column of a DataFrame</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])
print df

r = df.rolling(window=3,min_periods=1)
print r['A'].aggregate([np.sum,np.mean])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                 A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   1.879182   -1.038796   -3.215581   -0.299575
2000-01-03   1.303660   -2.003821   -3.155154   -2.479355
2000-01-04   1.884801   -0.141119   -0.862400   -0.483331
2000-01-05   1.194699    0.010551    0.297378   -1.216695
2000-01-06   1.925393    1.968551   -0.968183    1.284044
2000-01-07   0.565208    0.032738   -2.125934    0.482797
2000-01-08   0.564129   -0.759118   -2.454374   -0.325454
2000-01-09   2.048458   -1.820537   -0.535232   -1.212381
2000-01-10   2.065750    0.383357    1.541496   -3.201469
                  sum       mean
2000-01-01   1.088512   1.088512
2000-01-02   1.879182   0.939591
2000-01-03   1.303660   0.434553
2000-01-04   1.884801   0.628267
2000-01-05   1.194699   0.398233
2000-01-06   1.925393   0.641798
2000-01-07   0.565208   0.188403
2000-01-08   0.564129   0.188043
2000-01-09   2.048458   0.682819
2000-01-10   2.065750   0.688583
</pre>
<h3>Apply Multiple Functions on Multiple Columns of a DataFrame</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10, 4),
      index = pd.date_range('1/1/2000', periods=10),
      columns = ['A', 'B', 'C', 'D'])

print df
r = df.rolling(window=3,min_periods=1)
print r[['A','B']].aggregate([np.sum,np.mean])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                 A           B           C           D
2000-01-01   1.088512   -0.650942   -2.547450   -0.566858
2000-01-02   1.879182   -1.038796   -3.215581   -0.299575
2000-01-03   1.303660   -2.003821   -3.155154   -2.479355
2000-01-04   1.884801   -0.141119   -0.862400   -0.483331
2000-01-05   1.194699    0.010551    0.297378   -1.216695
2000-01-06   1.925393    1.968551   -0.968183    1.284044
2000-01-07   0.565208    0.032738   -2.125934    0.482797
2000-01-08   0.564129   -0.759118   -2.454374   -0.325454
2000-01-09   2.048458   -1.820537   -0.535232   -1.212381
2000-01-10   2.065750    0.383357    1.541496   -3.201469
                    A                      B
                  sum       mean         sum        mean
2000-01-01   1.088512   1.088512   -0.650942   -0.650942
2000-01-02   1.879182   0.939591   -1.038796   -0.519398
2000-01-03   1.303660   0.434553   -2.003821   -0.667940
2000-01-04   1.884801   0.628267   -0.141119   -0.047040
2000-01-05   1.194699   0.398233    0.010551    0.003517
2000-01-06   1.925393   0.641798    1.968551    0.656184
2000-01-07   0.565208   0.188403    0.032738    0.010913
2000-01-08   0.564129   0.188043   -0.759118   -0.253039
2000-01-09   2.048458   0.682819   -1.820537   -0.606846
2000-01-10   2.065750   0.688583    0.383357    0.127786
</pre>
<h3>Apply Different Functions to Different Columns of a Dataframe</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
df = pd.DataFrame(np.random.randn(3, 4),
      index = pd.date_range('1/1/2000', periods=3),
      columns = ['A', 'B', 'C', 'D'])
print df

r = df.rolling(window=3,min_periods=1)
print r.aggregate({'A' : np.sum,'B' : np.mean})
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
                    A          B          C         D
2000-01-01  -1.575749  -1.018105   0.317797  0.545081
2000-01-02  -0.164917  -1.361068   0.258240  1.113091
2000-01-03   1.258111   1.037941  -0.047487  0.867371
                    A          B
2000-01-01  -1.575749  -1.018105
2000-01-02  -1.740666  -1.189587
2000-01-03  -0.482555  -0.447078
</pre>
<h1>Python Pandas - Missing Data</h1>
<p>Missing data is always a problem in real life scenarios. Areas like machine learning and data mining face severe issues in the accuracy of their model predictions because of poor quality of data caused by missing values. In these areas, missing value treatment is a major point of focus to make their models more accurate and valid.</p>
<h2>When and Why Is Data Missed?</h2>
<p>Let us consider an online survey for a product. Many a times, people do not share all the information related to them. Few people share their experience, but not how long they are using the product; few people share how long they are using the product, their experience but not their contact information. Thus, in some or the other way a part of data is always missing, and this is very common in real time.</p>
<p>Let us now see how we can handle missing values (say NA or NaN) using Pandas.</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])

print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         one        two      three
a   0.077988   0.476149   0.965836
b        NaN        NaN        NaN
c  -0.390208  -0.551605  -2.301950
d        NaN        NaN        NaN
e  -2.000303  -0.788201   1.510072
f  -0.930230  -0.670473   1.146615
g        NaN        NaN        NaN
h   0.085100   0.532791   0.887415
</pre>
<p>Using reindexing, we have created a DataFrame with missing values. In the output, <b>NaN</b> means <b>Not a Number.</b></p>
<h3>Check for Missing Values</h3>
<p>To make detecting missing values easier (and across different array dtypes), Pandas provides the <b>isnull()</b> and <b>notnull()</b> functions, which are also methods on Series and DataFrame objects &minus;</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
 
df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])

print df['one'].isnull()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a  False
b  True
c  False
d  True
e  False
f  False
g  True
h  False
Name: one, dtype: bool
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])

print df['one'].notnull()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
a  True
b  False
c  True
d  False
e  True
f  True
g  False
h  True
Name: one, dtype: bool
</pre>
<h3>Calculations with Missing Data</h3>
<ul class="list">
<li>When summing data, NA will be treated as Zero</li>
<li>If the data are all NA, then the result will be NA</li>
</ul>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])

print df['one'].sum()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2.02357685917
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(index=[0,1,2,3,4,5],columns=['one','two'])
print df['one'].sum()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
nan
</pre>
<h2>Cleaning / Filling Missing Data</h2>
<p>Pandas provides various methods for cleaning the missing values. The fillna function can “fill in” NA values with non-null data in a couple of ways, which we have illustrated in the following sections.</p>
<h2>Replace NaN with a Scalar Value</h2>
<p>The following program shows how you can replace "NaN" with "0".</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(3, 3), index=['a', 'c', 'e'],columns=['one',
'two', 'three'])
df = df.reindex(['a', 'b', 'c'])
print df
print ("NaN replaced with '0':")
print df.fillna(0)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         one        two     three
a  -0.576991  -0.741695  0.553172
b        NaN        NaN       NaN
c   0.744328  -1.735166  1.749580

NaN replaced with '0':
         one        two     three
a  -0.576991  -0.741695  0.553172
b   0.000000   0.000000  0.000000
c   0.744328  -1.735166  1.749580
</pre>
<p>Here, we are filling with value zero; instead we can also fill with any other value.</p>
<h2>Fill NA Forward and Backward</h2>
<p>Using the concepts of filling discussed in the ReIndexing Chapter we will fill the missing values.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Method</th>
<th style="text-align:center;">Action</th>
</tr>
<tr>
<td>pad/fill</td>
<td>Fill methods Forward</td>
</tr>
<tr>
<td>bfill/backfill</td>
<td>Fill methods Backward</td>
</tr>
</table>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])
df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])

print df.fillna(method='pad')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         one        two      three
a   0.077988   0.476149   0.965836
b   0.077988   0.476149   0.965836
c  -0.390208  -0.551605  -2.301950
d  -0.390208  -0.551605  -2.301950
e  -2.000303  -0.788201   1.510072
f  -0.930230  -0.670473   1.146615
g  -0.930230  -0.670473   1.146615
h   0.085100   0.532791   0.887415
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])
print df.fillna(method='backfill')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         one        two      three
a   0.077988   0.476149   0.965836
b  -0.390208  -0.551605  -2.301950
c  -0.390208  -0.551605  -2.301950
d  -2.000303  -0.788201   1.510072
e  -2.000303  -0.788201   1.510072
f  -0.930230  -0.670473   1.146615
g   0.085100   0.532791   0.887415
h   0.085100   0.532791   0.887415
</pre>
<h2>Drop Missing Values</h2>
<p>If you want to simply exclude the missing values, then use the <b>dropna</b> function along with the <b>axis</b> argument. By default, axis=0, i.e., along row, which means that if any value within a row is NA then the whole row is excluded.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])
print df.dropna()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         one        two      three
a   0.077988   0.476149   0.965836
c  -0.390208  -0.551605  -2.301950
e  -2.000303  -0.788201   1.510072
f  -0.930230  -0.670473   1.146615
h   0.085100   0.532791   0.887415
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(5, 3), index=['a', 'c', 'e', 'f',
'h'],columns=['one', 'two', 'three'])

df = df.reindex(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])
print df.dropna(axis=1)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Empty DataFrame
Columns: [ ]
Index: [a, b, c, d, e, f, g, h]
</pre>
<h2>Replace Missing (or) Generic Values</h2>
<p>Many times, we have to replace a generic value with some specific value. We can achieve this by applying the replace method.</p>
<p>Replacing NA with a scalar value is equivalent behavior of the <b>fillna()</b> function.</p>
<h3>Example 1</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame({'one':[10,20,30,40,50,2000],
'two':[1000,0,30,40,50,60]})
print df.replace({1000:10,2000:60})
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   one  two
0   10   10
1   20    0
2   30   30
3   40   40
4   50   50
5   60   60
</pre>
<h3>Example 2</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame({'one':[10,20,30,40,50,2000],
'two':[1000,0,30,40,50,60]})
print df.replace({1000:10,2000:60})
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   one  two
0   10   10
1   20    0
2   30   30
3   40   40
4   50   50
5   60   60
</pre>
<h1>Python Pandas - GroupBy</h1>
<p>Any <b>groupby</b> operation involves one of the following operations on the original object. They are &minus;</p>
<ul class="list">
<li><p><b>Splitting</b> the Object</p></li>
<li><p><b>Applying</b> a function</p></li>
<li><p><b>Combining</b> the results</p></li>
</ul>
<p>In many situations, we split the data into sets and we apply some functionality on each subset. In the apply functionality, we can perform the following operations &minus;</p>
<ul class="list">
<li><p><b>Aggregation</b> &minus; computing a summary statistic</p></li>
<li><p><b>Transformation</b> &minus; perform some group-specific operation</p></li>
<li><p><b>Filtration</b> &minus; discarding the data with some condition</p></li>
</ul>
<p>Let us now create a DataFrame object and perform all the operations on it &minus;</p>
<pre class="prettyprint notranslate tryit">
#import the pandas library
import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Points   Rank     Team   Year
0      876      1   Riders   2014
1      789      2   Riders   2015
2      863      2   Devils   2014
3      673      3   Devils   2015
4      741      3    Kings   2014
5      812      4    kings   2015
6      756      1    Kings   2016
7      788      1    Kings   2017
8      694      2   Riders   2016
9      701      4   Royals   2014
10     804      1   Royals   2015
11     690      2   Riders   2017
</pre>
<h2>Split Data into Groups</h2>
<p>Pandas object can be split into any of their objects. There are multiple ways to split an
object like &minus;</p>
<ul class="list">
<li>obj.groupby('key')</li>
<li>obj.groupby(['key1','key2'])</li>
<li>obj.groupby(key,axis=1)</li>
</ul>
<p>Let us now see how the grouping objects can be applied to the DataFrame object</p>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

print df.groupby('Team')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
&lt;pandas.core.groupby.DataFrameGroupBy object at 0x7fa46a977e50&gt;
</pre>
<h2>View Groups</h2>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],           'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

print df.groupby('Team').groups
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
{'Kings': Int64Index([4, 6, 7],      dtype='int64'),
'Devils': Int64Index([2, 3],         dtype='int64'),
'Riders': Int64Index([0, 1, 8, 11],  dtype='int64'),
'Royals': Int64Index([9, 10],        dtype='int64'),
'kings' : Int64Index([5],            dtype='int64')}
</pre>
<h3>Example</h3>
<p><b>Group by</b> with multiple columns &minus;</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)
print df.groupby(['Team','Year']).groups
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
{('Kings', 2014): Int64Index([4], dtype='int64'),
 ('Royals', 2014): Int64Index([9], dtype='int64'),
 ('Riders', 2014): Int64Index([0], dtype='int64'),
 ('Riders', 2015): Int64Index([1], dtype='int64'),
 ('Kings', 2016): Int64Index([6], dtype='int64'),
 ('Riders', 2016): Int64Index([8], dtype='int64'),
 ('Riders', 2017): Int64Index([11], dtype='int64'),
 ('Devils', 2014): Int64Index([2], dtype='int64'),
 ('Devils', 2015): Int64Index([3], dtype='int64'),
 ('kings', 2015): Int64Index([5], dtype='int64'),
 ('Royals', 2015): Int64Index([10], dtype='int64'),
 ('Kings', 2017): Int64Index([7], dtype='int64')}
</pre>
<h2>Iterating through Groups</h2>
<p>With the <b>groupby</b> object in hand, we can iterate through the object similar to itertools.obj.</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Year')

for name,group in grouped:
    print name
    print group
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2014
   Points  Rank     Team   Year
0     876     1   Riders   2014
2     863     2   Devils   2014
4     741     3   Kings    2014
9     701     4   Royals   2014

2015
   Points  Rank     Team   Year
1     789     2   Riders   2015
3     673     3   Devils   2015
5     812     4    kings   2015
10    804     1   Royals   2015

2016
   Points  Rank     Team   Year
6     756     1    Kings   2016
8     694     2   Riders   2016

2017
   Points  Rank    Team   Year
7     788     1   Kings   2017
11    690     2  Riders   2017
</pre>
<p>By default, the <b>groupby</b> object has the same label name as the group name.</p>
<h2>Select a Group</h2>
<p>Using the <b>get_group()</b> method, we can select a single group.</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Year')
print grouped.get_group(2014)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   Points  Rank     Team    Year
0     876     1   Riders    2014
2     863     2   Devils    2014
4     741     3   Kings     2014
9     701     4   Royals    2014
</pre>
<h2>Aggregations</h2>
<p>An aggregated function returns a single aggregated value for each group. Once the <b>group by</b> object is created, several aggregation operations can be performed on the grouped data.</p>
<p>An obvious one is aggregation via the aggregate or equivalent <b>agg</b> method &minus;</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Year')
print grouped['Points'].agg(np.mean)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Year
2014   795.25
2015   769.50
2016   725.00
2017   739.00
Name: Points, dtype: float64
</pre>
<p>Another way to see the size of each group is by applying the size() function &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)
grouped = df.groupby('Team')
print grouped.agg(np.size)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
         Points   Rank   Year
Team
Devils        2      2      2
Kings         3      3      3
Riders        4      4      4
Royals        2      2      2
kings         1      1      1
</pre>
<h3>Applying Multiple Aggregation Functions at Once</h3>
<p>With grouped Series, you can also pass a <b>list</b> or <b>dict of functions</b> to do aggregation with, and generate DataFrame as output &minus;</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Team')
print grouped['Points'].agg([np.sum, np.mean, np.std])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Team      sum      mean          std
Devils   1536   768.000000   134.350288
Kings    2285   761.666667    24.006943
Riders   3049   762.250000    88.567771
Royals   1505   752.500000    72.831998
kings     812   812.000000          NaN
</pre>
<h2>Transformations</h2>
<p>Transformation on a group or a column returns an object that is indexed the same size of that is being grouped. Thus, the transform should return a result that is the same size as that of a group chunk.</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
import numpy as np

ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)

grouped = df.groupby('Team')
score = lambda x: (x - x.mean()) / x.std()*10
print grouped.transform(score)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
       Points        Rank        Year
0   12.843272  -15.000000  -11.618950
1   3.020286     5.000000   -3.872983
2   7.071068    -7.071068   -7.071068
3  -7.071068     7.071068    7.071068
4  -8.608621    11.547005  -10.910895
5        NaN          NaN         NaN
6  -2.360428    -5.773503    2.182179
7  10.969049    -5.773503    8.728716
8  -7.705963     5.000000    3.872983
9  -7.071068     7.071068   -7.071068
10  7.071068    -7.071068    7.071068
11 -8.157595     5.000000   11.618950
</pre>
<h2>Filtration</h2>
<p>Filtration filters the data on a defined criteria and returns the subset of data. The <b>filter()</b> function is used to filter the data.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
ipl_data = {'Team': ['Riders', 'Riders', 'Devils', 'Devils', 'Kings',
         'kings', 'Kings', 'Kings', 'Riders', 'Royals', 'Royals', 'Riders'],
         'Rank': [1, 2, 2, 3, 3,4 ,1 ,1,2 , 4,1,2],
         'Year': [2014,2015,2014,2015,2014,2015,2016,2017,2016,2014,2015,2017],
         'Points':[876,789,863,673,741,812,756,788,694,701,804,690]}
df = pd.DataFrame(ipl_data)
print df.groupby('Team').filter(lambda x: len(x) >= 3)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Points  Rank     Team   Year
0      876     1   Riders   2014
1      789     2   Riders   2015
4      741     3   Kings    2014
6      756     1   Kings    2016
7      788     1   Kings    2017
8      694     2   Riders   2016
11     690     2   Riders   2017
</pre>
<p>In the above filter condition, we are asking to return the teams which have participated three or more times in IPL.</p>
<h1>Python Pandas - Merging/Joining</h1>
<p>Pandas has full-featured, high performance in-memory join operations idiomatically very similar to relational databases like SQL.</p>
<p>Pandas provides a single function, <b>merge</b>, as the entry point for all standard database join operations between DataFrame objects &minus;</p>
<pre class="result notranslate">
pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None,
left_index=False, right_index=False, sort=True)
</pre>
<p>Here, we have used the following parameters &minus;</p>
<ul class="list">
<li><p><b>left</b> &minus; A DataFrame object.</p></li>
<li><p><b>right</b> &minus; Another DataFrame object.</p></li>
<li><p><b>on</b> &minus; Columns (names) to join on. Must be found in both the left and right DataFrame
objects.</p></li>
<li><p><b>left_on</b> &minus; Columns from the left DataFrame to use as keys. Can either be column names or arrays with length equal to the length of the DataFrame.</p></li>
<li><p><b>right_on</b> &minus; Columns from the right DataFrame to use as keys. Can either be column names or arrays with length equal to the length of the DataFrame.</p></li>
<li><p><b>left_index</b> &minus; If <b>True,</b> use the index (row labels) from the left DataFrame as its join key(s). In case of a DataFrame with a MultiIndex (hierarchical), the number of levels must match the number of join keys from the right DataFrame.</p></li>
<li><p><b>right_index</b> &minus; Same usage as <b>left_index</b> for the right DataFrame.</p></li>
<li><p><b>how</b> &minus; One of 'left', 'right', 'outer', 'inner'. Defaults to inner. Each method has been described below.</p></li>
<li><p><b>sort</b> &minus; Sort the result DataFrame by the join keys in lexicographical order. Defaults to True, setting to False will improve the performance substantially in many cases.</p></li>
</ul>
<p>Let us now create two different DataFrames and perform the merging operations on it.</p>
<pre class="prettyprint notranslate tryit">
# import the pandas library
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print left
print right
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Name  id   subject_id
0   Alex   1         sub1
1    Amy   2         sub2
2  Allen   3         sub4
3  Alice   4         sub6
4  Ayoung  5         sub5

    Name  id   subject_id
0  Billy   1         sub2
1  Brian   2         sub4
2  Bran    3         sub3
3  Bryce   4         sub6
4  Betty   5         sub5
</pre>
<h3>Merge Two DataFrames on a Key</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print pd.merge(left,right,on='id')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   Name_x   id  subject_id_x   Name_y   subject_id_y
0  Alex      1          sub1    Billy           sub2
1  Amy       2          sub2    Brian           sub4
2  Allen     3          sub4     Bran           sub3
3  Alice     4          sub6    Bryce           sub6
4  Ayoung    5          sub5    Betty           sub5
</pre>
<h3>Merge Two DataFrames on Multiple Keys</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print pd.merge(left,right,on=['id','subject_id'])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Name_x   id   subject_id   Name_y
0    Alice    4         sub6    Bryce
1   Ayoung    5         sub5    Betty
</pre>
<h2>Merge Using 'how' Argument</h2>
<p>The <b>how</b> argument to merge specifies how to determine which keys are to be included in the resulting table. If a key combination does not appear in either the left or the right tables, the values in the joined table will be NA.</p>
<p>Here is a summary of the <b>how</b> options and their SQL equivalent names &minus;</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Merge Method</th>
<th style="text-align:center;">SQL Equivalent</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">left</td>
<td style="text-align:center;">LEFT OUTER JOIN</td>
<td>Use keys from left object</td>
</tr>
<tr>
<td style="text-align:center;">right</td>
<td style="text-align:center;">RIGHT OUTER JOIN</td>
<td>Use keys from right object</td>
</tr>
<tr>
<td style="text-align:center;">outer</td>
<td style="text-align:center;">FULL OUTER JOIN</td>
<td>Use union of keys</td>
</tr>
<tr>
<td style="text-align:center;">inner</td>
<td style="text-align:center;">INNER JOIN</td>
<td>Use intersection of keys</td>
</tr>
</table>
<h3>Left Join</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print pd.merge(left, right, on='subject_id', how='left')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Name_x   id_x   subject_id   Name_y   id_y
0     Alex      1         sub1      NaN    NaN
1      Amy      2         sub2    Billy    1.0
2    Allen      3         sub4    Brian    2.0
3    Alice      4         sub6    Bryce    4.0
4   Ayoung      5         sub5    Betty    5.0
</pre>
<h3>Right Join</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print pd.merge(left, right, on='subject_id', how='right')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Name_x  id_x   subject_id   Name_y   id_y
0      Amy   2.0         sub2    Billy      1
1    Allen   3.0         sub4    Brian      2
2    Alice   4.0         sub6    Bryce      4
3   Ayoung   5.0         sub5    Betty      5
4      NaN   NaN         sub3     Bran      3
</pre>
<h3>Outer Join</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print pd.merge(left, right, how='outer', on='subject_id')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Name_x  id_x   subject_id   Name_y   id_y
0     Alex   1.0         sub1      NaN    NaN
1      Amy   2.0         sub2    Billy    1.0
2    Allen   3.0         sub4    Brian    2.0
3    Alice   4.0         sub6    Bryce    4.0
4   Ayoung   5.0         sub5    Betty    5.0
5      NaN   NaN         sub3     Bran    3.0
</pre>
<h3>Inner Join</h3>
<p>Joining will be performed on index. Join operation honors the object on which it is called.
So, <b>a.join(b)</b> is not equal to <b>b.join(a)</b>.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
left = pd.DataFrame({
         'id':[1,2,3,4,5],
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5']})
right = pd.DataFrame(
         {'id':[1,2,3,4,5],
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5']})
print pd.merge(left, right, on='subject_id', how='inner')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Name_x   id_x   subject_id   Name_y   id_y
0      Amy      2         sub2    Billy      1
1    Allen      3         sub4    Brian      2
2    Alice      4         sub6    Bryce      4
3   Ayoung      5         sub5    Betty      5
</pre>
<h1>Python Pandas - Concatenation</h1>
<p>Pandas provides various facilities for easily combining together <b>Series, DataFrame</b>, and <b>Panel</b> objects.</p>
<pre class="result notranslate">
 pd.concat(objs,axis=0,join='outer',join_axes=None,
ignore_index=False)
</pre>
<ul class="list">
<li><p><b>objs</b> &minus; This is a sequence or mapping of Series, DataFrame, or Panel objects.</p></li>
<li><p><b>axis</b> &minus; {0, 1, ...}, default 0. This is the axis to concatenate along.</p></li>
<li><p><b>join</b> &minus; {‘inner’, ‘outer’}, default ‘outer’. How to handle indexes on other axis(es). Outer for union and inner for intersection.</p></li>
<li><p><b>ignore_index</b> &minus; boolean, default False. If True, do not use the index values on the concatenation axis. The resulting axis will be labeled 0, ..., n - 1.</p></li>
<li><p><b>join_axes</b> &minus; This is the list of Index objects. Specific indexes to use for the other (n-1) axes instead of performing inner/outer set logic.</p></li>
</ul>
<h2>Concatenating Objects</h2>
<p>The <b>concat</b> function does all of the heavy lifting of performing concatenation operations along an axis. Let us create different objects and do concatenation.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
print pd.concat([one,two])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Marks_scored     Name   subject_id
1             98     Alex         sub1
2             90      Amy         sub2
3             87    Allen         sub4
4             69    Alice         sub6
5             78   Ayoung         sub5
1             89    Billy         sub2
2             80    Brian         sub4
3             79     Bran         sub3
4             97    Bryce         sub6
5             88    Betty         sub5
</pre>
<p>Suppose we wanted to associate specific keys with each of the pieces of the chopped up DataFrame. We can do this by using the <b>keys</b> argument &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
print pd.concat([one,two],keys=['x','y'])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
x  1  98    Alex    sub1
   2  90    Amy     sub2
   3  87    Allen   sub4
   4  69    Alice   sub6
   5  78    Ayoung  sub5
y  1  89    Billy   sub2
   2  80    Brian   sub4
   3  79    Bran    sub3
   4  97    Bryce   sub6
   5  88    Betty   sub5
</pre>
<p>The index of the resultant is duplicated; each index is repeated.</p>
<p>If the resultant object has to follow its own indexing, set <b>ignore_index</b> to <b>True</b>.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
print pd.concat([one,two],keys=['x','y'],ignore_index=True)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Marks_scored     Name    subject_id
0             98     Alex          sub1
1             90      Amy          sub2
2             87    Allen          sub4
3             69    Alice          sub6
4             78   Ayoung          sub5
5             89    Billy          sub2
6             80    Brian          sub4
7             79     Bran          sub3
8             97    Bryce          sub6
9             88    Betty          sub5
</pre>
<p>Observe, the index changes completely and the Keys are also overridden.</p>
<p>If two objects need to be added along <b>axis=1</b>, then the new columns will be appended.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
print pd.concat([one,two],axis=1)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Marks_scored    Name  subject_id   Marks_scored    Name   subject_id
1           98      Alex      sub1         89         Billy         sub2
2           90       Amy      sub2         80         Brian         sub4
3           87     Allen      sub4         79          Bran         sub3
4           69     Alice      sub6         97         Bryce         sub6
5           78    Ayoung      sub5         88         Betty         sub5
</pre>
<h3>Concatenating Using append</h3>
<p>A useful shortcut to concat are the append instance methods on Series and DataFrame. These methods actually predated concat. They concatenate along <b>axis=0</b>, namely the index &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
print one.append(two)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Marks_scored    Name  subject_id
1           98      Alex      sub1
2           90       Amy      sub2
3           87     Allen      sub4
4           69     Alice      sub6
5           78    Ayoung      sub5
1           89     Billy      sub2
2           80     Brian      sub4
3           79      Bran      sub3
4           97     Bryce      sub6
5           88     Betty      sub5
</pre>
<p>The <b>append</b> function can take multiple objects as well &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

one = pd.DataFrame({
         'Name': ['Alex', 'Amy', 'Allen', 'Alice', 'Ayoung'],
         'subject_id':['sub1','sub2','sub4','sub6','sub5'],
         'Marks_scored':[98,90,87,69,78]},
         index=[1,2,3,4,5])
            
two = pd.DataFrame({
         'Name': ['Billy', 'Brian', 'Bran', 'Bryce', 'Betty'],
         'subject_id':['sub2','sub4','sub3','sub6','sub5'],
         'Marks_scored':[89,80,79,97,88]},
         index=[1,2,3,4,5])
print one.append([two,one,two])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    Marks_scored   Name    subject_id
1           98     Alex          sub1
2           90      Amy          sub2
3           87    Allen          sub4
4           69    Alice          sub6
5           78   Ayoung          sub5
1           89    Billy          sub2
2           80    Brian          sub4
3           79     Bran          sub3
4           97    Bryce          sub6
5           88    Betty          sub5
1           98     Alex          sub1
2           90      Amy          sub2
3           87    Allen          sub4
4           69    Alice          sub6
5           78   Ayoung          sub5
1           89    Billy          sub2
2           80    Brian          sub4
3           79     Bran          sub3
4           97    Bryce          sub6
5           88    Betty          sub5
</pre>
<h2>Time Series</h2>
<p>Pandas provide a robust tool for working time with Time series data, especially in the financial sector. While working with time series data, we frequently come across the following &minus;</p>
<ul class="list">
<li>Generating sequence of time</li>
<li>Convert the time series to different frequencies</li>
</ul>
<p>Pandas provides a relatively compact and self-contained set of tools for performing the above tasks.</p>
<h3>Get Current Time</h3>
<p><b>datetime.now()</b> gives you the current date and time.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.datetime.now()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2017-05-11 06:10:13.393147
</pre>
<h3>Create a TimeStamp</h3>
<p>Time-stamped data is the most basic type of timeseries data that associates values with points in time. For pandas objects, it means using the points in time. Let’s take an example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.Timestamp('2017-03-01')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2017-03-01 00:00:00
</pre>
<p>It is also possible to convert integer or float epoch times. The default unit for these is nanoseconds (since these are how Timestamps are stored). However, often epochs are stored in another unit which can be specified. Let’s take another example</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.Timestamp(1587687255,unit='s')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2020-04-24 00:14:15
</pre>
<h3>Create a Range of Time</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.date_range("11:00", "13:30", freq="30min").time
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
[datetime.time(11, 0) datetime.time(11, 30) datetime.time(12, 0)
datetime.time(12, 30) datetime.time(13, 0) datetime.time(13, 30)]
</pre>
<h3>Change the Frequency of Time</h3>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.date_range("11:00", "13:30", freq="H").time
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
[datetime.time(11, 0) datetime.time(12, 0) datetime.time(13, 0)]
</pre>
<h3>Converting to Timestamps</h3>
<p>To convert a Series or list-like object of date-like objects, for example strings, epochs, or a mixture, you can use the <b>to_datetime</b> function. When passed, this returns a Series (with the same index), while a <b>list-like</b> is converted to a <b>DatetimeIndex</b>. Take a look at the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.to_datetime(pd.Series(['Jul 31, 2009','2010-01-10', None]))
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  2009-07-31
1  2010-01-10
2         NaT
dtype: datetime64[ns]
</pre>
<p><b>NaT</b> means <b>Not a Time</b> (equivalent to NaN)</p>
<p>Let’s take another example.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.to_datetime(['2005/11/23', '2010.12.31', None])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
DatetimeIndex(['2005-11-23', '2010-12-31', 'NaT'], dtype='datetime64[ns]', freq=None)
</pre>
<h1>Python Pandas - Date Functionality</h1>
<p>Extending the Time series, Date functionalities play major role in financial data analysis. While working with Date data, we will frequently come across the following &minus;</p>
<ul class="list">
<li>Generating sequence of dates</li>
<li>Convert the date series to different frequencies</li>
</ul>
<h2>Create a Range of Dates</h2>
<p>Using the <b>date.range()</b> function by specifying the periods and the frequency, we can create the date series. By default, the frequency of range is Days.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.date_range('1/1/2011', periods=5)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03', '2011-01-04', '2011-01-05'],
dtype='datetime64[ns]', freq='D')
</pre>
<h2>Change the Date Frequency</h2>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.date_range('1/1/2011', periods=5,freq='M')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31', '2011-04-30', '2011-05-31'],
dtype='datetime64[ns]', freq='M')
</pre>
<h2>bdate_range</h2>
<p>bdate_range() stands for business date ranges. Unlike date_range(), it excludes Saturday and Sunday.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.date_range('1/1/2011', periods=5)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03', '2011-01-04', '2011-01-05'],
dtype='datetime64[ns]', freq='D')
</pre>
<p>Observe, after 3rd March, the date jumps to 6th march excluding 4th and 5th. Just check your calendar for the days.</p>
<p>Convenience functions like <b>date_range</b> and <b>bdate_range</b> utilize a variety of frequency aliases. The default frequency for date_range is a calendar day while the default for bdate_range is a business day.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
start = pd.datetime(2011, 1, 1)
end = pd.datetime(2011, 1, 5)
print pd.date_range(start, end)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03', '2011-01-04', '2011-01-05'],
dtype='datetime64[ns]', freq='D')
</pre>
<h2>Offset Aliases</h2>
<p>A number of string aliases are given to useful common time series frequencies. We will refer to these aliases as offset aliases.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Alias</th>
<th style="text-align:center;">Description</th>
<th style="text-align:center;">Alias</th>
<th style="text-align:center;">Description</th>
</tr>
<tr>
<td style="text-align:center;">B</td>
<td>business day frequency</td>
<td style="text-align:center;">BQS</td>
<td>business quarter start frequency</td>
</tr>
<tr>
<td style="text-align:center;">D</td>
<td>calendar day frequency</td>
<td style="text-align:center;">A</td>
<td>annual(Year) end frequency</td>
</tr>
<tr>
<td style="text-align:center;">W</td>
<td>weekly frequency</td>
<td style="text-align:center;">BA</td>
<td>business year end frequency</td>
</tr>
<tr>
<td style="text-align:center;">M</td>
<td>month end frequency</td>
<td style="text-align:center;">BAS</td>
<td>business year start frequency</td>
</tr>
<tr>
<td style="text-align:center;">SM</td>
<td>semi-month end frequency</td>
<td style="text-align:center;">BH</td>
<td>business hour frequency</td>
</tr>
<tr>
<td style="text-align:center;">BM</td>
<td>business month end frequency</td>
<td style="text-align:center;">H</td>
<td>hourly frequency</td>
</tr>
<tr>
<td style="text-align:center;">MS</td>
<td>month start frequency</td>
<td style="text-align:center;">T, min</td>
<td>minutely frequency</td>
</tr>
<tr>
<td style="text-align:center;">SMS</td>
<td>SMS semi month start frequency</td>
<td style="text-align:center;">S</td>
<td>secondly frequency</td>
</tr>
<tr>
<td style="text-align:center;">BMS</td>
<td>business month start frequency</td>
<td style="text-align:center;">L, ms</td>
<td>milliseconds</td>
</tr><tr>
<td style="text-align:center;">Q</td>
<td>quarter end frequency</td>
<td style="text-align:center;">U, us</td>
<td>microseconds</td>
</tr>
<tr>
<td style="text-align:center;">BQ</td>
<td>business quarter end frequency</td>
<td style="text-align:center;">N</td>
<td>nanoseconds</td>
</tr>
<tr>
<td style="text-align:center;">QS</td>
<td>quarter start frequency</td>
<td style="text-align:center;"></td>
<td></td>
</tr>
</table>
<h1>Python Pandas - Timedelta</h1>
<p>Timedeltas are differences in times, expressed in difference units, for example, days, hours, minutes, seconds. They can be both positive and negative.</p>
<p>We can create Timedelta objects using various arguments as shown below &minus;</p>
<h2>String</h2>
<p>By passing a string literal, we can create a timedelta object.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.Timedelta('2 days 2 hours 15 minutes 30 seconds')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2 days 02:15:30
</pre>
<h2>Integer</h2>
<p>By passing an integer value with the unit, an argument creates a Timedelta object.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.Timedelta(6,unit='h')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0 days 06:00:00
</pre>
<h2>Data Offsets</h2>
<p>Data offsets such as - weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds can also be used in construction.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.Timedelta(days=2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2 days 00:00:00
</pre>
<h2>to_timedelta()</h2>
<p>Using the top-level <b>pd.to_timedelta</b>, you can convert a scalar, array, list, or series from a recognized timedelta format/ value into a Timedelta type. It will construct Series if the input is a Series, a scalar if the input is scalar-like, otherwise will output a <b>TimedeltaIndex</b>.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

print pd.Timedelta(days=2)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
2 days 00:00:00
</pre>
<h2>Operations</h2>
<p>You can operate on Series/ DataFrames and construct <b>timedelta64[ns]</b> Series through subtraction operations on <b>datetime64[ns]</b> Series, or Timestamps.</p>
<p>Let us now create a DataFrame with Timedelta and datetime objects and perform some arithmetic operations on it &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(pd.date_range('2012-1-1', periods=3, freq='D'))
td = pd.Series([ pd.Timedelta(days=i) for i in range(3) ])
df = pd.DataFrame(dict(A = s, B = td))
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
            A      B
0  2012-01-01 0 days
1  2012-01-02 1 days
2  2012-01-03 2 days
</pre>
<h2>Addition Operations</h2>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(pd.date_range('2012-1-1', periods=3, freq='D'))
td = pd.Series([ pd.Timedelta(days=i) for i in range(3) ])
df = pd.DataFrame(dict(A = s, B = td))
df['C']=df['A']+df['B']

print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A      B          C
0 2012-01-01 0 days 2012-01-01
1 2012-01-02 1 days 2012-01-03
2 2012-01-03 2 days 2012-01-05
</pre>
<h2>Subtraction Operation</h2>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(pd.date_range('2012-1-1', periods=3, freq='D'))
td = pd.Series([ pd.Timedelta(days=i) for i in range(3) ])
df = pd.DataFrame(dict(A = s, B = td))
df['C']=df['A']+df['B']
df['D']=df['C']+df['B']
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
           A      B          C          D
0 2012-01-01 0 days 2012-01-01 2012-01-01
1 2012-01-02 1 days 2012-01-03 2012-01-04
2 2012-01-03 2 days 2012-01-05 2012-01-07
</pre>
<h1>Python Pandas - Categorical Data</h1>
<p>Often in real-time, data includes the text columns, which are repetitive. Features like gender, country, and codes are always repetitive. These are the examples for categorical data.</p>
<p>Categorical variables can take on only a limited, and usually fixed number of possible values. Besides the fixed length, categorical data might have an order but cannot perform numerical operation. Categorical are a Pandas data type.</p>
<p>The categorical data type is useful in the following cases &minus;</p>
<ul class="list">
<li><p>A string variable consisting of only a few different values. Converting such a string variable to a categorical variable will save some memory.</p></li>
<li><p>The lexical order of a variable is not the same as the logical order (“one”, “two”, “three”). By converting to a categorical and specifying an order on the categories, sorting and min/max will use the logical order instead of the lexical order.</p></li>
<li><p>As a signal to other python libraries that this column should be treated as a categorical variable (e.g. to use suitable statistical methods or plot types).</p></li>
</ul>
<h2>Object Creation</h2>
<p>Categorical object can be created in multiple ways. The different ways have been described below &minus;</p>
<h3>category</h3>
<p>By specifying the dtype as "category" in pandas object creation.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
s = pd.Series(["a","b","c","a"], dtype="category")
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  a
1  b
2  c
3  a
dtype: category
Categories (3, object): [a, b, c]
</pre>
<p>The number of elements passed to the series object is four, but the categories are only three. Observe the same in the output Categories.</p>
<h3>pd.Categorical</h3>
<p>Using the standard pandas Categorical constructor, we can create a category object.</p>
<pre class="result notranslate">
pandas.Categorical(values, categories, ordered)
</pre>
<p>Let’s take an example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
cat = pd.Categorical(['a', 'b', 'c', 'a', 'b', 'c'])
print cat
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
[a, b, c, a, b, c]
Categories (3, object): [a, b, c]
</pre>
<p>Let’s have another example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
cat = cat=pd.Categorical(['a','b','c','a','b','c','d'], ['c', 'b', 'a'])
print cat
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
[a, b, c, a, b, c, NaN]
Categories (3, object): [c, b, a]
</pre>
<p>Here, the second argument signifies the categories. Thus, any value which is not present in the categories will be treated as <b>NaN</b>.</p>
<p>Now, take a look at the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
cat = cat=pd.Categorical(['a','b','c','a','b','c','d'], ['c', 'b', 'a'],ordered=True)
print cat
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
[a, b, c, a, b, c, NaN]
Categories (3, object): [c &lt; b &lt; a]
</pre>
<p>Logically, the order means that, <b>a</b> is greater than <b>b</b> and <b>b</b> is greater than <b>c</b>.</p>
<h3>Description</h3>
<p>Using the <b>.describe()</b> command on the categorical data, we get similar output to a <b>Series</b> or <b>DataFrame</b> of the <b>type</b> string.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

cat = pd.Categorical(["a", "c", "c", np.nan], categories=["b", "a", "c"])
df = pd.DataFrame({"cat":cat, "s":["a", "c", "c", np.nan]})
print df.describe()

print df["cat"].describe()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
       cat s
count    3 3
unique   2 2
top      c c
freq     2 2
count     3
unique    2
top       c
freq      2
Name: cat, dtype: object
</pre>
<h3>Get the Properties of the Category</h3>
<p><b>obj.cat.categories</b> command is used to get the <b>categories of the object</b>.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Categorical(["a", "c", "c", np.nan], categories=["b", "a", "c"])
print s.categories
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Index([u'b', u'a', u'c'], dtype='object')
</pre>
<p><b>obj.ordered</b> command is used to get the order of the object.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

cat = pd.Categorical(["a", "c", "c", np.nan], categories=["b", "a", "c"])
print cat.ordered
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
False
</pre>
<p>The function returned <b>false</b> because we haven't specified any order.</p>
<h3>Renaming Categories</h3>
<p>Renaming categories is done by assigning new values to the <b>series.cat.categories</b>series.cat.categories property.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(["a","b","c","a"], dtype="category")
s.cat.categories = ["Group %s" % g for g in s.cat.categories]

print s.cat.categories
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Index([u'Group a', u'Group b', u'Group c'], dtype='object')
</pre>
<p>Initial categories <b>[a,b,c]</b> are updated by the <b>s.cat.categories</b> property of the object.</p>
<h3>Appending New Categories</h3>
<p>Using the Categorical.add.categories() method, new categories can be appended.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(["a","b","c","a"], dtype="category")
s = s.cat.add_categories([4])
print s.cat.categories
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Index([u'a', u'b', u'c', 4], dtype='object')
</pre>
<h3>Removing Categories</h3>
<p>Using the <b>Categorical.remove_categories()</b> method, unwanted categories can be removed.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(["a","b","c","a"], dtype="category")
print ("Original object:")
print s

print ("After removal:")
print s.cat.remove_categories("a")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
Original object:
0  a
1  b
2  c
3  a
dtype: category
Categories (3, object): [a, b, c]

After removal:
0  NaN
1  b
2  c
3  NaN
dtype: category
Categories (2, object): [b, c]
</pre>
<h3>Comparison of Categorical Data</h3>
<p>Comparing categorical data with other objects is possible in three cases &minus;</p>
<ul class="list">
<li><p>comparing equality (== and !=) to a list-like object (list, Series, array, ...) of the
same length as the categorical data.</p></li>
<li><p>all comparisons (==, !=, &gt;, &gt;=, &lt;, and &lt;=) of categorical data to another
categorical Series, when ordered==True and the categories are the same.</p></li>
<li><p>all comparisons of a categorical data to a scalar.</p></li>
</ul>
<p>Take a look at the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

cat = pd.Series([1,2,3]).astype("category", categories=[1,2,3], ordered=True)
cat1 = pd.Series([2,2,2]).astype("category", categories=[1,2,3], ordered=True)

print cat>cat1
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0  False
1  False
2  True
dtype: bool
</pre>
<h1>Python Pandas - Visualization</h1>
<h3>Basic Plotting: plot</h3>
<p>This functionality on Series and DataFrame is just a simple wrapper around the <b>matplotlib</b> <b>libraries plot()</b> method.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10,4),index=pd.date_range('1/1/2000',
   periods=10), columns=list('ABCD'))

df.plot()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/basic_plotting.jpg" alt="Basic Plotting" />
<p>If the index consists of dates, it calls <b>gct().autofmt_xdate()</b> to format the x-axis as shown in the above illustration.</p>
<p>We can plot one column versus another using the <b>x</b> and <b>y</b> keywords.</p>
<p>Plotting methods allow a handful of plot styles other than the default line plot. These methods can be provided as the kind keyword argument to <b>plot()</b>. These include &minus;</p>
<ul class="list">
<li>bar or barh for bar plots</li>
<li>hist for histogram</li>
<li>box for boxplot</li>
<li>'area' for area plots</li>
<li>'scatter' for scatter plots</li>
</ul>
<h2>Bar Plot</h2>
<p>Let us now see what a Bar Plot is by creating one. A bar plot can be created in the following way &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.rand(10,4),columns=['a','b','c','d')
df.plot.bar()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/bar_plot.jpg" alt="Bar Plot" />
<p>To produce a stacked bar plot, <b>pass stacked=True</b> &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd
df = pd.DataFrame(np.random.rand(10,4),columns=['a','b','c','d')
df.plot.bar(stacked=True)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/stacked_bar_plot.jpg" alt="Stacked Bar Plot" />
<p>To get horizontal bar plots, use the <b>barh</b> method &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.rand(10,4),columns=['a','b','c','d')

df.plot.barh(stacked=True)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/horizontal_bar_plot.jpg" alt="Horizontal Bar Plot" />
<h2>Histograms</h2>
<p>Histograms can be plotted using the <b>plot.hist()</b> method. We can specify number of bins.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df = pd.DataFrame({'a':np.random.randn(1000)+1,'b':np.random.randn(1000),'c':
np.random.randn(1000) - 1}, columns=['a', 'b', 'c'])

df.plot.hist(bins=20)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/histograms_using_plot_hist.jpg" alt="Histograms using plot.hist() " />
<p>To plot different histograms for each column, use the following code &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df=pd.DataFrame({'a':np.random.randn(1000)+1,'b':np.random.randn(1000),'c':
np.random.randn(1000) - 1}, columns=['a', 'b', 'c'])

df.diff.hist(bins=20)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/histograms_for_column.jpg" alt="Histograms for Column " />
<h2>Box Plots</h2>
<p>Boxplot can be drawn calling <b>Series.box.plot()</b> and <b>DataFrame.box.plot()</b>, or <b>DataFrame.boxplot()</b> to visualize the distribution of values within each column.</p>
<p>For instance, here is a boxplot representing five trials of 10 observations of a uniform random variable on [0,1).</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.rand(10, 5), columns=['A', 'B', 'C', 'D', 'E'])
df.plot.box()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/box_plot.jpg" alt="Box Plots" />
<h2>Area Plot</h2>
<p>Area plot can be created using the <b>Series.plot.area()</b> or the <b>DataFrame.plot.area()</b> methods.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.rand(10, 4), columns=['a', 'b', 'c', 'd'])
df.plot.area()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/area_plot.jpg" alt="Area Plot" />
<h2>Scatter Plot</h2>
<p>Scatter plot can be created using the <b>DataFrame.plot.scatter()</b> methods.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.rand(50, 4), columns=['a', 'b', 'c', 'd'])
df.plot.scatter(x='a', y='b')
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/scatter_plot.jpg" alt="Scatter Plot" />
<h2>Pie Chart</h2>
<p>Pie chart can be created using the <b>DataFrame.plot.pie()</b> method.</p>
<pre class="prettyprint notranslate">
import pandas as pd
import numpy as np

df = pd.DataFrame(3 * np.random.rand(4), index=['a', 'b', 'c', 'd'], columns=['x'])
df.plot.pie(subplots=True)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<img src="https://www.tutorialspoint.com/python_pandas/images/pie_chart.jpg" alt="Pie Chart" />
<h1>Python Pandas - IO Tools</h1>
<p>The <b>Pandas I/O API</b> is a set of top level reader functions accessed like <b>pd.read_csv()</b> that generally return a Pandas object.</p>
<p>The two workhorse functions for reading text files (or the flat files) are <b>read_csv()</b> and <b>read_table()</b>. They both use the same parsing code to intelligently convert tabular data into a <b>DataFrame</b> object &minus;</p>
<pre class="result notranslate">
pandas.read_csv(filepath_or_buffer, sep=',', delimiter=None, header='infer',
names=None, index_col=None, usecols=None
</pre>
<p></p>
<pre class="result notranslate">
pandas.read_csv(filepath_or_buffer, sep='\t', delimiter=None, header='infer',
names=None, index_col=None, usecols=None
</pre>
<p>Here is how the <b>csv</b> file data looks like &minus;</p>
<pre class="result notranslate">
S.No,Name,Age,City,Salary
1,Tom,28,Toronto,20000
2,Lee,32,HongKong,3000
3,Steven,43,Bay Area,8300
4,Ram,38,Hyderabad,3900
</pre>
<p>Save this data as <b>temp.csv</b> and conduct operations on it.</p>
<pre class="result notranslate">
S.No,Name,Age,City,Salary
1,Tom,28,Toronto,20000
2,Lee,32,HongKong,3000
3,Steven,43,Bay Area,8300
4,Ram,38,Hyderabad,3900
</pre>
<p>Save this data as <b>temp.csv</b> and conduct operations on it.</p>
<h2>read.csv</h2>
<p><b>read.csv</b> reads data from the csv files and creates a DataFrame object.</p>
<pre class="prettyprint notranslate">
import pandas as pd
df=pd.read_csv("temp.csv")
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   S.No     Name   Age       City   Salary
0     1      Tom    28    Toronto    20000
1     2      Lee    32   HongKong     3000
2     3   Steven    43   Bay Area     8300
3     4      Ram    38  Hyderabad     3900
</pre>
<h3>custom index</h3>
<p>This specifies a column in the csv file to customize the index using <b>index_col.</b></p>
<pre class="prettyprint notranslate">
import pandas as pd

df=pd.read_csv("temp.csv",index_col=['S.No'])
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
S.No   Name   Age       City   Salary
1       Tom    28    Toronto    20000
2       Lee    32   HongKong     3000
3    Steven    43   Bay Area     8300
4       Ram    38  Hyderabad     3900
</pre>
<h3>Converters</h3>
<p><b>dtype</b> of the columns can be passed as a dict.</p>
<pre class="prettyprint notranslate">
import pandas as pd

df = pd.read_csv("temp.csv", dtype={'Salary': np.float64})
print df.dtypes
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
S.No       int64
Name      object
Age        int64
City      object
Salary   float64
dtype: object
</pre>
<p>By default, the <b>dtype</b> of the Salary column is <b>int</b>, but the result shows it as <b>float</b> because we have explicitly casted the type.</p>
<p>Thus, the data looks like float &minus;</p>
<pre class="result notranslate">
  S.No   Name   Age      City    Salary
0   1     Tom   28    Toronto   20000.0
1   2     Lee   32   HongKong    3000.0
2   3  Steven   43   Bay Area    8300.0
3   4     Ram   38  Hyderabad    3900.0
</pre>
<h3>header_names</h3>
<p>Specify the names of the header using the names argument.</p>
<pre class="prettyprint notranslate">
import pandas as pd
 
df=pd.read_csv("temp.csv", names=['a', 'b', 'c','d','e'])
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
       a        b    c           d        e
0   S.No     Name   Age       City   Salary
1      1      Tom   28     Toronto    20000
2      2      Lee   32    HongKong     3000
3      3   Steven   43    Bay Area     8300
4      4      Ram   38   Hyderabad     3900
</pre>
<p>Observe, the header names are appended with the custom names, but the header in the file has not been eliminated. Now, we use the header argument to remove that.</p>
<p>If the header is in a row other than the first, pass the row number to header. This will skip the preceding rows.</p>
<pre class="prettyprint notranslate">
import pandas as pd 

df=pd.read_csv("temp.csv",names=['a','b','c','d','e'],header=0)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
      a        b    c           d        e
0  S.No     Name   Age       City   Salary
1     1      Tom   28     Toronto    20000
2     2      Lee   32    HongKong     3000
3     3   Steven   43    Bay Area     8300
4     4      Ram   38   Hyderabad     3900
</pre>
<h3>skiprows</h3>
<p>skiprows skips the number of rows specified.</p>
<pre class="prettyprint notranslate">
import pandas as pd

df=pd.read_csv("temp.csv", skiprows=2)
print df
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    2      Lee   32    HongKong   3000
0   3   Steven   43    Bay Area   8300
1   4      Ram   38   Hyderabad   3900
</pre>
<h1>Python Pandas - Sparse Data</h1>
<p>Sparse objects are “compressed” when any data matching a specific value (NaN / missing value, though any value can be chosen) is omitted. A special SparseIndex object tracks where data has been “sparsified”. This will make much more sense in an example. All of the standard Pandas data structures apply the <b>to_sparse</b> method &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

ts = pd.Series(np.random.randn(10))
ts[2:-2] = np.nan
sts = ts.to_sparse()
print sts
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   -0.810497
1   -1.419954
2         NaN
3         NaN
4         NaN
5         NaN
6         NaN
7         NaN
8    0.439240
9   -1.095910
dtype: float64
BlockIndex
Block locations: array([0, 8], dtype=int32)
Block lengths: array([2, 2], dtype=int32)
</pre>
<p>The sparse objects exist for memory efficiency reasons.</p>
<p>Let us now assume you had a large NA DataFrame and execute the following code &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(10000, 4))
df.ix[:9998] = np.nan
sdf = df.to_sparse()

print sdf.density
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   0.0001
</pre>
<p>Any sparse object can be converted back to the standard dense form by calling <b>to_dense</b> &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
ts = pd.Series(np.random.randn(10))
ts[2:-2] = np.nan
sts = ts.to_sparse()
print sts.to_dense()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   -0.810497
1   -1.419954
2         NaN
3         NaN
4         NaN
5         NaN
6         NaN
7         NaN
8    0.439240
9   -1.095910
dtype: float64
</pre>
<h2>Sparse Dtypes</h2>
<p>Sparse data should have the same dtype as its dense representation. Currently, <b>float64, int64</b> and <b>booldtypes</b> are supported. Depending on the original <b>dtype, fill_value default</b> changes &minus;</p>
<ul class="list">
<li><p><b>float64</b> &minus; np.nan</p></li>
<li><p><b>int64</b> &minus; 0</p></li>
<li><p><b>bool</b> &minus; False</p></li>
</ul>
<p>Let us execute the following code to understand the same &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

s = pd.Series([1, np.nan, np.nan])
print s

s.to_sparse()
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0   1.0
1   NaN
2   NaN
dtype: float64

0   1.0
1   NaN
2   NaN
dtype: float64
</pre>
<h1>Python Pandas - Caveats &amp; Gotchas</h1>
<p>Caveats means warning and gotcha means an unseen problem.</p>
<h2>Using If/Truth Statement with Pandas</h2>
<p>Pandas follows the numpy convention of raising an error when you try to convert something to a <b>bool</b>. This happens in an <b>if</b> or <b>when</b> using the Boolean operations, and, <b>or</b>, or <b>not</b>. It is not clear what the result should be. Should it be True because it is not zerolength? False because there are False values? It is unclear, so instead, Pandas raises a <b>ValueError</b> &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

if pd.Series([False, True, False]):
   print 'I am True'
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool() a.item(), a.any() or a.all().
</pre>
<p>In <b>if</b> condition, it is unclear what to do with it. The error is suggestive of whether to use a <b>None</b> or <b>any of those</b>.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
if pd.Series([False, True, False]).any():
   print("I am any")
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
I am any
</pre>
<p>To evaluate single-element pandas objects in a Boolean context, use the method <b>.bool()</b> &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
print pd.Series([True]).bool()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
True
</pre>
<h3>Bitwise Boolean</h3>
<p>Bitwise Boolean operators like == and <b>!</b>= will return a Boolean series, which is almost always what is required anyways.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(range(5))
print s==4
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0 False
1 False
2 False
3 False
4 True
dtype: bool
</pre>
<h3>isin Operation</h3>
<p>This returns a Boolean series showing whether each element in the Series is exactly contained in the passed sequence of values.</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd

s = pd.Series(list('abc'))
s = s.isin(['a', 'c', 'e'])
print s
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
0 True
1 False
2 True
dtype: bool
</pre>
<h3>Reindexing vs ix Gotcha</h3>
<p>Many users will find themselves using the <b>ix indexing capabilities</b> as a concise means of selecting data from a Pandas object &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(6, 4), columns=['one', 'two', 'three',
'four'],index=list('abcdef'))

print df
print df.ix[['b', 'c', 'e']]
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
          one        two      three       four
a   -1.582025   1.335773   0.961417  -1.272084
b    1.461512   0.111372  -0.072225   0.553058
c   -1.240671   0.762185   1.511936  -0.630920
d   -2.380648  -0.029981   0.196489   0.531714
e    1.846746   0.148149   0.275398  -0.244559
f   -1.842662  -0.933195   2.303949   0.677641

          one        two      three       four
b    1.461512   0.111372  -0.072225   0.553058
c   -1.240671   0.762185   1.511936  -0.630920
e    1.846746   0.148149   0.275398  -0.244559
</pre>
<p>This is, of course, completely equivalent in this case to using the <b>reindex</b> method &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np
df = pd.DataFrame(np.random.randn(6, 4), columns=['one', 'two', 'three',
'four'],index=list('abcdef'))
print df
print df.reindex(['b', 'c', 'e'])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
          one        two      three       four
a    1.639081   1.369838   0.261287  -1.662003
b   -0.173359   0.242447  -0.494384   0.346882
c   -0.106411   0.623568   0.282401  -0.916361
d   -1.078791  -0.612607  -0.897289  -1.146893
e    0.465215   1.552873  -1.841959   0.329404
f    0.966022  -0.190077   1.324247   0.678064

          one        two      three       four
b   -0.173359   0.242447  -0.494384   0.346882
c   -0.106411   0.623568   0.282401  -0.916361
e    0.465215   1.552873  -1.841959   0.329404
</pre>
<p>Some might conclude that <b>ix</b> and <b>reindex</b> are 100% equivalent based on this. This is true except in the case of integer indexing. For example, the above operation can alternatively be expressed as &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
import numpy as np

df = pd.DataFrame(np.random.randn(6, 4), columns=['one', 'two', 'three',
'four'],index=list('abcdef'))

print df
print df.ix[[1, 2, 4]]
print df.reindex([1, 2, 4])
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
          one        two      three       four
a   -1.015695  -0.553847   1.106235  -0.784460
b   -0.527398  -0.518198  -0.710546  -0.512036
c   -0.842803  -1.050374   0.787146   0.205147
d   -1.238016  -0.749554  -0.547470  -0.029045
e   -0.056788   1.063999  -0.767220   0.212476
f    1.139714   0.036159   0.201912   0.710119

          one        two      three       four
b   -0.527398  -0.518198  -0.710546  -0.512036
c   -0.842803  -1.050374   0.787146   0.205147
e   -0.056788   1.063999  -0.767220   0.212476

    one  two  three  four
1   NaN  NaN    NaN   NaN
2   NaN  NaN    NaN   NaN
4   NaN  NaN    NaN   NaN
</pre>
<p>It is important to remember that <b>reindex is strict label indexing only</b>. This can lead to some potentially surprising results in pathological cases where an index contains, say, both integers and strings.</p>
<h1>Python Pandas - Comparison with SQL</h1>
<p>Since many potential Pandas users have some familiarity with SQL, this page is meant to provide some examples of how various SQL operations can be performed using pandas.</p>
<pre class="prettyprint notranslate">
import pandas as pd
url = 'https://raw.github.com/pandasdev/
pandas/master/pandas/tests/data/tips.csv'
tips=pd.read_csv(url)
print tips.head()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
    total_bill   tip      sex  smoker  day     time  size
0        16.99  1.01   Female      No  Sun  Dinner      2
1        10.34  1.66     Male      No  Sun  Dinner      3
2        21.01  3.50     Male      No  Sun  Dinner      3
3        23.68  3.31     Male      No  Sun  Dinner      2
4        24.59  3.61   Female      No  Sun  Dinner      4
</pre>
<h2>SELECT</h2>
<p>In SQL, selection is done using a comma-separated list of columns that you select (or a * to select all columns) &minus;</p>
<pre class="result notranslate">
SELECT total_bill, tip, smoker, time
FROM tips
LIMIT 5;
</pre>
<p>With Pandas, column selection is done by passing a list of column names to your DataFrame &minus;</p>
<pre class="result notranslate">
tips[['total_bill', 'tip', 'smoker', 'time']].head(5)
</pre>
<p>Let’s check the full program &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd

url = 'https://raw.github.com/pandasdev/
pandas/master/pandas/tests/data/tips.csv'
 
tips=pd.read_csv(url)
print tips[['total_bill', 'tip', 'smoker', 'time']].head(5)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   total_bill   tip  smoker     time
0       16.99  1.01      No   Dinner
1       10.34  1.66      No   Dinner
2       21.01  3.50      No   Dinner
3       23.68  3.31      No   Dinner
4       24.59  3.61      No   Dinner
</pre>
<p>Calling the DataFrame without the list of column names will display all columns (akin to SQL’s *).</p>
<h2>WHERE</h2>
<p>Filtering in SQL is done via a WHERE clause.</p>
<pre class="result notranslate">
  SELECT * FROM tips WHERE time = 'Dinner' LIMIT 5;
</pre>
<p>DataFrames can be filtered in multiple ways; the most intuitive of which is using Boolean indexing.</p>
<pre class="result notranslate">
  tips[tips['time'] == 'Dinner'].head(5)
</pre>
<p>Let’s check the full program &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd

url = 'https://raw.github.com/pandasdev/
pandas/master/pandas/tests/data/tips.csv'

tips=pd.read_csv(url)
print tips[tips['time'] == 'Dinner'].head(5)
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   total_bill   tip      sex  smoker  day    time  size
0       16.99  1.01   Female     No   Sun  Dinner    2
1       10.34  1.66     Male     No   Sun  Dinner    3
2       21.01  3.50     Male     No   Sun  Dinner    3
3       23.68  3.31     Male     No   Sun  Dinner    2
4       24.59  3.61   Female     No   Sun  Dinner    4
</pre>
<p>The above statement passes a Series of True/False objects to the DataFrame, returning all rows with True.</p>
<h2>GroupBy</h2>
<p>This operation fetches the count of records in each group throughout a dataset. For instance, a query fetching us the number of tips left by sex &minus;</p>
<pre class="result notranslate">
SELECT sex, count(*)
FROM tips
GROUP BY sex;
</pre>
<p>The Pandas equivalent would be &minus;</p>
<pre class="result notranslate">
tips.groupby('sex').size()
</pre>
<p>Let’s check the full program &minus;</p>
<pre class="prettyprint notranslate">
import pandas as pd

url = 'https://raw.github.com/pandasdev/
pandas/master/pandas/tests/data/tips.csv'

tips=pd.read_csv(url)
print tips.groupby('sex').size()
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
sex
Female   87
Male    157
dtype: int64
</pre>
<h2>Top N rows</h2>
<p>SQL returns the <b>top n rows</b> using <b>LIMIT</b> &minus;</p>
<pre class="result notranslate">
SELECT * FROM tips
LIMIT 5 ;
</pre>
<p>The Pandas equivalent would be &minus;</p>
<pre class="result notranslate">
tips.head(5)
</pre>
<p>Let’s check the full example &minus;</p>
<pre class="prettyprint notranslate tryit">
import pandas as pd
url = 'https://raw.github.com/pandas-dev/pandas/master/pandas/tests/data/tips.csv'

tips=pd.read_csv(url)
tips = tips[['smoker', 'day', 'time']].head(5)
print tips
</pre>
<p>Its <b>output</b> is as follows &minus;</p>
<pre class="result notranslate">
   smoker   day     time
0      No   Sun   Dinner
1      No   Sun   Dinner
2      No   Sun   Dinner
3      No   Sun   Dinner
4      No   Sun   Dinner
</pre>
<p>These are the few basic operations we compared are, which we learnt, in the previous chapters of the Pandas Library.</p>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/python_pandas/python_pandas_comparison_with_sql.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="https://www.tutorialspoint.com/cgi-bin/printpage.cgi" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/python_pandas/python_pandas_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="https://www.tutorialspoint.com/index.htm" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="https://www.tutorialspoint.com/scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="https://www.tutorialspoint.com/about/tutorials_writing.htm">Write for us</a></li>
         <li><a href="https://www.tutorialspoint.com/about/faq.htm">FAQ's</a></li>
         <li><a href="https://www.tutorialspoint.com/about/about_helping.htm">Helping</a></li>
         <li><a href="https://www.tutorialspoint.com/about/contact_us.htm">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/custom-min.js?v=5"></script>
<script src="https://www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/jquery.colorbox-min.js"></script>
<script type="text/javascript">
   var tryit = new $.TryIt('https://www.tutorialspoint.com/python_pandas/try_python_pandas.php');
   tryit.compile();
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Python Pandas Quick Guide",
    "name": "Python Pandas Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/python_pandas/images/structure_table.jpg",
        "width": 572,
        "height": 501
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "August 03 2017 00:37:05.",
    "dateModified": "July 25 2017 02:20:14.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": "Pandas is an open-source Python Library providing high-performance data manipulation and analysis tool using its powerful data structures. The name Pandas is derived from the word Panel Data \u2013 an Econometrics from Multidimensional data...."
}
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Python Pandas",
                "@id": "https://www.tutorialspoint.com/python_pandas"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": "Python Pandas - Quick Guide"
            }
        }
    ]
}
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/python_pandas/python_pandas_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:25:59 GMT -->
</html>
