Operating System - Quick Guide Jobs  SENDFiles  Whiteboard  Net Meeting Tools  Articles Facebook Google+ Twitter Linkedin YouTube Home Tutorials Library Coding Ground Tutor Connect Videos Search Operating System Tutorial OS - Home OS - Overview OS - Types OS - Services OS - Properties OS - Processes OS - Process Scheduling OS - Scheduling algorithms OS - Multi-threading OS - Memory Management OS - Virtual Memory OS - I/O Hardware OS - I/O Software OS - File System OS - Security OS - Linux OS - Exams Questions with Answers OS - Exams Questions with Answers Operating System Useful Resources OS - Quick Guide OS - Useful Resources OS - Discussion Selected Reading Developer's Best Practices Questions and Answers Effective Resume Writing HR Interview Questions Computer Glossary Who is Who Operating System - Quick Guide Advertisements Previous Page Next Page   Operating System - Overview An Operating System (OS) is an interface between a computer user and computer hardware. An operating system is a software which performs all the basic tasks like file management, memory management, process management, handling input and output, and controlling peripheral devices such as disk drives and printers. Some popular Operating Systems include Linux Operating System, Windows Operating System, VMS, OS/400, AIX, z/OS, etc. Definition An operating system is a program that acts as an interface between the user and the computer hardware and controls the execution of all kinds of programs. Following are some of important functions of an operating System. Memory Management Processor Management Device Management File Management Security Control over system performance Job accounting Error detecting aids Coordination between other software and users Memory Management Memory management refers to management of Primary Memory or Main Memory. Main memory is a large array of words or bytes where each word or byte has its own address. Main memory provides a fast storage that can be accessed directly by the CPU. For a program to be executed, it must in the main memory. An Operating System does the following activities for memory management ? Keeps tracks of primary memory, i.e., what part of it are in use by whom, what part are not in use. In multiprogramming, the OS decides which process will get memory when and how much. Allocates the memory when a process requests it to do so. De-allocates the memory when a process no longer needs it or has been terminated. Processor Management In multiprogramming environment, the OS decides which process gets the processor when and for how much time. This function is called process scheduling. An Operating System does the following activities for processor management ? Keeps tracks of processor and status of process. The program responsible for this task is known as traffic controller. Allocates the processor (CPU) to a process. De-allocates processor when a process is no longer required. Device Management An Operating System manages device communication via their respective drivers. It does the following activities for device management ? Keeps tracks of all devices. Program responsible for this task is known as the I/O controller. Decides which process gets the device when and for how much time. Allocates the device in the efficient way. De-allocates devices. File Management A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. An Operating System does the following activities for file management ? Keeps track of information, location, uses, status etc. The collective facilities are often known as file system. Decides who gets the resources. Allocates the resources. De-allocates the resources. Other Important Activities Following are some of the important activities that an Operating System performs ? Security ? By means of password and similar other techniques, it prevents unauthorized access to programs and data. Control over system performance ? Recording delays between request for a service and response from the system. Job accounting ? Keeping track of time and resources used by various jobs and users. Error detecting aids ? Production of dumps, traces, error messages, and other debugging and error detecting aids. Coordination between other softwares and users ? Coordination and assignment of compilers, interpreters, assemblers and other software to the various users of the computer systems. Types of Operating System Operating systems are there from the very first computer generation and they keep evolving with time. In this chapter, we will discuss some of the important types of operating systems which are most commonly used. Batch operating system The users of a batch operating system do not interact with the computer directly. Each user prepares his job on an off-line device like punch cards and submits it to the computer operator. To speed up processing, jobs with similar needs are batched together and run as a group. The programmers leave their programs with the operator and the operator then sorts the programs with similar requirements into batches. The problems with Batch Systems are as follows ? Lack of interaction between the user and the job. CPU is often idle, because the speed of the mechanical I/O devices is slower than the CPU. Difficult to provide the desired priority. Time-sharing operating systems Time-sharing is a technique which enables many people, located at various terminals, to use a particular computer system at the same time. Time-sharing or multitasking is a logical extension of multiprogramming. Processor's time which is shared among multiple users simultaneously is termed as time-sharing. The main difference between Multiprogrammed Batch Systems and Time-Sharing Systems is that in case of Multiprogrammed batch systems, the objective is to maximize processor use, whereas in Time-Sharing Systems, the objective is to minimize response time. Multiple jobs are executed by the CPU by switching between them, but the switches occur so frequently. Thus, the user can receive an immediate response. For example, in a transaction processing, the processor executes each user program in a short burst or quantum of computation. That is, if n users are present, then each user can get a time quantum. When the user submits the command, the response time is in few seconds at most. The operating system uses CPU scheduling and multiprogramming to provide each user with a small portion of a time. Computer systems that were designed primarily as batch systems have been modified to time-sharing systems. Advantages of Timesharing operating systems are as follows ? Provides the advantage of quick response. Avoids duplication of software. Reduces CPU idle time. Disadvantages of Time-sharing operating systems are as follows ? Problem of reliability. Question of security and integrity of user programs and data. Problem of data communication. Distributed operating System Distributed systems use multiple central processors to serve multiple real-time applications and multiple users. Data processing jobs are distributed among the processors accordingly. The processors communicate with one another through various communication lines (such as high-speed buses or telephone lines). These are referred as loosely coupled systems or distributed systems. Processors in a distributed system may vary in size and function. These processors are referred as sites, nodes, computers, and so on. The advantages of distributed systems are as follows ? With resource sharing facility, a user at one site may be able to use the resources available at another. Speedup the exchange of data with one another via electronic mail. If one site fails in a distributed system, the remaining sites can potentially continue operating. Better service to the customers. Reduction of the load on the host computer. Reduction of delays in data processing. Network operating System A Network Operating System runs on a server and provides the server the capability to manage data, users, groups, security, applications, and other networking functions. The primary purpose of the network operating system is to allow shared file and printer access among multiple computers in a network, typically a local area network (LAN), a private network or to other networks. Examples of network operating systems include Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux, Mac OS X, Novell NetWare, and BSD. The advantages of network operating systems are as follows ? Centralized servers are highly stable. Security is server managed. Upgrades to new technologies and hardware can be easily integrated into the system. Remote access to servers is possible from different locations and types of systems. The disadvantages of network operating systems are as follows ? High cost of buying and running a server. Dependency on a central location for most operations. Regular maintenance and updates are required. Real Time operating System A real-time system is defined as a data processing system in which the time interval required to process and respond to inputs is so small that it controls the environment. The time taken by the system to respond to an input and display of required updated information is termed as the response time. So in this method, the response time is very less as compared to online processing. Real-time systems are used when there are rigid time requirements on the operation of a processor or the flow of data and real-time systems can be used as a control device in a dedicated application. A real-time operating system must have well-defined, fixed time constraints, otherwise the system will fail. For example, Scientific experiments, medical imaging systems, industrial control systems, weapon systems, robots, air traffic control systems, etc. There are two types of real-time operating systems. Hard real-time systems Hard real-time systems guarantee that critical tasks complete on time. In hard real-time systems, secondary storage is limited or missing and the data is stored in ROM. In these systems, virtual memory is almost never found. Soft real-time systems Soft real-time systems are less restrictive. A critical real-time task gets priority over other tasks and retains the priority until it completes. Soft real-time systems have limited utility than hard real-time systems. For example, multimedia, virtual reality, Advanced Scientific Projects like undersea exploration and planetary rovers, etc. Operating System - Services An Operating System provides services to both the users and to the programs. It provides programs an environment to execute. It provides users the services to execute the programs in a convenient manner. Following are a few common services provided by an operating system ? Program execution I/O operations File System manipulation Communication Error Detection Resource Allocation Protection Program execution Operating systems handle many kinds of activities from user programs to system programs like printer spooler, name servers, file server, etc. Each of these activities is encapsulated as a process. A process includes the complete execution context (code to execute, data to manipulate, registers, OS resources in use). Following are the major activities of an operating system with respect to program management ? Loads a program into memory. Executes the program. Handles program's execution. Provides a mechanism for process synchronization. Provides a mechanism for process communication. Provides a mechanism for deadlock handling. I/O Operation An I/O subsystem comprises of I/O devices and their corresponding driver software. Drivers hide the peculiarities of specific hardware devices from the users. An Operating System manages the communication between user and device drivers. I/O operation means read or write operation with any file or any specific I/O device. Operating system provides the access to the required I/O device when required. File system manipulation A file represents a collection of related information. Computers can store files on the disk (secondary storage), for long-term storage purpose. Examples of storage media include magnetic tape, magnetic disk and optical disk drives like CD, DVD. Each of these media has its own properties like speed, capacity, data transfer rate and data access methods. A file system is normally organized into directories for easy navigation and usage. These directories may contain files and other directions. Following are the major activities of an operating system with respect to file management ? Program needs to read a file or write a file. The operating system gives the permission to the program for operation on file. Permission varies from read-only, read-write, denied and so on. Operating System provides an interface to the user to create/delete files. Operating System provides an interface to the user to create/delete directories. Operating System provides an interface to create the backup of file system. Communication In case of distributed systems which are a collection of processors that do not share memory, peripheral devices, or a clock, the operating system manages communications between all the processes. Multiple processes communicate with one another through communication lines in the network. The OS handles routing and connection strategies, and the problems of contention and security. Following are the major activities of an operating system with respect to communication ? Two processes often require data to be transferred between them Both the processes can be on one computer or on different computers, but are connected through a computer network. Communication may be implemented by two methods, either by Shared Memory or by Message Passing. Error handling Errors can occur anytime and anywhere. An error may occur in CPU, in I/O devices or in the memory hardware. Following are the major activities of an operating system with respect to error handling ? The OS constantly checks for possible errors. The OS takes an appropriate action to ensure correct and consistent computing. Resource Management In case of multi-user or multi-tasking environment, resources such as main memory, CPU cycles and files storage are to be allocated to each user or job. Following are the major activities of an operating system with respect to resource management ? The OS manages all kinds of resources using schedulers. CPU scheduling algorithms are used for better utilization of CPU. Protection Considering a computer system having multiple users and concurrent execution of multiple processes, the various processes must be protected from each other's activities. Protection refers to a mechanism or a way to control the access of programs, processes, or users to the resources defined by a computer system. Following are the major activities of an operating system with respect to protection ? The OS ensures that all access to system resources is controlled. The OS ensures that external I/O devices are protected from invalid access attempts. The OS provides authentication features for each user by means of passwords. Operating System - Properties Batch processing Batch processing is a technique in which an Operating System collects the programs and data together in a batch before processing starts. An operating system does the following activities related to batch processing ? The OS defines a job which has predefined sequence of commands, programs and data as a single unit. The OS keeps a number a jobs in memory and executes them without any manual information. Jobs are processed in the order of submission, i.e., first come first served fashion. When a job completes its execution, its memory is released and the output for the job gets copied into an output spool for later printing or processing. Advantages Batch processing takes much of the work of the operator to the computer. Increased performance as a new job get started as soon as the previous job is finished, without any manual intervention. Disadvantages Difficult to debug program. A job could enter an infinite loop. Due to lack of protection scheme, one batch job can affect pending jobs. Multitasking Multitasking is when multiple jobs are executed by the CPU simultaneously by switching between them. Switches occur so frequently that the users may interact with each program while it is running. An OS does the following activities related to multitasking ? The user gives instructions to the operating system or to a program directly, and receives an immediate response. The OS handles multitasking in the way that it can handle multiple operations/executes multiple programs at a time. Multitasking Operating Systems are also known as Time-sharing systems. These Operating Systems were developed to provide interactive use of a computer system at a reasonable cost. A time-shared operating system uses the concept of CPU scheduling and multiprogramming to provide each user with a small portion of a time-shared CPU. Each user has at least one separate program in memory. A program that is loaded into memory and is executing is commonly referred to as a process. When a process executes, it typically executes for only a very short time before it either finishes or needs to perform I/O. Since interactive I/O typically runs at slower speeds, it may take a long time to complete. During this time, a CPU can be utilized by another process. The operating system allows the users to share the computer simultaneously. Since each action or command in a time-shared system tends to be short, only a little CPU time is needed for each user. As the system switches CPU rapidly from one user/program to the next, each user is given the impression that he/she has his/her own CPU, whereas actually one CPU is being shared among many users. Multiprogramming Sharing the processor, when two or more programs reside in memory at the same time, is referred as multiprogramming. Multiprogramming assumes a single shared processor. Multiprogramming increases CPU utilization by organizing jobs so that the CPU always has one to execute. The following figure shows the memory layout for a multiprogramming system. An OS does the following activities related to multiprogramming. The operating system keeps several jobs in memory at a time. This set of jobs is a subset of the jobs kept in the job pool. The operating system picks and begins to execute one of the jobs in the memory. Multiprogramming operating systems monitor the state of all active programs and system resources using memory management programs to ensures that the CPU is never idle, unless there are no jobs to process. Advantages High and efficient CPU utilization. User feels that many programs are allotted CPU almost simultaneously. Disadvantages CPU scheduling is required. To accommodate many jobs in memory, memory management is required. Interactivity Interactivity refers to the ability of users to interact with a computer system. An Operating system does the following activities related to interactivity ? Provides the user an interface to interact with the system. Manages input devices to take inputs from the user. For example, keyboard. Manages output devices to show outputs to the user. For example, Monitor. The response time of the OS needs to be short, since the user submits and waits for the result. Real Time System Real-time systems are usually dedicated, embedded systems. An operating system does the following activities related to real-time system activity. In such systems, Operating Systems typically read from and react to sensor data. The Operating system must guarantee response to events within fixed periods of time to ensure correct performance. Distributed Environment A distributed environment refers to multiple independent CPUs or processors in a computer system. An operating system does the following activities related to distributed environment ? The OS distributes computation logics among several physical processors. The processors do not share memory or a clock. Instead, each processor has its own local memory. The OS manages the communications between the processors. They communicate with each other through various communication lines. Spooling Spooling is an acronym for simultaneous peripheral operations on line. Spooling refers to putting data of various I/O jobs in a buffer. This buffer is a special area in memory or hard disk which is accessible to I/O devices. An operating system does the following activities related to distributed environment ? Handles I/O device data spooling as devices have different data access rates. Maintains the spooling buffer which provides a waiting station where data can rest while the slower device catches up. Maintains parallel computation because of spooling process as a computer can perform I/O in parallel fashion. It becomes possible to have the computer read data from a tape, write data to disk and to write out to a tape printer while it is doing its computing task. Advantages The spooling operation uses a disk as a very large buffer. Spooling is capable of overlapping I/O operation for one job with processor operations for another job. Operating System - Processes Process A process is basically a program in execution. The execution of a process must progress in a sequential fashion. A process is defined as an entity which represents the basic unit of work to be implemented in the system. To put it in simple terms, we write our computer programs in a text file and when we execute this program, it becomes a process which performs all the tasks mentioned in the program. When a program is loaded into the memory and it becomes a process, it can be divided into four sections ? stack, heap, text and data. The following image shows a simplified layout of a process inside main memory ? S.N. Component & Description 1 Stack The process Stack contains the temporary data such as method/function parameters, return address and local variables. 2 Heap This is dynamically allocated memory to a process during its run time. 3 Text This includes the current activity represented by the value of Program Counter and the contents of the processor's registers. 4 Data This section contains the global and static variables. Program A program is a piece of code which may be a single line or millions of lines. A computer program is usually written by a computer programmer in a programming language. For example, here is a simple program written in C programming language ? 
#include <stdio.h>

int main() {
   printf("Hello, World! \n");
   return 0;
}
 A computer program is a collection of instructions that performs a specific task when executed by a computer. When we compare a program with a process, we can conclude that a process is a dynamic instance of a computer program. A part of a computer program that performs a well-defined task is known as an algorithm. A collection of computer programs, libraries and related data are referred to as a software. Process Life Cycle When a process executes, it passes through different states. These stages may differ in different operating systems, and the names of these states are also not standardized. In general, a process can have one of the following five states at a time. S.N. State & Description 1 Start This is the initial state when a process is first started/created. 2 Ready The process is waiting to be assigned to a processor. Ready processes are waiting to have the processor allocated to them by the operating system so that they can run. Process may come into this state after Start state or while running it by but interrupted by the scheduler to assign CPU to some other process. 3 Running Once the process has been assigned to a processor by the OS scheduler, the process state is set to running and the processor executes its instructions. 4 Waiting Process moves into the waiting state if it needs to wait for a resource, such as waiting for user input, or waiting for a file to become available. 5 Terminated or Exit Once the process finishes its execution, or it is terminated by the operating system, it is moved to the terminated state where it waits to be removed from main memory. Process Control Block (PCB) A Process Control Block is a data structure maintained by the Operating System for every process. The PCB is identified by an integer process ID (PID). A PCB keeps all the information needed to keep track of a process as listed below in the table ? S.N. Information & Description 1 Process State The current state of the process i.e., whether it is ready, running, waiting, or whatever. 2 Process privileges This is required to allow/disallow access to system resources. 3 Process ID Unique identification for each of the process in the operating system. 4 Pointer A pointer to parent process. 5 Program Counter Program Counter is a pointer to the address of the next instruction to be executed for this process. 6 CPU registers Various CPU registers where process need to be stored for execution for running state. 7 CPU Scheduling Information Process priority and other scheduling information which is required to schedule the process. 8 Memory management information This includes the information of page table, memory limits, Segment table depending on memory used by the operating system. 9 Accounting information This includes the amount of CPU used for process execution, time limits, execution ID etc. 10 IO status information This includes a list of I/O devices allocated to the process. The architecture of a PCB is completely dependent on Operating System and may contain different information in different operating systems. Here is a simplified diagram of a PCB ? The PCB is maintained for a process throughout its lifetime, and is deleted once the process terminates. Operating System - Process Scheduling Definition The process scheduling is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a particular strategy. Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing. Process Scheduling Queues The OS maintains all PCBs in Process Scheduling Queues. The OS maintains a separate queue for each of the process states and PCBs of all processes in the same execution state are placed in the same queue. When the state of a process is changed, its PCB is unlinked from its current queue and moved to its new state queue. The Operating System maintains the following important process scheduling queues ? Job queue ? This queue keeps all the processes in the system. Ready queue ? This queue keeps a set of all processes residing in main memory, ready and waiting to execute. A new process is always put in this queue. Device queues ? The processes which are blocked due to unavailability of an I/O device constitute this queue. The OS can use different policies to manage each queue (FIFO, Round Robin, Priority, etc.). The OS scheduler determines how to move processes between the ready and run queues which can only have one entry per processor core on the system; in the above diagram, it has been merged with the CPU. Two-State Process Model Two-state process model refers to running and non-running states which are described below ? S.N. State & Description 1 Running When a new process is created, it enters into the system as in the running state. 2 Not Running Processes that are not running are kept in queue, waiting for their turn to execute. Each entry in the queue is a pointer to a particular process. Queue is implemented by using linked list. Use of dispatcher is as follows. When a process is interrupted, that process is transferred in the waiting queue. If the process has completed or aborted, the process is discarded. In either case, the dispatcher then selects a process from the queue to execute. Schedulers Schedulers are special system software which handle process scheduling in various ways. Their main task is to select the jobs to be submitted into the system and to decide which process to run. Schedulers are of three types ? Long-Term Scheduler Short-Term Scheduler Medium-Term Scheduler Long Term Scheduler It is also called a job scheduler. A long-term scheduler determines which programs are admitted to the system for processing. It selects processes from the queue and loads them into memory for execution. Process loads into the memory for CPU scheduling. The primary objective of the job scheduler is to provide a balanced mix of jobs, such as I/O bound and processor bound. It also controls the degree of multiprogramming. If the degree of multiprogramming is stable, then the average rate of process creation must be equal to the average departure rate of processes leaving the system. On some systems, the long-term scheduler may not be available or minimal. Time-sharing operating systems have no long term scheduler. When a process changes the state from new to ready, then there is use of long-term scheduler. Short Term Scheduler It is also called as CPU scheduler. Its main objective is to increase system performance in accordance with the chosen set of criteria. It is the change of ready state to running state of the process. CPU scheduler selects a process among the processes that are ready to execute and allocates CPU to one of them. Short-term schedulers, also known as dispatchers, make the decision of which process to execute next. Short-term schedulers are faster than long-term schedulers. Medium Term Scheduler Medium-term scheduling is a part of swapping. It removes the processes from the memory. It reduces the degree of multiprogramming. The medium-term scheduler is in-charge of handling the swapped out-processes. A running process may become suspended if it makes an I/O request. A suspended processes cannot make any progress towards completion. In this condition, to remove the process from memory and make space for other processes, the suspended process is moved to the secondary storage. This process is called swapping, and the process is said to be swapped out or rolled out. Swapping may be necessary to improve the process mix. Comparison among Scheduler S.N. Long-Term Scheduler Short-Term Scheduler Medium-Term Scheduler 1 It is a job scheduler It is a CPU scheduler It is a process swapping scheduler. 2 Speed is lesser than short term scheduler Speed is fastest among other two Speed is in between both short and long term scheduler. 3 It controls the degree of multiprogramming It provides lesser control over degree of multiprogramming It reduces the degree of multiprogramming. 4 It is almost absent or minimal in time sharing system It is also minimal in time sharing system It is a part of Time sharing systems. 5 It selects processes from pool and loads them into memory for execution It selects those processes which are ready to execute It can re-introduce the process into memory and execution can be continued. Context Switch A context switch is the mechanism to store and restore the state or context of a CPU in Process Control block so that a process execution can be resumed from the same point at a later time. Using this technique, a context switcher enables multiple processes to share a single CPU. Context switching is an essential part of a multitasking operating system features. When the scheduler switches the CPU from executing one process to execute another, the state from the current running process is stored into the process control block. After this, the state for the process to run next is loaded from its own PCB and used to set the PC, registers, etc. At that point, the second process can start executing. Context switches are computationally intensive since register and memory state must be saved and restored. To avoid the amount of context switching time, some hardware systems employ two or more sets of processor registers. When the process is switched, the following information is stored for later use. Program Counter Scheduling information Base and limit register value Currently used register Changed State I/O State information Accounting information Operating System Scheduling algorithms A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms which we are going to discuss in this chapter ? First-Come, First-Served (FCFS) Scheduling Shortest-Job-Next (SJN) Scheduling Priority Scheduling Shortest Remaining Time Round Robin(RR) Scheduling Multiple-Level Queues Scheduling These algorithms are either non-preemptive or preemptive. Non-preemptive algorithms are designed so that once a process enters the running state, it cannot be preempted until it completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state. First Come First Serve (FCFS) Jobs are executed on first come, first serve basis. It is a non-preemptive, pre-emptive scheduling algorithm. Easy to understand and implement. Its implementation is based on FIFO queue. Poor in performance as average wait time is high. Wait time of each process is as follows ? Process Wait Time : Service Time - Arrival Time P0 0 - 0 = 0 P1 5 - 1 = 4 P2 8 - 2 = 6 P3 16 - 3 = 13 Average Wait Time: (0+4+6+13) / 4 = 5.75 Shortest Job Next (SJN) This is also known as shortest job first, or SJF This is a non-preemptive, pre-emptive scheduling algorithm. Best approach to minimize waiting time. Easy to implement in Batch systems where required CPU time is known in advance. Impossible to implement in interactive systems where required CPU time is not known. The processer should know in advance how much time process will take. Wait time of each process is as follows ? Process Wait Time : Service Time - Arrival Time P0 3 - 0 = 3 P1 0 - 0 = 0 P2 16 - 2 = 14 P3 8 - 3 = 5 Average Wait Time: (3+0+14+5) / 4 = 5.50 Priority Based Scheduling Priority scheduling is a non-preemptive algorithm and one of the most common scheduling algorithms in batch systems. Each process is assigned a priority. Process with highest priority is to be executed first and so on. Processes with same priority are executed on first come first served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement. Wait time of each process is as follows ? Process Wait Time : Service Time - Arrival Time P0 9 - 0 = 9 P1 6 - 1 = 5 P2 14 - 2 = 12 P3 0 - 0 = 0 Average Wait Time: (9+5+12+0) / 4 = 6.5 Shortest Remaining Time Shortest remaining time (SRT) is the preemptive version of the SJN algorithm. The processor is allocated to the job closest to completion but it can be preempted by a newer ready job with shorter time to completion. Impossible to implement in interactive systems where required CPU time is not known. It is often used in batch environments where short jobs need to give preference. Round Robin Scheduling Round Robin is the preemptive process scheduling algorithm. Each process is provided a fix time to execute, it is called a quantum. Once a process is executed for a given time period, it is preempted and other process executes for a given time period. Context switching is used to save states of preempted processes. Wait time of each process is as follows ? Process Wait Time : Service Time - Arrival Time P0 (0 - 0) + (12 - 3) = 9 P1 (3 - 1) = 2 P2 (6 - 2) + (14 - 9) + (20 - 17) = 12 P3 (9 - 3) + (17 - 12) = 11 Average Wait Time: (9+2+12+11) / 4 = 8.5 Multiple-Level Queues Scheduling Multiple-level queues are not an independent scheduling algorithm. They make use of other existing algorithms to group and schedule jobs with common characteristics. Multiple queues are maintained for processes with common characteristics. Each queue can have its own scheduling algorithms. Priorities are assigned to each queue. For example, CPU-bound jobs can be scheduled in one queue and all I/O-bound jobs in another queue. The Process Scheduler then alternately selects jobs from each queue and assigns them to the CPU based on the algorithm assigned to the queue. Operating System - Multi-Threading What is Thread? A thread is a flow of execution through the process code, with its own program counter that keeps track of which instruction to execute next, system registers which hold its current working variables, and a stack which contains the execution history. A thread shares with its peer threads few information like code segment, data segment and open files. When one thread alters a code segment memory item, all other threads see that. A thread is also called a lightweight process. Threads provide a way to improve application performance through parallelism. Threads represent a software approach to improving performance of operating system by reducing the overhead thread is equivalent to a classical process. Each thread belongs to exactly one process and no thread can exist outside a process. Each thread represents a separate flow of control. Threads have been successfully used in implementing network servers and web server. They also provide a suitable foundation for parallel execution of applications on shared memory multiprocessors. The following figure shows the working of a single-threaded and a multithreaded process. Difference between Process and Thread S.N. Process Thread 1 Process is heavy weight or resource intensive. Thread is light weight, taking lesser resources than a process. 2 Process switching needs interaction with operating system. Thread switching does not need to interact with operating system. 3 In multiple processing environments, each process executes the same code but has its own memory and file resources. All threads can share same set of open files, child processes. 4 If one process is blocked, then no other process can execute until the first process is unblocked. While one thread is blocked and waiting, a second thread in the same task can run. 5 Multiple processes without using threads use more resources. Multiple threaded processes use fewer resources. 6 In multiple processes each process operates independently of the others. One thread can read, write or change another thread's data. Advantages of Thread Threads minimize the context switching time. Use of threads provides concurrency within a process. Efficient communication. It is more economical to create and context switch threads. Threads allow utilization of multiprocessor architectures to a greater scale and efficiency. Types of Thread Threads are implemented in following two ways ? User Level Threads ? User managed threads. Kernel Level Threads ? Operating System managed threads acting on kernel, an operating system core. User Level Threads In this case, the thread management kernel is not aware of the existence of threads. The thread library contains code for creating and destroying threads, for passing message and data between threads, for scheduling thread execution and for saving and restoring thread contexts. The application starts with a single thread. Advantages Thread switching does not require Kernel mode privileges. User level thread can run on any operating system. Scheduling can be application specific in the user level thread. User level threads are fast to create and manage. Disadvantages In a typical operating system, most system calls are blocking. Multithreaded application cannot take advantage of multiprocessing. Kernel Level Threads In this case, thread management is done by the Kernel. There is no thread management code in the application area. Kernel threads are supported directly by the operating system. Any application can be programmed to be multithreaded. All of the threads within an application are supported within a single process. The Kernel maintains context information for the process as a whole and for individuals threads within the process. Scheduling by the Kernel is done on a thread basis. The Kernel performs thread creation, scheduling and management in Kernel space. Kernel threads are generally slower to create and manage than the user threads. Advantages Kernel can simultaneously schedule multiple threads from the same process on multiple processes. If one thread in a process is blocked, the Kernel can schedule another thread of the same process. Kernel routines themselves can be multithreaded. Disadvantages Kernel threads are generally slower to create and manage than the user threads. Transfer of control from one thread to another within the same process requires a mode switch to the Kernel. Multithreading Models Some operating system provide a combined user level thread and Kernel level thread facility. Solaris is a good example of this combined approach. In a combined system, multiple threads within the same application can run in parallel on multiple processors and a blocking system call need not block the entire process. Multithreading models are three types Many to many relationship. Many to one relationship. One to one relationship. Many to Many Model The many-to-many model multiplexes any number of user threads onto an equal or smaller number of kernel threads. The following diagram shows the many-to-many threading model where 6 user level threads are multiplexing with 6 kernel level threads. In this model, developers can create as many user threads as necessary and the corresponding Kernel threads can run in parallel on a multiprocessor machine. This model provides the best accuracy on concurrency and when a thread performs a blocking system call, the kernel can schedule another thread for execution. Many to One Model Many-to-one model maps many user level threads to one Kernel-level thread. Thread management is done in user space by the thread library. When thread makes a blocking system call, the entire process will be blocked. Only one thread can access the Kernel at a time, so multiple threads are unable to run in parallel on multiprocessors. If the user-level thread libraries are implemented in the operating system in such a way that the system does not support them, then the Kernel threads use the many-to-one relationship modes. One to One Model There is one-to-one relationship of user-level thread to the kernel-level thread. This model provides more concurrency than the many-to-one model. It also allows another thread to run when a thread makes a blocking system call. It supports multiple threads to execute in parallel on microprocessors. Disadvantage of this model is that creating user thread requires the corresponding Kernel thread. OS/2, windows NT and windows 2000 use one to one relationship model. Difference between User-Level & Kernel-Level Thread S.N. User-Level Threads Kernel-Level Thread 1 User-level threads are faster to create and manage. Kernel-level threads are slower to create and manage. 2 Implementation is by a thread library at the user level. Operating system supports creation of Kernel threads. 3 User-level thread is generic and can run on any operating system. Kernel-level thread is specific to the operating system. 4 Multi-threaded applications cannot take advantage of multiprocessing. Kernel routines themselves can be multithreaded. Operating System - Memory Management Memory management is the functionality of an operating system which handles or manages primary memory and moves processes back and forth between main memory and disk during execution. Memory management keeps track of each and every memory location, regardless of either it is allocated to some process or it is free. It checks how much memory is to be allocated to processes. It decides which process will get memory at what time. It tracks whenever some memory gets freed or unallocated and correspondingly it updates the status. This tutorial will teach you basic concepts related to Memory Management. Process Address Space The process address space is the set of logical addresses that a process references in its code. For example, when 32-bit addressing is in use, addresses can range from 0 to 0x7fffffff; that is, 2^31 possible numbers, for a total theoretical size of 2 gigabytes. The operating system takes care of mapping the logical addresses to physical addresses at the time of memory allocation to the program. There are three types of addresses used in a program before and after memory is allocated ? S.N. Memory Addresses & Description 1 Symbolic addresses The addresses used in a source code. The variable names, constants, and instruction labels are the basic elements of the symbolic address space. 2 Relative addresses At the time of compilation, a compiler converts symbolic addresses into relative addresses. 3 Physical addresses The loader generates these addresses at the time when a program is loaded into main memory. Virtual and physical addresses are the same in compile-time and load-time address-binding schemes. Virtual and physical addresses differ in execution-time address-binding scheme. The set of all logical addresses generated by a program is referred to as a logical address space. The set of all physical addresses corresponding to these logical addresses is referred to as a physical address space. The runtime mapping from virtual to physical address is done by the memory management unit (MMU) which is a hardware device. MMU uses following mechanism to convert virtual address to physical address. The value in the base register is added to every address generated by a user process, which is treated as offset at the time it is sent to memory. For example, if the base register value is 10000, then an attempt by the user to use address location 100 will be dynamically reallocated to location 10100. The user program deals with virtual addresses; it never sees the real physical addresses. Static vs Dynamic Loading The choice between Static or Dynamic Loading is to be made at the time of computer program being developed. If you have to load your program statically, then at the time of compilation, the complete programs will be compiled and linked without leaving any external program or module dependency. The linker combines the object program with other necessary object modules into an absolute program, which also includes logical addresses. If you are writing a Dynamically loaded program, then your compiler will compile the program and for all the modules which you want to include dynamically, only references will be provided and rest of the work will be done at the time of execution. At the time of loading, with static loading, the absolute program (and data) is loaded into memory in order for execution to start. If you are using dynamic loading, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program. Static vs Dynamic Linking As explained above, when static linking is used, the linker combines all other modules needed by a program into a single executable program to avoid any runtime dependency. When dynamic linking is used, it is not required to link the actual module or library with the program, rather a reference to the dynamic module is provided at the time of compilation and linking. Dynamic Link Libraries (DLL) in Windows and Shared Objects in Unix are good examples of dynamic libraries. Swapping Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory. Though performance is usually affected by swapping process but it helps in running multiple and big processes in parallel and that's the reason Swapping is also known as a technique for memory compaction. The total time taken by swapping process includes the time it takes to move the entire process to a secondary disk and then to copy the process back to memory, as well as the time the process takes to regain main memory. Let us assume that the user process is of size 2048KB and on a standard hard disk where swapping will take place has a data transfer rate around 1 MB per second. The actual transfer of the 1000K process to or from memory will take 
2048KB / 1024KB per second
= 2 seconds
= 2000 milliseconds
 Now considering in and out time, it will take complete 4000 milliseconds plus other overhead where the process competes to regain main memory. Memory Allocation Main memory usually has two partitions ? Low Memory ? Operating system resides in this memory. High Memory ? User processes are held in high memory. Operating system uses the following memory allocation mechanism. S.N. Memory Allocation & Description 1 Single-partition allocation In this type of allocation, relocation-register scheme is used to protect user processes from each other, and from changing operating-system code and data. Relocation register contains value of smallest physical address whereas limit register contains range of logical addresses. Each logical address must be less than the limit register. 2 Multiple-partition allocation In this type of allocation, main memory is divided into a number of fixed-sized partitions where each partition should contain only one process. When a partition is free, a process is selected from the input queue and is loaded into the free partition. When the process terminates, the partition becomes available for another process. Fragmentation As processes are loaded and removed from memory, the free memory space is broken into little pieces. It happens after sometimes that processes cannot be allocated to memory blocks considering their small size and memory blocks remains unused. This problem is known as Fragmentation. Fragmentation is of two types ? S.N. Fragmentation & Description 1 External fragmentation Total memory space is enough to satisfy a request or to reside a process in it, but it is not contiguous, so it cannot be used. 2 Internal fragmentation Memory block assigned to process is bigger. Some portion of memory is left unused, as it cannot be used by another process. The following diagram shows how fragmentation can cause waste of memory and a compaction technique can be used to create more free memory out of fragmented memory ? External fragmentation can be reduced by compaction or shuffle memory contents to place all free memory together in one large block. To make compaction feasible, relocation should be dynamic. The internal fragmentation can be reduced by effectively assigning the smallest partition but large enough for the process. Paging A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard that's set up to emulate the computer's RAM. Paging technique plays an important role in implementing virtual memory. Paging is a memory management technique in which process address space is broken into blocks of the same size called pages (size is power of 2, between 512 bytes and 8192 bytes). The size of the process is measured in the number of pages. Similarly, main memory is divided into small fixed-sized blocks of (physical) memory called frames and the size of a frame is kept the same as that of a page to have optimum utilization of the main memory and to avoid external fragmentation. Address Translation Page address is called logical address and represented by page number and the offset. 
Logical Address = Page number + page offset
 Frame address is called physical address and represented by a frame number and the offset. 
Physical Address = Frame number + page offset
 A data structure called page map table is used to keep track of the relation between a page of a process to a frame in physical memory. When the system allocates a frame to any page, it translates this logical address into a physical address and create entry into the page table to be used throughout execution of the program. When a process is to be executed, its corresponding pages are loaded into any available memory frames. Suppose you have a program of 8Kb but your memory can accommodate only 5Kb at a given point in time, then the paging concept will come into picture. When a computer runs out of RAM, the operating system (OS) will move idle or unwanted pages of memory to secondary memory to free up RAM for other processes and brings them back when needed by the program. This process continues during the whole execution of the program where the OS keeps removing idle pages from the main memory and write them onto the secondary memory and bring them back when required by the program. Advantages and Disadvantages of Paging Here is a list of advantages and disadvantages of paging ? Paging reduces external fragmentation, but still suffer from internal fragmentation. Paging is simple to implement and assumed as an efficient memory management technique. Due to equal size of the pages and frames, swapping becomes very easy. Page table requires extra memory space, so may not be good for a system having small RAM. Segmentation Segmentation is a memory management technique in which each job is divided into several segments of different sizes, one for each module that contains pieces that perform related functions. Each segment is actually a different logical address space of the program. When a process is to be executed, its corresponding segmentation are loaded into non-contiguous memory though every segment is loaded into a contiguous block of available memory. Segmentation memory management works very similar to paging but here segments are of variable-length where as in paging pages are of fixed size. A program segment contains the program's main function, utility functions, data structures, and so on. The operating system maintains a segment map table for every process and a list of free memory blocks along with segment numbers, their size and corresponding memory locations in main memory. For each segment, the table stores the starting address of the segment and the length of the segment. A reference to a memory location includes a value that identifies a segment and an offset. Operating System - Virtual Memory A computer can address more memory than the amount physically installed on the system. This extra memory is actually called virtual memory and it is a section of a hard disk that's set up to emulate the computer's RAM. The main visible advantage of this scheme is that programs can be larger than physical memory. Virtual memory serves two purposes. First, it allows us to extend the use of physical memory by using disk. Second, it allows us to have memory protection, because each virtual address is translated to a physical address. Following are the situations, when entire program is not required to be loaded fully in main memory. User written error handling routines are used only when an error occurred in the data or computation. Certain options and features of a program may be used rarely. Many tables are assigned a fixed amount of address space even though only a small amount of the table is actually used. The ability to execute a program that is only partially in memory would counter many benefits. Less number of I/O would be needed to load or swap each user program into memory. A program would no longer be constrained by the amount of physical memory that is available. Each user program could take less physical memory, more programs could be run the same time, with a corresponding increase in CPU utilization and throughput. Modern microprocessors intended for general-purpose use, a memory management unit, or MMU, is built into the hardware. The MMU's job is to translate virtual addresses into physical addresses. A basic example is given below ? Virtual memory is commonly implemented by demand paging. It can also be implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory. Demand Paging A demand paging system is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance. When a context switch occurs, the operating system does not copy any of the old programs pages out to the disk or any of the new programs pages into the main memory Instead, it just begins executing the new program after loading the first page and fetches that programs pages as they are referenced. While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats this invalid memory reference as a page fault and transfers control from the program to the operating system to demand the page back into the memory. Advantages Following are the advantages of Demand Paging ? Large virtual memory. More efficient use of memory. There is no limit on degree of multiprogramming. Disadvantages Number of tables and the amount of processor overhead for handling page interrupts are greater than in the case of the simple paged management techniques. Page Replacement Algorithm Page replacement algorithms are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated. Paging happens whenever a page fault occurs and a free page cannot be used for allocation purpose accounting to reason that pages are not available or the number of free pages is lower than required pages. When the page that was selected for replacement and was paged out, is referenced again, it has to read in from disk, and this requires for I/O completion. This process determines the quality of the page replacement algorithm: the lesser the time waiting for page-ins, the better is the algorithm. A page replacement algorithm looks at the limited information about accessing the pages provided by hardware, and tries to select which pages should be replaced to minimize the total number of page misses, while balancing it with the costs of primary storage and processor time of the algorithm itself. There are many different page replacement algorithms. We evaluate an algorithm by running it on a particular string of memory reference and computing the number of page faults, Reference String The string of memory references is called reference string. Reference strings are generated artificially or by tracing a given system and recording the address of each memory reference. The latter choice produces a large number of data, where we note two things. For a given page size, we need to consider only the page number, not the entire address. If we have a reference to a page p, then any immediately following references to page p will never cause a page fault. Page p will be in memory after the first reference; the immediately following references will not fault. For example, consider the following sequence of addresses ? 123,215,600,1234,76,96 If page size is 100, then the reference string is 1,2,6,12,0,0 First In First Out (FIFO) algorithm Oldest page in main memory is the one which will be selected for replacement. Easy to implement, keep a list, replace pages from the tail and add new pages at the head. Optimal Page algorithm An optimal page-replacement algorithm has the lowest page-fault rate of all algorithms. An optimal page-replacement algorithm exists, and has been called OPT or MIN. Replace the page that will not be used for the longest period of time. Use the time when a page is to be used. Least Recently Used (LRU) algorithm Page which has not been used for the longest time in main memory is the one which will be selected for replacement. Easy to implement, keep a list, replace pages by looking back into time. Page Buffering algorithm To get a process start quickly, keep a pool of free frames. On page fault, select a page to be replaced. Write the new page in the frame of free pool, mark the page table and restart the process. Now write the dirty page out of disk and place the frame holding replaced page in free pool. Least frequently Used(LFU) algorithm The page with the smallest count is the one which will be selected for replacement. This algorithm suffers from the situation in which a page is used heavily during the initial phase of a process, but then is never used again. Most frequently Used(MFU) algorithm This algorithm is based on the argument that the page with the smallest count was probably just brought in and has yet to be used. Operating System - I/O Hardware One of the important jobs of an Operating System is to manage various I/O devices including mouse, keyboards, touch pad, disk drives, display adapters, USB devices, Bit-mapped screen, LED, Analog-to-digital converter, On/off switch, network connections, audio I/O, printers etc. An I/O system is required to take an application I/O request and send it to the physical device, then take whatever response comes back from the device and send it to the application. I/O devices can be divided into two categories ? Block devices ? A block device is one with which the driver communicates by sending entire blocks of data. For example, Hard disks, USB cameras, Disk-On-Key etc. Character devices ? A character device is one with which the driver communicates by sending and receiving single characters (bytes, octets). For example, serial ports, parallel ports, sounds cards etc Device Controllers Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. The Device Controller works like an interface between a device and a device driver. I/O units (Keyboard, mouse, printer, etc.) typically consist of a mechanical component and an electronic component where electronic component is called the device controller. There is always a device controller and a device driver for each device to communicate with the Operating Systems. A device controller may be able to handle multiple devices. As an interface its main task is to convert serial bit stream to block of bytes, perform error correction as necessary. Any device connected to the computer is connected by a plug and socket, and the socket is connected to a device controller. Following is a model for connecting the CPU, memory, controllers, and I/O devices where CPU and device controllers all use a common bus for communication. Synchronous vs asynchronous I/O Synchronous I/O ? In this scheme CPU execution waits while I/O proceeds Asynchronous I/O ? I/O proceeds concurrently with CPU execution Communication to I/O Devices The CPU must have a way to pass information to and from an I/O device. There are three approaches available to communicate with the CPU and Device. Special Instruction I/O Memory-mapped I/O Direct memory access (DMA) Special Instruction I/O This uses CPU instructions that are specifically made for controlling I/O devices. These instructions typically allow data to be sent to an I/O device or read from an I/O device. Memory-mapped I/O When using memory-mapped I/O, the same address space is shared by memory and I/O devices. The device is connected directly to certain main memory locations so that I/O device can transfer block of data to/from memory without going through CPU. While using memory mapped IO, OS allocates buffer in memory and informs I/O device to use that buffer to send data to the CPU. I/O device operates asynchronously with CPU, interrupts CPU when finished. The advantage to this method is that every instruction which can access memory can be used to manipulate an I/O device. Memory mapped IO is used for most high-speed I/O devices like disks, communication interfaces. Direct Memory Access (DMA) Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead. Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred. Direct Memory Access needs a special hardware called DMA controller (DMAC) that manages the data transfers and arbitrates access to the system bus. The controllers are programmed with source and destination pointers (where to read/write the data), counters to track the number of transferred bytes, and settings, which includes I/O and memory types, interrupts and states for the CPU cycles. The operating system uses the DMA hardware as follows ? Step Description 1 Device driver is instructed to transfer disk data to a buffer address X. 2 Device driver then instruct disk controller to transfer data to buffer. 3 Disk controller starts DMA transfer. 4 Disk controller sends each byte to DMA controller. 5 DMA controller transfers bytes to buffer, increases the memory address, decreases the counter C until C becomes zero. 6 When C becomes zero, DMA interrupts CPU to signal transfer completion. Polling vs Interrupts I/O A computer must have a way of detecting the arrival of any type of input. There are two ways that this can happen, known as polling and interrupts. Both of these techniques allow the processor to deal with events that can happen at any time and that are not related to the process it is currently running. Polling I/O Polling is the simplest way for an I/O device to communicate with the processor. The process of periodically checking status of the device to see if it is time for the next I/O operation, is called polling. The I/O device simply puts the information in a Status register, and the processor must come and get the information. Most of the time, devices will not require attention and when one does it will have to wait until it is next interrogated by the polling program. This is an inefficient method and much of the processors time is wasted on unnecessary polls. Compare this method to a teacher continually asking every student in a class, one after another, if they need help. Obviously the more efficient method would be for a student to inform the teacher whenever they require assistance. Interrupts I/O An alternative scheme for dealing with I/O is the interrupt-driven method. An interrupt is a signal to the microprocessor from a device that requires attention. A device controller puts an interrupt signal on the bus when it needs CPUs attention when CPU receives an interrupt, It saves its current state and invokes the appropriate interrupt handler using the interrupt vector (addresses of OS routines to handle various events). When the interrupting device has been dealt with, the CPU continues with its original task as if it had never been interrupted. Operating System - I/O Softwares I/O software is often organized in the following layers ? User Level Libraries ? This provides simple interface to the user program to perform input and output. For example, stdio is a library provided by C and C++ programming languages. Kernel Level Modules ? This provides device driver to interact with the device controller and device independent I/O modules used by the device drivers. Hardware ? This layer includes actual hardware and hardware controller which interact with the device drivers and makes hardware alive. A key concept in the design of I/O software is that it should be device independent where it should be possible to write programs that can access any I/O device without having to specify the device in advance. For example, a program that reads a file as input should be able to read a file on a floppy disk, on a hard disk, or on a CD-ROM, without having to modify the program for each different device. Device Drivers Device drivers are software modules that can be plugged into an OS to handle a particular device. Operating System takes help from device drivers to handle all I/O devices. Device drivers encapsulate device-dependent code and implement a standard interface in such a way that code contains device-specific register reads/writes. Device driver, is generally written by the device's manufacturer and delivered along with the device on a CD-ROM. A device driver performs the following jobs ? To accept request from the device independent software above to it. Interact with the device controller to take and give I/O and perform required error handling Making sure that the request is executed successfully How a device driver handles a request is as follows: Suppose a request comes to read a block N. If the driver is idle at the time a request arrives, it starts carrying out the request immediately. Otherwise, if the driver is already busy with some other request, it places the new request in the queue of pending requests. Interrupt handlers An interrupt handler, also known as an interrupt service routine or ISR, is a piece of software or more specifically a callback function in an operating system or more specifically in a device driver, whose execution is triggered by the reception of an interrupt. When the interrupt happens, the interrupt procedure does whatever it has to in order to handle the interrupt, updates data structures and wakes up process that was waiting for an interrupt to happen. The interrupt mechanism accepts an address ? a number that selects a specific interrupt handling routine/function from a small set. In most architectures, this address is an offset stored in a table called the interrupt vector table. This vector contains the memory addresses of specialized interrupt handlers. Device-Independent I/O Software The basic function of the device-independent software is to perform the I/O functions that are common to all devices and to provide a uniform interface to the user-level software. Though it is difficult to write completely device independent software but we can write some modules which are common among all the devices. Following is a list of functions of device-independent I/O Software ? Uniform interfacing for device drivers Device naming - Mnemonic names mapped to Major and Minor device numbers Device protection Providing a device-independent block size Buffering because data coming off a device cannot be stored in final destination. Storage allocation on block devices Allocation and releasing dedicated devices Error Reporting User-Space I/O Software These are the libraries which provide richer and simplified interface to access the functionality of the kernel or ultimately interactive with the device drivers. Most of the user-level I/O software consists of library procedures with some exception like spooling system which is a way of dealing with dedicated I/O devices in a multiprogramming system. I/O Libraries (e.g., stdio) are in user-space to provide an interface to the OS resident device-independent I/O SW. For example putchar(), getchar(), printf() and scanf() are example of user level I/O library stdio available in C programming. Kernel I/O Subsystem Kernel I/O Subsystem is responsible to provide many services related to I/O. Following are some of the services provided. Scheduling ? Kernel schedules a set of I/O requests to determine a good order in which to execute them. When an application issues a blocking I/O system call, the request is placed on the queue for that device. The Kernel I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by the applications. Buffering ? Kernel I/O Subsystem maintains a memory area known as buffer that stores data while they are transferred between two devices or between a device with an application operation. Buffering is done to cope with a speed mismatch between the producer and consumer of a data stream or to adapt between devices that have different data transfer sizes. Caching ? Kernel maintains cache memory which is region of fast memory that holds copies of data. Access to the cached copy is more efficient than access to the original. Spooling and Device Reservation ? A spool is a buffer that holds output for a device, such as a printer, that cannot accept interleaved data streams. The spooling system copies the queued spool files to the printer one at a time. In some operating systems, spooling is managed by a system daemon process. In other operating systems, it is handled by an in kernel thread. Error Handling ? An operating system that uses protected memory can guard against many kinds of hardware and application errors. Operating System - File System File A file is a named collection of related information that is recorded on secondary storage such as magnetic disks, magnetic tapes and optical disks. In general, a file is a sequence of bits, bytes, lines or records whose meaning is defined by the files creator and user. File Structure A File Structure should be according to a required format that the operating system can understand. A file has a certain defined structure according to its type. A text file is a sequence of characters organized into lines. A source file is a sequence of procedures and functions. An object file is a sequence of bytes organized into blocks that are understandable by the machine. When operating system defines different file structures, it also contains the code to support these file structure. Unix, MS-DOS support minimum number of file structure. File Type File type refers to the ability of the operating system to distinguish different types of file such as text files source files and binary files etc. Many operating systems support many types of files. Operating system like MS-DOS and UNIX have the following types of files ? Ordinary files These are the files that contain user information. These may have text, databases or executable program. The user can apply various operations on such files like add, modify, delete or even remove the entire file. Directory files These files contain list of file names and other information related to these files. Special files These files are also known as device files. These files represent physical device like disks, terminals, printers, networks, tape drive etc. These files are of two types ? Character special files ? data is handled character by character as in case of terminals or printers. Block special files ? data is handled in blocks as in the case of disks and tapes. File Access Mechanisms File access mechanism refers to the manner in which the records of a file may be accessed. There are several ways to access files ? Sequential access Direct/Random access Indexed sequential access Sequential access A sequential access is that in which the records are accessed in some sequence, i.e., the information in the file is processed in order, one record after the other. This access method is the most primitive one. Example: Compilers usually access files in this fashion. Direct/Random access Random access file organization provides, accessing the records directly. Each record has its own address on the file with by the help of which it can be directly accessed for reading or writing. The records need not be in any sequence within the file and they need not be in adjacent locations on the storage medium. Indexed sequential access This mechanism is built up on base of sequential access. An index is created for each file which contains pointers to various blocks. Index is searched sequentially and its pointer is used to access the file directly. Space Allocation Files are allocated disk spaces by operating system. Operating systems deploy following three main ways to allocate disk space to files. Contiguous Allocation Linked Allocation Indexed Allocation Contiguous Allocation Each file occupies a contiguous address space on disk. Assigned disk address is in linear order. Easy to implement. External fragmentation is a major issue with this type of allocation technique. Linked Allocation Each file carries a list of links to disk blocks. Directory contains link / pointer to first block of a file. No external fragmentation Effectively used in sequential access file. Inefficient in case of direct access file. Indexed Allocation Provides solutions to problems of contigous and linked allocation. A index block is created having all pointers to files. Each file has its own index block which stores the addresses of disk space occupied by the file. Directory contains the addresses of index blocks of files. Operating System - Security Security refers to providing a protection system to computer system resources such as CPU, memory, disk, software programs and most importantly data/information stored in the computer system. If a computer program is run by an unauthorized user, then he/she may cause severe damage to computer or data stored in it. So a computer system must be protected against unauthorized access, malicious access to system memory, viruses, worms etc. We're going to discuss following topics in this chapter. Authentication One Time passwords Program Threats System Threats Computer Security Classifications Authentication Authentication refers to identifying each user of the system and associating the executing programs with those users. It is the responsibility of the Operating System to create a protection system which ensures that a user who is running a particular program is authentic. Operating Systems generally identifies/authenticates users using following three ways ? Username / Password ? User need to enter a registered username and password with Operating system to login into the system. User card/key ? User need to punch card in card slot, or enter key generated by key generator in option provided by operating system to login into the system. User attribute - fingerprint/ eye retina pattern/ signature ? User need to pass his/her attribute via designated input device used by operating system to login into the system. One Time passwords One-time passwords provide additional security along with normal authentication. In One-Time Password system, a unique password is required every time user tries to login into the system. Once a one-time password is used, then it cannot be used again. One-time password are implemented in various ways. Random numbers ? Users are provided cards having numbers printed along with corresponding alphabets. System asks for numbers corresponding to few alphabets randomly chosen. Secret key ? User are provided a hardware device which can create a secret id mapped with user id. System asks for such secret id which is to be generated every time prior to login. Network password ? Some commercial applications send one-time passwords to user on registered mobile/ email which is required to be entered prior to login. Program Threats Operating system's processes and kernel do the designated task as instructed. If a user program made these process do malicious tasks, then it is known as Program Threats. One of the common example of program threat is a program installed in a computer which can store and send user credentials via network to some hacker. Following is the list of some well-known program threats. Trojan Horse ? Such program traps user login credentials and stores them to send to malicious user who can later on login to computer and can access system resources. Trap Door ? If a program which is designed to work as required, have a security hole in its code and perform illegal action without knowledge of user then it is called to have a trap door. Logic Bomb ? Logic bomb is a situation when a program misbehaves only when certain conditions met otherwise it works as a genuine program. It is harder to detect. Virus ? Virus as name suggest can replicate themselves on computer system. They are highly dangerous and can modify/delete user files, crash systems. A virus is generatlly a small code embedded in a program. As user accesses the program, the virus starts getting embedded in other files/ programs and can make system unusable for user System Threats System threats refers to misuse of system services and network connections to put user in trouble. System threats can be used to launch program threats on a complete network called as program attack. System threats creates such an environment that operating system resources/ user files are misused. Following is the list of some well-known system threats. Worm ? Worm is a process which can choked down a system performance by using system resources to extreme levels. A Worm process generates its multiple copies where each copy uses system resources, prevents all other processes to get required resources. Worms processes can even shut down an entire network. Port Scanning ? Port scanning is a mechanism or means by which a hacker can detects system vulnerabilities to make an attack on the system. Denial of Service ? Denial of service attacks normally prevents user to make legitimate use of the system. For example, a user may not be able to use internet if denial of service attacks browser's content settings. Computer Security Classifications As per the U.S. Department of Defense Trusted Computer System's Evaluation Criteria there are four security classifications in computer systems: A, B, C, and D. This is widely used specifications to determine and model the security of systems and of security solutions. Following is the brief description of each classification. S.N. Classification Type & Description 1 Type A Highest Level. Uses formal design specifications and verification techniques. Grants a high degree of assurance of process security. 2 Type B Provides mandatory protection system. Have all the properties of a class C2 system. Attaches a sensitivity label to each object. It is of three types. B1 ? Maintains the security label of each object in the system. Label is used for making decisions to access control. B2 ? Extends the sensitivity labels to each system resource, such as storage objects, supports covert channels and auditing of events. B3 ? Allows creating lists or user groups for access-control to grant access or revoke access to a given named object. 3 Type C Provides protection and user accountability using audit capabilities. It is of two types. C1 ? Incorporates controls so that users can protect their private information and keep other users from accidentally reading / deleting their data. UNIX versions are mostly Cl class. C2 ? Adds an individual-level access control to the capabilities of a Cl level system. 4 Type D Lowest level. Minimum protection. MS-DOS, Window 3.1 fall in this category. Operating System - Linux Linux is one of popular version of UNIX operating System. It is open source as its source code is freely available. It is free to use. Linux was designed considering UNIX compatibility. Its functionality list is quite similar to that of UNIX. Components of Linux System Linux Operating System has primarily three components Kernel ? Kernel is the core part of Linux. It is responsible for all major activities of this operating system. It consists of various modules and it interacts directly with the underlying hardware. Kernel provides the required abstraction to hide low level hardware details to system or application programs. System Library ? System libraries are special functions or programs using which application programs or system utilities accesses Kernel's features. These libraries implement most of the functionalities of the operating system and do not requires kernel module's code access rights. System Utility ? System Utility programs are responsible to do specialized, individual level tasks. Kernel Mode vs User Mode Kernel component code executes in a special privileged mode called kernel mode with full access to all resources of the computer. This code represents a single process, executes in single address space and do not require any context switch and hence is very efficient and fast. Kernel runs each processes and provides system services to processes, provides protected access to hardware to processes. Support code which is not required to run in kernel mode is in System Library. User programs and other system programs works in User Mode which has no access to system hardware and kernel code. User programs/ utilities use System libraries to access Kernel functions to get system's low level tasks. Basic Features Following are some of the important features of Linux Operating System. Portable ? Portability means software can works on different types of hardware in same way. Linux kernel and application programs supports their installation on any kind of hardware platform. Open Source ? Linux source code is freely available and it is community based development project. Multiple teams work in collaboration to enhance the capability of Linux operating system and it is continuously evolving. Multi-User ? Linux is a multiuser system means multiple users can access system resources like memory/ ram/ application programs at same time. Multiprogramming ? Linux is a multiprogramming system means multiple applications can run at same time. Hierarchical File System ? Linux provides a standard file structure in which system files/ user files are arranged. Shell ? Linux provides a special interpreter program which can be used to execute commands of the operating system. It can be used to do various types of operations, call application programs. etc. Security ? Linux provides user security using authentication features like password protection/ controlled access to specific files/ encryption of data. Architecture The following illustration shows the architecture of a Linux system ? The architecture of a Linux System consists of the following layers ? Hardware layer ? Hardware consists of all peripheral devices (RAM/ HDD/ CPU etc). Kernel ? It is the core component of Operating System, interacts directly with hardware, provides low level services to upper layer components. Shell ? An interface to kernel, hiding complexity of kernel's functions from users. The shell takes commands from the user and executes kernel's functions. Utilities ? Utility programs that provide the user most of the functionalities of an operating systems. Previous Page Print Next Page   Advertisements Write for us FAQ's Helping Contact © Copyright 2017. All Rights Reserved. go
