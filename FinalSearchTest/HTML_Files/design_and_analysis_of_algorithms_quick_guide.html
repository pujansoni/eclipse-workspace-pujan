<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:19:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>Design and Analysis of Algorithms Quick Guide</title>
<meta name="description" content="Design and Analysis of Algorithms Quick Guide - Learn Design and Analysis of Algorithms in simple and easy steps starting from basic to advanced concepts with examples including Introduction, Analysis of Algorithms, Methodology, Asymptotic Notations and Apriori, Space Complexities, Divide and Conquer, Max-Min Problem, Merge Sort, Binary Search, Strassen’s Matrix Multiplication, Greedy Method, Fractional Knapsack, Job Sequencing with Deadline, Optimal Merge Pattern, Dynamic Programming, 0-1 Knapsack, Longest Common Subsequence, Spanning Tree, Shortest Paths, Multistage Graph, Travelling Salesman Problem, Optimal Cost Binary Search Trees, Binary Heap, Insert Method, Heapify Method, Extract Method, Bubble Sort, Insertion Sort, Selection Sort, Quick Sort, Radix Sort, Deterministic vs. Nondeterministic Computations, Max Cliques, Vertex Cover, P and NP Class, Cook’s Theorem, NP Hard and NP-Complete Classes, Hill Climbing Algorithm." />
<meta name="keywords" content="Design and Analysis of Algorithms, Tutorial, Introduction, Analysis of Algorithms, Methodology, Asymptotic Notations and Apriori, Space Complexities, Divide and Conquer, Max-Min Problem, Merge Sort, Binary Search, Strassen’s Matrix Multiplication, Greedy Method, Fractional Knapsack, Job Sequencing with Deadline, Optimal Merge Pattern, Dynamic Programming, 0-1 Knapsack, Longest Common Subsequence, Spanning Tree, Shortest Paths, Multistage Graph, Travelling Salesman Problem, Optimal Cost Binary Search Trees, Binary Heap, Insert Method, Heapify Method, Extract Method, Bubble Sort, Insertion Sort, Selection Sort, Quick Sort, Radix Sort, Deterministic vs. Nondeterministic Computations, Max Cliques, Vertex Cover, P and NP Class, Cook’s Theorem, NP Hard and NP-Complete Classes, Hill Climbing Algorithm." />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
"HTML-CSS": {
linebreaks: { automatic: true, width: "container" }
}
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<base  />
<link rel="shortcut icon" href="https://www.tutorialspoint.com/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="https://www.tutorialspoint.com/theme/css/style-min.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #711e1e url(https://www.tutorialspoint.com/images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #711e1e !important;}
.submenu-item{ border-bottom: 2px solid #711e1e !important; border-top: 2px solid #711e1e !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="https://www.tutorialspoint.com/images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="https://www.tutorialspoint.com/index.htm" title="tutorialspoint">
      <img alt="tutorialspoint" src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="https://www.tutorialspoint.com/about/about_careers.htm" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="https://www.tutorialspoint.com/whiteboard.htm"><img src="https://www.tutorialspoint.com/theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="https://www.tutorialspoint.com/netmeeting.php"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="https://www.tutorialspoint.com/online_dev_tools.htm"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="https://www.tutorialspoint.com/articles/index.php"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="https://www.tutorialspoint.com/index.htm"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/codingground.htm"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/tutor_connect/index.php"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/design-and-analysis-of-algorithms-mini-logo.jpg" alt="Design and Analysis of Algorithms Tutorial" />
</div>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Design and Analysis of Algorithms</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/index.htm">Home</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Basics of Algorithms</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_introduction.htm">DAA - Introduction</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/analysis_of_algorithms.htm">DAA - Analysis of Algorithms</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_methodology.htm">DAA - Methodology of Analysis</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_asymptotic_notations_apriori.htm">Asymptotic Notations &amp; Apriori Analysis</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_space_complexities.htm">DAA - Space Complexities</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Design Strategies</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_divide_conquer.htm">DAA - Divide &amp; Conquer</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_max_min_problem.htm">DAA - Max-Min Problem</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_merge_sort.htm">DAA - Merge Sort</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_binary_search.htm">DAA - Binary Search</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_strassens_matrix_multiplication.htm">Strassen’s Matrix Multiplication</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_greedy_method.htm">DAA - Greedy Method</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_fractional_knapsack.htm">DAA - Fractional Knapsack</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_job_sequencing_with_deadline.htm">DAA - Job Sequencing with Deadline</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_optimal_merge_pattern.htm">DAA - Optimal Merge Pattern</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_dynamic_programming.htm">DAA - Dynamic Programming</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_01_knapsack.htm">DAA - 0-1 Knapsack</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_longest_common_subsequence.htm">Longest Common Subsequence</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Graph Theory</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_spanning_tree.htm">DAA - Spanning Tree</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_shortest_paths.htm">DAA - Shortest Paths</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_multistage_graph.htm">DAA - Multistage Graph</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_travelling_salesman_problem.htm">Travelling Salesman Problem</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_optimal_cost_binary_search_trees.htm">Optimal Cost Binary Search Trees</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Heap Algorithms</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_binary_heap.htm">DAA - Binary Heap</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_insert_method.htm">DAA - Insert Method</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_heapify_method.htm">DAA - Heapify Method</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_extract_method.htm">DAA - Extract Method</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Sorting Methods</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_bubble_sort.htm">DAA - Bubble Sort</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_insertion_sort.htm">DAA - Insertion Sort</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_selection_sort.htm">DAA - Selection Sort</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_sort.htm">DAA - Quick Sort</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_radix_sort.htm">DAA - Radix Sort</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Complexity Theory</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_deterministic_vs_nondeterministic_computations.htm">Deterministic vs. Nondeterministic Computations</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_max_cliques.htm">DAA - Max Cliques</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_vertex_cover.htm">DAA - Vertex Cover</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_p_np_class.htm">DAA - P and NP Class</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_cooks_theorem.htm">DAA - Cook’s Theorem</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_np_hard_complete_classes.htm">NP Hard &amp; NP-Complete Classes</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_hill_climbing.htm">DAA - Hill Climbing Algorithm</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">DAA Useful Resources</li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm">DAA - Quick Guide</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_useful_resources.htm">DAA - Useful Resources</a></li>
<li><a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_discussion.htm">DAA - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="https://www.tutorialspoint.com/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>DAA - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_hill_climbing.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>DAA - Introduction</h1>
<p>An algorithm is a set of steps of operations to solve a problem performing calculation, data processing, and automated reasoning tasks. An algorithm is an efficient method that can be expressed within finite amount of time and space.</p>
<p>An algorithm is the best way to represent the solution of a particular problem in a very simple and efficient way. If we have an algorithm for a specific problem, then we can implement it in any programming language, meaning that the <b>algorithm is independent from any programming languages</b>.</p>
<h2>Algorithm Design</h2>
<p>The important aspects of algorithm design include creating an efficient algorithm to solve a problem in an efficient way using minimum time and space.</p>
<p>To solve a problem, different approaches can be followed. Some of them can be efficient with respect to time consumption, whereas other approaches may be memory efficient. However, one has to keep in mind that both time consumption and memory usage cannot be optimized simultaneously. If we require an algorithm to run in lesser time, we have to invest in more memory and if we require an algorithm to run with lesser memory, we need to have more time.</p>
<h2>Problem Development Steps</h2>
<p>The following steps are involved in solving computational problems.</p>
<ul class="list">
<li>Problem definition</li>
<li>Development of a model</li>
<li>Specification of an Algorithm</li>
<li>Designing an Algorithm</li>
<li>Checking the correctness of an Algorithm</li>
<li>Analysis of an Algorithm</li>
<li>Implementation of an Algorithm</li>
<li>Program testing</li>
<li>Documentation</li>
</ul>
<h2>Characteristics of Algorithms</h2>
<p>The main characteristics of algorithms are as follows &minus;</p>
<ul class="list">
<li><p>Algorithms must have a unique name</p></li>
<li><p>Algorithms should have explicitly defined set of inputs and outputs</p></li>
<li><p>Algorithms are well-ordered with unambiguous operations</p></li>
<li><p>Algorithms halt in a finite amount of time. Algorithms should not run for infinity, i.e., an algorithm must end at some point</p></li>
</ul>
<h2>Pseudocode</h2>
<p>Pseudocode gives a high-level description of an algorithm without the ambiguity associated with plain text but also without the need to know the syntax of a particular programming language.</p>
<p>The running time can be estimated in a more general manner by using Pseudocode to represent the algorithm as a set of fundamental operations which can then be counted.</p>
<h2>Difference between Algorithm and Pseudocode</h2>
<p>An algorithm is a formal definition with some specific characteristics that describes a process, which could be executed by a Turing-complete computer machine to perform a specific task. Generally, the word "algorithm" can be used to describe any high level task in computer science.</p>
<p>On the other hand, pseudocode is an informal and (often rudimentary) human readable description of an algorithm leaving many granular details of it. Writing a pseudocode has no restriction of styles and its only objective is to describe the high level steps of algorithm in a much realistic manner in natural language.</p>
<p>For example, following is an algorithm for Insertion Sort.</p>
<pre class="result notranslate">
<b>Algorithm: Insertion-Sort</b> 
Input: A list L of integers of length n  
Output: A sorted list L1 containing those integers present in L 
Step 1: Keep a sorted list L1 which starts off empty  
Step 2: Perform Step 3 for each element in the original list L  
Step 3: Insert it into the correct position in the sorted list L1.  
Step 4: Return the sorted list 
Step 5: Stop
</pre>
<p>Here is a pseudocode which describes how the high level abstract process mentioned above in the algorithm Insertion-Sort could be described in a more realistic way.</p>
<pre class="result notranslate">
for i &lt;- 1 to length(A) 
   x &lt;- A[i] 
   j &lt;- i 
   while j &gt; 0 and A[j-1] &gt; x 
      A[j] &lt;- A[j-1] 
      j &lt;- j - 1 
   A[j] &lt;- x
</pre>
<p>In this tutorial, algorithms will be presented in the form of pseudocode, that is similar in many respects to C, C++, Java, Python, and other programming languages.</p>
<h1>DAA - Analysis of Algorithms</h1>
<p>In theoretical analysis of algorithms, it is common to estimate their complexity in the asymptotic sense, i.e., to estimate the complexity function for arbitrarily large input. The term <b>"analysis of algorithms"</b> was coined by Donald Knuth.</p>
<p>Algorithm analysis is an important part of computational complexity theory, which provides theoretical estimation for the required resources of an algorithm to solve a specific computational problem. Most algorithms are designed to work with inputs of arbitrary length. Analysis of algorithms is the determination of the amount of time and space resources required to execute it.</p>
<p>Usually, the efficiency or running time of an algorithm is stated as a function relating the input length to the number of steps, known as <b>time complexity</b>, or volume of memory, known as <b>space complexity</b>.</p>
<h2>The Need for Analysis</h2>
<p>In this chapter, we will discuss the need for analysis of algorithms and how to choose a better algorithm for a particular problem as one computational problem can be solved by different algorithms.</p>
<p>By considering an algorithm for a specific problem, we can begin to develop pattern recognition so that similar types of problems can be solved by the help of this algorithm.</p>
<p>Algorithms are often quite different from one another, though the objective of these algorithms are the same. For example, we know that a set of numbers can be sorted using different algorithms. Number of comparisons performed by one algorithm may vary with others for the same input. Hence, time complexity of those algorithms may differ. At the same time, we need to calculate the memory space required by each algorithm.</p>
<p>Analysis of algorithm is the process of analyzing the problem-solving capability of the algorithm in terms of the time and size required (the size of memory for storage while implementation). However, the main concern of analysis of algorithms is the required time or performance. Generally, we perform the following types of analysis &minus;</p>
<ul class="list">
<li><p><b>Worst-case</b> &minus; The maximum number of steps taken on any instance of size <b>a</b>.</p></li>
<li><p><b>Best-case</b> &minus; The minimum number of steps taken on any instance of size <b>a</b>.</p></li>
<li><p><b>Average case</b> &minus; An average number of steps taken on any instance of size <b>a</b>.</p></li>
<li><p><b>Amortized</b> &minus; A sequence of operations applied to the input of size <b>a</b> averaged over time.</p></li>
</ul>
<p>To solve a problem, we need to consider time as well as space complexity as the program may run on a system where memory is limited but adequate space is available or may be vice-versa. In this context, if we compare <b>bubble sort</b> and <b>merge sort</b>. Bubble sort does not require additional memory, but merge sort requires additional space. Though time complexity of bubble sort is higher compared to merge sort, we may need to apply bubble sort if the program needs to run in an environment, where memory is very limited.</p>
<h1>DAA - Methodology of Analysis</h1>
<p>To measure resource consumption of an algorithm, different strategies are used as discussed in this chapter.</p>
<h2>Asymptotic Analysis</h2>
<p>The asymptotic behavior of a function <b><i>f(n)</i></b> refers to the growth of <b><i>f(n)</i></b> as <b>n</b> gets large.</p>
<p>We typically ignore small values of <b>n</b>, since we are usually interested in estimating how slow the program will be on large inputs.</p>
<p>A good rule of thumb is that the slower the asymptotic growth rate, the better the algorithm. Though it’s not always true.</p>
<p>For example, a linear algorithm $f(n) = d * n + k$ is always asymptotically better than a quadratic one, $f(n) = c.n^2 + q$.</p>
<h2>Solving Recurrence Equations</h2>
<p>A recurrence is an equation or inequality that describes a function in terms of its value on smaller inputs. Recurrences are generally used in divide-and-conquer paradigm.</p>
<p>Let us consider <b><i>T(n)</i></b> to be the running time on a problem of size <b>n</b>.</p>
<p>If the problem size is small enough, say <b><i>n &lt; c</i></b> where <b>c</b> is a constant, the straightforward solution takes constant time, which is written as <b>&theta;(1)</b>. If the division of the problem yields a number of sub-problems with size $\frac{n}{b}$.</p>
<p>To solve the problem, the required time is <b><i>a.T(n/b)</i></b>. If we consider the time required for division is <b><i>D(n)</i></b> and the time required for combining the results of sub-problems is <b><i>C(n)</i></b>, the recurrence relation can be represented as &minus;</p>
<p>$$T(n)=\begin{cases}\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\:\theta(1) & if\:n\leqslant c\\a T(\frac{n}{b})+D(n)+C(n) & otherwise\end{cases}$$</p>
<p>A recurrence relation can be solved using the following methods &minus;</p>
<ul class="list">
<li><p><b>Substitution Method</b> &minus; In this method, we guess a bound and using mathematical induction we prove that our assumption was correct.</p></li>
<li><p><b>Recursion Tree Method</b> &minus; In this method, a recurrence tree is formed where each node represents the cost.</p></li> 
<li><p><b>Master’s Theorem</b> &minus; This is another important technique to find the complexity of a recurrence relation.</p></li>
</ul>
<h2>Amortized Analysis</h2>
<p>Amortized analysis is generally used for certain algorithms where a sequence of similar operations are performed.</p>
<ul class="list">
<li><p>Amortized analysis provides a bound on the actual cost of the entire sequence, instead of bounding the cost of sequence of operations separately.</p></li>
<li><p>Amortized analysis differs from average-case analysis; probability is not involved in amortized analysis. Amortized analysis guarantees the average performance of each operation in the worst case.</p></li>
</ul>
<p>It is not just a tool for analysis, it’s a way of thinking about the design, since designing and analysis are closely related.</p>
<h3>Aggregate Method</h3>
<p>The aggregate method gives a global view of a problem. In this method, if <b>n</b> operations takes worst-case time <b><i>T(n)</i></b> in total. Then the amortized cost of each operation is <b><i>T(n)/n</i></b>. Though different operations may take different time, in this method varying cost is neglected.</p>
<h3>Accounting Method</h3>
<p>In this method, different charges are assigned to different operations according to their actual cost. If the amortized cost of an operation exceeds its actual cost, the difference is assigned to the object as credit. This credit helps to pay for later operations for which the amortized cost less than actual cost.</p>
<p>If the actual cost and the amortized cost of <b>i<sup>th</sup></b> operation are $c_{i}$ and $\hat{c_{l}}$, then</p>
<p>$$\displaystyle\sum\limits_{i=1}^n \hat{c_{l}}\geqslant\displaystyle\sum\limits_{i=1}^n c_{i}$$</p>
<h3>Potential Method</h3>
<p>This method represents the prepaid work as potential energy, instead of considering prepaid work as credit. This energy can be released to pay for future operations.</p>
<p>If we perform <b><i>n</i></b> operations starting with an initial data structure <b><i>D<sub>0</sub></i></b>. Let us consider, <b><i>c<sub>i</sub></i></b> as the actual cost and <b><i>D<sub>i</sub></i></b> as data structure of <b>i<sup>th</sup></b> operation. The potential function &#1060; maps to a real number &#1060;(<b><i>D<sub>i</sub></i></b>), the associated potential of <b><i>D<sub>i</sub></i></b>. The amortized cost $\hat{c_{l}}$ can be defined by</p>
<p>$$\hat{c_{l}}=c_{i}+\Phi (D_{i})-\Phi (D_{i-1})$$</p>
<p>Hence, the total amortized cost is</p>
<p>$$\displaystyle\sum\limits_{i=1}^n \hat{c_{l}}=\displaystyle\sum\limits_{i=1}^n (c_{i}+\Phi (D_{i})-\Phi (D_{i-1}))=\displaystyle\sum\limits_{i=1}^n c_{i}+\Phi (D_{n})-\Phi (D_{0})$$</p>
<h3>Dynamic Table</h3>
<p>If the allocated space for the table is not enough, we must copy the table into larger size table. Similarly, if large number of members are erased from the table, it is a good idea to reallocate the table with a smaller size.</p>
<p>Using amortized analysis, we can show that the amortized cost of insertion and deletion is constant and unused space in a dynamic table never exceeds a constant fraction of the total space.</p>
<p>In the next chapter of this tutorial, we will discuss Asymptotic Notations in brief.</p>
<h1>Asymptotic Notations and Apriori Analysis</h1>
<p>In designing of Algorithm, complexity analysis of an algorithm is an essential aspect. Mainly, algorithmic complexity is concerned about its performance, how fast or slow it works.</p>
<p>The complexity of an algorithm describes the efficiency of the algorithm in terms of the amount of the memory required to process the data and the processing time.</p>
<p>Complexity of an algorithm is analyzed in two perspectives: <b>Time</b> and <b>Space</b>.</p>
<h3>Time Complexity</h3>
<p>It’s a function describing the amount of time required to run an algorithm in terms of the size of the input. "Time" can mean the number of memory accesses performed, the number of comparisons between integers, the number of times some inner loop is executed, or some other natural unit related to the amount of real time the algorithm will take.</p>
<h3>Space Complexity</h3>
<p>It’s a function describing the amount of memory an algorithm takes in terms of the size of input to the algorithm. We often speak of "extra" memory needed, not counting the memory needed to store the input itself. Again, we use natural (but fixed-length) units to measure this.</p>
<p>Space complexity is sometimes ignored because the space used is minimal and/or obvious, however sometimes it becomes as important an issue as time.</p>
<h2>Asymptotic Notations</h2>
<p>Execution time of an algorithm depends on the instruction set, processor speed, disk I/O speed, etc. Hence, we estimate the efficiency of an algorithm asymptotically.</p>
<p>Time function of an algorithm is represented by <b>T(n)</b>, where <b>n</b> is the input size.</p>
<p>Different types of asymptotic notations are used to represent the complexity of an algorithm. Following asymptotic notations are used to calculate the running time complexity of an algorithm.</p>
<ul class="list">
<li><p><b>O</b> &minus; Big Oh</p></li>
<li><p><b>&Omega;</b> &minus; Big omega</p></li>
<li><p><b>&theta;</b> &minus; Big theta</p></li>
<li><p><b>o</b> &minus; Little Oh</p></li>
<li><p><b>&omega;</b> &minus; Little omega</p></li>
</ul>
<h2>O: Asymptotic Upper Bound</h2>
<p>‘O’ (Big Oh) is the most commonly used notation. A function <b><i>f(n)</i></b> can be represented is the order of <b><i>g(n)</i></b> that is <b><i>O(g(n))</i></b>, if there exists a value of positive integer <b>n</b> as <b>n<sub>0</sub></b> and a positive constant <b>c</b> such that &minus;</p>
<p style="padding-left:25%">$f(n)\leqslant c.g(n)$ for $n > n_{0}$ in all case</p>
<p>Hence, function <b><i>g(n)</i></b> is an upper bound for function <b><i>f(n)</i></b>, as <b><i>g(n)</i></b> grows faster than <b><i>f(n)</i></b>.</p>
<h3>Example</h3>
<p>Let us consider a given function, $f(n) = 4.n^3 + 10.n^2 + 5.n + 1$</p>
<p>Considering $g(n) = n^3$,</p>
<p style="padding-left:25%">$f(n)\leqslant 5.g(n)$ for all the values of $n > 2$</p>
<p>Hence, the complexity of <b><i>f(n)</i></b> can be represented as $O(g(n))$, i.e. $O(n^3)$</p>
<h2>&Omega;: Asymptotic Lower Bound</h2>
<p>We say that $f(n) = \Omega (g(n))$ when there exists constant <b>c</b> that $f(n)\geqslant c.g(n)$ for all sufficiently large value of <b>n</b>. Here <b>n</b> is a positive integer. It means function <b><i>g</i></b> is a lower bound for function <b><i>f</i></b>; after a certain value of <b><i>n, f</i></b> will never go below <b><i>g</i></b>.</p>
<h3>Example</h3>
<p>Let us consider a given function, $f(n) = 4.n^3 + 10.n^2 + 5.n + 1$.</p>
<p>Considering $g(n) = n^3$, $f(n)\geqslant 4.g(n)$ for all the values of $n > 0$.</p>
<p>Hence, the complexity of <b><i>f(n)</i></b> can be represented as $\Omega (g(n))$, i.e. $\Omega (n^3)$</p>
<h2>&theta;: Asymptotic Tight Bound</h2>
<p>We say that $f(n) = \theta(g(n))$ when there exist constants <b>c<sub>1</sub></b> and <b>c<sub>2</sub></b> that $c_{1}.g(n) \leqslant f(n) \leqslant c_{2}.g(n)$ for all sufficiently large value of <b>n</b>. Here <b>n</b> is a positive integer.</p>
<p>This means function <b>g</b> is a tight bound for function <b>f</b>.</p>
<h3>Example</h3>
<p>Let us consider a given function, $f(n) = 4.n^3 + 10.n^2 + 5.n + 1$</p>
<p>Considering $g(n) = n^3$, $4.g(n) \leqslant f(n) \leqslant 5.g(n)$ for all the large values of <b>n</b>.</p>
<p>Hence, the complexity of <b><i>f(n)</i></b> can be represented as $\theta (g(n))$, i.e. $\theta (n^3)$.</p>
<h2>O - Notation</h2>
<p>The asymptotic upper bound provided by <b>O-notation</b> may or may not be asymptotically tight. The bound $2.n^2 = O(n^2)$ is asymptotically tight, but the bound $2.n = O(n^2)$ is not.</p>
<p>We use <b>o-notation</b> to denote an upper bound that is not asymptotically tight.</p>
<p>We formally define <b><i>o(g(n))</i></b> (little-oh of g of n) as the set <b><i>f(n) = o(g(n))</i></b> for any positive constant $c > 0$ and there exists a value $n_{0} > 0$, such that $0 \leqslant f(n) \leqslant c.g(n)$.</p>
<p>Intuitively, in the <b>o-notation</b>, the function <b><i>f(n)</i></b> becomes insignificant relative to <b><i>g(n)</i></b> as <b>n</b> approaches infinity; that is,</p>
<p>$$\lim_{n \rightarrow \infty}\left(\frac{f(n)}{g(n)}\right) = 0$$</p>
<h3>Example</h3>
<p>Let us consider the same function, $f(n) = 4.n^3 + 10.n^2 + 5.n + 1$</p>
<p>Considering $g(n) = n^{4}$,</p>
<p>$$\lim_{n \rightarrow \infty}\left(\frac{4.n^3 + 10.n^2 + 5.n + 1}{n^4}\right) = 0$$</p>
<p>Hence, the complexity of <b><i>f(n)</i></b> can be represented as $o(g(n))$, i.e. $o(n^4)$.</p>
<h2>&omega; – Notation</h2>
<p>We use <b>&omega;-notation</b> to denote a lower bound that is not asymptotically tight. Formally, however, we define <b><i>&omega;(g(n))</i></b> (little-omega of g of n) as the set <b><i>f(n) = &omega;(g(n))</i></b> for any positive constant <b><i>C &gt; 0</i></b> and there exists a value $n_{0} > 0$, such that $0 \leqslant c.g(n) < f(n)$.</p>
<p>For example, $\frac{n^2}{2} = \omega (n)$, but $\frac{n^2}{2} \neq \omega (n^2)$. The relation $f(n) = \omega (g(n))$ implies that the following limit exists</p>
<p>$$\lim_{n \rightarrow \infty}\left(\frac{f(n)}{g(n)}\right) = \infty$$</p>
<p>That is, <b><i>f(n)</i></b> becomes arbitrarily large relative to <b><i>g(n)</i></b> as <b>n</b> approaches infinity.</p>
<h3>Example</h3>
<p>Let us consider same function, $f(n) = 4.n^3 + 10.n^2 + 5.n + 1$</p>
<p>Considering $g(n) = n^2$,</p>
<p>$$\lim_{n \rightarrow \infty}\left(\frac{4.n^3 + 10.n^2 + 5.n + 1}{n^2}\right) = \infty$$</p>
<p>Hence, the complexity of <b><i>f(n)</i></b> can be represented as $o(g(n))$, i.e. $\omega (n^2)$.</p>
<h2>Apriori and Apostiari Analysis</h2>
<p>Apriori analysis means, analysis is performed prior to running it on a specific system. This analysis is a stage where a function is defined using some theoretical model. Hence, we determine the time and space complexity of an algorithm by just looking at the algorithm rather than running it on a particular system with a different memory, processor, and compiler.</p>
<p>Apostiari analysis of an algorithm means we perform analysis of an algorithm only after running it on a system. It directly depends on the system and changes from system to system.</p>
<p>In an industry, we cannot perform Apostiari analysis as the software is generally made for an anonymous user, which runs it on a system different from those present in the industry.</p>
<p>In Apriori, it is the reason that we use asymptotic notations to determine time and space complexity as they change from computer to computer; however, asymptotically they are the same.</p>
<h1>DAA - Space Complexities</h1>
<p>In this chapter, we will discuss the complexity of computational problems with respect to the amount of space an algorithm requires.</p>
<p>Space complexity shares many of the features of time complexity and serves as a further way of classifying problems according to their computational difficulties.</p>
<h2>What is Space Complexity?</h2>
<p>Space complexity is a function describing the amount of memory (space) an algorithm takes in terms of the amount of input to the algorithm.</p>
<p>We often speak of <b>extra memory</b> needed, not counting the memory needed to store the input itself. Again, we use natural (but fixed-length) units to measure this.</p>
<p>We can use bytes, but it's easier to use, say, the number of integers used, the number of fixed-sized structures, etc.</p>
<p>In the end, the function we come up with will be independent of the actual number of bytes needed to represent the unit.</p>
<p>Space complexity is sometimes ignored because the space used is minimal and/or obvious, however sometimes it becomes as important issue as time complexity</p>
<h3>Definition</h3>
<p>Let <b>M</b> be a deterministic <b>Turing machine (TM)</b> that halts on all inputs. The space complexity of <b>M</b> is the function $f \colon N \rightarrow N$, where <b><i>f(n)</i></b> is the maximum number of cells of tape and <b>M</b> scans any input of length <b>M</b>. If the space complexity of <b>M</b> is <b><i>f(n)</i></b>, we can say that <b>M</b> runs in space <b><i>f(n)</i></b>.</p>
<p>We estimate the space complexity of Turing machine by using asymptotic notation.</p>
<p>Let $f \colon N \rightarrow R^+$ be a function. The space complexity classes can be defined as follows &minus;</p>
<p><b><i>SPACE = {L | L is a language decided by an O(f(n)) space deterministic TM}</i></b></p>
<p><b><i>SPACE = {L | L is a language decided by an O(f(n)) space non-deterministic TM}</i></b></p>
<p><b>PSPACE</b> is the class of languages that are decidable in polynomial space on a deterministic Turing machine.</p>
<p>In other words, <b><i>PSPACE = U<sub>k</sub> SPACE (n<sup>k</sup>)</i></b></p>
<h2>Savitch’s Theorem</h2>
<p>One of the earliest theorem related to space complexity is Savitch’s theorem. According to this theorem, a deterministic machine can simulate non-deterministic machines by using a small amount of space.</p>
<p>For time complexity, such a simulation seems to require an exponential increase in time. For space complexity, this theorem shows that any non-deterministic Turing machine that uses <b><i>f(n)</i></b> space can be converted to a deterministic TM that uses <b><i>f<sup>2</sup>(n)</i></b> space.</p>
<p>Hence, Savitch’s theorem states that, for any function, $f \colon N \rightarrow R^+$, where $f(n) \geqslant n$</p>
<p style="padding-left:30%"><b><i>NSPACE(f(n)) &sube; SPACE(f(n))</i></b></p>
<h3>Relationship Among Complexity Classes</h3>
<p>The following diagram depicts the relationship among different complexity classes.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/relationship.jpg" alt="Relationship" />
<p>Till now, we have not discussed P and NP classes in this tutorial. These will be discussed later.</p>
<h1>DAA - Divide &amp; Conquer</h1>
<p>Many algorithms are recursive in nature to solve a given problem recursively dealing with sub-problems.</p>
<p>In <b>divide and conquer approach</b>, a problem is divided into smaller problems, then the smaller problems are solved independently, and finally the solutions of smaller problems are combined into a solution for the large problem.</p>
<p>Generally, divide-and-conquer algorithms have three parts &minus;</p>
<ul class="list">
<li><p><b>Divide the problem</b> into a number of sub-problems that are smaller instances of the same problem.</p></li>
<li><p><b>Conquer the sub-problems</b> by solving them recursively. If they are small enough, solve the sub-problems as base cases.</p></li>
<li><p><b>Combine the solutions</b> to the sub-problems into the solution for the original problem.</p></li>
</ul>
<h2>Pros and cons of Divide and Conquer Approach</h2>
<p>Divide and conquer approach supports parallelism as sub-problems are independent. Hence, an algorithm, which is designed using this technique, can run on the multiprocessor system or in different machines simultaneously.</p>
<p>In this approach, most of the algorithms are designed using recursion, hence memory management is very high. For recursive function stack is used, where function state needs to be stored.</p>
<h2>Application of Divide and Conquer Approach</h2>
<p>Following are some problems, which are solved using divide and conquer approach.</p>
<ul class="list">
<li>Finding the maximum and minimum of a sequence of numbers</li>
<li>Strassen’s matrix multiplication</li>
<li>Merge sort</li>
<li>Binary search</li>
</ul>
<h1>DAA - Max-Min Problem</h1>
<p>Let us consider a simple problem that can be solved by divide and conquer technique.</p>
<h3>Problem Statement</h3>
<p>The Max-Min Problem in algorithm analysis is finding the maximum and minimum value in an array.</p>
<h3>Solution</h3>
<p>To find the maximum and minimum numbers in a given array <b><i>numbers[]</i></b> of size <b>n</b>, the following algorithm can be used. First we are representing the <b>naive method</b> and then we will present <b>divide and conquer approach</b>.</p>
<h2>Naïve Method</h2>
<p>Naïve method is a basic method to solve any problem. In this method, the maximum and minimum number can be found separately. To find the maximum and minimum numbers, the following straightforward algorithm can be used.</p>
<pre class="result notranslate">
<b>Algorithm: Max-Min-Element (numbers[])</b> 
max := numbers[1] 
min := numbers[1] 

for i = 2 to n do 
   if numbers[i] &gt; max then  
      max := numbers[i] 
   if numbers[i] &lt; min then  
      min := numbers[i] 
return (max, min) 
</pre>
<h3>Analysis</h3>
<p>The number of comparison in Naive method is <b>2n - 2</b>.</p>
<p>The number of comparisons can be reduced using the divide and conquer approach. Following is the technique.</p>
<h2>Divide and Conquer Approach</h2>
<p>In this approach, the array is divided into two halves. Then using recursive approach maximum and minimum numbers in each halves are found. Later, return the maximum of two maxima of each half and the minimum of two minima of each half.</p>
<p>In this given problem, the number of elements in an array is $y - x + 1$, where <b>y</b> is greater than or equal to <b>x</b>.</p>
<p>$\mathbf{\mathit{Max - Min(x, y)}}$ will return the maximum and minimum values of an array $\mathbf{\mathit{numbers[x...y]}}$.</p>
<pre class="result notranslate">
<b>Algorithm: Max - Min(x, y)</b> 
if x – y &le; 1 then  
   return (max(numbers[x], numbers[y]), min((numbers[x], numbers[y])) 
else 
   (max1, min1):= maxmin(x, &lfloor;((x + y)/2)&rfloor;) 
   (max2, min2):= maxmin(&lfloor;((x + y)/2) + 1)&rfloor;,y) 
return (max(max1, max2), min(min1, min2)) 
</pre>
<h3>Analysis</h3>
<p>Let <b><i>T(n)</i></b> be the number of comparisons made by $\mathbf{\mathit{Max - Min(x, y)}}$, where the number of elements $n = y - x + 1$.</p>
<p>If <b><i>T(n)</i></b> represents the numbers, then the recurrence relation can be represented as</p>
<p>$$T(n) = \begin{cases}T\left(\lfloor\frac{n}{2}\rfloor\right)+T\left(\lceil\frac{n}{2}\rceil\right)+2 & for\: n>2\\1 & for\:n = 2 \\0 & for\:n = 1\end{cases}$$</p>
<p>Let us assume that <b><i>n</i></b> is in the form of power of <b>2</b>. Hence, <b>n = 2<sup>k</sup></b> where <b>k</b> is height of the recursion tree.</p>
<p>So,</p>
<p>$$T(n) = 2.T (\frac{n}{2}) + 2 = 2.\left(\begin{array}{c}2.T(\frac{n}{4}) + 2\end{array}\right) + 2 ..... = \frac{3n}{2} - 2$$</p>
<p>Compared to Naïve method, in divide and conquer approach, the number of comparisons is less. However, using the asymptotic notation both of the approaches are represented by <b>O(n)</b>.</p>
<h1>DAA - Merge Sort</h1>
<p>In this chapter, we will discuss merge sort and analyze its complexity.</p>
<h2>Problem Statement</h2>
<p>The problem of sorting a list of numbers lends itself immediately to a divide-and-conquer strategy: split the list into two halves, recursively sort each half, and then merge the two sorted sub-lists.</p>
<h2>Solution</h2>
<p>In this algorithm, the numbers are stored in an array <b><i>numbers[]</i></b>. Here, <b><i>p</i></b> and <b><i>q</i></b> represents the start and end index of a sub-array.</p>
<pre class="result notranslate">
<b>Algorithm: Merge-Sort (numbers[], p, r)</b> 
if p &lt; r then  
q = &lfloor;(p + q) / 2&rfloor; 
Merge-Sort (numbers[], p, q) 
    Merge-Sort (numbers[], q + 1, r) 
    Merge (numbers[], p, q, r) 
</pre>
<p></p>
<pre class="result notranslate">
<b>Function: Merge (numbers[], p, q, r)</b>
n<sub>1</sub> = q – p + 1 
n<sub>2</sub> = r – q 
declare leftnums[1…n<sub>1</sub> + 1] and rightnums[1…n<sub>2</sub> + 1] temporary arrays 
for i = 1 to n<sub>1</sub> 
   leftnums[i] = numbers[p + i - 1] 
for j = 1 to n<sub>2</sub> 
   leftnums[j] = numbers[q+ j] 
leftnums[n<sub>1</sub> + 1] = ∞ 
rightnums[n<sub>2</sub> + 1] = ∞ 
i = 1 
j = 1 
for k = p to r 
   if leftnums[i] &le; rightnums[j] 
      numbers[k] = leftnums[i] 
      i = i + 1 
   else
      numbers[k] = rightnums[j] 
      j = j + 1 
</pre>
<h2>Analysis</h2>
<p>Let us consider, the running time of Merge-Sort as <b><i>T(n)</i></b>. Hence,</p>
<p style="padding-left:10%">$T(n)=\begin{cases}c & if\:n\leqslant 1\\2\:x\:T(\frac{n}{2})+d\:x\:n & otherwise\end{cases}$ where <i>c</i> and <i>d</i> are constants</p>
<p>Therefore, using this recurrence relation,</p>
<p>$$T(n) = 2^i T(\frac{n}{2^i}) + i.d.n$$</p>
<p>As, $i = log\:n,\: T(n) = 2^{log\:n} T(\frac{n}{2^{log\:n}}) + log\:n.d.n$</p>
<p style="padding-left:24%">$=\:c.n + d.n.log\:n$</p>
<p>Therefore, <span style="padding-left:5%">$T(n) = O(n\:log\:n)$</span></p>
<h2>Example</h2>
<p>In the following example, we have shown Merge-Sort algorithm step by step. First, every iteration array is divided into two sub-arrays, until the sub-array contains only one element. When these sub-arrays cannot be divided further, then merge operations are performed.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/example.jpg" alt="Example" />
<h1>DAA - Binary Search</h1>
<p>In this chapter, we will discuss another algorithm based on divide and conquer method.</p>
<h2>Problem Statement</h2>
<p>Binary search can be performed on a sorted array. In this approach, the index of an element <b>x</b> is determined if the element belongs to the list of elements. If the array is unsorted, linear search is used to determine the position.</p>
<h2>Solution</h2>
<p>In this algorithm, we want to find whether element <b>x</b> belongs to a set of numbers stored in an array <b><i>numbers[]</i></b>. Where <b><i>l</i></b> and <b><i>r</i></b> represent the left and right index of a sub-array in which searching operation should be performed.</p>
<pre class="result notranslate">
<b>Algorithm: Binary-Search(numbers[], x, l, r)</b>
if l = r then  
   return l  
else 
   m := &lfloor;(l + r) / 2&rfloor; 
   if x &le; numbers[m]  then 
      return Binary-Search(numbers[], x, l, m) 
   else 
      return Binary-Search(numbers[], x, m+1, r) 
</pre>
<h2>Analysis</h2>
<p>Linear search runs in <b><i>O(n)</i></b> time. Whereas binary search produces the result in <b><i>O(log n)</i></b> time</p>
<p>Let <b>T(n)</b> be the number of comparisons in worst-case in an array of <b>n</b> elements.</p>
<p>Hence,</p>
<p>$$T(n)=\begin{cases}0 & if\:n= 1\\T(\frac{n}{2})+1 & otherwise\end{cases}$$</p>
<p>Using this recurrence relation $T(n) = log\:n$.</p>
<p>Therefore, binary search uses $O(log\:n)$ time.</p>
<h2>Example</h2>
<p>In this example, we are going to search element 63.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/binary_search.jpg" alt="Binary Search" />
<h1>DAA - Strassen’s Matrix Multiplication</h1>
<p>In this chapter, first we will discuss the general method of matrix multiplication and later we will discuss Strassen’s matrix multiplication algorithm.</p>
<h3>Problem Statement</h3>
<p>Let us consider two matrices <b><i>X</i></b> and <b><i>Y</i></b>. We want to calculate the resultant matrix <b><i>Z</i></b> by multiplying <b><i>X</i></b> and <b><i>Y</i></b>.</p>
<h2>Naïve Method</h2>
<p>First, we will discuss naïve method and its complexity. Here, we are calculating <b><i>Z = X &times; Y</i></b>. Using Naïve method, two matrices (<b><i>X</i></b> and <b><i>Y</i></b>) can be multiplied if the order of these matrices are <b><i>p &times; q</i></b> and <b><i>q &times; r</i></b>. Following is the algorithm.</p>
<pre class="result notranslate">
<b>Algorithm: Matrix-Multiplication (X, Y, Z)</b> 
for i = 1 to p do 
   for j = 1 to r do 
      Z[i,j] := 0 
      for k = 1 to q do 
         Z[i,j] := Z[i,j] + X[i,k] &times; Y[k,j] 
</pre>
<h3>Complexity</h3>
<p>Here, we assume that integer operations take <b><i>O(1)</i></b> time. There are three <b>for</b> loops in this algorithm and one is nested in other. Hence, the algorithm takes <b><i>O(n<sup>3</sup>)</i></b> time to execute.</p>
<h2>Strassen’s Matrix Multiplication Algorithm</h2>
<p>In this context, using Strassen’s Matrix multiplication algorithm, the time consumption can be improved a little bit.</p>
<p>Strassen’s Matrix multiplication can be performed only on <b>square matrices</b> where <b>n</b> is a <b>power of 2</b>. Order of both of the matrices are <b>n &times; n</b>.</p>
<p>Divide <b>X</b>, <b>Y</b> and <b>Z</b> into four (n/2)&times;(n/2) matrices as represented below &minus;</p>
<p style="padding-left:8%">$Z = \begin{bmatrix}I & J \\K & L \end{bmatrix}$ <span style="padding-left:5%">$X = \begin{bmatrix}A & B \\C & D \end{bmatrix}$</span> and <span style="padding-left:5%">$Y = \begin{bmatrix}E & F \\G & H \end{bmatrix}$</span></p>
<p>Using Strassen’s Algorithm compute the following &minus;</p>
<p>$$M_{1} \: \colon= (A+C) \times (E+F)$$</p>
<p>$$M_{2} \: \colon= (B+D) \times (G+H)$$</p>
<p>$$M_{3} \: \colon= (A-D) \times (E+H)$$</p>
<p>$$M_{4} \: \colon= A \times (F-H)$$</p>
<p>$$M_{5} \: \colon= (C+D) \times (E)$$</p>
<p>$$M_{6} \: \colon= (A+B) \times (H)$$</p>
<p>$$M_{7} \: \colon= D \times (G-E)$$</p>
<p>Then,</p>
<p>$$I \: \colon= M_{2} + M_{3} - M_{6} - M_{7}$$</p>
<p>$$J \: \colon= M_{4} + M_{6}$$</p>
<p>$$K \: \colon= M_{5} + M_{7}$$</p>
<p>$$L \: \colon= M_{1} - M_{3} - M_{4} - M_{5}$$</p>
<h3>Analysis</h3>
<p>$T(n)=\begin{cases}c & if\:n= 1\\7\:x\:T(\frac{n}{2})+d\:x\:n^2 & otherwise\end{cases}$ where <i>c</i> and <i>d</i> are constants</p>
<p>Using this recurrence relation, we get $T(n) = O(n^{log7})$</p>
<p>Hence, the complexity of Strassen’s matrix multiplication algorithm is $O(n^{log7})$.</p>
<h1>DAA - Greedy Method</h1>
<p>Among all the algorithmic approaches, the simplest and straightforward approach is the Greedy method. In this approach, the decision is taken on the basis of current available information without worrying about the effect of the current decision in future.</p>
<p>Greedy algorithms build a solution part by part, choosing the next part in such a way, that it gives an immediate benefit. This approach never reconsiders the choices taken previously. This approach is mainly used to solve optimization problems. Greedy method is easy to implement and quite efficient in most of the cases. Hence, we can say that Greedy algorithm is an algorithmic paradigm based on heuristic that follows local optimal choice at each step with the hope of finding global optimal solution.</p>
<p>In many problems, it does not produce an optimal solution though it gives an approximate (near optimal) solution in a reasonable time.</p>
<h2>Components of Greedy Algorithm</h2>
<p>Greedy algorithms have the following five components &minus;</p>
<ul class="list">
<li><p><b>A candidate set</b> &minus; A solution is created from this set.</p></li>
<li><p><b>A selection function</b> &minus; Used to choose the best candidate to be added to the solution.</p></li>
<li><p><b>A feasibility function</b> &minus; Used to determine whether a candidate can be used to contribute to the solution.</p></li>
<li><p><b>An objective function</b> &minus; Used to assign a value to a solution or a partial solution.</p></li>
<li><p><b>A solution function</b> &minus; Used to indicate whether a complete solution has been reached.</p></li>
</ul>
<h2>Areas of Application</h2>
<p>Greedy approach is used to solve many problems, such as</p>
<ul class="list">
<li><p>Finding the shortest path between two vertices using Dijkstra’s algorithm.</p></li>
<li><p>Finding the minimal spanning tree in a graph using Prim’s /Kruskal’s algorithm, etc.</p></li>
</ul>
<h2>Where Greedy Approach Fails</h2>
<p>In many problems, Greedy algorithm fails to find an optimal solution, moreover it may produce a worst solution. Problems like Travelling Salesman and Knapsack cannot be solved using this approach.</p>
<h1>DAA - Fractional Knapsack</h1>
<p>The Greedy algorithm could be understood very well with a well-known problem referred to as Knapsack problem. Although the same problem could be solved by employing other algorithmic approaches, Greedy approach solves Fractional Knapsack problem reasonably in a good time. Let us discuss the Knapsack problem in detail.</p>
<h2>Knapsack Problem</h2>
<p>Given a set of items, each with a weight and a value, determine a subset of items to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.</p>
<p>The knapsack problem is in combinatorial optimization problem. It appears as a subproblem in many, more complex mathematical models of real-world problems. One general approach to difficult problems is to identify the most restrictive constraint, ignore the others, solve a knapsack problem, and somehow adjust the solution to satisfy the ignored constraints.</p>
<h3>Applications</h3>
<p>In many cases of resource allocation along with some constraint, the problem can be derived in a similar way of Knapsack problem. Following is a set of example.</p>
<ul class="list">
<li>Finding the least wasteful way to cut raw materials</li>
<li>portfolio optimization</li>
<li>Cutting stock problems</li>
</ul>
<h3>Problem Scenario</h3>
<p>A thief is robbing a store and can carry a maximal weight of <b><i>W</i></b> into his knapsack. There are n items available in the store and weight of <b><i>i<sup>th</sup></i></b> item is <b><i>w<sub>i</sub></i></b> and its profit is <b><i>p<sub>i</sub></i></b>. What items should the thief take?</p>
<p>In this context, the items should be selected in such a way that the thief will carry those items for which he will gain maximum profit. Hence, the objective of the thief is to maximize the profit.</p>
<p>Based on the nature of the items, Knapsack problems are categorized as</p>
<ul class="list">
<li>Fractional Knapsack</li>
<li>Knapsack</li>
</ul>
<h2>Fractional Knapsack</h2>
<p>In this case, items can be broken into smaller pieces, hence the thief can select fractions of items.</p>
<p>According to the problem statement,</p>
<ul class="list">
<li><p>There are <b>n</b> items in the store</p></li>
<li><p>Weight of <b>i<sup>th</sup></b> item $w_{i} > 0$</p></li>
<li><p>Profit for <b>i<sup>th</sup></b> item $p_{i} > 0$ and</p></li>
<li><p>Capacity of the Knapsack is <b>W</b></p></li>
</ul>
<p>In this version of Knapsack problem, items can be broken into smaller pieces. So, the thief may take only a fraction <b><i>x<sub>i</sub></i></b> of <b>i<sup>th</sup></b> item.</p>
<p>$$0 \leqslant x_{i} \leqslant 1$$</p>
<p>The <b>i<sup>th</sup></b> item contributes the weight $x_{i}.w_{i}$ to the total weight in the knapsack and profit $x_{i}.p_{i}$ to the total profit.</p>
<p>Hence, the objective of this algorithm is to</p>
<p>$$maximize\:\displaystyle\sum\limits_{n=1}^n (x_{i}.p_{}i)$$</p>
<p>subject to constraint,</p>
<p>$$\displaystyle\sum\limits_{n=1}^n (x_{i}.w_{}i) \leqslant W$$</p>
<p>It is clear that an optimal solution must fill the knapsack exactly, otherwise we could add a fraction of one of the remaining items and increase the overall profit.</p>
<p>Thus, an optimal solution can be obtained by</p>
<p>$$\displaystyle\sum\limits_{n=1}^n (x_{i}.w_{}i) = W$$</p>
<p>In this context, first we need to sort those items according to the value of $\frac{p_{i}}{w_{i}}$, so that $\frac{p_{i}+1}{w_{i}+1}$ &le; $\frac{p_{i}}{w_{i}}$ . Here, <b><i>x</i></b> is an array to store the fraction of items.</p>
<pre class="result notranslate">
<b>Algorithm: Greedy-Fractional-Knapsack (w[1..n], p[1..n], W)</b> 
for i = 1 to n 
   do x[i] = 0 
weight = 0 
for i = 1 to n 
   if weight + w[i] &le; W then  
      x[i] = 1 
      weight = weight + w[i] 
   else 
      x[i] = (W - weight) / w[i] 
      weight = W 
      break 
return x
</pre>
<h3>Analysis</h3>
<p>If the provided items are already sorted into a decreasing order of $\mathbf{\frac{p_{i}}{w_{i}}}$, then the whileloop takes a time in <b><i>O(n)</i></b>; Therefore, the total time including the sort is in <b><i>O(n logn)</i></b>.</p>
<h3>Example</h3>
<p>Let us consider that the capacity of the knapsack <b><i>W</i> = 60</b> and the list of provided items are shown in the following table &minus;</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Item</th>
<th style="text-align:center;">A</th>
<th style="text-align:center;">B</th>
<th style="text-align:center;">C</th>
<th style="text-align:center;">D</th>
</tr>
<tr>
<td>Profit</td>
<td>280</td>
<td>100</td>
<td>120</td>
<td>120</td>
</tr>
<tr>
<td>Weight</td>
<td>40</td>
<td>10</td>
<td>20</td>
<td>24</td>
</tr>
<tr>
<td>Ratio $(\frac{p_{i}}{w_{i}})$</td>
<td style="vertical-align:middle;">7</td>
<td style="vertical-align:middle;">10</td>
<td style="vertical-align:middle;">6</td>
<td style="vertical-align:middle;">5</td>
</tr>
</table>
<p>As the provided items are not sorted based on $\mathbf{\frac{p_{i}}{w_{i}}}$. After sorting, the items are as shown in the following table.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Item</th>
<th style="text-align:center;">B</th>
<th style="text-align:center;">A</th>
<th style="text-align:center;">C</th>
<th style="text-align:center;">D</th>
</tr>
<tr>
<td>Profit</td>
<td>100</td>
<td>280</td>
<td>120</td>
<td>120</td>
</tr>
<tr>
<td>Weight</td>
<td>10</td>
<td>40</td>
<td>20</td>
<td>24</td>
</tr>
<tr>
<td>Ratio $(\frac{p_{i}}{w_{i}})$</td>
<td style="vertical-align:middle;">10</td>
<td style="vertical-align:middle;">7</td>
<td style="vertical-align:middle;">6</td>
<td style="vertical-align:middle;">5</td>
</tr>
</table>
<h3>Solution</h3>
<p>After sorting all the items according to $\frac{p_{i}}{w_{i}}$. First all of <b><i>B</i></b> is chosen as weight of <b><i>B</i></b> is less than the capacity of the knapsack. Next, item <b><i>A</i></b> is chosen, as the available capacity of the knapsack is greater than the weight of <b><i>A</i></b>. Now, <b><i>C</i></b> is chosen as the next item. However, the whole item cannot be chosen as the remaining capacity of the knapsack is less than the weight of <b><i>C</i></b>.</p>
<p>Hence, fraction of <b><i>C</i></b> (i.e. (60 − 50)/20) is chosen.</p>
<p>Now, the capacity of the Knapsack is equal to the selected items. Hence, no more item can be selected.</p>
<p>The total weight of the selected items is  <b>10 + 40 + 20 &ast; (10/20) = 60</b></p>
<p>And the total profit is <b>100 + 280 + 120 &ast; (10/20) = 380 + 60 = 440</b></p>
<p>This is the optimal solution. We cannot gain more profit selecting any different combination of items. </p>
<h1>DAA - Job Sequencing with Deadline</h1>
<h2>Problem Statement</h2>
<p>In job sequencing problem, the objective is to find a sequence of jobs, which is completed within their deadlines and gives maximum profit.</p>
<h2>Solution</h2>
<p>Let us consider, a set of <b><i>n</i></b> given jobs which are associated with deadlines and profit is earned, if a job is completed by its deadline. These jobs need to be ordered in such a way that there is maximum profit.</p>
<p>It may happen that all of the given jobs may not be completed within their deadlines.</p>
<p>Assume, deadline of <b>i<sup>th</sup></b> job <b><i>J<sub>i</sub></i></b> is <b><i>d<sub>i</sub></i></b> and the profit received from this job is <b><i>p<sub>i</sub></i></b>. Hence, the optimal solution of this algorithm is a feasible solution with maximum profit.</p>
<p>Thus, $D(i) > 0$ for $1 \leqslant i \leqslant n$.</p>
<p>Initially, these jobs are ordered according to profit, i.e. $p_{1} \geqslant p_{2} \geqslant p_{3} \geqslant \:... \: \geqslant p_{n}$.</p>
<pre class="result notranslate">
<b>Algorithm: Job-Sequencing-With-Deadline (D, J, n, k)</b> 
D(0) := J(0) := 0 
k := 1 
J(1) := 1   // means first job is selected 
for i = 2 … n do 
   r := k 
   while D(J(r)) &gt; D(i) and D(J(r)) ≠ r do 
      r := r – 1 
   if D(J(r)) &le; D(i) and D(i) &gt; r then 
      for l = k … r + 1 by -1 do 
         J(l + 1) := J(l) 
         J(r + 1) := i 
         k := k + 1 
</pre>
<h2>Analysis</h2>
<p>In this algorithm, we are using two loops, one is within another. Hence, the complexity of this algorithm is $O(n^2)$.</p>
<h2>Example</h2>
<p>Let us consider a set of given jobs as shown in the following table. We have to find a sequence of jobs, which will be completed within their deadlines and will give maximum profit. Each job is associated with a deadline and profit.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center">Job</th>
<th style="text-align:center"><b>J<sub>1</sub></b></th>
<th style="text-align:center"><b>J<sub>2</sub></b></th>
<th style="text-align:center"><b>J<sub>3</sub></b></th>
<th style="text-align:center"><b>J<sub>4</sub></b></th>
<th style="text-align:center"><b>J<sub>5</sub></b></th>
</tr>
<tr>
<td>Deadline</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>Profit</td>
<td>60</td>
<td>100</td>
<td>20</td>
<td>40</td>
<td>20</td>
</tr>
</table>
<h2>Solution</h2>
<p>To solve this problem, the given jobs are sorted according to their profit in a descending order. Hence, after sorting, the jobs are ordered as shown in the following table.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center">Job</th>
<th style="text-align:center"><b>J<sub>2</sub></b></th>
<th style="text-align:center"><b>J<sub>1</sub></b></th>
<th style="text-align:center"><b>J<sub>4</sub></b></th>
<th style="text-align:center"><b>J<sub>3</sub></b></th>
<th style="text-align:center"><b>J<sub>5</sub></b></th>
</tr>
<tr>
<td>Deadline</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>Profit</td>
<td>100</td>
<td>60</td>
<td>40</td>
<td>20</td>
<td>20</td>
</tr>
</table>
<p>From this set of jobs, first we select <b><i>J<sub>2</sub></i></b>, as it can be completed within its deadline and contributes maximum profit.</p>
<ul class="list">
<li><p>Next, <b><i>J<sub>1</sub></i></b> is selected as it gives more profit compared to <b><i>J<sub>4</sub></i></b>.</p></li>
<li><p>In the next clock, <b><i>J<sub>4</sub></i></b> cannot be selected as its deadline is over, hence <b><i>J<sub>3</sub></i></b> is selected as it executes within its deadline.</p></li>
<li><p>The job <b><i>J<sub>5</sub></i></b> is discarded as it cannot be executed within its deadline.</p></li>
</ul>
<p>Thus, the solution is the sequence of jobs (<b><i>J<sub>2</sub>, J<sub>1</sub>, J<sub>4</sub></i></b>), which are being executed within their deadline and gives maximum profit.</p>
<p>Total profit of this sequence is <b>100 + 60 + 20 = 180</b>.</p>
<h1>DAA - Optimal Merge Pattern</h1>
<p>Merge a set of sorted files of different length into a single sorted file. We need to find an optimal solution, where the resultant file will be generated in minimum time.</p>
<p>If the number of sorted files are given, there are many ways to merge them into a single sorted file. This merge can be performed pair wise. Hence, this type of merging is called as <b>2-way merge patterns</b>.</p>
<p>As, different pairings require different amounts of time, in this strategy we want to determine an optimal way of merging many files together. At each step, two shortest sequences are merged.</p>
<p>To merge a <b>p-record file</b> and a <b>q-record file</b> requires possibly <b>p + q</b> record moves, the obvious choice being, merge the two smallest files together at each step.</p>
<p>Two-way merge patterns can be represented by binary merge trees. Let us consider a set of <b>n</b> sorted files <b>{f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub>, …, f<sub>n</sub>}</b>. Initially, each element of this is considered as a single node binary tree. To find this optimal solution, the following algorithm is used.</p>
<pre class="result notranslate">
<b>Algorithm: TREE (n)</b>  
for i := 1 to n – 1 do  
   declare new node  
   node.leftchild := least (list) 
   node.rightchild := least (list) 
   node.weight) := ((node.leftchild).weight) + ((node.rightchild).weight)  
   insert (list, node);  
return least (list); 
</pre>
<p>At the end of this algorithm, the weight of the root node represents the optimal cost.</p>
<h2>Example</h2>
<p>Let us consider the given files, f<sub>1</sub>, f<sub>2</sub>, f<sub>3</sub>, f<sub>4</sub> and f<sub>5</sub> with 20, 30, 10, 5 and 30 number of elements respectively.</p>
<p>If merge operations are performed according to the provided sequence, then</p>
<p style="padding-left:30%"><b>M<sub>1</sub> = merge f<sub>1</sub> and f<sub>2</sub></b>   =&gt;  20 + 30 = 50</p>
<p style="padding-left:30%"><b>M<sub>2</sub> = merge M<sub>1</sub> and f<sub>3</sub></b>   =&gt;  50 + 10 = 60</p>
<p style="padding-left:30%"><b>M<sub>3</sub> = merge M<sub>2</sub> and f<sub>4</sub></b>   =&gt;  60 +  5 = 65</p>
<p style="padding-left:30%"><b>M<sub>4</sub> = merge M<sub>3</sub> and f<sub>5</sub></b>   =&gt;  65 + 30 = 95</p>
<p>Hence, the total number of operations is</p>
<p style="padding-left:30%">50 + 60 + 65 + 95 = 270</p>
<p>Now, the question arises is there any better solution?</p>
<p>Sorting the numbers according to their size in an ascending order, we get the following sequence &minus;</p>
<p style="padding-left:30%"><b>f<sub>4</sub>, f<sub>3</sub>, f<sub>1</sub>, f<sub>2</sub>, f<sub>5</sub></b></p>
<p>Hence, merge operations can be performed on this sequence</p>
<p style="padding-left:30%"><b>M<sub>1</sub> = merge f<sub>4</sub> and f<sub>3</sub></b>   =&gt;   5 + 10 = 15</p>
<p style="padding-left:30%"><b>M<sub>2</sub> = merge M<sub>1</sub> and f<sub>1</sub></b>   =&gt;  15 + 20 = 35</p>
<p style="padding-left:30%"><b>M<sub>3</sub> = merge M<sub>2</sub> and f<sub>2</sub></b>   =&gt;  35 + 30 = 65</p>
<p style="padding-left:30%"><b>M<sub>4</sub> = merge M<sub>3</sub> and f<sub>5</sub></b>   =&gt;  65 + 30 = 95</p>
<p>Therefore, the total number of operations is</p>
<p style="padding-left:30%">15 + 35 + 65 + 95 = 210</p>
<p>Obviously, this is better than the previous one.</p>
<p>In this context, we are now going to solve the problem using this algorithm.</p>
<h3>Initial Set</h3>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/initial_set.jpg" alt="Initial Set" />
<h3>Step-1</h3>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/step_1.jpg" alt="Step-1" />
<h3>Step-2</h3>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/step_2.jpg" alt="Initial Set" />
<h3>Step-3</h3>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/step_3.jpg" alt="Initial Set" />
<h3>Step-4</h3>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/step_4.jpg" alt="Initial Set" />
<p>Hence, the solution takes 15 + 35 + 60 + 95 = 205 number of comparisons.</p>
<h1>DAA - Dynamic Programming</h1>
<p>Dynamic Programming is also used in optimization problems. Like divide-and-conquer method, Dynamic Programming solves problems by combining the solutions of subproblems. Moreover, Dynamic Programming algorithm solves each sub-problem just once and then saves its answer in a table, thereby avoiding the work of re-computing the answer every time.</p>
<p>Two main properties of a problem suggest that the given problem can be solved using Dynamic Programming. These properties are <b>overlapping sub-problems and optimal substructure</b>.</p>
<h2>Overlapping Sub-Problems</h2>
<p>Similar to Divide-and-Conquer approach, Dynamic Programming also combines solutions to sub-problems. It is mainly used where the solution of one sub-problem is needed repeatedly. The computed solutions are stored in a table, so that these don’t have to be re-computed. Hence, this technique is needed where overlapping sub-problem exists.</p>
<p>For example, Binary Search does not have overlapping sub-problem. Whereas recursive program of Fibonacci numbers have many overlapping sub-problems.</p>
<h2>Optimal Sub-Structure</h2>
<p>A given problem has Optimal Substructure Property, if the optimal solution of the given problem can be obtained using optimal solutions of its sub-problems.</p>
<p>For example, the Shortest Path problem has the following optimal substructure property &minus;</p>
<p>If a node <b>x</b> lies in the shortest path from a source node <b>u</b> to destination node <b>v</b>, then the shortest path from <b>u</b> to <b>v</b> is the combination of the shortest path from <b>u</b> to <b>x</b>, and the shortest path from <b>x</b> to <b>v</b>.</p>
<p>The standard All Pair Shortest Path algorithms like Floyd-Warshall and Bellman-Ford are typical examples of Dynamic Programming.</p>
<h2>Steps of Dynamic Programming Approach</h2>
<p>Dynamic Programming algorithm is designed using the following four steps &minus;</p>
<ul class="list">
<li>Characterize the structure of an optimal solution.</li>
<li>Recursively define the value of an optimal solution.</li>
<li>Compute the value of an optimal solution, typically in a bottom-up fashion.</li>
<li>Construct an optimal solution from the computed information.</li>
</ul>
<h2>Applications of Dynamic Programming Approach</h2>
<ul class="list">
<li>Matrix Chain Multiplication</li>
<li>Longest Common Subsequence</li>
<li>Travelling Salesman Problem</li>
</ul>
<h1>DAA - 0-1 Knapsack</h1>
<p>In this tutorial, earlier we have discussed Fractional Knapsack problem using Greedy approach. We have shown that Greedy approach gives an optimal solution for Fractional Knapsack. However, this chapter will cover 0-1 Knapsack problem and its analysis.</p>
<p>In 0-1 Knapsack, items cannot be broken which means the thief should take the item as a whole or should leave it. This is reason behind calling it as 0-1 Knapsack.</p>
<p>Hence, in case of 0-1 Knapsack, the value of <b><i>x<sub>i</sub></i></b> can be either <b><i>0</i></b> or <b><i>1</i></b>, where other constraints remain the same.</p>
<p>0-1 Knapsack cannot be solved by Greedy approach. Greedy approach does not ensure an optimal solution. In many instances, Greedy approach may give an optimal solution.</p>
<p>The following examples will establish our statement.</p>
<h3>Example-1</h3>
<p>Let us consider that the capacity of the knapsack is W = 25 and the items are as shown in the following table.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Item</th>
<th style="text-align:center;">A</th>
<th style="text-align:center;">B</th>
<th style="text-align:center;">C</th>
<th style="text-align:center;">D</th>
</tr>
<tr>
<td>Profit</td>
<td>24</td>
<td>18</td>
<td>18</td>
<td>10</td>
</tr>
<tr>
<td>Weight</td>
<td>24</td>
<td>10</td>
<td>10</td>
<td>7</td>
</tr>
</table>
<p>Without considering the profit per unit weight (<b><i>p<sub>i</sub>/w<sub>i</sub></i></b>), if we apply Greedy approach to solve this problem, first item <b><i>A</i></b> will be selected as it will contribute max<sub>i</sub>mum profit among all the elements.</p>
<p>After selecting item <b><i>A</i></b>, no more item will be selected. Hence, for this given set of items total profit is <b><i>24</i></b>. Whereas, the optimal solution can be achieved by selecting items, <b><i>B</i></b> and C, where the total profit is 18 + 18 = 36.</p>
<h3>Example-2</h3>
<p>Instead of selecting the items based on the overall benefit, in this example the items are selected based on ratio <i>p<sub>i</sub>/w<sub>i</sub></i>. Let us consider that the capacity of the knapsack is <i>W</i> = 30 and the items are as shown in the following table.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Item</th>
<th style="text-align:center;">A</th>
<th style="text-align:center;">B</th>
<th style="text-align:center;">C</th>
</tr>
<tr>
<td>Price</td>
<td>100</td>
<td>280</td>
<td>120</td>
</tr>
<tr>
<td>Weight</td>
<td>10</td>
<td>40</td>
<td>20</td>
</tr>
<tr>
<td>Ratio</td>
<td>10</td>
<td>7</td>
<td>6</td>
</tr>
</table>
<p>Using the Greedy approach, first item <b><i>A</i></b> is selected. Then, the next item <b><i>B</i></b> is chosen. Hence, the total profit is <b>100 + 280 = 380</b>. However, the optimal solution of this instance can be achieved by selecting items, <b><i>B</i></b> and <b><i>C</i></b>, where the total profit is <b>280 + 120 = 400</b>.</p>
<p>Hence, it can be concluded that Greedy approach may not give an optimal solution.</p>
<p>To solve 0-1 Knapsack, Dynamic Programming approach is required.</p>
<h3>Problem Statement</h3>
<p>A thief is robbing a store and can carry a max<sub>i</sub>mal weight of <b><i>W</i></b> into his knapsack. There are <b><i>n</i></b> items and weight of <b>i<sup>th</sup></b> item is <b><i>w<sub>i</sub></i></b> and the profit of selecting this item is <b><i>p<sub>i</sub></i></b>. What items should the thief take?</p>
<h2>Dynamic-Programming Approach</h2>
<p>Let <b><i>i</i></b> be the highest-numbered item in an optimal solution <b>S</b> for <b>W</b> dollars. Then <b><i>S<sup>'</sup> = S - {i}</i></b> is an optimal solution for <b><i>W - w<sub>i</sub></i></b> dollars and the value to the solution <b><i>S</i></b> is <b><i>V<sub>i</sub></i></b> plus the value of the sub-problem.</p>
<p>We can express this fact in the following formula: define <b>c[i, w]</b> to be the solution for items <b>1,2, … , i</b> and the max<sub>i</sub>mum weight <b>w</b>.</p>
<p>The algorithm takes the following inputs</p>
<ul class="list">
<li><p>The max<sub>i</sub>mum weight <b>W</b></p></li>
<li><p>The number of items <b>n</b></p></li>
<li><p>The two sequences <b>v = &lt;v<sub>1</sub>, v<sub>2</sub>, …, v<sub>n</sub>&gt;</b> and <b>w = &lt;w<sub>1</sub>, w<sub>2</sub>, …, w<sub>n</sub>&gt;</b></p></li>
</ul>
<pre class="result notranslate">
<b>Dynamic-0-1-knapsack (v, w, n, W)</b> 
for w = 0 to W do 
   c[0, w] = 0 
for i = 1 to n do 
   c[i, 0] = 0 
   for w = 1 to W do 
      if w<sub>i</sub> &le; w then 
         if v<sub>i</sub> + c[i-1, w-w<sub>i</sub>] then 
            c[i, w] = v<sub>i</sub> + c[i-1, w-w<sub>i</sub>] 
         else c[i, w] = c[i-1, w] 
      else 
         c[i, w] = c[i-1, w] 
</pre>
<p>The set of items to take can be deduced from the table, starting at <b>c[n, w]</b> and tracing backwards where the optimal values came from.</p>
<p>If <i>c[i, w] = c[i-1, w]</i>, then item <b><i>i</i></b> is not part of the solution, and we continue tracing with <b>c[i-1, w]</b>. Otherwise, item <b><i>i</i></b> is part of the solution, and we continue tracing with <b>c[i-1, w-W]</b>.</p>
<h3>Analysis</h3>
<p>This algorithm takes &theta;(<i>n</i>, <i>w</i>) times as table <i>c</i> has (<i>n</i> + 1).(<i>w</i> + 1) entries, where each entry requires &theta;(1) time to compute.</p>
<h1>DAA - Longest Common Subsequence</h1>
<p>The longest common subsequence problem is finding the longest sequence which exists in both the given strings.</p>
<h2>Subsequence</h2>
<p>Let us consider a sequence S = &lt;s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, s<sub>4</sub>, …,s<sub>n</sub>&gt;.</p>
<p>A sequence Z = &lt;z<sub>1</sub>, z<sub>2</sub>, z<sub>3</sub>, z<sub>4</sub>, …,z<sub>m</sub>&gt; over S is called a subsequence of S, if and only if it can be derived from S deletion of some elements.</p>
<h2>Common Subsequence</h2>
<p>Suppose, <b><i>X</i></b> and <b><i>Y</i></b> are two sequences over a finite set of elements. We can say that <b><i>Z</i></b> is a common subsequence of <b><i>X</i></b> and <b><i>Y</i></b>, if <b><i>Z</i></b> is a subsequence of both <b><i>X</i></b> and <b><i>Y</i></b>.</p>
<h2>Longest Common Subsequence</h2>
<p>If a set of sequences are given, the longest common subsequence problem is to find a common subsequence of all the sequences that is of maximal length.</p>
<p>The longest common subsequence problem is a classic computer science problem, the basis of data comparison programs such as the diff-utility, and has applications in bioinformatics. It is also widely used by revision control systems, such as SVN and Git, for reconciling multiple changes made to a revision-controlled collection of files.</p>
<h2>Naïve Method</h2>
<p>Let <b><i>X</i></b> be a sequence of length <b><i>m</i></b> and <b><i>Y</i></b> a sequence of length <b><i>n</i></b>. Check for every subsequence of <b><i>X</i></b> whether it is a subsequence of <b><i>Y</i></b>, and return the longest common subsequence found.</p>
<p>There are <b><i>2<sup>m</sup></i></b> subsequences of <b><i>X</i></b>. Testing sequences whether or not it is a subsequence of <b><i>Y</i></b> takes <b><i>O(n)</i></b> time. Thus, the naïve algorithm would take <b><i>O(n2<sup>m</sup>)</i></b> time.</p>
<h2>Dynamic Programming</h2>
<p>Let <i>X = &lt; x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>,…, x<sub>m</sub> &gt;</i>  and <i>Y = &lt; y<sub>1</sub>, y<sub>2</sub>, y<sub>3</sub>,…, y<sub>n</sub> &gt;</i> be the sequences. To compute the length of an element the following algorithm is used.</p>
<p>In this procedure, table <b><i>C[m, n]</i></b> is computed in row major order and another table <b><i>B[m,n]</i></b> is computed to construct optimal solution.</p>
<pre class="result notranslate">
<b>Algorithm: LCS-Length-Table-Formulation (X, Y)</b>
m := length(X) 
n := length(Y) 
for i = 1 to m do 
   C[i, 0] := 0 
for j = 1 to n do 
   C[0, j] := 0 
for i = 1 to m do 
   for j = 1 to n do 
      if x<sub>i</sub> = y<sub>j</sub> 
         C[i, j] := C[i - 1, j - 1] + 1 
         B[i, j] := ‘D’ 
      else 
         if C[i -1, j] &ge; C[i, j -1] 
            C[i, j] := C[i - 1, j] + 1 
            B[i, j] := ‘U’ 
         else 
         C[i, j] := C[i, j - 1] + 1 
         B[i, j] := ‘L’ 
return C and B
</pre>
<p></p>
<pre class="result notranslate">
<b>Algorithm: Print-LCS (B, X, i, j)</b>
if i = 0 and j = 0 
   return  
if B[i, j] = ‘D’ 
   Print-LCS(B, X, i-1, j-1) 
   Print(x<sub>i</sub>) 
else if B[i, j] = ‘U’ 
   Print-LCS(B, X, i-1, j) 
else 
   Print-LCS(B, X, i, j-1) 
</pre>
<p>This algorithm will print the longest common subsequence of <b>X</b> and <b>Y</b>.</p>
<h2>Analysis</h2>
<p>To populate the table, the outer <b>for</b> loop iterates <b><i>m</i></b> times and the inner <b>for</b> loop iterates <b><i>n</i></b> times. Hence, the complexity of the algorithm is <i>O(m, n)</i>, where <b><i>m</i></b> and <b><i>n</i></b> are the length of two strings.</p>
<h2>Example</h2>
<p>In this example, we have two strings <b><i>X = BACDB</i></b> and <b><i>Y = BDCB</i></b> to find the longest common subsequence.</p>
<p>Following the algorithm LCS-Length-Table-Formulation (as stated above), we have calculated table C (shown on the left hand side) and table B (shown on the right hand side).</p>
<p>In table B, instead of ‘D’, ‘L’ and ‘U’, we are using the diagonal arrow, left arrow and up arrow, respectively. After generating table B, the LCS is determined by function LCS-Print. The result is BCB.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/lcs.jpg" alt="LCS" />
<h1>DAA - Spanning Tree</h1>
<p>A <b>spanning tree</b> is a subset of an undirected Graph that has all the vertices connected by minimum number of edges.</p>
<p>If all the vertices are connected in a graph, then there exists at least one spanning tree. In a graph, there may exist more than one spanning tree.</p>
<h3>Properties</h3>
<ul class="list">
<li>A spanning tree does not have any cycle.</li>
<li>Any vertex can be reached from any other vertex.</li>
</ul>
<h3>Example</h3>
<p>In the following graph, the highlighted edges form a spanning tree.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/edges_spinning_tree.jpg" alt="Edges Spinning Tree" />
<h2>Minimum Spanning Tree</h2>
<p>A <b>Minimum Spanning Tree (MST)</b> is a subset of edges of a connected weighted undirected graph that connects all the vertices together with the minimum possible total edge weight. To derive an MST, Prim’s algorithm or Kruskal’s algorithm can be used. Hence, we will discuss Prim’s algorithm in this chapter.</p>
<p>As we have discussed, one graph may have more than one spanning tree. If there are <b>n</b> number of vertices, the spanning tree should have <b><i>n</i> - 1</b> number of edges. In this context, if each edge of the graph is associated with a weight and there exists more than one spanning tree, we need to find the minimum spanning tree of the graph.</p>
<p>Moreover, if there exist any duplicate weighted edges, the graph may have multiple minimum spanning tree.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/minimum_spinning_tree.jpg" alt="Minimum Spinning Tree" />
<p>In the above graph, we have shown a spanning tree though it’s not the minimum spanning tree. The cost of this spanning tree is (5 + 7 + 3 + 3 + 5 + 8 + 3 + 4) = 38.</p>
<p>We will use Prim’s algorithm to find the minimum spanning tree.</p>
<h2>Prim’s Algorithm</h2>
<p>Prim’s algorithm is a greedy approach to find the minimum spanning tree. In this algorithm, to form a MST we can start from an arbitrary vertex.</p>
<pre class="result notranslate">
<b>Algorithm: MST-Prim’s (G, w, r)</b> 
for each u &#1108; G.V 
   u.key = &infin; 
   u.∏ = NIL 
r.key = 0 
Q = G.V 
while Q ≠ &#1060; 
   u = Extract-Min (Q) 
   for each v &#1108; G.adj[u] 
      if each v &#1108; Q and w(u, v) &lt; v.key 
         v.∏ = u 
         v.key = w(u, v) 
</pre>
<p>The function Extract-Min returns the vertex with minimum edge cost. This function works on min-heap.</p>
<h3>Example</h3>
<p>Using Prim’s algorithm, we can start from any vertex, let us start from vertex <b>1</b>.</p>
<p>Vertex <b>3</b> is connected to vertex <b>1</b> with minimum edge cost, hence edge <b>(1, 2)</b> is added to the spanning tree.</p>
<p>Next, edge <b>(2, 3)</b> is considered as this is the minimum among edges <b>{(1, 2), (2, 3), (3, 4), (3, 7)}</b>.</p>
<p>In the next step, we get edge <b>(3, 4)</b> and <b>(2, 4)</b> with minimum cost. Edge <b>(3, 4)</b> is selected at random.</p>
<p>In a similar way, edges <b>(4, 5), (5, 7), (7, 8), (6, 8)</b> and <b>(6, 9)</b> are selected. As all the vertices are visited, now the algorithm stops.</p>
<p>The cost of the spanning tree is (2 + 2 + 3 + 2 + 5 + 2 + 3 + 4) = 23. There is no more spanning tree in this graph with cost less than <b>23</b>.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/prims_algorithm.jpg" alt="Prim’s Algorithm" />
<h1>DAA - Shortest Paths</h1>
<h2>Dijkstra’s Algorithm</h2>
<p>Dijkstra’s algorithm solves the single-source shortest-paths problem on a directed weighted graph <i>G = (V, E)</i>, where all the edges are non-negative (i.e., <i>w(u, v)</i> &ge; 0 for each edge <i>(u, v) &#1028; E</i>).</p>
<p>In the following algorithm, we will use one function <b><i>Extract-Min()</i></b>, which extracts the node with the smallest key.</p>
<pre class="result notranslate">
<b>Algorithm: Dijkstra’s-Algorithm (G, w, s)</b> 
for each vertex v &#1028; G.V  
   v.d := &infin; 
   v.∏ := NIL 
s.d := 0 
S := &#1060; 
Q := G.V 
while Q ≠ &#1060; 
   u := Extract-Min (Q) 
   S := S U {u} 
   for each vertex v &#1028; G.adj[u] 
      if v.d &gt; u.d + w(u, v) 
         v.d := u.d + w(u, v) 
         v.∏ := u
</pre>
<h3>Analysis</h3>
<p>The complexity of this algorithm is fully dependent on the implementation of Extract-Min function. If extract min function is implemented using linear search, the complexity of this algorithm is <b><i>O(V<sup>2</sup> + E)</i></b>.</p>
<p>In this algorithm, if we use min-heap on which <b><i>Extract-Min()</i></b> function works to return the node from <b><i>Q</i></b> with the smallest key, the complexity of this algorithm can be reduced further.</p>
<h3>Example</h3>
<p>Let us consider vertex <b><i>1</i></b> and <b><i>9</i></b> as the start and destination vertex respectively. Initially, all the vertices except the start vertex are marked by &infin; and the start vertex is marked by <b><i>0</i></b>.</p>
<table class="table table-bordered" style="text-align:center;font-size: 13px;">
<tr>
<th style="text-align:center;vertical-align:middle;">Vertex</th>
<th style="text-align:center;vertical-align:middle;">Initial</th>
<th style="text-align:center;">Step1 V<sub>1</sub></th>
<th style="text-align:center;">Step2 V<sub>3</sub></th>
<th style="text-align:center;">Step3 V<sub>2</sub></th>
<th style="text-align:center;">Step4 V<sub>4</sub></th>
<th style="text-align:center;">Step5 V<sub>5</sub></th>
<th style="text-align:center;">Step6 V<sub>7</sub></th>
<th style="text-align:center;">Step7 V<sub>8</sub></th>
<th style="text-align:center;">Step8 V<sub>6</sub></th>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>&infin;</td>
<td>5</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>&infin;</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
<td>7</td>
</tr>
<tr>
<td>5</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>11</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
<td>9</td>
</tr>
<tr>
<td>6</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>17</td>
<td>17</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>7</td>
<td>&infin;</td>
<td>&infin;</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>11</td>
</tr>
<tr>
<td>8</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>16</td>
<td>13</td>
<td>13</td>
<td>13</td>
</tr>
<tr>
<td>9</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>&infin;</td>
<td>20</td>
</tr>
</table>
<p>Hence, the minimum distance of vertex <b><i>9</i></b> from vertex <b><i>1</i></b> is <b><i>20</i></b>. And the path is</p>
<p style="padding-left:35%">1&rarr; 3&rarr; 7&rarr; 8&rarr; 6&rarr; 9</p>
<p>This path is determined based on predecessor information.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/path.jpg" alt="Path" />
<h2>Bellman Ford Algorithm</h2>
<p>This algorithm solves the single source shortest path problem of a directed graph <b><i>G = (V, E)</i></b> in which the edge weights may be negative. Moreover, this algorithm can be applied to find the shortest path, if there does not exist any negative weighted cycle.</p>
<pre class="result notranslate">
<b>Algorithm: Bellman-Ford-Algorithm (G, w, s)</b> 
for each vertex v &#1028; G.V  
   v.d := &infin; 
   v.∏ := NIL 
s.d := 0 
for i = 1 to |G.V| - 1 
   for each edge (u, v) &#1028; G.E 
      if v.d &gt; u.d + w(u, v) 
         v.d := u.d +w(u, v) 
         v.∏ := u 
for each edge (u, v) &#1028; G.E 
   if v.d &gt; u.d + w(u, v) 
      return FALSE 
return TRUE
</pre>
<h3>Analysis</h3>
<p>The first <b>for</b> loop is used for initialization, which runs in <b><i>O(V)</i></b> times. The next <b>for</b> loop runs |<b><i>V - 1</i></b>| passes over the edges, which takes <b><i>O(E)</i></b> times.</p>
<p>Hence, Bellman-Ford algorithm runs in <b><i>O(V, E)</i></b> time.</p>
<h3>Example</h3>
<p>The following example shows how Bellman-Ford algorithm works step by step. This graph has a negative edge but does not have any negative cycle, hence the problem can be solved using this technique.</p>
<p>At the time of initialization, all the vertices except the source are marked by ∞ and the source is marked by <b>0</b>.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/graph.jpg" alt="Graph" />
<p>In the first step, all the vertices which are reachable from the source are updated by minimum cost. Hence, vertices <b><i>a</i></b> and <b><i>h</i></b> are updated.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/updated.jpg" alt="Updated" />
<p>In the next step, vertices <b><i>a, b, f</i></b> and <b><i>e</i></b> are updated.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/next_path.jpg" alt="Next Path" />
<p>Following the same logic, in this step vertices <b><i>b, f, c</i></b> and <b><i>g</i></b> are updated.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/vertices.jpg" alt="Vertices" />
<p>Here, vertices <b><i>c</i></b> and <b><i>d</i></b> are updated.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/vertices_updated.jpg" alt="Vertices Updated" />
<p>Hence, the minimum distance between vertex <b>s</b> and vertex <b>d</b> is <b>20</b>.</p>
<p>Based on the predecessor information, the path is s&rarr; h&rarr; e&rarr; g&rarr; c&rarr; d</p>
<h1>DAA - Multistage Graph</h1>
<p>A multistage graph <b>G = (V, E)</b> is a directed graph where vertices are partitioned into <b>k</b> (where <b><i>k</i> &gt; 1</b>) number of disjoint subsets <b><i>S = {s<sub>1</sub>,s<sub>2</sub>,…,s<sub>k</sub>}</i></b> such that edge <i>(u, v)</i> is in E, then <i>u &#1028; s<sub>i</sub></i> and <i>v &#1028; s<sub>1 + 1</sub></i>  for some subsets in the partition and |<b><i>s<sub>1</sub></i></b>| = |<b><i>s<sub>k</sub></i></b>| = 1.</p>
<p>The vertex <b><i>s &#1028; s<sub>1</sub></i></b> is called the <b>source</b> and the vertex <b><i>t &#1028; s<sub>k</sub></i></b> is called <b>sink</b>.</p>
<p><b><i>G</i></b> is usually assumed to be a weighted graph. In this graph, cost of an edge <i>(i, j)</i> is represented by <i>c(i, j)</i>. Hence, the cost of path from source <b><i>s</i></b> to sink <b><i>t</i></b> is the sum of costs of each edges in this path.</p>
<p>The multistage graph problem is finding the path with minimum cost from source <b><i>s</i></b> to sink <b><i>t</i></b>.</p>
<h2>Example</h2>
<p>Consider the following example to understand the concept of multistage graph.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/multistage_graph.jpg" alt="Multistage Graph" />
<p>According to the formula, we have to calculate the cost <b>(i, j)</b> using the following steps</p>
<h3>Step-1: Cost (K-2, j)</h3>
<p>In this step, three nodes (node 4, 5. 6) are selected as <b>j</b>. Hence, we have three options to choose the minimum cost at this step.</p>
<p style="padding-left:8%"><i>Cost(3, 4) = min {c(4, 7) + Cost(7, 9),c(4, 8) + Cost(8, 9)} = 7</i></p>
<p style="padding-left:8%"><i>Cost(3, 5) = min {c(5, 7) + Cost(7, 9),c(5, 8) + Cost(8, 9)} = 5</i></p>
<p style="padding-left:8%"><i>Cost(3, 6) = min {c(6, 7) + Cost(7, 9),c(6, 8) + Cost(8, 9)} = 5</i></p>
<h3>Step-2: Cost (K-3, j)</h3>
<p>Two nodes are selected as j because at stage k - 3 = 2 there are two nodes, 2 and 3. So, the value i = 2 and j = 2 and 3.</p>
<p style="padding-left:10%"><i>Cost(2, 2) = min {c(2, 4) + Cost(4, 8) + Cost(8, 9),c(2, 6) +</i></p>
<p style="padding-left:28%"><i> Cost(6, 8) + Cost(8, 9)} = 8</i></p>
<p><i>Cost(2, 3) = min {c(3, 4) + Cost(4, 9) + Cost(8, 9),c(3, 5) + Cost(8, 9)} = 7</i></p>
<h3>Step-3: Cost (K-4, j)</h3>
<p style="padding-left:8%"><i>Cost (1, 1) = min {c(1, 2) + Cost(2, 6) + Cost(6, 8) + Cost(8, 9),</i></p>
<p style="padding-left:15%"><i>c(1, 3) + Cost(3, 6) + Cost(6, 8 + Cost(8, 9))} = 13</i></p>
<p>Hence, the path having the minimum cost is <b>1&rarr; 2&rarr; 6&rarr; 8&rarr; 9</b>.</p>
<h1>DAA - Travelling Salesman Problem</h1>
<h2>Problem Statement</h2>
<p>A traveler needs to visit all the cities from a list, where distances between all the cities are known and each city should be visited just once. What is the shortest possible route that he visits each city exactly once and returns to the origin city?</p>
<h2>Solution</h2>
<p>Travelling salesman problem is the most notorious computational problem. We can use brute-force approach to evaluate every possible tour and select the best one. For <b>n</b> number of vertices in a graph, there are <b>(<i>n</i> - 1)!</b> number of possibilities.</p>
<p>Instead of brute-force using dynamic programming approach, the solution can be obtained in lesser time, though there is no polynomial time algorithm.</p>
<p>Let us consider a graph <b><i>G = (V, E)</i></b>, where <b><i>V</i></b> is a set of cities and <b><i>E</i></b> is a set of weighted edges. An edge <b><i>e(u, v)</i></b> represents that vertices <b><i>u</i></b> and <b><i>v</i></b> are connected. Distance between vertex <b><i>u</i></b> and <b><i>v</i></b> is <b><i>d(u, v)</i></b>, which should be non-negative.</p>
<p>Suppose we have started at city <b><i>1</i></b> and after visiting some cities now we are in city <b><i>j</i></b>. Hence, this is a partial tour. We certainly need to know <b><i>j</i></b>, since this will determine which cities are most convenient to visit next. We also need to know all the cities visited so far, so that we don't repeat any of them. Hence, this is an appropriate sub-problem.</p>
<p>For a subset of cities <b><i>S &#1028; {1, 2, 3, ... , n}</i></b> that includes <b><i>1</i></b>, and <b><i>j &#1028; S</i></b>, let <b><i>C(S, j)</i></b> be the length of the shortest path visiting each node in <b>S</b> exactly once, starting at <b><i>1</i></b> and ending at <b><i>j</i></b>.</p>
<p>When |<b><i>S</i></b>| &gt; 1, we define <b><i>C(S, 1)</i></b> = &prop; since the path cannot start and end at <b>1</b>.</p>
<p>Now, let express <b>C(S, j)</b> in terms of smaller sub-problems. We need to start at <b><i>1</i></b> and end at <b>j</b>. We should select the next city in such a way that</p>
<p>$$C(S, j) = min \:C(S - \lbrace j \rbrace, i) + d(i, j)\:where\: i\in S \: and\: i \neq j$$</p>
<pre class="result notranslate">
<b>Algorithm: Traveling-Salesman-Problem</b> 
C ({1}, 1) = 0 
for s = 2 to n do 
   for all subsets S &#1028; {1, 2, 3, … , n} of size s and containing 1 
      C (S, 1) = &infin; 
   for all j &#1028; S and j ≠ 1 
      C (S, j) = min {C (S – {j}, i) + d(i, j) for i &#1028; S and i ≠ j} 
Return minj C ({1, 2, 3, …, n}, j) + d(j, i) 
</pre>
<h2>Analysis</h2>
<p>There are at the most $2^n.n$ sub-problems and each one takes linear time to solve. Therefore, the total running time is $O(2^n.n^2)$.</p>
<h2>Example</h2>
<p>In the following example, we will illustrate the steps to solve the travelling salesman problem.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/analysis.jpg" alt="Analysis" />
<p>From the above graph, the following table is prepared.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>10</td>
<td>15</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>5</td>
<td>0</td>
<td>9</td>
<td>10</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>13</td>
<td>0</td>
<td>12</td>
</tr>
<tr>
<td>4</td>
<td>8</td>
<td>8</td>
<td>9</td>
<td>0</td>
</tr>
</table>
<h3>S = &Phi;</h3>
<p>$$\small Cost (2,\Phi,1) = d (2,1) = 5$$</p>
<p>$$\small Cost (3,\Phi,1) = d (3,1) = 6$$</p>
<p>$$\small Cost (4,\Phi,1) = d (4,1) = 8$$</p>
<h3>S = 1</h3>
<p>$$\small Cost (i,s) = min \lbrace Cost (j,s – (j)) + d [i,j]\rbrace$$</p>
<p>$$\small Cost (2,\lbrace 3 \rbrace,1) = d [2,3] + Cost (3,\Phi,1) = 9 + 6 = 15$$</p>
<p>$$\small Cost (2,\lbrace 4 \rbrace,1) = d [2,4] + Cost (4,\Phi,1) = 10 + 8 = 18$$</p>
<p>$$\small Cost (3,\lbrace 2 \rbrace,1) = d [3,2] + Cost (2,\Phi,1) = 13 + 5 = 18$$</p>
<p>$$\small Cost (3,\lbrace 4 \rbrace,1) = d [3,4] + Cost (4,\Phi,1) = 12 + 8 = 20$$</p>
<p>$$\small Cost (4,\lbrace 3 \rbrace,1) = d [4,3] + Cost (3,\Phi,1) = 9 + 6 = 15$$</p>
<p>$$\small Cost (4,\lbrace 2 \rbrace,1) = d [4,2] + Cost (2,\Phi,1) = 8 + 5 = 13$$</p>
<h3>S = 2</h3>
<p>$$\small Cost(2, \lbrace 3, 4 \rbrace, 1)=\begin{cases}d[2, 3] + Cost(3, \lbrace 4 \rbrace, 1) = 9 + 20 = 29\\d[2, 4] + Cost(4, \lbrace 3 \rbrace, 1) = 10 + 15 = 25\end{cases}= 25$$</p>
<p>$$\small Cost(3, \lbrace 2, 4 \rbrace, 1)=\begin{cases}d[3, 2] + Cost(2, \lbrace 4 \rbrace, 1) = 13 + 18 = 31\\d[3, 4] + Cost(4, \lbrace 2 \rbrace, 1) = 12 + 13 = 25\end{cases}= 25$$</p>
<p>$$\small Cost(4, \lbrace 2, 3 \rbrace, 1)=\begin{cases}d[4, 2] + Cost(2, \lbrace 3 \rbrace, 1) = 8 + 15 = 23\\d[4, 3] + Cost(3, \lbrace 2 \rbrace, 1) = 9 + 18 = 27\end{cases}= 23$$</p>
<h3>S = 3</h3>
<p>$$\small Cost(1, \lbrace 2, 3, 4 \rbrace, 1)=\begin{cases}d[1, 2] + Cost(2, \lbrace 3, 4 \rbrace, 1) = 10 + 25 = 35\\d[1, 3] + Cost(3, \lbrace 2, 4 \rbrace, 1) = 15 + 25 = 40\\d[1, 4] + Cost(4, \lbrace 2, 3 \rbrace, 1) = 20 + 23 = 43\end{cases}= 35$$</p>
<p>The minimum cost path is 35.</p>
<p>Start from cost <b>{1, {2, 3, 4}, 1}</b>, we get the minimum value for <b>d [1, 2]</b>. When <b>s = 3</b>, select the path from 1 to 2 (cost is 10) then go backwards. When <b>s = 2</b>, we get the minimum value for <b>d [4, 2]</b>. Select the path from 2 to 4 (cost is 10) then go backwards.</p>
<p>When <b>s = 1</b>, we get the minimum value for <b>d [4, 2]</b> but 2 and 4 is already selected. Therefore, we select <b>d [4, 3]</b> (two possible values are 15 for d [2, 3] and d [4, 3], but our last node of the path is 4). Select path 4 to 3 (cost is 9), then go to <b>s = &Phi;</b> step. We get the minimum value for <b>d [3, 1]</b> (cost is 6).</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/values.jpg" alt="Values" />
<h1>DAA - Optimal Cost Binary Search Trees</h1>
<p>A Binary Search Tree (BST) is a tree where the key values are stored in the internal nodes. The external nodes are null nodes. The keys are ordered lexicographically, i.e. for each internal node all the keys in the left sub-tree are less than the keys in the node, and all the keys in the right sub-tree are greater.</p>
<p>When we know the frequency of searching each one of the keys, it is quite easy to compute the expected cost of accessing each node in the tree. An optimal binary search tree is a BST, which has minimal expected cost of locating each node</p>
<p>Search time of an element in a BST is <b><i>O(n)</i></b>, whereas in a Balanced-BST search time is <b><i>O(log n)</i></b>. Again the search time can be improved in Optimal Cost Binary Search Tree, placing the most frequently used data in the root and closer to the root element, while placing the least frequently used data near leaves and in leaves.</p>
<p>Here, the Optimal Binary Search Tree Algorithm is presented. First, we build a BST from a set of provided <b>n</b> number of distinct keys <b><i>&lt; k<sub>1</sub>, k<sub>2</sub>, k<sub>3</sub>, ... k<sub>n</sub> &gt;</i></b>. Here we assume, the probability of accessing a key <b><i>K<sub>i</sub></i></b> is <b><i>p<sub>i</sub></i></b>. Some dummy keys (<b><i>d<sub>0</sub>, d<sub>1</sub>, d<sub>2</sub>, ... d<sub>n</sub></i></b>) are added as some searches may be performed for the values which are not present in the Key set <b><i>K</i></b>. We assume, for each dummy key <b><i>d<sub>i</sub></i></b> probability of access is <b><i>q<sub>i</sub></i></b>.</p>
<pre class="result notranslate">
<b>Optimal-Binary-Search-Tree(p, q, n)</b> 
e[1…n + 1, 0…n],  
w[1…n + 1, 0…n], 
root[1…n + 1, 0…n]  
for i = 1 to n + 1 do 
   e[i, i - 1] := q<sub>i</sub> - 1 
   w[i, i - 1] := q<sub>i</sub> - 1  
for l = 1 to n do 
   for i = 1 to n – l + 1 do 
      j = i + l – 1 e[i, j] := &infin; 
      w[i, i] := w[i, i -1] + p<sub>j</sub> + q<sub>j</sub> 
      for r = i to j do 
         t := e[i, r - 1] + e[r + 1, j] + w[i, j] 
         if t &lt; e[i, j] 
            e[i, j] := t 
            root[i, j] := r 
return e and root 
</pre>
<h2>Analysis</h2>
<p>The algorithm requires <b>O (n<sup>3</sup>)</b> time, since three nested <b>for</b> loops are used. Each of these loops takes on at most <b>n</b> values.</p>
<h2>Example</h2>
<p>Considering the following tree, the cost is 2.80, though this is not an optimal result.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/tree.jpg" alt="Tree" />
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Node</th>
<th style="text-align:center;">Depth</th>
<th style="text-align:center;">Probability</th>
<th style="text-align:center;">Contribution</th>
</tr>
<tr>
<td>k<sub>1</sub></td>
<td>1</td>
<td>0.15</td>
<td>0.30</td>
</tr>
<tr>
<td>k<sub>2</sub></td>
<td>0</td>
<td>0.10</td>
<td>0.10</td>
</tr>
<tr>
<td>k<sub>3</sub></td>
<td>2</td>
<td>0.05</td>
<td>0.15</td>
</tr>
<tr>
<td>k<sub>4</sub></td>
<td>1</td>
<td>0.10</td>
<td>0.20</td>
</tr>
<tr>
<td>k<sub>5</sub></td>
<td>2</td>
<td>0.20</td>
<td>0.60</td>
</tr>
<tr>
<td>d<sub>0</sub></td>
<td>2</td>
<td>0.05</td>
<td>0.15</td>
</tr>
<tr>
<td>d<sub>1</sub></td>
<td>2</td>
<td>0.10</td>
<td>0.30</td>
</tr>
<tr>
<td>d<sub>2</sub></td>
<td>3</td>
<td>0.05</td>
<td>0.20</td>
</tr>
<tr>
<td>d<sub>3</sub></td>
<td>3</td>
<td>0.05</td>
<td>0.20</td>
</tr>
<tr>
<td>d<sub>4</sub></td>
<td>3</td>
<td>0.05</td>
<td>0.20</td>
</tr>
<tr>
<td>d<sub>5</sub></td>
<td>3</td>
<td>0.10</td>
<td>0.40</td>
</tr>
<tr>
<td><b>Total</b></td>
<td></td>
<td></td>
<td>2.80</td>
</tr>
</table>
<p>To get an optimal solution, using the algorithm discussed in this chapter, the following tables are generated.</p>
<p>In the following tables, column index is <b>i</b> and row index is <b>j</b>.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">e</th>
<th style="text-align:center;">1</th>
<th style="text-align:center;">2</th>
<th style="text-align:center;">3</th>
<th style="text-align:center;">4</th>
<th style="text-align:center;">5</th>
<th style="text-align:center;">6</th>
</tr>
<tr>
<th style="text-align:center;">5</th>
<td>2.75</td>
<td>2.00</td>
<td>1.30</td>
<td>0.90</td>
<td>0.50</td>
<td>0.10</td>
</tr>
<tr>
<th style="text-align:center;">4</th>
<td>1.75</td>
<td>1.20</td>
<td>0.60</td>
<td>0.30</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">3</th>
<td>1.25</td>
<td>0.70</td>
<td>0.25</td>
<td>0.05</td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">2</th>
<td>0.90</td>
<td>0.40</td>
<td>0.05</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">1</th>
<td>0.45</td>
<td>0.10</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">0</th>
<td>0.05</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p></p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">w</th>
<th style="text-align:center;">1</th>
<th style="text-align:center;">2</th>
<th style="text-align:center;">3</th>
<th style="text-align:center;">4</th>
<th style="text-align:center;">5</th>
<th style="text-align:center;">6</th>
</tr>
<tr>
<th style="text-align:center;">5</th>
<td>1.00</td>
<td>0.80</td>
<td>0.60</td>
<td>0.50</td>
<td>0.35</td>
<td>0.10</td>
</tr>
<tr>
<th style="text-align:center;">4</th>
<td>0.70</td>
<td>0.50</td>
<td>0.30</td>
<td>0.20</td>
<td>0.05</td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">3</th>
<td>0.55</td>
<td>0.35</td>
<td>0.15</td>
<td>0.05</td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">2</th>
<td>0.45</td>
<td>0.25</td>
<td>0.05</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">1</th>
<td>0.30</td>
<td>0.10</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">0</th>
<td>0.05</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p></p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">root</th>
<th style="text-align:center;">1</th>
<th style="text-align:center;">2</th>
<th style="text-align:center;">3</th>
<th style="text-align:center;">4</th>
<th style="text-align:center;">5</th>
</tr>
<tr>
<th style="text-align:center;">5</th>
<td>2</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<th style="text-align:center;">4</th>
<td>2</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">3</th>
<td>2</td>
<td>2</td>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">2</th>
<td>1</td>
<td>2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<th style="text-align:center;">1</th>
<td>1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
<p>From these tables, the optimal tree can be formed.</p>
<h1>DAA - Binary Heap</h1>
<p>There are several types of heaps, however in this chapter, we are going to discuss binary heap. A <b>binary heap</b> is a data structure, which looks similar to a complete binary tree. Heap data structure obeys ordering properties discussed below. Generally, a Heap is represented by an array. In this chapter, we are representing a heap by <b><i>H</i></b>.</p>
<p>As the elements of a heap is stored in an array, considering the starting index as <b><i>1</i></b>, the position of the parent node of <b>i<sup>th</sup></b> element can be found at <b><i>&lfloor; i/2 &rfloor;</i></b> .  Left child and right child of <b>i<sup>th</sup></b> node is at position <b><i>2i</i></b> and <b><i>2i + 1</i></b>.</p>
<p>A binary heap can be classified further as either a <b><i>max-heap</i></b> or a <b><i>min-heap</i></b> based on the ordering property.</p>
<h2>Max-Heap</h2>
<p>In this heap, the key value of a node is greater than or equal to the key value of the highest child.</p>
<p style="padding-left:30%">Hence, <b><i>H[Parent(i)] &ge; H[i]</i></b></p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/maxheap.jpg" alt="Max-Heap" />
<h2>Min-Heap</h2>
<p>In mean-heap, the key value of a node is lesser than or equal to the key value of the lowest child.</p>
<p style="padding-left:30%">Hence, <b><i>H[Parent(i)] &le; H[i]</i></b></p>
<p>In this context, basic operations are shown below with respect to Max-Heap. Insertion and deletion of elements in and from heaps need rearrangement of elements. Hence, <b>Heapify</b> function needs to be called.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/minheap.jpg" alt="Min-Heap" />
<h2>Array Representation</h2>
<p>A complete binary tree can be represented by an array, storing its elements using level order traversal.</p>
<p>Let us consider a heap (as shown below) which will be represented by an array <b>H</b>.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/array_representation.jpg" alt="Array Representation" />
<p>Considering the starting index as <b>0</b>, using level order traversal, the elements are being kept in an array as follows.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<td><b>Index</b></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>...</td>
</tr>
<tr>
<td><b>elements</b></td>
<td>70</td>
<td>30</td>
<td>50</td>
<td>12</td>
<td>20</td>
<td>35</td>
<td>25</td>
<td>4</td>
<td>8</td>
<td>...</td>
</tr>
</table>
<p>In this context, operations on heap are being represented with respect to Max-Heap.</p>
<p>To find the index of the parent of an element at index <b>i</b>, the following algorithm <b><i>Parent (numbers[], i)</i></b> is used.</p>
<pre class="result notranslate">
<b>Algorithm: Parent (numbers[], i)</b> 
if i == 1 
   return NULL 
else 
   [i / 2]
</pre>
<p>The index of the left child of an element at index <b>i</b> can be found using the following algorithm, <b><i>Left-Child (numbers[], i)</i></b>.</p>
<pre class="result notranslate">
<b>Algorithm: Left-Child (numbers[], i)</b> 
If 2 * i &le; heapsize 
   return [2 * i] 
else 
   return NULL 
</pre>
<p>The index of the right child of an element at index <b>i</b> can be found using the following algorithm, <b><i>Right-Child(numbers[], i)</i></b>.</p>
<pre class="result notranslate">
<b>Algorithm: Right-Child (numbers[], i)</b> 
if 2 * i &lt; heapsize 
   return [2 * i + 1] 
else 
   return NULL
</pre>
<h1>DAA - Insert Method</h1>
<p>To insert an element in a heap, the new element is initially appended to the end of the heap as the last element of the array.</p>
<p>After inserting this element, heap property may be violated, hence the heap property is repaired by comparing the added element with its parent and moving the added element up a level, swapping positions with the parent. This process is called <b><i>percolation up</i></b>.</p>
<p>The comparison is repeated until the parent is larger than or equal to the percolating element.</p>
<pre class="result notranslate">
<b>Algorithm: Max-Heap-Insert (numbers[], key)</b> 
heapsize = heapsize + 1 
numbers[heapsize] = -&infin; 
i = heapsize 
numbers[i] = key 
while i &gt; 1 and numbers[Parent(numbers[], i)] &lt; numbers[i] 
   exchange(numbers[i], numbers[Parent(numbers[], i)]) 
   i = Parent (numbers[], i) 
</pre>
<h2>Analysis</h2>
<p>Initially, an element is being added at the end of the array. If it violates the heap property, the element is exchanged with its parent. The height of the tree is <b><i>log n</i></b>. Maximum <b><i>log n</i></b> number of operations needs to be performed.</p>
<p>Hence, the complexity of this function is <b><i>O(log n)</i></b>.</p>
<h2>Example</h2>
<p>Let us consider a max-heap, as shown below, where a new element 5 needs to be added.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/new_element.jpg" alt="New Element" />
<p>Initially, 55 will be added at the end of this array.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/array.jpg" alt="Array" />
<p>After insertion, it violates the heap property. Hence, the element needs to swap with its parent. After swap, the heap looks like the following.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/swap.jpg" alt="Swap" />
<p>Again, the element violates the property of heap. Hence, it is swapped with its parent.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/swapped.jpg" alt="Swapped" />
<p>Now, we have to stop.</p>
<h1>DAA - Heapify Method</h1>
<p>Heapify method rearranges the elements of an array where the left and right sub-tree of <b>i<sup>th</sup></b> element obeys the heap property.</p>
<pre class="result notranslate">
<b>Algorithm: Max-Heapify(numbers[], i)</b> 
leftchild := numbers[2i] 
rightchild := numbers [2i + 1] 
if leftchild &le; numbers[].size and numbers[leftchild] &gt; numbers[i] 
   largest := leftchild 
else 
   largest := i 
if rightchild &le; numbers[].size and numbers[rightchild] &gt; numbers[largest] 
   largest := rightchild 
if largest ≠ i 
   swap numbers[i] with numbers[largest] 
   Max-Heapify(numbers, largest)
</pre>
<p>When the provided array does not obey the heap property, Heap is built based on the following algorithm <b><i>Build-Max-Heap (numbers[])</i></b>.</p>
<pre class="result notranslate">
<b>Algorithm: Build-Max-Heap(numbers[])</b> 
numbers[].size := numbers[].length 
fori = &lfloor; numbers[].length/2 &rfloor; to 1 by -1 
   Max-Heapify (numbers[], i) 
</pre>
<h1>DAA - Extract Method</h1>
<p>Extract method is used to extract the root element of a Heap. Following is the algorithm.</p>
<pre class="result notranslate">
<b>Algorithm: Heap-Extract-Max (numbers[])</b> 
max = numbers[1] 
numbers[1] = numbers[heapsize] 
heapsize = heapsize – 1 
Max-Heapify (numbers[], 1) 
return max 
</pre>
<h2>Example</h2>
<p>Let us consider the same example discussed previously. Now we want to extract an element. This method will return the root element of the heap.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/method.jpg" alt="Method" />
<p>After deletion of the root element, the last element will be moved to the root position.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/root_element.jpg" alt="Root Element" />
<p>Now, Heapify function will be called. After Heapify, the following heap is generated.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/heapify.jpg" alt="Heapify" />
<h1>DAA - Bubble Sort</h1>
<p>Bubble Sort is an elementary sorting algorithm, which works by repeatedly exchanging adjacent elements, if necessary. When no exchanges are required, the file is sorted.</p>
<p>This is the simplest technique among all sorting algorithms.</p>
<pre class="result notranslate">
<b>Algorithm: Sequential-Bubble-Sort (A)</b> 
fori&larr; 1 to length [A] do 
for j &larr; length [A] down-to i +1 do 
   if A[A] &lt; A[j - 1] then 
      Exchange A[j] &harr; A[j-1] 
</pre>
<h2>Implementation</h2>
<pre class="result notranslate">
voidbubbleSort(int numbers[], intarray_size) { 
   inti, j, temp; 
   for (i = (array_size - 1); i &gt;= 0; i--) 
   for (j = 1; j &lt;= i; j++) 
      if (numbers[j - 1] &gt; numbers[j]) { 
         temp = numbers[j-1]; 
         numbers[j - 1] = numbers[j]; 
         numbers[j] = temp; 
      } 
} 
</pre>
<h2>Analysis</h2>
<p>Here, the number of comparisons are</p>
<p style="padding-left:20%"><b>1 + 2 + 3 +...+ (<i>n</i> - 1) = <i>n</i>(<i>n</i> - 1)/2 = O(<i>n</i><sup>2</sup>)</b></p>
<p>Clearly, the graph shows the <b><i>n<sup>2</sup></i></b> nature of the bubble sort.</p>
<p>In this algorithm, the number of comparison is irrespective of the data set, i.e. whether the provided input elements are in sorted order or in reverse order or at random.</p>
<h2>Memory Requirement</h2>
<p>From the algorithm stated above, it is clear that bubble sort does not require extra memory.</p>
<h2>Example</h2>
<table border="0" style="width:100%">
<tr>
<td><p><b>Unsorted list:</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">5</td>
<td style="padding:5px;">2</td>
<td style="padding:5px;">1</td>
<td style="padding:5px;">4</td>
<td style="padding:5px;">3</td>
<td style="padding:5px;">7</td>
<td style="padding:5px;">6</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>1<sup>st</sup> iteration:</h3>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p><b>5 &gt; 2 swap</b></p></td>
<td style="vertical-align:middle;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">7</td>
<td style="padding: 5px;">6</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>5 &gt; 1 swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">7</td>
<td style="padding: 5px;">6</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>5 &gt; 4 swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">7</td>
<td style="padding: 5px;">6</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>5 &gt; 3 swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">7</td>
<td style="padding: 5px;">6</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>5 &lt; 7 no swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">7</td>
<td style="padding: 5px;">6</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>7 &gt; 6 swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">6</td>
<td style="padding: 5px;">7</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>2<sup>nd</sup> iteration:</h3>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p><b>2 &gt; 1 swap</b></p></td>
<td style="vertical-align:middle;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">6</td>
<td style="padding: 5px;">7</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>2 &lt; 4 no swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">6</td>
<td style="padding: 5px;">7</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>4 &gt; 3 swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">6</td>
<td style="padding: 5px;">7</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>4 &lt; 5 no swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">6</td>
<td style="padding: 5px;">7</td>
</tr>
</table>
</td>
</tr>
<tr>
<td style="padding-left:15%"><p><b>5 &lt; 6 no swap</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">6</td>
<td style="padding: 5px;">7</td>
</tr>
</table>
</td>
</tr>
</table>
<p>There is no change in 3<sup>rd</sup>, 4<sup>th</sup>, 5<sup>th</sup> and 6<sup>th</sup> iteration.</p>
<p>Finally,</p>
<table border="0" style="width:100%">
<tr>
<td><p><b>the sorted list is</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</table>
</td>
</tr>
</table>
<h1>DAA - Insertion Sort</h1>
<p>Insertion sort is a very simple method to sort numbers in an ascending or descending order. This method follows the incremental method. It can be compared with the technique how cards are sorted at the time of playing a game.</p>
<p>The numbers, which are needed to be sorted, are known as <b>keys</b>. Here is the algorithm of the insertion sort method.</p>
<pre class="result notranslate">
<b>Algorithm: Insertion-Sort(A)</b> 
for j = 2 to A.length 
   key = A[j] 
   i = j – 1 
   while i &gt; 0 and A[i] &gt; key 
      A[i + 1] = A[i] 
      i = i -1 
   A[i + 1] = key 
</pre>
<h2>Analysis</h2>
<p>Run time of this algorithm is very much dependent on the given input.</p>
<p>If the given numbers are sorted, this algorithm runs in <b><i>O(n)</i></b> time. If the given numbers are in reverse order, the algorithm runs in <b><i>O(n<sup>2</sup>)</i></b> time.</p>
<h2>Example</h2>
<table border="0" style="width:100%">
<tr>
<td><p><b>Unsorted list:</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">18</td>
<td style="padding:5px;">14</td>
</tr>
</table>
</td>
</tr>
</table>
<p><b>1<sup>st</sup> iteration:</b></p>
<p style="padding-left:15%">Key = a[2] = 13</p>
<p style="padding-left:15%">a[1] = 2 &lt; 13</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap, no swap</p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">18</td>
<td style="padding:5px;">14</td>
</tr>
</table>
</td>
</tr>
</table>
<p><b>2<sup>nd</sup> iteration:</b></p>
<p style="padding-left:15%">Key = a[3] = 5</p>
<p style="padding-left:15%">a[2] = 13 &gt; 5</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap 5 and 13</p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">18</td>
<td style="padding:5px;">14</td>
</tr>
</table>
</td>
</tr>
</table>
<p style="padding-left:15%">Next, a[1] = 2 &lt; 13</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap, no swap</p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">18</td>
<td style="padding:5px;">14</td>
</tr>
</table>
</td>
</tr>
</table>
<p><b>3<sup>rd</sup> iteration:</b></p>
<p style="padding-left:15%">Key = a[4] = 18</p>
<p style="padding-left:15%">a[3] = 13 &lt; 18,</p>
<p style="padding-left:15%">a[2] = 5 &lt; 18,</p>
<p style="padding-left:15%">a[1] = 2 &lt; 18</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap, no swap</p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">18</td>
<td style="padding:5px;">14</td>
</tr>
</table>
</td>
</tr>
</table>
<p><b>4<sup>th</sup> iteration:</b></p>
<p style="padding-left:15%">Key = a[5] = 14</p>
<p style="padding-left:15%">a[4] = 18 &gt; 14</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap 18 and 14</p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">14</td>
<td style="padding:5px;">18</td>
</tr>
</table>
</td>
</tr>
</table>
<p style="padding-left:15%">Next, a[3] = 13 &lt; 14,</p>
<p style="padding-left:15%">a[2] = 5 &lt; 14,</p>
<p style="padding-left:15%">a[1] = 2 &lt; 14</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>So, no swap</p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">14</td>
<td style="padding:5px;">18</td>
</tr>
</table>
</td>
</tr>
</table>
<p>Finally,</p>
<table border="0" style="width:100%">
<tr>
<td><p><b>the sorted list is</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">2</td>
<td style="padding:5px;">5</td>
<td style="padding:5px;">13</td>
<td style="padding:5px;">14</td>
<td style="padding:5px;">18</td>
</tr>
</table>
</td>
</tr>
</table>
<h1>DAA - Selection Sort</h1>
<p>This type of sorting is called <b>Selection Sort</b> as it works by repeatedly sorting elements. It works as follows: first find the smallest in the array and exchange it with the element in the first position, then find the second smallest element and exchange it with the element in the second position, and continue in this way until the entire array is sorted.</p>
<pre class="result notranslate">
<b>Algorithm: Selection-Sort (A)</b> 
fori &larr; 1 to n-1 do 
   min j &larr; i; 
   min x &larr; A[i] 
   for j &larr;i + 1 to n do 
      if A[j] &lt; min x then 
         min j &larr; j 
         min x &larr; A[j] 
   A[min j] &larr; A [i] 
   A[i] &larr; min x 
</pre>
<p>Selection sort is among the simplest of sorting techniques and it works very well for small files. It has a quite important application as each item is actually moved at the most once.</p>
<p>Section sort is a method of choice for sorting files with very large objects (records) and small keys. The worst case occurs if the array is already sorted in a descending order and we want to sort them in an ascending order.</p>
<p>Nonetheless, the time required by selection sort algorithm is not very sensitive to the original order of the array to be sorted: the test if <b><i>A[j]</i></b> &lt; <b><i>min x</i></b> is executed exactly the same number of times in every case.</p>
<p>Selection sort spends most of its time trying to find the minimum element in the unsorted part of the array. It clearly shows the similarity between Selection sort and Bubble sort.</p>
<ul class="list">
<li><p>Bubble sort selects the maximum remaining elements at each stage, but wastes some effort imparting some order to an unsorted part of the array.</p></li>
<li><p>Selection sort is quadratic in both the worst and the average case, and requires no extra memory.</p></li>
</ul>
<p>For each <b><i>i</i></b> from <b><i>1</i></b> to <b><i>n - 1</i></b>, there is one exchange and <b><i>n - i</i></b> comparisons, so there is a total of <b><i>n - 1</i></b> exchanges and</p>
<p style="padding-left:15%"><b><i>(n − 1) + (n − 2) + ...+ 2 + 1 = n(n − 1)/2</i></b> comparisons.</p>
<p>These observations hold, no matter what the input data is.</p>
<p>In the worst case, this could be quadratic, but in the average case, this quantity is <b><i>O(n log n)</i></b>. It implies that the <b>running time of Selection sort is quite insensitive to the input</b>.</p>
<h2>Implementation</h2>
<pre class="result notranslate">
Void Selection-Sort(int numbers[], int array_size) { 
   int i, j; 
   int min, temp;  
   for (i = 0; I &lt; array_size-1; i++) { 
      min = i; 
      for (j = i+1; j &lt; array_size; j++) 
         if (numbers[j] &lt; numbers[min]) 
            min = j; 
      temp = numbers[i]; 
      numbers[i] = numbers[min]; 
      numbers[min] = temp; 
   } 
} 
</pre>
<h2>Example</h2>
<table border="0" style="width:100%">
<tr>
<td><p><b>Unsorted list:</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding:5px;">5</td>
<td style="padding:5px;">2</td>
<td style="padding:5px;">1</td>
<td style="padding:5px;">4</td>
<td style="padding:5px;">3</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>1<sup>st</sup> iteration:</h3>
<p style="padding-left:15%">Smallest = 5</p>
<p style="padding-left:15%">2 &lt; 5, smallest = 2</p>
<p style="padding-left:15%">1 &lt; 2, smallest = 1</p>
<p style="padding-left:15%">4 &gt; 1, smallest = 1</p>
<p style="padding-left:15%">3 &gt; 1, smallest = 1</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap 5 and 1</p></td>
<td style="vertical-align:middle;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>2<sup>nd</sup> iteration:</h3>
<p style="padding-left:15%">Smallest = 2</p>
<p style="padding-left:15%">2 &lt; 5, smallest = 2</p>
<p style="padding-left:15%">2 &lt; 4, smallest = 2</p>
<p style="padding-left:15%">2 &lt; 3, smallest = 2</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>No Swap</p></td>
<td style="vertical-align:middle;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">5</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">3</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>3<sup>rd</sup> iteration:</h3>
<p style="padding-left:15%">Smallest = 5</p>
<p style="padding-left:15%">4 &lt; 5, smallest = 4</p>
<p style="padding-left:15%">3 &lt; 4, smallest = 3</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>Swap 5 and 3</p></td>
<td style="vertical-align:middle;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">5</td>
</tr>
</table>
</td>
</tr>
</table>
<h3>4<sup>th</sup> iteration:</h3>
<p style="padding-left:15%">Smallest = 4</p>
<p style="padding-left:15%">4 &lt; 5, smallest = 4</p>
<table border="0" style="width:100%">
<tr>
<td style="padding-left:15%"><p>No Swap</p></td>
<td style="vertical-align:middle;">
<table style="text-align:center;" class="table table-bordered">
<tr>
<td style="padding: 5px;">1</td>
<td style="padding: 5px;">2</td>
<td style="padding: 5px;">3</td>
<td style="padding: 5px;">4</td>
<td style="padding: 5px;">5</td>
</tr>
</table>
</td>
</tr>
</table>
<p>Finally,</p>
<table border="0" style="width:100%">
<tr>
<td><p><b>the sorted list is</b></p></td>
<td>
<table style="text-align:center;" class="table table-bordered">
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</table>
</td>
</tr>
</table>
<h1>DAA - Quick Sort</h1>
<p>It is used on the principle of divide-and-conquer. Quick sort is an algorithm of choice in many situations as it is not difficult to implement. It is a good general purpose sort and it consumes relatively fewer resources during execution.</p>
<h2>Advantages</h2>
<ul class="list">
<li><p>It is in-place since it uses only a small auxiliary stack.</p></li>
<li><p>It requires only <b><i>n (log n)</i></b> time to sort <b>n</b> items.</p></li>
<li><p>It has an extremely short inner loop.</p></li>
<li><p>This algorithm has been subjected to a thorough mathematical analysis, a very precise statement can be made about performance issues.</p></li>
</ul>
<h2>Disadvantages</h2>
<ul class="list">
<li><p>It is recursive. Especially, if recursion is not available, the implementation is extremely complicated.</p></li>
<li><p>It requires quadratic (i.e., n2) time in the worst-case.</p></li>
<li><p>It is fragile, i.e. a simple mistake in the implementation can go unnoticed and cause it to perform badly.</p></li>
</ul>
<p>Quick sort works by partitioning a given array <b><i>A[p ... r]</i></b> into two non-empty sub array <b><i>A[p ... q]</i></b> and <b><i>A[q+1 ... r]</i></b> such that every key in <b><i>A[p ... q]</i></b> is less than or equal to every key in <b><i>A[q+1 ... r]</i></b>.</p>
<p>Then, the two sub-arrays are sorted by recursive calls to Quick sort. The exact position of the partition depends on the given array and index <b><i>q</i></b> is computed as a part of the partitioning procedure.</p>
<pre class="result notranslate">
<b>Algorithm: Quick-Sort (A, p, r)</b> 
if p &lt; r then 
   q Partition (A, p, r) 
   Quick-Sort (A, p, q) 
   Quick-Sort (A, q + r, r) 
</pre>
<p>Note that to sort the entire array, the initial call should be <b><i>Quick-Sort (A, 1, length[A])</i></b></p>
<p>As a first step, Quick Sort chooses one of the items in the array to be sorted as pivot. Then, the array is partitioned on either side of the pivot. Elements that are less than or equal to pivot will move towards the left, while the elements that are greater than or equal to pivot will move towards the right.</p>
<h2>Partitioning the Array</h2>
<p>Partitioning procedure rearranges the sub-arrays in-place.</p>
<pre class="result notranslate">
<b>Function: Partition (A, p, r)</b> 
x &larr; A[p] 
i &larr; p-1 
j &larr; r+1 
while TRUE do 
   Repeat j &larr; j - 1 
   until A[j] &le; x  
   Repeat i&larr; i+1 
   until A[i] &ge; x  
   if i &lt; j then  
      exchange A[i] &harr; A[j] 
   else  
      return j 
</pre>
<h2>Analysis</h2>
<p>The worst case complexity of Quick-Sort algorithm is <b><i>O(n<sup>2</sup>)</i></b>. However using this technique, in average cases generally we get the output in <b><i>O(n log n)</i></b> time.</p>
<h1>DAA - Radix Sort</h1>
<p><b>Radix sort</b> is a small method that many people intuitively use when alphabetizing a large list of names. Specifically, the list of names is first sorted according to the first letter of each name, that is, the names are arranged in 26 classes.</p>
<p>Intuitively, one might want to sort numbers on their most significant digit. However, Radix sort works counter-intuitively by sorting on the least significant digits first. On the first pass, all the numbers are sorted on the least significant digit and combined in an array. Then on the second pass, the entire numbers are sorted again on the second least significant digits and combined in an array and so on.</p>
<pre class="result notranslate">
<b>Algorithm: Radix-Sort (list, n)</b> 
shift = 1 
for loop = 1 to keysize do 
   for entry = 1 to n do 
      bucketnumber = (list[entry].key / shift) mod 10 
      append (bucket[bucketnumber], list[entry]) 
   list = combinebuckets() 
   shift = shift * 10 
</pre>
<h2>Analysis</h2>
<p>Each key is looked at once for each digit (or letter if the keys are alphabetic) of the longest key. Hence, if the longest key has <b>m</b> digits and there are <b>n</b> keys, radix sort has order <b>O(m.n)</b>.</p>
<p>However, if we look at these two values, the size of the keys will be relatively small when compared to the number of keys. For example, if we have six-digit keys, we could have a million different records.</p>
<p>Here, we see that the size of the keys is not significant, and this algorithm is of linear complexity <b>O(n)</b>.</p>
<h2>Example</h2>
<p>Following example shows how Radix sort operates on seven 3-digits number.</p>
<table class="table table-bordered" style="text-align:center;">
<tr>
<th style="text-align:center;">Input</th>
<th style="text-align:center;">1<sup>st</sup> Pass</th>
<th style="text-align:center;">2<sup>nd</sup> Pass</th>
<th style="text-align:center;">3<sup>rd</sup> Pass</th>
</tr>
<tr>
<td>329</td>
<td>720</td>
<td>720</td>
<td>329</td>
</tr>
<tr>
<td>457</td>
<td>355</td>
<td>329</td>
<td>355</td>
</tr>
<tr>
<td>657</td>
<td>436</td>
<td>436</td>
<td>436</td>
</tr>
<tr>
<td>839</td>
<td>457</td>
<td>839</td>
<td>457</td>
</tr>
<tr>
<td>436</td>
<td>657</td>
<td>355</td>
<td>657</td>
</tr>
<tr>
<td>720</td>
<td>329</td>
<td>457</td>
<td>720</td>
</tr>
<tr>
<td>355</td>
<td>839</td>
<td>657</td>
<td>839</td>
</tr>
</table>
<p>In the above example, the first column is the input. The remaining columns show the list after successive sorts on increasingly significant digits position. The code for Radix sort assumes that each element in an array <b><i>A</i></b> of <b><i>n</i></b> elements has <b><i>d</i></b> digits, where digit <b><i>1</i></b> is the lowest-order digit and <b><i>d</i></b> is the highest-order digit.</p>
<h1>Deterministic vs. Nondeterministic Computations</h1>
<p>To understand class <b>P</b> and <b>NP</b>, first we should know the computational model. Hence, in this chapter we will discuss two important computational models.</p>
<h2>Deterministic Computation and the Class P</h2>
<h3>Deterministic Turing Machine</h3>
<p>One of these models is deterministic one-tape Turing machine. This machine consists of a finite state control, a read-write head and a two-way tape with infinite sequence.</p>
<p>Following is the schematic diagram of a deterministic one-tape Turing machine.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/deterministic_turing_machine.jpg" alt="Deterministic Turing Machine" />
<p>A program for a deterministic Turing machine specifies the following information &minus;</p>
<ul class="list">
<li>A finite set of tape symbols (input symbols and a blank symbol)</li>
<li>A finite set of states</li>
<li>A transition function</li>
</ul>
<p>In algorithmic analysis, if a problem is solvable in polynomial time by a deterministic one tape Turing machine, the problem belongs to P class.</p>
<h2>Nondeterministic Computation and the Class NP</h2>
<h3>Nondeterministic Turing Machine</h3>
<p>To solve the computational problem, another model is the Non-deterministic Turing Machine (NDTM). The structure of NDTM is similar to DTM, however here we have one additional module known as the guessing module, which is associated with one write-only head.</p>
<p>Following is the schematic diagram.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/nondeterministic_turing_machine.jpg" alt="Nondeterministic Turing Machine" />
<p>If the problem is solvable in polynomial time by a non-deterministic Turing machine, the problem belongs to NP class.</p>
<h1>DAA - Max Cliques</h1>
<p>In an undirected graph, a <b>clique</b> is a complete sub-graph of the given graph. Complete sub-graph means, all the vertices of this sub-graph is connected to all other vertices of this sub-graph.</p>
<p>The Max-Clique problem is the computational problem of finding maximum clique of the graph. Max clique is used in many real-world problems.</p>
<p>Let us consider a social networking application, where vertices represent people’s profile and the edges represent mutual acquaintance in a graph. In this graph, a clique represents a subset of people who all know each other.</p>
<p>To find a maximum clique, one can systematically inspect all subsets, but this sort of brute-force search is too time-consuming for networks comprising more than a few dozen vertices.</p>
<pre class="result notrnslate">
<b>Algorithm: Max-Clique (G, n, k)</b> 
S := &Phi; 
for i = 1 to k do 
   t := choice (1…n)  
   if t &#1028; S then 
      return failure 
   S := S &cup; t  
for all pairs (i, j) such that i &#1028; S and j &#1028; S and i ≠ j do 
   if (i, j) is not a edge of the graph then  
      return failure 
return success 
</pre>
<h2>Analysis</h2>
<p>Max-Clique problem is a non-deterministic algorithm. In this algorithm, first we try to determine a set of <b>k</b> distinct vertices and then we try to test whether these vertices form a complete graph.</p>
<p>There is no polynomial time deterministic algorithm to solve this problem. This problem is NP-Complete.</p>
<h2>Example</h2>
<p>Take a look at the following graph. Here, the sub-graph containing vertices 2, 3, 4 and 6 forms a complete graph. Hence, this sub-graph is a <b>clique</b>. As this is the maximum complete sub-graph of the provided graph, it’s a <b>4-Clique</b>.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/max_cliques.jpg" alt="Max Cliques" />
<h1>DAA - Vertex Cover</h1>
<p>A vertex-cover of an undirected graph <b><i>G = (V, E)</i></b> is a subset of vertices <b><i>V<sup>'</sup>  &sube; V</i></b> such that if edge <b><i>(u, v)</i></b> is an edge of <b><i>G</i></b>, then either <b><i>u</i></b> in <b><i>V</i></b> or <b><i>v</i></b> in <b><i>V<sup>'</sup></i></b> or both.</p>
<p>Find a vertex-cover of maximum size in a given undirected graph. This optimal vertexcover is the optimization version of an NP-complete problem. However, it is not too hard to find a vertex-cover that is near optimal.</p>
<pre class="result notranslate">
<b>APPROX-VERTEX_COVER (G: Graph) c &larr; { } E<sup>'</sup> &larr; E[G]</b> 
while E<sup>'</sup> is not empty do 
   Let (u, v) be an arbitrary edge of E<sup>'</sup> c &larr; c U {u, v} 
   Remove from E<sup>'</sup> every edge incident on either u or v 
return c
</pre>
<h2>Example</h2>
<p>The set of edges of the given graph is &minus;</p>
<p style="padding-left:6%"><b>{(1,6),(1,2),(1,4),(2,3),(2,4),(6,7),(4,7),(7,8),(3,8),(3,5),(8,5)}</b></p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/set_edges.jpg" alt="Set Edges" />
<p>Now, we start by selecting an arbitrary edge (1,6). We eliminate all the edges, which are either incident to vertex 1 or 6 and we add edge (1,6) to cover.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/arbitrary_edge.jpg" alt="Arbitrary Edge" />
<p>In the next step, we have chosen another edge (2,3) at random</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/another_edge.jpg" alt="Another Edge" />
<p>Now we select another edge (4,7).</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/select_another_edge.jpg" alt="Select Another Edge" />
<p>We select another edge (8,5).</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/edge.jpg" alt="Edge" />
<p>Hence, the vertex cover of this graph is {1,2,4,5}.</p>
<h2>Analysis</h2>
<p>It is easy to see that the running time of this algorithm is <b><i>O(V + E)</i></b>, using adjacency list to represent <b><i>E<sup>'</sup></i></b>.</p>
<h1>DAA - P &amp; NP Class</h1>
<p>In Computer Science, many problems are solved where the objective is to maximize or minimize some values, whereas in other problems we try to find whether there is a solution or not. Hence, the problems can be categorized as follows &minus;</p>
<h2>Optimization Problem</h2>
<p>Optimization problems are those for which the objective is to maximize or minimize some values. For example,</p>
<ul class="list">
<li><p>Finding the minimum number of colors needed to color a given graph.</p></li>
<li><p>Finding the shortest path between two vertices in a graph.</p></li>
</ul>
<h2>Decision Problem</h2>
<p>There are many problems for which the answer is a Yes or a No. These types of problems are known as <b>decision problems</b>. For example,</p>
<ul class="list">
<li><p>Whether a given graph can be colored by only 4-colors.</p></li>
<li><p>Finding Hamiltonian cycle in a graph is not a decision problem, whereas checking a graph is Hamiltonian or not is a decision problem.</p></li>
</ul>
<h2>What is Language?</h2>
<p>Every decision problem can have only two answers, yes or no. Hence, a decision problem may belong to a language if it provides an answer ‘yes’ for a specific input. A language is the totality of inputs for which the answer is Yes. Most of the algorithms discussed in the previous chapters are <b>polynomial time algorithms</b>.</p>
<p>For input size <b><i>n</i></b>, if worst-case time complexity of an algorithm is <b><i>O(n<sup>k</sup>)</i></b>, where <b><i>k</i></b> is a constant, the algorithm is a polynomial time algorithm.</p>
<p>Algorithms such as Matrix Chain Multiplication, Single Source Shortest Path, All Pair Shortest Path, Minimum Spanning Tree, etc. run in polynomial time. However there are many problems, such as traveling salesperson, optimal graph coloring, Hamiltonian cycles, finding the longest path in a graph, and satisfying a Boolean formula, for which no polynomial time algorithms is known. These problems belong to an interesting class of problems, called the <b>NP-Complete</b> problems, whose status is unknown.</p>
<p>In this context, we can categorize the problems as follows &minus;</p>
<h2>P-Class</h2>
<p>The class P consists of those problems that are solvable in polynomial time, i.e. these problems can be solved in time <b><i>O(n<sup>k</sup>)</i></b> in worst-case, where <b>k</b> is constant.</p>
<p>These problems are called <b>tractable</b>, while others are called <b>intractable or superpolynomial</b>.</p>
<p>Formally, an algorithm is polynomial time algorithm, if there exists a polynomial <b><i>p(n)</i></b> such that the algorithm can solve any instance of size <b>n</b> in a time <b><i>O(p(n))</i></b>.</p>
<p>Problem requiring <b><i>&ohm;(n<sup>50</sup>)</i></b> time to solve are essentially intractable for large <b><i>n</i></b>. Most known polynomial time algorithm run in time <b><i>O(n<sup>k</sup>)</i></b> for fairly low value of <b><i>k</i></b>.</p>
<p>The advantages in considering the class of polynomial-time algorithms is that all reasonable <b>deterministic single processor model of computation</b> can be simulated on each other with at most a polynomial slow-d</p>
<h2>NP-Class</h2>
<p>The class NP consists of those problems that are verifiable in polynomial time. NP is the class of decision problems for which it is easy to check the correctness of a claimed answer, with the aid of a little extra information. Hence, we aren’t asking for a way to find a solution, but only to verify that an alleged solution really is correct.</p>
<p>Every problem in this class can be solved in exponential time using exhaustive search.</p>
<h2>P versus NP</h2>
<p>Every decision problem that is solvable by a deterministic polynomial time algorithm is also solvable by a polynomial time non-deterministic algorithm.</p>
<p>All problems in P can be solved with polynomial time algorithms, whereas all problems in <i>NP - P</i> are intractable.</p>
<p>It is not known whether <b><i>P = NP</i></b>. However, many problems are known in NP with the property that if they belong to P, then it can be proved that P = NP.</p>
<p>If <b><i>P &ne; NP</i></b>, there are problems in NP that are neither in P nor in NP-Complete.</p>
<p>The problem belongs to class <b>P</b> if it’s easy to find a solution for the problem. The problem belongs to <b>NP</b>, if it’s easy to check a solution that may have been very tedious to find.</p>
<h1>DAA - Cook’s Theorem</h1>
<p>Stephen Cook presented four theorems in his paper “The Complexity of Theorem Proving Procedures”. These theorems are stated below. We do understand that many unknown terms are being used in this chapter, but we don’t have any scope to discuss everything in detail.</p>
<p>Following are the four theorems by Stephen Cook &minus;</p>
<h2>Theorem-1</h2>
<p>If a set <b>S</b> of strings is accepted by some non-deterministic Turing machine within polynomial time, then <b>S</b> is P-reducible to {DNF tautologies}.</p>
<h2>Theorem-2</h2>
<p>The following sets are P-reducible to each other in pairs (and hence each has the same polynomial degree of difficulty): {tautologies}, {DNF tautologies}, D3, {sub-graph pairs}.</p>
<h2>Theorem-3</h2>
<ul class="list">
<li><p>For any <b><i>T<sub>Q</sub>(k)</i></b> of type <b>Q</b>, $\mathbf{\frac{T_{Q}(k)}{\frac{\sqrt{k}}{(log\:k)^2}}}$ is unbounded</p></li>
<li><p>There is a <b><i>T<sub>Q</sub>(k)</i></b> of type <b>Q</b> such that $T_{Q}(k)\leqslant 2^{k(log\:k)^2}$</p></li>
</ul>
<h2>Theorem-4</h2>
<p>If the set S of strings is accepted by a non-deterministic machine within time <b><i>T(n) = 2<sup>n</sup></i></b>, and if <b><i>T<sub>Q</sub>(k)</i></b> is an honest (i.e. real-time countable) function of type <b>Q</b>, then there is a constant <b>K</b>, so <b>S</b> can be recognized by a deterministic machine within time <b><i>T<sub>Q</sub>(K8<sup>n</sup>)</i></b>.</p>
<ul class="list">
<li><p>First, he emphasized the significance of polynomial time reducibility. It means that if we have a polynomial time reduction from one problem to another, this ensures that any polynomial time algorithm from the second problem can be converted into a corresponding polynomial time algorithm for the first problem.</p></li>
<li><p>Second, he focused attention on the class NP of decision problems that can be solved in polynomial time by a non-deterministic computer. Most of the intractable problems belong to this class, NP.</p></li>
<li><p>Third, he proved that one particular problem in NP has the property that every other problem in NP can be polynomially reduced to it. If the satisfiability problem can be solved with a polynomial time algorithm, then every problem in NP can also be solved in polynomial time. If any problem in NP is intractable, then satisfiability problem must be intractable. Thus, satisfiability problem is the hardest problem in NP.</p></li>
<li><p>Fourth, Cook suggested that other problems in NP might share with the satisfiability problem this property of being the hardest member of NP.</p></li>
</ul>
<h1>NP Hard and NP-Complete Classes</h1>
<p>A problem is in the class NPC if it is in NP and is as <b>hard</b> as any problem in NP. A problem is <b>NP-hard</b> if all problems in NP are polynomial time reducible to it, even though it may not be in NP itself.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/np_hard.jpg" alt="NP-hard" />
<p>If a polynomial time algorithm exists for any of these problems, all problems in NP would be polynomial time solvable. These problems are called <b>NP-complete</b>. The phenomenon of NP-completeness is important for both theoretical and practical reasons.</p>
<h2>Definition of NP-Completeness</h2>
<p>A language <b>B</b> is <b><i>NP-complete</i></b> if it satisfies two conditions</p>
<ul class="list">
<li><p><b>B</b> is in NP</p></li>
<li><p>Every <b>A</b> in NP is polynomial time reducible to <b>B</b>.</p></li>
</ul>
<p>If a language satisfies the second property, but not necessarily the first one, the language <b>B</b> is known as <b>NP-Hard</b>. Informally, a search problem <b>B</b> is <b>NP-Hard</b> if there exists some <b>NP-Complete</b> problem <b>A</b> that Turing reduces to <b>B</b>.</p>
<p>The problem in NP-Hard cannot be solved in polynomial time, until <b>P = NP</b>. If a problem is proved to be NPC, there is no need to waste time on trying to find an efficient algorithm for it. Instead, we can focus on design approximation algorithm.</p>
<h2>NP-Complete Problems</h2>
<p>Following are some NP-Complete problems, for which no polynomial time algorithm is known.</p>
<ul class="list">
<li>Determining whether a graph has a Hamiltonian cycle</li>
<li>Determining whether a Boolean formula is satisfiable, etc.</li> 
</ul>
<h2>NP-Hard Problems</h2>
<p>The following problems are NP-Hard</p>
<ul class="list">
<li>The circuit-satisfiability problem </li>
<li>Set Cover </li>
<li>Vertex Cover</li>
<li>Travelling Salesman Problem</li>
</ul>
<p>In this context, now we will discuss TSP is NP-Complete</p>
<h2>TSP is NP-Complete</h2>
<p>The traveling salesman problem consists of a salesman and a set of cities. The salesman has to visit each one of the cities starting from a certain one and returning to the same city. The challenge of the problem is that the traveling salesman wants to minimize the total length of the trip</p>
<h2>Proof</h2>
<p>To prove <b><i>TSP is NP-Complete</i></b>, first we have to prove that <b><i>TSP belongs to NP</i></b>. In TSP, we find a tour and check that the tour contains each vertex once. Then the total cost of the edges of the tour is calculated. Finally, we check if the cost is minimum. This can be completed in polynomial time. Thus <b><i>TSP belongs to NP</i></b>.</p>
<p>Secondly, we have to prove that <b><i>TSP is NP-hard</i></b>. To prove this, one way is to show that <b><i>Hamiltonian cycle &le;<sub>p</sub> TSP</i></b> (as we know that the Hamiltonian cycle problem is NPcomplete).</p>
<p>Assume <b><i>G = (V, E)</i></b> to be an instance of Hamiltonian cycle.</p>
<p>Hence, an instance of TSP is constructed. We create the complete graph <b><i>G<sup>'</sup> = (V, E<sup>'</sup>)</i></b>, where</p>
<p>$$E^{'}=\lbrace(i, j)\colon i, j \in V \:\:and\:i\neq j$$</p>
<p>Thus, the cost function is defined as follows &minus;</p>
<p>$$t(i,j)=\begin{cases}0 & if\: (i, j)\: \in E\\1 & otherwise\end{cases}$$</p>
<p>Now, suppose that a Hamiltonian cycle <b><i>h</i></b> exists in <b><i>G</i></b>. It is clear that the cost of each edge in <b><i>h</i></b> is <b>0</b> in <b><i>G<sup>'</sup></i></b> as each edge belongs to <b><i>E</i></b>. Therefore, <b><i>h</i></b> has a cost of <b>0</b> in <b><i>G<sup>'</sup></i></b>. Thus, if graph <b><i>G</i></b> has a Hamiltonian cycle, then graph <b><i>G<sup>'</sup></i></b> has a tour of <b>0</b> cost.</p>
<p>Conversely, we assume that <b><i>G<sup>'</sup></i></b> has a tour <b><i>h<sup>'</sup></i></b> of cost at most <b>0</b>. The cost of edges in <b><i>E<sup>'</sup></i></b> are <b>0</b> and <b>1</b> by definition. Hence, each edge must have a cost of <b>0</b> as the cost of <b><i>h<sup>'</sup></i></b> is <b>0</b>. We therefore conclude that <b><i>h<sup>'</sup></i></b> contains only edges in <b><i>E</i></b>.</p>
<p>We have thus proven that <b><i>G</i></b> has a Hamiltonian cycle, if and only if <b><i>G<sup>'</sup></i></b> has a tour of cost at most <b>0</b>. TSP is NP-complete.</p>
<h1>DAA - Hill Climbing Algorithm</h1>
<p>The algorithms discussed in the previous chapters run systematically. To achieve the goal, one or more previously explored paths toward the solution need to be stored to find the optimal solution.</p>
<p>For many problems, the path to the goal is irrelevant. For example, in N-Queens problem, we don’t need to care about the final configuration of the queens as well as in which order the queens are added.</p>
<h2>Hill Climbing</h2>
<p>Hill Climbing is a technique to solve certain optimization problems. In this technique, we start with a sub-optimal solution and the solution is improved repeatedly until some condition is maximized.</p>
<img src="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/hill_climbing.jpg" alt="Hill Climbing" />
<p>The idea of starting with a sub-optimal solution is compared to starting from the base of the hill, improving the solution is compared to walking up the hill, and finally maximizing some condition is compared to reaching the top of the hill.</p>
<p>Hence, the hill climbing technique can be considered as the following phases &minus;</p>
<ul class="list">
<li>Constructing a sub-optimal solution obeying the constraints of the problem</li>
<li>Improving the solution step-by-step</li>
<li>Improving the solution until no more improvement is possible</li>
</ul>
<p>Hill Climbing technique is mainly used for solving computationally hard problems. It looks only at the current state and immediate future state. Hence, this technique is memory efficient as it does not maintain a search tree.</p>
<pre class="result notranslate">
<b>Algorithm: Hill Climbing</b> 
Evaluate the initial state. 
Loop until a solution is found or there are no new operators left to be applied: 
   - Select and apply a new operator 
   - Evaluate the new state: 
      goal -&rarr; quit 
      better than current state -&rarr; new current state 
</pre>
<h3>Iterative Improvement</h3>
<p>In iterative improvement method, the optimal solution is achieved by making progress towards an optimal solution in every iteration. However, this technique may encounter local maxima. In this situation, there is no nearby state for a better solution.</p>
<p>This problem can be avoided by different methods. One of these methods is simulated annealing.</p>
<h3>Random Restart</h3>
<p>This is another method of solving the problem of local optima. This technique conducts a series of searches. Every time, it starts from a randomly generated initial state. Hence, optima or nearly optimal solution can be obtained comparing the solutions of searches performed.</p>
<h2>Problems of Hill Climbing Technique</h2>
<h3>Local Maxima</h3>
<p>If the heuristic is not convex, Hill Climbing may converge to local maxima, instead of global maxima.</p>
<h3>Ridges and Alleys</h3>
<p>If the target function creates a narrow ridge, then the climber can only ascend the ridge or descend the alley by zig-zagging. In this scenario, the climber needs to take very small steps requiring more time to reach the goal.</p>
<h3>Plateau</h3>
<p>A plateau is encountered when the search space is flat or sufficiently flat that the value returned by the target function is indistinguishable from the value returned for nearby regions, due to the precision used by the machine to represent its value.</p>
<h2>Complexity of Hill Climbing Technique</h2>
<p>This technique does not suffer from space related issues, as it looks only at the current state. Previously explored paths are not stored.</p>
<p>For most of the problems in Random-restart Hill Climbing technique, an optimal solution can be achieved in polynomial time. However, for NP-Complete problems, computational time can be exponential based on the number of local maxima.</p>
<h2>Applications of Hill Climbing Technique</h2>
<p>Hill Climbing technique can be used to solve many problems, where the current state allows for an accurate evaluation function, such as Network-Flow, Travelling Salesman problem, 8-Queens problem, Integrated Circuit design, etc.</p>
<p>Hill Climbing is used in inductive learning methods too. This technique is used in robotics for coordination among multiple robots in a team. There are many other problems where this technique is used.</p>
<h3>Example</h3>
<p>This technique can be applied to solve the travelling salesman problem. First an initial solution is determined that visits all the cities exactly once. Hence, this initial solution is not optimal in most of the cases. Even this solution can be very poor. The Hill Climbing algorithm starts with such an initial solution and makes improvements to it in an iterative way. Eventually, a much shorter route is likely to be obtained.</p>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_hill_climbing.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="https://www.tutorialspoint.com/cgi-bin/printpage.cgi" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="https://www.tutorialspoint.com/index.htm" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="https://www.tutorialspoint.com/scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="https://www.tutorialspoint.com/about/tutorials_writing.htm">Write for us</a></li>
         <li><a href="https://www.tutorialspoint.com/about/faq.htm">FAQ's</a></li>
         <li><a href="https://www.tutorialspoint.com/about/about_helping.htm">Helping</a></li>
         <li><a href="https://www.tutorialspoint.com/about/contact_us.htm">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/custom-min.js?v=4"></script>
<script src="https://www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Design and Analysis of Algorithms Quick Guide",
    "name": "Design and Analysis of Algorithms Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/design_and_analysis_of_algorithms/images/relationship.jpg",
        "width": 469,
        "height": 167
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "July 23 2017 03:34:50.",
    "dateModified": "July 23 2017 03:34:50.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": "An algorithm is a set of steps of operations to solve a problem performing calculation, data processing, and automated reasoning tasks. An algorithm is an efficient method that can be expressed within finite amount of time and space...."
}
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Academic Tutorials",
                "@id": "https://www.tutorialspoint.com/academic_tutorials.htm"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": "Design And Analysis Of Algorithms",
                "@id": "https://www.tutorialspoint.com/design_and_analysis_of_algorithms"
            }
        },
        {
            "@type": "ListItem",
            "position": 4,
            "item": {
                "name": "DAA - Quick Guide"
            }
        }
    ]
}
</script></div>
</body>

<!-- Mirrored from www.tutorialspoint.com/design_and_analysis_of_algorithms/design_and_analysis_of_algorithms_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:19:57 GMT -->
</html>
