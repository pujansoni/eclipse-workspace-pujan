<!doctype html> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]> <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]> <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]> <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en"><!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/swift/swift_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 16:16:05 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8">
<title>Swift Quick Guide</title>
<meta name="description" content="Swift Quick Guide - Learn Swift programming on iOS in simple and easy steps starting from its overview, basic syntax, environment setup, data types, variables, optionals, constants, literals, operators, decision making, strings, characters, arrays, dictionaries, loops, control flow, functions, closures, enumerations, classes, structures, properties, methods, inheritance, initialization, deinitialization, ARC overview, optional chaining, type casting, automatic reference count, extensions, protocols, generics, access control etc." />
<meta name="keywords" content="Swift, Tutorial, beginners, overview, basic Syntax, environment setup, data types, variables, optionals, constants, literals, operators, decision making, strings, characters, arrays, dictionaries, loops, control flow, functions, closures, enumerations, classes, structures, properties, methods, inheritance, initialization, deinitialization, ARC overview, optional chaining, type casting, automatic reference count, extensions, protocols, generics, access control etc." />
<base  />
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="../theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="../theme/css/style-min5e1f.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
pre.prettyprint.tryit {min-height:37px; background: #eee url(images/try-it.jpg) top right no-repeat !important}select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #f05c02 url(../images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #f05c02 !important;}
.submenu-item{ border-bottom: 2px solid #f05c02 !important; border-top: 2px solid #f05c02 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="../images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="../index-2.html" title="tutorialspoint">
      <img alt="tutorialspoint" src="images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="../about/about_careers.html" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="../whiteboard.html"><img src="../theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="../netmeeting.html"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="../online_dev_tools.html"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="../articles/index.html"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="../index-2.html"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../codingground.html"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../tutor_connect/index.html"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../videotutorials/index.html"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="images/swift-mini-logo.jpg" alt="Swift Tutorial" />
</div>
<ul class="nav nav-list primary left-menu">
<li class="heading">Swift Tutorial</li>
<li><a href="index.html">Swift - Home</a></li>
<li><a href="swift_overview.html">Swift - Overview</a></li>
<li><a href="swift_environment.html">Swift - Environment</a></li>
<li><a href="swift_basic_syntax.html">Swift - Basic Syntax</a></li>
<li><a href="swift_data_types.html">Swift - Data Types</a></li>
<li><a href="swift_variables.html">Swift - Variables</a></li>
<li><a href="swift_optionals.html">Swift - Optionals</a></li>
<li><a href="swift_constants.html">Swift - Constants</a></li>
<li><a href="swift_literals.html">Swift - Literals</a></li>
<li><a href="swift_operators.html">Swift - Operators</a></li>
<li><a href="swift_decision_making.html">Swift - Decision Making</a></li>
<li><a href="swift_loops.html">Swift - Loops</a></li>
<li><a href="swift_strings.html">Swift - Strings</a></li>
<li><a href="swift_characters.html">Swift - Characters</a></li>
<li><a href="swift_arrays.html">Swift - Arrays</a></li>
<li><a href="swift_dictionaries.html">Swift - Dictionaries</a></li>
<li><a href="swift_functions.html">Swift - Functions</a></li>
<li><a href="swift_closures.html">Swift - Closures</a></li>
<li><a href="swift_enumerations.html">Swift - Enumerations</a></li>
<li><a href="swift_structures.html">Swift - Structures</a></li>
<li><a href="swift_classes.html">Swift - Classes</a></li>
<li><a href="swift_properties.html">Swift - Properties</a></li>
<li><a href="swift_methods.html">Swift - Methods</a></li>
<li><a href="swift_subscripts.html">Swift - Subscripts</a></li>
<li><a href="swift_inheritance.html">Swift - Inheritance</a></li>
<li><a href="swift_initialization.html">Swift - Initialization</a></li>
<li><a href="swift_deinitialization.html">Swift - Deinitialization</a></li>
<li><a href="swift_arc_overview.html">Swift - ARC Overview</a></li>
<li><a href="swift_optional_chaining.html">Swift - Optional Chaining</a></li>
<li><a href="swift_type_casting.html">Swift - Type Casting</a></li>
<li><a href="swift_extensions.html">Swift - Extensions</a></li>
<li><a href="swift_protocols.html">Swift - Protocols</a></li>
<li><a href="swift_generics.html">Swift - Generics</a></li>
<li><a href="swift_access_control.html">Swift - Access Control</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Swift Useful Resources</li>
<li><a href="swift_quick_guide.html">Swift - Quick Guide</a></li>
<li><a href="swift_useful_resources.html">Swift - Useful Resources</a></li>
<li><a href="swift_discussion.html">Swift - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../questions_and_answers.html">Questions and Answers</a></li>
<li><a target="_top" href="../effective_resume_writing.html">Effective Resume Writing</a></li>
<li><a target="_top" href="../hr_interview_questions/index.html">HR Interview Questions</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>Swift - Quick Guide</h1>
<hr />
<div class="topgooglead">
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="swift_access_control.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="swift_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>Swift - Overview</h1>
<p>Swift is a new programming language developed by Apple Inc for iOS and OS X development. Swift adopts the best of C and Objective-C, without the constraints of C compatibility.</p>
<ul class="list">
<li><p>Swift makes use of safe programming patterns.</p></li>
<li><p>Swift provides modern programming features.</p></li>
<li><p>Swift provides Objective-C like syntax.</p></li>
<li><p>Swift is a fantastic way to write iOS and OS X apps.</p></li>
<li><p>Swift provides seamless access to existing Cocoa frameworks.</p></li>
<li><p>Swift unifies the procedural and object-oriented portions of the language.</p></li>
<li><p>Swift does not need a separate library import to support functionalities like input/output or string handling.</p></li>
</ul>
<p>Swift uses the same runtime as the existing Obj-C system on Mac OS and iOS, which enables Swift programs to run on many existing iOS 6 and OS X 10.8 platforms.</p>
<p>Swift comes with playground feature where Swift programmers can write their code and execute it to see the results immediately.</p>
<p>The first public release of Swift was released in 2010. It took <b>Chris Lattner</b> almost 14 years to come up with the first official version, and later, it was supported by many other contributors. Swift has been included in Xcode 6 beta.</p>
<p>Swift designers took ideas from various other popular languages such as Objective-C, Rust, Haskell, Ruby, Python, C#, and CLU.</p>
<h1>Swift - Environment</h1>
<blockquote>
<h2>Try it Option Online</h2>
<p>We have set up the Swift Programming environment online, so that you can compile and execute all the available examples online. It gives you confidence in what you are reading and enables you to verify the programs with different options. Feel free to modify any example and execute it online.</p>
<p><p>Try the following example using our online compiler available at <a href="../codingground.html">CodingGround</a></p></p>
<pre class="prettyprint notranslate tryit">
import Cocoa

/* My first program in Swift */
var myString = "Hello, World!"

println(myString)
</pre>
<p>For most of the examples given in this tutorial, you will find a Try it option in our website code sections at the top right corner that will take you to the online compiler. So just make use of it and enjoy your learning.</p>
</blockquote>
<h2>Local Environment Setup</h2>
<p>Swift provides a Playground platform for learning purpose and we are going to setup the same. You need xCode software to start your Swift coding in Playground. Once you are comfortable with the concepts of Swift, you can use xCode IDE for iSO/OS x application development.</p>
<p>To start with, we consider you already have an account at Apple Developer website. Once you are logged in, go to the following link &minus; <a target="_blank" rel="nofollow" href="https://developer.apple.com/downloads/index.action">Download for Apple Developers</a></p>
<p>This will list down a number of software available as follows &minus;</p>
<img src="images/xcode.jpg" alt="xCode" />
<p>Now select xCode and download it by clicking on the given link near to disc image. After downloading the dmg file, you can install it by simply double-clicking on it and following the given instructions. Finally, follow the given instructions and drop xCode icon into the Application folder.</p>
<img src="images/xcode2.jpg" alt="xCode" />
<p>Now you have xCode installed on your machine. Next, open Xcode from the Application folder and proceed after accepting the terms and conditions. If everything is fine, you will get the following screen &minus;</p>
<img src="images/playground.jpg" alt="Playground" />
<p>Select <b>Get started with a playground</b> option and enter a name for playground and select iOS as platform. Finally, you will get the Playground window as follows &minus;</p>
<img src="images/playground2.jpg" alt="Playground" />
<p>Following is the code taken from the default Swift Playground Window.</p>
<pre class="prettyprint notranslate">
import UIKit

var str = "Hello, playground"
</pre>
<p>If you create the same program for OS X program, then it will include <b>import Cocoa</b> and the program will look like as follows &minus;</p>
<pre class="prettyprint notranslate">
import Cocoa

var str = "Hello, playground"
</pre>
<p>When the above program gets loaded, it should display the following result in Playground result area (Right Hand Side).</p>
<pre class="result notranslate">
Hello, playground
</pre>
<p>Congratulations, you have your Swift programming environment ready and you can proceed with your learning vehicle "Tutorials Point".</p>
<h1>Swift - Basic Syntax</h1>
<p>We have already seen a piece of Swift program while setting up the environment. Let's start once again with the following <b>Hello, World!</b> program created for OS X playground, which includes <b>import Cocoa</b> as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

/* My first program in Swift */
var myString = "Hello, World!"

println(myString)
</pre>
<p>If you create the same program for iOS playground, then it will include <b>import UIKit</b> and the program will look as follows &minus;</p>
<pre class="prettyprint notranslate">
import UIKit
var myString = "Hello, World!"
println(myString)
</pre>
<p>When we run the above program using an appropriate playground, we will get the following result &minus;</p>
<pre class="result notranslate">
Hello, World! 
</pre>
<p>Let us now see the basic structure of a Swift program, so that it will be easy for you to understand the basic building blocks of the Swift programming language.</p>
<h2>Import in Swift</h2>
<p>You can use the <b>import</b> statement to import any Objective-C framework (or C library) directly into your Swift program. For example, the above <b>import cocoa</b> statement makes all Cocoa libraries, APIs, and runtimes that form the development layer for all of OS X, available in Swift.</p>
<p>Cocoa is implemented in Objective-C, which is a superset of C, so it is easy to mix C and even C++ into your Swift applications.</p>
<h2>Tokens in Swift</h2>
<p>A Swift program consists of various tokens and a token is either a keyword, an identifier, a constant, a string literal, or a symbol. For example, the following Swift statement consists of three tokens &minus;</p>
<pre class="result notranslate">
println("test!")
The individual tokens are:
println (
   "test!"
)
</pre>
<h2>Comments</h2>
<p>Comments are like helping texts in your Swift program. They are ignored by the compiler. Multi-line comments start with /* and terminate with the characters */ as shown below &minus;</p>
<pre class="result notranslate">
/* My first program in Swift */
</pre>
<p>Multi-line comments can be nested in Swift. Following is a valid comment in Swift &minus;</p>
<pre class="result notranslate">
/* My first program in Swift is Hello, World!
/* Where as second program is Hello, Swift! */
</pre>
<p>Single-line comments are written using // at the beginning of the comment.</p>
<pre class="result notranslate">
// My first program in Swift
</pre>
<h2>Semicolons</h2>
<p>Swift does not require you to type a semicolon (;) after each statement in your code, though it’s optional; and if you use a semicolon, then the compiler does not complain about it.</p>
<p>However, if you are using multiple statements in the same line, then it is required to use a semicolon as a delimiter, otherwise the compiler will raise a syntax error. You can write the above Hello, World! program as follows &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa
/* My first program in Swift */
var myString = "Hello, World!"; println(myString)
</pre>
<h2>Identifiers</h2>
<p>A Swift identifier is a name used to identify a variable, function, or any other user-defined item. An identifier starts with an alphabet A to Z or a to z or an underscore _ followed by zero or more letters, underscores, and digits (0 to 9).</p>
<p>Swift does not allow special characters such as @, $, and % within identifiers. Swift is a <b>case sensitive</b> programming language. Thus, <i>Manpower</i> and <i>manpower</i> are two different identifiers in Swift. Here are some examples of acceptable identifiers &minus;</p>
<pre class="result notranslate">
Azad       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
</pre>
<p>To use a reserved word as an identifier, you will need to put a backtick (`) before and after it. For example, <b>class</b> is not a valid identifier, but <b>`class`</b> is valid.</p>
<h2>Keywords</h2>
<p>The following keywords are reserved in Swift. These reserved words may not be used as constants or variables or any other identifier names, unless they're escaped with backticks &minus;</p>
<h3>Keywords used in declarations</h3>
<table class="table table-bordered">
<tr>
<td>class</td>
<td>deinit</td>
<td>enum</td>
<td>extension</td>
</tr>
<tr>
<td>func</td>
<td>import</td>
<td>init</td>
<td>internal</td>
</tr>
<tr>
<td>let</td>
<td>operator</td>
<td>private</td>
<td>protocol</td>
</tr>
<tr>
<td>public</td>
<td>static</td>
<td>struct</td>
<td>subscript</td>
</tr>
<tr>
<td>typealias</td>
<td>var</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<h3>Keywords used in statements</h3>
<table class="table table-bordered">
<tr>
<td>break</td>
<td>case</td>
<td>continue</td>
<td>default</td>
</tr>
<tr>
<td>do</td>
<td>else</td>
<td>fallthrough</td>
<td>for</td>
</tr>
<tr>
<td>if</td>
<td>in</td>
<td>return</td>
<td>switch</td>
</tr>
<tr>
<td>where</td>
<td>while</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<h3>Keywords used in expressions and types</h3>
<table class="table table-bordered">
<tr>
<td>as</td>
<td>dynamicType</td>
<td>false</td>
<td>is</td>
</tr>
<tr>
<td>nil</td>
<td>self</td>
<td>Self</td>
<td>super</td>
</tr>
<tr>
<td>true</td>
<td>_COLUMN_</td>
<td>_FILE_</td>
<td>_FUNCTION_</td>
</tr>
<tr>
<td>_LINE_</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<h3>Keywords used in particular contexts</h3>
<table class="table table-bordered">
<tr>
<td>associativity</td>
<td>convenience</td>
<td>dynamic</td>
<td>didSet</td>
</tr>
<tr>
<td>final</td>
<td>get</td>
<td>infix</td>
<td>inout</td>
</tr>
<tr>
<td>lazy</td>
<td>left</td>
<td>mutating</td>
<td>none</td>
</tr>
<tr>
<td>nonmutating</td>
<td>optional</td>
<td>override</td>
<td>postfix</td>
</tr>
<tr>
<td>precedence</td>
<td>prefix</td>
<td>Protocol</td>
<td>required</td>
</tr>
<tr>
<td>right</td>
<td>set</td>
<td>Type</td>
<td>unowned</td>
</tr>
<tr>
<td>weak</td>
<td>willSet</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<h2>Whitespaces</h2>
<p>A line containing only whitespace, possibly with a comment, is known as a blank line, and a Swift compiler totally ignores it.</p>
<p>Whitespace is the term used in Swift to describe blanks, tabs, newline characters, and comments. Whitespaces separate one part of a statement from another and enable the compiler to identify where one element in a statement, such as int, ends and the next element begins. Therefore, in the following statement &minus;</p>
<pre class="result notranslate">
var age
</pre>
<p>there must be at least one whitespace character (usually a space) between <b>var</b> and <b>age</b> for the compiler to be able to distinguish them. On the other hand, in the following statement &minus;</p>
<pre class="result notranslate">
int fruit = apples &plus; oranges   //get the total fruits
</pre>
<p>no whitespace characters are necessary between fruit and =, or between = and apples, although you are free to include some for better readability.</p>
<h2>Literals</h2>
<p>A literal is the source code representation of a value of an integer, floating-point number, or string type. The following are examples of literals &minus;</p>
<pre class="result notranslate">
92               // Integer literal
4.24159          // Floating-point literal
"Hello, World!"  // String literal
</pre>
<h1>Swift - Data Types</h1>
<p>While doing programming in any programming language, you need to use different types of variables to store information. Variables are nothing but reserved memory locations to store values. This means that when you create a variable, you reserve some space in memory.</p>
<p>You may like to store information of various data types like string, character, wide character, integer, floating point, Boolean, etc. Based on the data type of a variable, the operating system allocates memory and decides what can be stored in the reserved memory.</p>
<h2>Built-in Data Types</h2>
<p>Swift offers the programmer a rich assortment of built-in as well as user-defined data types. The following types of basic data types are most frequently when declaring variables &minus;</p>
<ul class="list">
<li><p><b>Int or UInt</b> &minus; This is used for whole numbers. More specifically, you can use Int32, Int64 to define 32 or 64 bit signed integer, whereas UInt32 or UInt64 to define 32 or 64 bit unsigned integer variables. For example, 42 and -23.</p></li>
<li><p><b>Float</b> &minus; This is used to represent a 32-bit floating-point number and numbers with smaller decimal points. For example, 3.14159, 0.1, and -273.158.</p></li>
<li><p><b>Double</b> &minus; This is used to represent a 64-bit floating-point number and used when floating-point values must be very large. For example, 3.14159, 0.1, and -273.158.</p></li>
<li><p><b>Bool</b> &minus; This represents a Boolean value which is either true or false.</p></li>
<li><p><b>String</b> &minus; This is an ordered collection of characters. For example, "Hello, World!"</p></li>
<li><p><b>Character</b> &minus; This is a single-character string literal. For example, "C"</p></li>
<li><p><b>Optional</b> &minus; This represents a variable that can hold either a value or no value.</p></li>
</ul>
<p>We have listed here a few important points related to Integer types &minus;</p>
<ul class="list">
<li><p>On a 32-bit platform, Int is the same size as Int32.</p></li>
<li><p>On a 64-bit platform, Int is the same size as Int64.</p></li>
<li><p>On a 32-bit platform, UInt is the same size as UInt32.</p></li>
<li><p>On a 64-bit platform, UInt is the same size as UInt64.</p></li>
<li><p>Int8, Int16, Int32, Int64 can be used to represent 8 Bit, 16 Bit, 32 Bit, and 64 Bit forms of signed integer.</p></li>
<li><p>UInt8, UInt16, UInt32, and UInt64 can be used to represent 8 Bit, 16 Bit, 32 Bit and 64 Bit forms of unsigned integer.</p></li>
</ul>
<h2>Bound Values</h2>
<p>The following table shows the variable type, how much memory it takes to store the value in memory, and what is the maximum and minimum value which can be stored in such type of variables.</p>
<table class="table table-bordered">
<tr>
<th>Type</th>
<th>Typical Bit Width</th>
<th>Typical Range</th>
</tr>
<tr>
<td>Int8</td>
<td>1byte</td>
<td>-127 to 127</td>
</tr>
<tr>
<td>UInt8</td>
<td>1byte</td>
<td>0 to 255</td>
</tr>
<tr>
<td>Int32</td>
<td>4bytes</td>
<td>-2147483648 to 2147483647</td>
</tr>
<tr>
<td>UInt32</td>
<td>4bytes</td>
<td>0 to 4294967295</td>
</tr>
<tr>
<td>Int64</td>
<td>8bytes</td>
<td>-9223372036854775808 to 9223372036854775807</td>
</tr>
<tr>
<td>UInt64</td>
<td>8bytes</td>
<td>0 to 18446744073709551615</td>
</tr>
<tr>
<td>Float</td>
<td>4bytes</td>
<td>1.2E-38 to 3.4E+38 (~6 digits)</td>
</tr>
<tr>
<td>Double</td>
<td>8bytes</td>
<td>2.3E-308 to 1.7E+308 (~15 digits)</td>
</tr>
</table>
<h2>Type Aliases</h2>
<p>You can create a new name for an existing type using <b>typealias</b>. Here is the simple syntax to define a new type using typealias &minus;</p>
<pre class="result notranslate">
typealias newname = type
</pre>
<p>For example, the following line instructs the compiler that <b>Feet</b> is another name for <b>Int</b> &minus;</p>
<pre class="result notranslate">
typealias Feet = Int
</pre>
<p>Now, the following declaration is perfectly legal and creates an integer variable called distance &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

typealias Feet = Int
var distance: Feet = 100
println(distance)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
100
</pre>
<h2>Type Safety</h2>
<p>Swift is a type-safe language which means if a part of your code expects a String, you can't pass it an Int by mistake.</p>
<p>As Swift is type-safe, it performs type-checks when compiling your code and flags any mismatched types as errors.</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA = 42
varA = "This is hello"
println(varA)
</pre>
<p>When we compile the above program, it produces the following compile time error.</p>
<pre class="result notranslate">
Playground execution failed: error: &lt;EXPR&gt;:6:6: error: cannot assign to 'let' value 'varA'
varA = "This is hello"
</pre>
<h2>Type Inference</h2>
<p>Type inference enables a compiler to deduce the type of a particular expression automatically when it compiles your code, simply by examining the values you provide. Swift uses type inference to work out the appropriate type as follows.</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

// varA is inferred to be of type Int
var varA = 42
println(varA)

// varB is inferred to be of type Double
var varB = 3.14159
println(varB)

// varC is also inferred to be of type Double
var varC = 3 + 0.14159
println(varC)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
42
3.14159
3.14159
</pre>
<h1>Swift - Variables</h1>
<p>A variable provides us with named storage that our programs can manipulate. Each variable in Swift has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<p>Swift supports the following basic types of variables &minus;</p>
<ul class="list">
<li><p><b>Int or UInt</b> &minus; This is used for whole numbers. More specifically, you can use Int32, Int64 to define 32 or 64 bit signed integer, whereas UInt32 or UInt64 to define 32 or 64 bit unsigned integer variables. For example, 42 and -23.</p></li>
<li><p><b>Float</b> &minus; This is used to represent a 32-bit floating-point number. It is used to hold numbers with smaller decimal points. For example, 3.14159, 0.1, and -273.158.</p></li>
<li><p><b>Double</b> &minus; This is used to represent a 64-bit floating-point number and used when floating-point values must be very large. For example 3.14159, 0.1, and -273.158.</p></li>
<li><p><b>Bool</b> &minus; This represents a Boolean value which is either true or false.</p></li>
<li><p><b>String</b> &minus; This is an ordered collection of characters. For example, "Hello, World!"</p></li>
<li><p><b>Character</b> &minus; This is a single-character string literal. For example, "C"</p></li>
</ul>
<p>Swift also allows to define various other types of variables, which we will cover in subsequent chapters, such as <b>Optional</b>, <b>Array</b>, <b>Dictionaries</b>, <b>Structures</b>, and <b>Classes</b>.</p>
<p>The following section will cover how to declare and use various types of variables in Swift programming.</p>
<h2>Variable Declaration</h2>
<p>A variable declaration tells the compiler where and how much to create the storage for the variable. Before you use variables, you must declare them using <b>var</b> keyword as follows &minus;</p>
<pre class="result notranslate">
var variableName = &lt;initial value&gt;
</pre>
<p>The following example shows how to declare a variable in Swift &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA = 42
println(varA)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
42
</pre>
<h2>Type Annotations</h2>
<p>You can provide a <b>type annotation</b> when you declare a variable, to be clear about the kind of values the variable can store. Here is the syntax &minus;</p>
<pre class="result notranslate">
var variableName:&lt;data type&gt; = &lt;optional initial value&gt;
</pre>
<p>The following example shows how to declare a variable in Swift using Annotation. Here it is important to note that if we are not using type annotation, then it becomes mandatory to provide an initial value for the variable, otherwise we can just declare our variable using type annotation.</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA = 42
println(varA)

var varB:Float

varB = 3.14159
println(varB)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
42
3.1415901184082
</pre>
<h2>Naming Variables</h2>
<p>The name of a variable can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Swift is a case-sensitive programming language.</p>
<p>You can use simple or Unicode characters to name your variables. The following examples shows how you can name the variables &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var _var = "Hello, Swift!"
println(_var)

var 你好 = "你好世界"
println(你好)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift!
你好世界
</pre>
<h2>Printing Variables</h2>
<p>You can print the current value of a constant or variable with the <b>println</b> function. You can interpolate a variable value by wrapping the name in parentheses and escape it with a backslash before the opening parenthesis: Following are valid examples &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA = "Godzilla"
var varB = 1000.00

println("Value of \(varA) is more than \(varB) millions")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Value of Godzilla is more than 1000.0 millions
</pre>
<h1>Swift - Optionals</h1>
<p>Swift also introduces <b>Optionals</b> type, which handles the absence of a value. Optionals say either "there is a value, and it equals x" or "there isn't a value at all".</p>
<p>An Optional is a type on its own, actually one of Swift’s new super-powered enums. It has two possible values, <b>None</b> and <b>Some(T)</b>, where <b>T</b> is an associated value of the correct data type available in Swift.</p>
<p>Here’s an optional Integer declaration &minus;</p>
<pre class="result notranslate">
var perhapsInt: Int?
</pre>
<p>Here’s an optional String declaration &minus;</p>
<pre class="result notranslate">
var perhapsStr: String?
</pre>
<p>The above declaration is equivalent to explicitly initializing it to <b>nil</b> which means no value &minus;</p>
<pre class="result notranslate">
var perhapsStr: String?  = nil
</pre>
<p>Let's take the following example to understand how optionals work in Swift &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var myString:String? = nil

if myString != nil {
   println(myString)
}else {
   println("myString has nil value")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
myString has nil value
</pre>
<p>Optionals are similar to using <b>nil</b> with pointers in Objective-C, but they work for any type, not just classes.</p>
<h2>Forced Unwrapping</h2>
<p>If you defined a variable as <b>optional</b>, then to get the value from this variable, you will have to <b>unwrap</b> it. This just means putting an exclamation mark at the end of the variable.</p>
<p>Let's take a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var myString:String?

myString = "Hello, Swift!"

if myString != nil {
   println(myString)
}else {
   println("myString has nil value")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Optional("Hello, Swift!")
</pre>
<p>Now let's apply unwrapping to get the correct value of the variable &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var myString:String?

myString = "Hello, Swift!"

if myString != nil {
   println( myString! )
}else {
   println("myString has nil value")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift!
</pre>
<h2>Automatic Unwrapping</h2>
<p>You can declare optional variables using exclamation mark instead of a question mark. Such optional variables will unwrap automatically and you do not need to use any further exclamation mark at the end of the variable to get the assigned value. Let's take a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var myString:String!

myString = "Hello, Swift!"

if myString != nil {
   println(myString)
}else {
   println("myString has nil value")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift!
</pre>
<h2>Optional Binding</h2>
<p>Use optional binding to find out whether an optional contains a value, and if so, to make that value available as a temporary constant or variable.</p>
<p>An optional binding for the <b>if</b> statement is as follows &minus;</p>
<pre class="result notranslate">
if let constantName = someOptional {
   statements
}
</pre>
<p>Let's take a simple example to understand the usage of optional binding &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var myString:String?

myString = "Hello, Swift!"

if let yourString = myString {
   println("Your string has - \(yourString)")
}else {
   println("Your string does not have a value")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Your string has - Hello, Swift!
</pre>
<h1>Swift - Constants</h1>
<p>Constants refer to fixed values that a program may not alter during its execution. Constants can be of any of the basic data types like an <i>integer constant, a floating constant, a character constant, or a string literal</i>. There are <i>enumeration constants</i> as well.</p>
<p><b>Constants</b> are treated just like regular variables except the fact that their values cannot be modified after their definition.</p>
<h2>Constants Declaration</h2>
<p>Before you use constants, you must declare them using <b>let</b> keyword as follows &minus;</p>
<pre class="result notranslate">
let constantName = &lt;initial value&gt;
</pre>
<p>Following is a simple example to show how to declare a constant in Swift &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let constA = 42
println(constA)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
42
</pre>
<h2>Type Annotations</h2>
<p>You can provide a <b>type annotation</b> when you declare a constant, to be clear about the kind of values the constant can store. Following is the syntax &minus;</p>
<pre class="result notranslate">
var constantName:&lt;data type&gt; = &lt;optional initial value&gt;
</pre>
<p>The following example shows how to declare a constant in Swift using Annotation. Here it is important to note that it is mandatory to provide an initial value while creating a constant &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let constA = 42
println(constA)

let constB:Float = 3.14159

println(constB)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
42
3.1415901184082
</pre>
<h2>Naming Constants</h2>
<p>The name of a constant can be composed of letters, digits, and the underscore character. It must begin with either a letter or an underscore. Upper and lowercase letters are distinct because Swift is a case-sensitive programming language.</p>
<p>You can use simple or Unicode characters to name your variables. Following are valid examples &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let _const = "Hello, Swift!"
println(_const)

let 你好 = "你好世界"
println(你好)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift!
你好世界
</pre>
<h2>Printing Constants</h2>
<p>You can print the current value of a constant or variable using <b>println</b> function. You can interpolate a variable value by wrapping the name in parentheses and escape it with a backslash before the opening parenthesis: Following are valid examples &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let constA = "Godzilla"
let constB = 1000.00

println("Value of \(constA) is more than \(constB) millions")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Value of Godzilla is more than 1000.0 millions
</pre>
<h1>Swift - Literals</h1>
<p>A literal is the source code representation of a value of an integer, floating-point number, or string type. The following are examples of literals &minus;</p>
<pre class="result notranslate">
42               // Integer literal
3.14159          // Floating-point literal
"Hello, world!"  // String literal
</pre>
<h2>Integer Literals</h2>
<p>An integer literal can be a decimal, binary, octal, or hexadecimal constant. Binary literals begin with 0b, octal literals begin with 0o, and hexadecimal literals begin with 0x and nothing for decimal.</p>
<p>Here are some examples of integer literals &minus;</p>
<pre class="result notranslate">
let decimalInteger = 17           // 17 in decimal notation
let binaryInteger = 0b10001       // 17 in binary notation
let octalInteger = 0o21           // 17 in octal notation
let hexadecimalInteger = 0x11     // 17 in hexadecimal notation
</pre>
<h2>Floating-point Literals</h2>
<p>A floating-point literal has an integer part, a decimal point, a fractional part, and an exponent part. You can represent floating point literals either in decimal form or hexadecimal form.</p>
<p>Decimal floating-point literals consist of a sequence of decimal digits followed by either a decimal fraction, a decimal exponent, or both.</p>
<p>Hexadecimal floating-point literals consist of a 0x prefix, followed by an optional hexadecimal fraction, followed by a hexadecimal exponent.</p>
<p>Here are some examples of floating-point literals &minus;</p>
<pre class="result notranslate">
let decimalDouble = 12.1875
let exponentDouble = 1.21875e1
let hexadecimalDouble = 0xC.3p0
</pre>
<h2>String Literals</h2>
<p>A string literal is a sequence of characters surrounded by double quotes, with the following form &minus;</p>
<pre class="result notranslate">
"characters"
</pre>
<p>String literals cannot contain an unescaped double quote ("), an unescaped backslash (\), a carriage return, or a line feed. Special characters can be included in string literals using the following escape sequences &minus;</p>
<table class="table table-bordered">
<tr>
<th>Escape sequence</th>
<th>Meaning</th>
</tr>
<tr>
<td>\0</td>
<td>Null Character</td>
</tr>
<tr>
<td>\\</td>
<td>\character</td>
</tr>
<tr>
<td>\b</td>
<td>Backspace</td>
</tr>
<tr>
<td>\f</td>
<td>Form feed</td>
</tr>
<tr>
<td>\n</td>
<td>Newline</td>
</tr>
<tr>
<td>\r</td>
<td>Carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>Horizontal tab</td>
</tr>
<tr>
<td>\v</td>
<td>Vertical tab</td>
</tr>
<tr>
<td>\'</td>
<td>Single Quote</td>
</tr>
<tr>
<td>\"</td>
<td>Double Quote</td>
</tr>
<tr>
<td>\000</td>
<td>Octal number of one to three digits</td>
</tr>
<tr>
<td>\xhh...</td>
<td>Hexadecimal number of one or more digits</td>
</tr>
</table>
<p>The following example shows how to use a few string literals &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let stringL = "Hello\tWorld\n\nHello\'Swift\'"
println(stringL)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Hello	World

Hello'Swift'
</pre>
<h2>Boolean Literals</h2>
<p>There are three Boolean literals and they are part of standard Swift keywords &minus;</p>
<ul class="list">
<li>A value of <b>true</b> representing true.</li>
<li>A value of <b>false</b> representing false.</li>
<li>A value of <b>nil</b> representing no value.</li>
</ul>
<h1>Swift - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. Objective-C is rich in built-in operators and provides the following types of operators &minus;</p>
<ul class="list">
<li>Arithmetic Operators</li>
<li>Comparison Operators</li>
<li>Logical Operators</li>
<li>Bitwise Operators</li>
<li>Assignment Operators</li>
<li>Range Operators</li>
<li>Misc Operators</li>
</ul>
<p>This tutorial will explain the arithmetic, relational, logical, bitwise, assignment and other operators one by one.</p>
<h2>Arithmetic Operators</h2>
<p>The following table shows all the arithmetic operators supported by Swift language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="swift_arithmetic_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:25%;">Example</th>
</tr>
<tr>
<td>&plus;</td>
<td>Adds two operands</td>
<td>A &plus; B will give 30</td>
</tr>
<tr>
<td>&minus;</td>
<td>Subtracts second operand from the first</td>
<td>A &minus; B will give -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplies both operands</td>
<td>A * B will give 200</td>
</tr>
<tr>
<td>/</td>
<td>Divides numerator by denominator</td>
<td>B / A will give 2</td>
</tr>
<tr>
<td>%</td>
<td>Modulus Operator and remainder of after an integer/float division</td>
<td>B % A will give 0</td>
</tr>
<tr>
<td>++</td>
<td>Increment operator increases integer value by one</td>
<td>A++ will give 11</td>
</tr>
<tr>
<td>--</td>
<td>Decrement operator decreases integer value by one</td>
<td>A-- will give 9</td>
</tr>
</table>
<h2>Comparison Operators</h2>
<p>The following table shows all the relational operators supported by Swift language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="swift_comparison_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:25%;">Example</th>
</tr>
<tr>
<td>==</td>
<td>Checks if the values of two operands are equal or not; if yes, then condition becomes true.</td>
<td>(A == B) is not true.</td>
</tr>
<tr>
<td>!=</td>
<td>Checks if the values of two operands are equal or not; if values are not equal, then the condition becomes true.</td>
<td>(A != B) is true.</td>
</tr>
<tr>
<td>&gt;</td>
<td>Checks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.</td>
<td>(A &gt; B) is not true.</td>
</tr>
<tr>
<td>&lt;</td>
<td>Checks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.</td>
<td>(A &lt; B) is true.</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Checks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td>(A &gt;= B) is not true.</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Checks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td>(A &lt;= B) is true.</td>
</tr>
</table>
<h2>Logical Operators</h2>
<p>The following table shows all the logical operators supported by Swift language. Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then &minus;</p>
<p><a href="swift_logical_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:25%;">Example</th>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Called Logical AND operator. If both the operands are non-zero, then the condition becomes true.</td>
<td>(A &amp;&amp; B) is false.</td>
</tr>
<tr>
<td>||</td>
<td>Called Logical OR Operator. If any of the two operands is non-zero, then the condition becomes true.</td>
<td>(A || B) is true.</td>
</tr>
<tr>
<td>!</td>
<td>Called Logical NOT Operator. Use to reverses the logical state of its operand. If a condition is true, then the Logical NOT operator will make it false.</td>
<td>!(A &amp;&amp; B) is true.</td>
</tr>
</table>
<h2>Bitwise Operators</h2>
<p>Bitwise operators work on bits and perform bit by bit operation. The truth tables for &, |, and ^ are as follows &minus;</p>
<table class="table table-bordered">
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<pre class="result notranslate">
Assume if A = 60; and B = 13; now in binary format they will be as follows:

A = 0011 1100

B = 0000 1101

-----------------

A &amp; B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A  = 1100 0011
</pre>
<p>Bitwise operators supported by Swift language are listed in the following table. Assume variable <b>A</b> holds 60 and variable <b>B</b> holds 13, then &minus;</p>
<p><a href="swift_bitwise_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th style="width:25%;">Example</th>
</tr>
<tr>
<td>&amp;</td>
<td>Binary AND Operator copies a bit to the result, if it exists in both operands.</td>
<td>(A &amp; B) will give 12, which is 0000 1100</td>
</tr>
<tr>
<td>|</td>
<td>Binary OR Operator copies a bit, if it exists in either operand.</td>
<td>(A | B) will give 61, which is 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>Binary XOR Operator copies the bit, if it is set in one operand but not both.</td>
<td>(A ^ B) will give 49, which is 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>Binary Ones Complement Operator is unary and has the effect of 'flipping' bits.</td>
<td>(~A ) will give -61, which is 1100 0011 in 2's complement form.</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Binary Left Shift Operator. The left operands value is moved left by the number of bits specified by the right operand.</td>
<td>A &lt;&lt; 2 will give 240, which is 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Binary Right Shift Operator. The left operands value is moved right by the number of bits specified by the right operand.</td>
<td>A &gt;&gt; 2 will give 15, which is 0000 1111</td>
</tr>
</table>
<h2>Assignment Operators</h2>
<p>Swift supports the following assignment operators &minus;</p>
<p><a href="swift_assignment_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th>Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>=</td>
<td>Simple assignment operator, Assigns values from right side operands to left side operand</td>
<td>C = A + B will assign value of A + B into C</td>
</tr>
<tr>
<td>+=</td>
<td>Add AND assignment operator, It adds right operand to the left operand and assigns the result to left operand</td>
<td>C += A is equivalent to C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>Subtract AND assignment operator, It subtracts right operand from the left operand and assigns the result to left operand</td>
<td>C -= A is equivalent to C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>Multiply AND assignment operator, It multiplies right operand with the left operand and assigns the result to left operand</td>
<td>C *= A is equivalent to C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>Divide AND assignment operator, It divides left operand with the right operand and assigns the result to left operand</td>
<td>C /= A is equivalent to C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>Modulus AND assignment operator, It takes modulus using two operands and assigns the result to left operand</td>
<td>C %= A is equivalent to C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>Left shift AND assignment operator</td>
<td>C &lt;&lt;= 2 is same as C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>Right shift AND assignment operator</td>
<td>C &gt;&gt;= 2 is same as C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>Bitwise AND assignment operator</td>
<td>C &amp;= 2 is same as C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>bitwise exclusive OR and assignment operator</td>
<td>C ^= 2 is same as C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>bitwise inclusive OR and assignment operator</td>
<td>C |= 2 is same as C = C | 2</td>
</tr>
</table>
<h2>Range Operators</h2>
<p>Swift includes two range operators, which are shortcuts for expressing a range of values. The following table explains these two operators.</p>
<p><a href="swift_range_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:24%;">Operator</th>
<th>Description</th>
<th style="width:30%;">Example</th>
</tr>
<tr>
<td>Closed Range</td>
<td>(a...b) defines a range that runs from a to b, and includes the values a and b.</td>
<td>1...5 gives 1, 2, 3, 4 and 5</td>
</tr>
<tr>
<td>Half-Open Range</td>
<td>(a..&lt; b) defines a range that runs from a to b, but does not include b.</td>
<td>1..&lt; 5 gives 1, 2, 3, and 4</td>
</tr>
</table>
<h2>Misc Operators</h2>
<p>Swift supports a few other important operators including <b>range</b> and <b>?</b> : which are explained in the following table.</p>
<p><a href="swift_misc_operators.html">Show Examples</a></p>
<table class="table table-bordered">
<tr>
<th style="width:26%;">Operator</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>Unary Minus</td>
<td>The sign of a numeric value can be toggled using a prefixed -</td>
<td>-3 or -4</td>
</tr>
<tr>
<td>Unary Plus</td>
<td>Returns the value it operates on, without any change.</td>
<td>+6 gives 6</td>
</tr>
<tr>
<td>Ternary Conditional</td>
<td>Condition ? X : Y</td>
<td>If Condition is true ? Then value X : Otherwise value Y</td>
</tr>
</table>
<h2>Operators Precedence</h2>
<p>Operator precedence determines the grouping of terms in an expression. This affects how an expression is evaluated. Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator.</p>
<p>For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.</p>
<p>Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom. Within an expression, higher precedence operators will be evaluated first.</p>
<p><a href="swift_operators_precedence.html">Show Example</a></p>
<table class="table table-bordered">
<tr>
<th>Operator Type</th>
<th>Operator</th>
<th>Associativity</th>
</tr>
<tr>
<td>Primary Expression Operators</td>
<td>() [] . expr++ expr--</td>
<td style="vertical-align:middle;">left-to-right</td>
</tr>
<tr>
<td>Unary Operators</td>
<td><p>* &amp; + - ! ~ ++expr --expr</p>
<p>* / %</p>
<p>+ -</p>
<p>&gt;&gt; &lt;&lt;</p>
<p>&lt; &gt; &lt;= &gt;=</p>
<p>== !=</p>
</td>
<td style="vertical-align:middle;">right-to-left</td>
</tr>
<tr>
<td>Binary Operators</td>
<td><p>&amp;</p>
<p>^</p>
<p>|</p>
<p>&amp;&amp;</p>
<p>||</p>
</td>
<td style="vertical-align:middle;">left-to-right</td>
</tr>
<tr>
<td>Ternary Operator</td>
<td>?:</td>
<td>right-to-left</td>
</tr>
<tr>
<td>Assignment Operators</td>
<td>= += -= *= /= %= &gt;&gt;= &lt;&lt;= &amp;= ^= |=</td>
<td>right-to-left</td>	
</tr>
<tr>
<td>Comma</td>
<td>,</td>
<td style="vertical-align:middle;">left-to-right</td>
</tr>
</table>
<h1>Swift - Decision Making</h1>
<p>Decision making structures require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be <b>true</b>, and optionally, other statements to be executed if the condition is determined to be <b>false</b>.</p>
<p>Following is the general from of a typical decision making structure found in most of the programming languages &minus;</p>
<img src="images/decision_making.jpg" alt="Decision Making" />
<p>Swift provides the following types of decision making statements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No</th>
<th style="text-align:center;">Statement &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="if_statement.html">if statement</a>
<p>An <b>if statement</b> consists of a Boolean expression followed by one or more statements.</p></td>
</tr>
<tr>
<td>2</td>
<td><a href="if_else_statement.html">if...else statement</a>
<p>An <b>if statement</b> can be followed by an optional <b>else statement</b>, which executes when the Boolean expression is false.</p></td>
</tr>
<tr>
<td>3</td>
<td><a href="if_else_if_else_statement.html">if...else if...else Statement</a>
<p>An <b>if</b> statement can be followed by an optional <b>else if...else</b> statement, which is very useful to test various conditions using single if...else if statement.</p></td>
</tr>
<tr>
<td>4</td>
<td><a href="nested_if_statement.html">nested if statements</a>
<p>You can use one if or else if statement inside another if or else if statement(s).</p></td>
</tr>
<tr>
<td>5</td>
<td><a href="switch_statement.html">switch statement</a>
<p>A <b>switch</b> statement allows a variable to be tested for equality against a list of values.</p></td>
</tr>
</table>
<h2>The ? : Operator</h2>
<p>We have covered <b>conditional operator ?</b> : in the previous chapter which can be used to replace <b>if...else</b> statements. It has the following general form &minus;</p>
<pre class="result notranslate">
Exp1 ? Exp2 : Exp3;
</pre>
<p>Where Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.</p>
<p>The value of a <b>?</b> expression is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire <b>?</b> expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.</p>
<h1>Swift - Loops</h1>
<p>There may be a situation when you need to execute a block of code several number of times. In general statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.</p>
<p>Programming languages provide various control structures that allow for more complicated execution paths.</p>
<p>A loop statement allows us to execute a statement or group of statements multiple times. Following is the general from of a loop statement in most of the programming languages &minus;</p>
<img src="images/loop_architecture.jpg" alt="Loop Architecture" />
<p>Swift programming language provides the following kinds of loop to handle looping requirements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th>Sr.No</th>
<th style="text-align:center;">Loop Type &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="swift_for_in.html">for-in</a>
<p>This loop performs a set of statements for each item in a range, sequence, collection, or progression.</p></td>
</tr>
<tr>
<td>2</td>
<td><a href="swift_for_loop.html">for loop</a>
<p>Executes a sequence of statements multiple times and abbreviates the code that manages the loop variable.</p></td>
</tr>
<tr>
<td>3</td>
<td><a href="swift_while_loop.html">while loop</a>
<p>Repeats a statement or group of statements while a given condition is true. It tests the condition before executing the loop body.</p></td>
</tr>
<tr>
<td>4</td>
<td>
<a href="swift_do_while_loop.html">do...while loop</a>
<p>Like a while statement, except that it tests the condition at the end of the loop body.</p></td>
</tr>
</table>
<h2>Loop Control Statements</h2>
<p>Loop control statements change execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.</p>
<p>Swift supports the following control statements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th>S.No</th>
<th style="text-align:center;">Control Statement &amp; Description</th>
</tr>
<tr>
<td>1</td>
<td><a href="swift_continue_statement.html">continue statement</a>
<p>This statement tells a loop to stop what it is doing and start again at the beginning of the next iteration through the loop.</p></td>
</tr>
<tr>
<td>2</td>
<td><a href="swift_break_statement.html">break statement</a>
<p>Terminates the <b>loop</b> statement and transfers execution to the statement immediately following the loop.</p></td>
</tr>
<tr>
<td>3</td>
<td><a href="swift_fallthrough_statement.html">fallthrough statement</a>
<p>The fallthrough statement simulates the behavior of swift switch to C-style switch.</p></td>
</tr>
</table>
<h1>Swift - Strings</h1>
<p>Strings in Swift are an ordered collection of characters, such as "Hello, World!" and they are represented by the Swift data type <b>String</b>, which in turn represents a collection of values of <b>Character</b> type.</p>
<h2>Create a String</h2>
<p>You can create a String either by using a string literal or creating an instance of a String class as follows &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

// String creation using String literal
var stringA = "Hello, Swift!"
println( stringA )

// String creation using String instance
var stringB = String("Hello, Swift!")
println( stringB )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift!
Hello, Swift!
</pre>
<h2>Empty String</h2>
<p>You can create an empty String either by using an empty string literal or creating an instance of String class as shown below. You can also check whether a string is empty or not using the Boolean property <b>isEmpty</b>.</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

// Empty string creation using String literal
var stringA = ""

if stringA.isEmpty {
   println( "stringA is empty" )
}else {
   println( "stringA is not empty" )
}

// Empty string creation using String instance
let stringB = String()

if stringB.isEmpty {
   println( "stringB is empty" )
}else {
   println( "stringB is not empty" )
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
stringA is empty
stringB is empty
</pre>
<h2>String Constants</h2>
<p>You can specify whether your String can be modified (or mutated) by assigning it to a variable, or it will be constant by assigning it to a constant using <b>let</b> keyword as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

// stringA can be modified
var stringA = "Hello, Swift!"
stringA + = "--Readers--"
println( stringA )

// stringB can not be modified
let stringB = String("Hello, Swift!")
stringB + = "--Readers--"
println( stringB )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Playground execution failed: error: &lt;EXPR&gt;:10:1: error: 'String' is not convertible to '@lvalue UInt8'
stringB + = "--Readers--"
</pre>
<h2>String Interpolation</h2>
<p>String interpolation is a way to construct a new String value from a mix of constants, variables, literals, and expressions by including their values inside a string literal.</p>
<p>Each item (variable or constant) that you insert into the string literal is wrapped in a pair of parentheses, prefixed by a backslash. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA   = 20
let constA = 100
var varC:Float = 20.0

var stringA = "\(varA) times \(constA) is equal to \(varC * 100)"
println( stringA )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
20 times 100 is equal to 2000.0
</pre>
<h2>String Concatenation</h2>
<p>You can use the + operator to concatenate two strings or a string and a character, or two characters. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let constA = "Hello,"
let constB = "World!"

var stringA = constA + constB

println( stringA )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello,World!
</pre>
<h2>String Length</h2>
<p>Swift strings do not have a <b>length</b> property, but you can use the global count() function to count the number of characters in a string. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA   = "Hello, Swift!"

println( "\(varA), length is \(count(varA))" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift!, length is 13
</pre>
<h2>String Comparison</h2>
<p>You can use the == operator to compare two strings variables or constants. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA   = "Hello, Swift!"
var varB   = "Hello, World!"

if varA == varB {
   println( "\(varA) and \(varB) are equal" )
}else {
   println( "\(varA) and \(varB) are not equal" )
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Swift! and Hello, World! are not equal
</pre>
<h2>Unicode Strings</h2>
<p>You can access a UTF-8 and UTF-16 representation of a String by iterating over its utf8 and utf16 properties as demonstrated in the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var unicodeString   = "Dogâ€¼ðŸ¶"

println("UTF-8 Codes: ")
for code in unicodeString.utf8 {
   print("\(code) ")
}

print("\n")

println("UTF-16 Codes: ")
for code in unicodeString.utf16 {
   print("\(code) ")
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
UTF-8 Codes: 
68 111 103 226 128 188 240 159 144 182 
UTF-16 Codes: 
68 111 103 8252 55357 56374 
</pre>
<h2>String Functions &amp; Operators</h2>
<p>Swift supports a wide range of methods and operators related to Strings &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.No</th>
<th>Functions/Operators &amp; Purpose</th>
</tr>
<tr>
<td>1</td>
<td><p><b>isEmpty</b></p>
<p>A Boolean value that determines whether a string is empty or not.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>hasPrefix(prefix: String)</b></p>
<p>Function to check whether a given parameter string exists as a prefix of the string or not.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>hasSuffix(suffix: String)</b></p>
<p>Function to check whether a given parameter string exists as a prefix of the string or not.</p></td>
</tr>
<tr>
<td>4</td>
<td><p><b>toInt()</b></p>
<p>Function to convert numeric String value into Integer.</p></td>
</tr>
<tr>
<td>5</td>
<td><p><b>count()</b></p>
<p>Global function to count the number of Characters in a string.</p></td>
</tr>
<tr>
<td>6</td>
<td><p><b>utf8</b></p>
<p>Property to return a <b>UTF-8</b> representation of a string.</p></td>
</tr>
<tr>
<td>7</td>
<td><p><b>utf16</b></p>
<p>Property to return a <b>UTF-16</b> representation of a string.</p></td>
</tr>
<tr>
<td>8</td>
<td><p><b>unicodeScalars</b></p>
<p>Property to return a <b>Unicode Scalar</b> representation of a string.</p></td>
</tr>
<tr>
<td>9</td>
<td><p><b>+</b></p>
<p>Operator to concatenate two strings, or a string and a character, or two characters.</p></td>
</tr>
<tr>
<td>10</td>
<td><p><b>+=</b></p>
<p>Operator to append a string or character to an existing string.</p></td>
</tr>
<tr>
<td>11</td>
<td><p><b>==</b></p>
<p>Operator to determine the equality of two strings.</p></td>
</tr>
<tr>
<td>12</td>
<td><p><b>&lt;</b></p>
<p>Operator to perform a lexicographical comparison to determine whether one string evaluates as less than another.</p></td>
</tr>
<tr>
<td>13</td>
<td><p><b>==</b></p>
<p>Operator to determine the equality of two strings.</p></td>
</tr>
</table>
<h1>Swift - Characters</h1>
<p>A <b>character</b> in Swift is a single character String literal, addressed by the data type <b>character</b>. Take a look at the following example. It uses two Character constants &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

let char1: Character = "A"
let char2: Character = "B"

println("Value of char1 \(char1)")
println("Value of char2 \(char2)")
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of char1 A
Value of char2 B
</pre>
<p>If you try to store more than one character in a Character type variable or constant, then Swift will not allow that. Try to type the following example in Swift Playground and you will get an error even before compilation.</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

// Following is wrong in Swift
let char: Character = "AB"

println("Value of char \(char)")
</pre>
<h2>Empty Character Variables</h2>
<p>It is not possible to create an empty Character variable or constant which will have an empty value. The following syntax is not possible &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

// Following is wrong in Swift
let char1: Character = ""
var char2: Character = ""

println("Value of char1 \(char1)")
println("Value of char2 \(char2)")
</pre>
<h2>Accessing Characters from Strings</h2>
<p>As explained while discussing Swift's Strings, String represents a collection of Character values in a specified order. So we can access individual characters from the given String by iterating over that string with a <b>for-in</b> loop &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

for ch in "Hello" {
   println(ch)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
H
e
l
l
o
</pre>
<h2>Concatenating Strings with Characters</h2>
<p>The following example demonstrates how a Swift's Character can be concatenated with Swift's String.</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var varA:String = "Hello "
let varB:Character = "G"

varA.append( varB )

println("Value of varC  =  \(varA)")
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of varC Hello G
</pre>
<h1>Swift - Arrays</h1>
<p>Swift arrays are used to store ordered lists of values of the same type. Swift puts strict checking which does not allow you to enter a wrong type in an array even by mistake.</p>
<p>If you assign a created array to a variable then its always mutable which means you can change it by adding, removing, or changing its items but if you assign an array to a constant then that array is immutable, and its size and contents cannot be changed.</p>
<h2>Creating Arrays</h2>
<p>You can create an empty array of a certain type using the following initializer syntax &minus;</p>
<pre class="result notranslate">
var someArray = [SomeType]()
</pre>
<p>Here is the syntax to create an array of a given size a* and initialize it with a value &minus;</p>
<pre class="result notranslate">
var someArray = [SomeType](count: NumbeOfElements, repeatedValue: InitialValue)
</pre>
<p>You can use the following statement to create an empty array of <b>Int</b> type having 3 elements and the initial value as zero &minus;</p>
<pre class="result notranslate">
var someInts = [Int](count: 3, repeatedValue: 0)
</pre>
<p>Following is one more example to create an array of three elements and assign three values to that array &minus;</p>
<pre class="result notranslate">
var someInts:[Int] = [10, 20, 30]
</pre>
<h2>Accessing Arrays</h2>
<p>You can retrieve a value from an array by using <b>subscript</b> syntax, passing the index of the value you want to retrieve within square brackets immediately after the name of the array as follows &minus;</p>
<pre class="result notranslate">
var someVar = someArray[index]
</pre>
<p>Here, the <b>index</b> starts from 0 which means the first element can be accessed using the index as 0, the second element can be accessed using the index as 1 and so on. The following example shows how to create, initialize, and access arrays &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someInts = [Int](count: 3, repeatedValue: 10)

var someVar = someInts[0]

println( "Value of first element is \(someVar)" )
println( "Value of second element is \(someInts[1])" )
println( "Value of third element is \(someInts[2])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of first element is 10
Value of second element is 10
Value of third element is 10
</pre>
<h2>Modifying Arrays</h2>
<p>You can use <b>append()</b> method or addition assignment operator (+=) to add a new item at the end of an array. Take a look at the following example. Here, initially, we create an empty array and then add new elements into the same array &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someInts = [Int]()

someInts.append(20)
someInts.append(30)
someInts += [40]

var someVar = someInts[0]

println( "Value of first element is \(someVar)" )
println( "Value of second element is \(someInts[1])" )
println( "Value of third element is \(someInts[2])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of first element is 20
Value of second element is 30
Value of third element is 40
</pre>
<p>You can modify an existing element of an Array by assigning a new value at a given index as shown in the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someInts = [Int]()

someInts.append(20)
someInts.append(30)
someInts += [40]

// Modify last element
someInts[2] = 50

var someVar = someInts[0]

println( "Value of first element is \(someVar)" )
println( "Value of second element is \(someInts[1])" )
println( "Value of third element is \(someInts[2])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of first element is 20
Value of second element is 30
Value of third element is 50
</pre>
<h2>Iterating Over an Array</h2>
<p>You can use <b>for-in</b> loop to iterate over the entire set of values in an array as shown in the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someStrs = [String]()

someStrs.append("Apple")
someStrs.append("Amazon")
someStrs += ["Google"]

for item in someStrs {
   println(item)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Apple
Amazon
Google
</pre>
<p>You can use <b>enumerate()</b> function which returns the index of an item along with its value as shown below in the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someStrs = [String]()

someStrs.append("Apple")
someStrs.append("Amazon")
someStrs += ["Google"]

for (index, item) in enumerate(someStrs) {
   println("Value at index = \(index) is \(item)")
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value at index = 0 is Apple
Value at index = 1 is Amazon
Value at index = 2 is Google
</pre>
<h2>Adding Two Arrays</h2>
<p>You can use the addition operator (+) to add two arrays of the same type which will yield a new array with a combination of values from the two arrays as follows &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var intsA = [Int](count:2, repeatedValue: 2)
var intsB = [Int](count:3, repeatedValue: 1)

var intsC = intsA + intsB

for item in intsC {
   println(item)
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
2
2
1
1
1
</pre>
<h2>The count Property</h2>
<p>You can use the read-only <b>count</b> property of an array to find out the number of items in an array shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var intsA = [Int](count:2, repeatedValue: 2)
var intsB = [Int](count:3, repeatedValue: 1)

var intsC = intsA + intsB

println("Total items in intsA = \(intsA.count)")
println("Total items in intsB = \(intsB.count)")
println("Total items in intsC = \(intsC.count)")
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Total items in intsA = 2
Total items in intsB = 3
Total items in intsC = 5
</pre>
<h2>The empty Property</h2>
<p>You can use the read-only <b>empty</b> property of an array to find out whether an array is empty or not as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var intsA = [Int](count:2, repeatedValue: 2)
var intsB = [Int](count:3, repeatedValue: 1)
var intsC = [Int]()

println("intsA.isEmpty = \(intsA.isEmpty)")
println("intsB.isEmpty = \(intsB.isEmpty)")
println("intsC.isEmpty = \(intsC.isEmpty)")
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
intsA.isEmpty = false
intsB.isEmpty = false
intsC.isEmpty = true
</pre>
<h1>Swift - Dictionaries</h1>
<p>Swift <b>dictionaries</b> are used to store unordered lists of values of the same type. Swift puts strict checking which does not allow you to enter a wrong type in a dictionary even by mistake.</p>
<p>Swift dictionaries use unique identifier known as a <b>key</b> to store a value which later can be referenced and looked up through the same key. Unlike items in an array, items in a <b>dictionary</b> do not have a specified order. You can use a <b>dictionary</b> when you need to look up values based on their identifiers.</p>
<p>A dictionary key can be either an integer or a string without a restriction, but it should be unique within a dictionary.</p>
<p>If you assign a created dictionary to a variable, then it is always mutable which means you can change it by adding, removing, or changing its items. But if you assign a dictionary to a constant, then that dictionary is immutable, and its size and contents cannot be changed.</p>
<h2>Creating Dictionary</h2>
<p>You can create an empty dictionary of a certain type using the following initializer syntax &minus;</p>
<pre class="result notranslate">
var someDict =  [KeyType: ValueType]()
</pre>
<p>You can use the following simple syntax to create an empty dictionary whose key will be of Int type and the associated values will be strings &minus;</p>
<pre class="result notranslate">
var someDict = [Int: String]()
</pre>
<p>Here is an example to create a dictionary from a set of given values &minus;</p>
<pre class="result notranslate">
var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]
</pre>
<h2>Accessing Dictionaries</h2>
<p>You can retrieve a value from a dictionary by using subscript syntax, passing the key of the value you want to retrieve within square brackets immediately after the name of the dictionary as follows &minus;</p>
<pre class="result notranslate">
var someVar = someDict[key]
</pre>
<p>Let's check the following example to create, initialize, and access values from a dictionary &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

var someVar = someDict[1]

println( "Value of key = 1 is \(someVar)" )
println( "Value of key = 2 is \(someDict[2])" )
println( "Value of key = 3 is \(someDict[3])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of key = 1 is Optional("One")
Value of key = 2 is Optional("Two")
Value of key = 3 is Optional("Three")
</pre>
<h2>Modifying Dictionaries</h2>
<p>You can use <b>updateValue(forKey:)</b> method to add an existing value to a given key of the dictionary. This method returns an optional value of the dictionary's value type. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

var oldVal = someDict.updateValue("New value of one", forKey: 1)

var someVar = someDict[1]

println( "Old value of key = 1 is \(oldVal)" )
println( "Value of key = 1 is \(someVar)" )
println( "Value of key = 2 is \(someDict[2])" )
println( "Value of key = 3 is \(someDict[3])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Old value of key = 1 is Optional("One")
Value of key = 1 is Optional("New value of one")
Value of key = 2 is Optional("Two")
Value of key = 3 is Optional("Three")
</pre>
<p>You can modify an existing element of a dictionary by assigning new value at a given key as shown in the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

var oldVal = someDict[1]
someDict[1] = "New value of one"
var someVar = someDict[1]

println( "Old value of key = 1 is \(oldVal)" )
println( "Value of key = 1 is \(someVar)" )
println( "Value of key = 2 is \(someDict[2])" )
println( "Value of key = 3 is \(someDict[3])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Old value of key = 1 is Optional("One")
Value of key = 1 is Optional("New value of one")
Value of key = 2 is Optional("Two")
Value of key = 3 is Optional("Three")
</pre>
<h2>Remove Key-Value Pairs</h2>
<p>You can use <b>removeValueForKey()</b> method to remove a key-value pair from a dictionary. This method removes the key-value pair if it exists and returns the removed value, or returns nil if no value existed. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

var removedValue = someDict.removeValueForKey(2)

println( "Value of key = 1 is \(someDict[1])" )
println( "Value of key = 2 is \(someDict[2])" )
println( "Value of key = 3 is \(someDict[3])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of key = 1 is Optional("One")
Value of key = 2 is nil
Value of key = 3 is Optional("Three")
</pre>
<p>You can also use subscript syntax to remove a key-value pair from a dictionary by assigning a value of <b>nil</b> for that key. Here is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

someDict[2] = nil

println( "Value of key = 1 is \(someDict[1])" )
println( "Value of key = 2 is \(someDict[2])" )
println( "Value of key = 3 is \(someDict[3])" )
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Value of key = 1 is Optional("One")
Value of key = 2 is nil
Value of key = 3 is Optional("Three")
</pre>
<h2>Iterating Over a Dictionary</h2>
<p>You can use a <b>for</b>-<b>in</b> loop to iterate over the entire set of key-value pairs in a Dictionary as shown in the following example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

for (key, value) in someDict {
   println("Dictionary key \(key) -  Dictionary value \(value)")
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Dictionary key 2 -  Dictionary value Two
Dictionary key 3 -  Dictionary value Three
Dictionary key 1 -  Dictionary value One
</pre>
<p>You can use <b>enumerate()</b> function which returns the index of the item along with its (key, value) pair as shown below in the example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

for (key, value) in enumerate(someDict) {
   println("Dictionary key \(key) -  Dictionary value \(value)")
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Dictionary key 0 -  Dictionary value (2, Two)
Dictionary key 1 -  Dictionary value (3, Three)
Dictionary key 2 -  Dictionary value (1, One)
</pre>
<h2>Convert to Arrays</h2>
<p>You can extract a list of key-value pairs from a given dictionary to build separate arrays for both keys and values. Here is an example &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict:[Int:String] = [1:"One", 2:"Two", 3:"Three"]

let dictKeys = [Int](someDict.keys)
let dictValues = [String](someDict.values)

println("Print Dictionary Keys")

for (key) in dictKeys {
   println("\(key)")
}

println("Print Dictionary Values")

for (value) in dictValues {
   println("\(value)")
}
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Print Dictionary Keys
2
3
1
Print Dictionary Values
Two
Three
One
</pre>
<h2>The count Property</h2>
<p>You can use the read-only <b>count</b> property of a dictionary to find out the number of items in a dictionary as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict1:[Int:String] = [1:"One", 2:"Two", 3:"Three"]
var someDict2:[Int:String] = [4:"Four", 5:"Five"]

println("Total items in someDict1 = \(someDict1.count)")
println("Total items in someDict2 = \(someDict2.count)")
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
Total items in someDict1 = 3
Total items in someDict2 = 2
</pre>
<h2>The empty Property</h2>
<p>You can use read-only <b>empty</b> property of a dictionary to find out whether a dictionary is empty or not, as shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
import Cocoa

var someDict1:[Int:String] = [1:"One", 2:"Two", 3:"Three"]
var someDict2:[Int:String] = [4:"Four", 5:"Five"]
var someDict3:[Int:String] = [Int:String]()

println("someDict1 = \(someDict1.isEmpty)")
println("someDict2 = \(someDict2.isEmpty)")
println("someDict3 = \(someDict3.isEmpty)")
</pre>
<p>When the above code is compiled and executed, it produces the following result &minus;</p>
<pre class="result notranslate">
someDict1 = false
someDict2 = false
someDict3 = true
</pre>
<h1>Swift - Functions</h1>
<p>A function is a set of statements organized together to perform a specific task. A Swift function can be as simple as a simple C function to as complex as an Objective C language function. It allows us to pass local and global parameter values inside the function calls.</p>
<ul class="list">
<li><p><b>Function Declaration</b> &minus; It tells the compiler about a function's name, return type, and parameters.</p></li>
<li><p><b>Function Definition</b> &minus; It provides the actual body of the function.</p></li>
</ul>
<p>Swift functions contain parameter type and its return types.</p>
<h2>Function Definition</h2>
<p>In Swift, a function is defined by the "func" keyword. When a function is newly defined, it may take one or several values as input 'parameters' to the function and it will process the functions in the main body and pass back the values to the functions as output 'return types'.</p>
<p>Every function has a function name, which describes the task that the function performs. To use a function, you "call" that function with its name and pass input values (known as arguments) that match the types of the function's parameters. Function parameters are also called as 'tuples'.</p>
<p>A function's arguments must always be provided in the same order as the function's parameter list and the return values are followed by &rarr;.</p>
<h3>Syntax</h3>
<pre class="result notranslate">
func funcname(Parameters) -> returntype {
   Statement1
   Statement2
   ---
   Statement N
   return parameters
}
</pre>
<p>Take a look at the following code. The student’s name is declared as string datatype declared inside the function 'student' and when the function is called, it will return student’s name.</p>
<pre class="prettyprint notranslate tryit">
func student(name: String) -> String {
   return name
}
println(student("First Program"))
println(student("About Functions"))
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
First Program
About Functions
</pre>
<h2>Calling a Function</h2>
<p>Let us suppose we defined a function called 'display' to Consider for example to display the numbers a function with function name 'display' is initialized first with argument 'no1' which holds integer data type. Then the argument 'no1' is assigned to argument 'a' which hereafter will point to the same data type integer. Now the argument 'a' is returned to the function. Here display() function will hold the integer value and return the integer values when each and every time the function is invoked.</p>
<pre class="prettyprint notranslate tryit">
func display(no1: Int) -> Int {
   let a = no1
   return a
}

println(display(100))
println(display(200))
</pre>
<p>When we run above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
100
200
</pre>
<h2>Parameters and Return Values</h2>
<p>Swift provides flexible function parameters and its return values from simple to complex values. Similar to that of C and Objective C, functions in Swift may also take several forms.</p>
<h2>Functions with Parameters</h2>
<p>A function is accessed by passing its parameter values to the body of the function. We can pass single to multiple parameter values as tuples inside the function.</p> 
<pre class="prettyprint notranslate tryit">
func mult(no1: Int, no2: Int) -> Int {
   return no1*no2
}
println(mult(2,20))
println(mult(3,15))
println(mult(4,30))
</pre>
<p>When we run above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
40
45
120
</pre>
<h2>Functions without Parameters</h2>
<p>We may also have functions without any parameters.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
func funcname() -> datatype {
   return datatype
}
</pre>
<p>Following is an example having a function without a parameter &minus;</p>
<pre class="prettyprint notranslate tryit">
func votersname() -> String {
   return "Alice"
}
println(votersname()) 
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Alice
</pre>
<h2>Functions with Return Values</h2>
<p>Functions are also used to return string, integer, and float data type values as return types. To find out the largest and smallest number in a given array function 'ls' is declared with large and small integer datatypes.</p>
<p>An array is initialized to hold integer values. Then the array is processed and each and every value in the array is read and compared for its previous value. When the value is lesser than the previous one it is stored in 'small' argument, otherwise it is stored in 'large' argument and the values are returned by calling the function.</p>
<pre class="prettyprint notranslate tryit">
func ls(array: [Int]) -> (large: Int, small: Int) {
   var lar = array[0]
   var sma = array[0]
   for i in array[1..&lt;array.count] {
      if i &lt; sma {
         sma = i
      }else if i &gt; lar {
         lar = i
      }
   }
   return (lar, sma)
}
let num = ls([40,12,-5,78,98])
println("Largest number is: \(num.large) and smallest number is: \(num.small)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Largest number is: 98 and smallest number is: -5
</pre>
<h2>Functions Without Return Values</h2>
<p>Some functions may have arguments declared inside the function without any return values. The following program declares <b>a</b> and <b>b</b> as arguments to the sum() function. inside the function itself the values for arguments <b>a</b> and <b>b</b> are passed by invoking the function call sum() and its values are printed thereby eliminating return values.</p>
<pre class="prettyprint notranslate tryit">
func sum(a: Int, b: Int) {
   let a = a + b
   let b = a - b
   println(a, b)
}
sum(20, 10)
sum(40,10)
sum(24,6)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
(30, 20)
(50, 40)
(30, 24)
</pre>
<h2>Functions with Optional Return Types</h2>
<p>Swift introduces 'optional' feature to get rid of problems by introducing a safety measure. Consider for example we are declaring function values return type as integer but what will happen when the function returns a string value or either a nil value. In that case compiler will return an error value. 'optional' are introduced to get rid of these problems.</p>
<p>Optional functions will take two forms 'value' and a 'nil'. We will mention 'Optionals' with the key reserved character '?' to check whether the tuple is returning a value or a nil value.</p> 
<pre class="prettyprint notranslate tryit">
func minMax(array: [Int]) -> (min: Int, max: Int)? {
   if array.isEmpty { return nil }
   var currentMin = array[0]
   var currentMax = array[0]
   for value in array[1..&lt;array.count] {
      if value &lt; currentMin {
         currentMin = value
      }else if value &gt; currentMax {
         currentMax = value
      }
   }
   return (currentMin, currentMax)
}
if let bounds = minMax([8, -6, 2, 109, 3, 71]) {
   println("min is \(bounds.min) and max is \(bounds.max)")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
min is -6 and max is 109
</pre>
<p>'Optionals' are used to check 'nil' or garbage values thereby consuming lot of time in debugging and make the code efficient and readable for the user.</p>
<h2>Functions Local Vs External Parameter Names</h2>
<h3>Local Parameter Names</h3>
<p>Local parameter names are accessed inside the function alone.</p>
<pre class="prettyprint notranslate">
func sample(number: Int) {
   println(number)
}
</pre>
<p>Here, the <b>func</b> sample argument number is declared as internal variable since it is accessed internally by the function sample(). Here the 'number' is declared as local variable but the reference to the variable is made outside the function with the following statement &minus;</p>
<pre class="prettyprint notranslate tryit">
func sample(number: Int) {
   println(number)
}
sample(1)
sample(2)
sample(3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
1
2
3
</pre>
<h3>External Parameter Names</h3>
<p>External parameter names allow us to name a function parameters to make their purpose more clear. For example below you can name two function parameters and then call that function as follows &minus;</p>
<pre class="prettyprint notranslate tryit">
func pow(firstArg a: Int, secondArg b: Int) -> Int {
   var res = a
   for _ in 1..&lt;b {
      res = res * a
   }
   println(res)
   return res
}
pow(firstArg:5, secondArg:3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
125
</pre>
<h2>Variadic Parameters</h2>
<p>When we want to define function with multiple number of arguments, then we can declare the members as 'variadic' parameters. Parameters can be specified as variadic by (&middot;&middot;&middot;) after the parameter name.</p>
<pre class="prettyprint notranslate tryit">
func vari&lt;N&gt;(members: N...) {
   for i in members {
      println(i)
   }
}
vari(4,3,5)
vari(4.5, 3.1, 5.6)
vari("Swift", "Enumerations", "Closures")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
4
3
5
4.5
3.1
5.6
Swift
Enumerations
Closures
</pre>
<h2>Constant, Variable and I/O Parameters</h2>
<p>Functions by default consider the parameters as 'constant', whereas the user can declare the arguments to the functions as variables also. We already discussed that 'let' keyword is used to declare constant parameters and variable parameters is defined with 'var' keyword.</p>
<p>I/O parameters in Swift provide functionality to retain the parameter values even though its values are modified after the function call. At the beginning of the function parameter definition, 'inout' keyword is declared to retain the member values.</p>
<p>It derives the keyword 'inout' since its values are passed 'in' to the function and its values are accessed and modified by its function body and it is returned back 'out' of the function to modify the original argument.</p>
<p>Variables are only passed as an argument for in-out parameter since its values alone are modified inside and outside the function. Hence no need to declare strings and literals as in-out parameters. '&amp;' before a variable name refers that we are passing the argument to the in-out parameter.</p>
<pre class="prettyprint notranslate tryit">
func temp(inout a1: Int, inout b1: Int) {
   let t = a1
   a1 = b1
   b1 = t
}
var no = 2
var co = 10
temp(&amp;no, &amp;co)
println("Swapped values are \(no), \(co)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Swapped values are 10, 2
</pre>
<h2>Function Types &amp; its Usage</h2>
<p>Each and every function follows the specific function by considering the input parameters and outputs the desired result.</p>
<pre class="prettyprint notranslate">
func inputs(no1: Int, no2: Int) -> Int {
   return no1/no2
}
</pre>
<p>Following is an example &minus;</p>
<pre class="prettyprint notranslate tryit">
func inputs(no1: Int, no2: Int) -> Int {
   return no1/no2
}
println(inputs(20,10))
println(inputs(36,6))
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
2
6
</pre>
<p>Here the function is initialized with two arguments no1 and no2 as integer data types and its return type is also declared as 'int'.</p>
<pre class="prettyprint notranslate">
Func inputstr(name: String) -> String {
   return name
}
</pre>
<p>Here the function is declared as <b>string</b> datatype.</p>
<p>Functions may also have <b>void</b> data types and such functions won't return anything.</p>
<pre class="prettyprint notranslate tryit">
func inputstr() {
   println("Swift Functions")
   println("Types and its Usage")
}
inputstr()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Swift Functions
Types and its Usage
</pre>
<p>The above function is declared as a void function with no arguments and no return values.</p>
<h2>Using Function Types</h2>
<p>Functions are first passed with integer, float or string type arguments and then it is passed as constants or variables to the function as mentioned below.</p>
<pre class="prettyprint notranslate">
var addition: (Int, Int) -> Int = sum
</pre>
<p>Here sum is a function name having 'a' and 'b' integer variables which is now declared as a variable to the function name addition. Hereafter both addition and sum function both have same number of arguments declared as integer datatype and also return integer values as references.</p>
<pre class="prettyprint notranslate tryit">
func sum(a: Int, b: Int) -> Int {
   return a + b
}
var addition: (Int, Int) -> Int = sum
println("Result: \(addition(40, 89))")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Result: 129
</pre>
<h2>Function Types as Parameter Types &amp; Return Types</h2>
<p>We can also pass the function itself as parameter types to another function.</p>
<pre class="prettyprint notranslate tryit">
func sum(a: Int, b: Int) -> Int {
   return a + b
}
var addition: (Int, Int) -> Int = sum
println("Result: \(addition(40, 89))")
func another(addition: (Int, Int) -> Int, a: Int, b: Int) {
   println("Result: \(addition(a, b))")
}
another(sum, 10, 20)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Result: 129
Result: 30
</pre>
<h2>Nested Functions</h2>
<p>A nested function provides the facility to call the outer function by invoking the inside function.</p>
<pre class="prettyprint notranslate tryit">
func calcDecrement(forDecrement total: Int) -> () -> Int {
   var overallDecrement = 0
   func decrementer() -> Int {
      overallDecrement -= total
      return overallDecrement
   }
   return decrementer
}
let decrem = calcDecrement(forDecrement: 30)
println(decrem())
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
-30
</pre>
<h1>Swift - Closures</h1>
<p>Closures in Swift are similar to that of self-contained functions organized as blocks and called anywhere like C and Objective C languages. Constants and variable references defined inside the functions are captured and stored in closures. Functions are considered as special cases of closures and it takes the following three forms &minus;</p>
<table class="table table-bordered">
<tr>
<th>Global Functions</th>
<th>Nested Functions</th>
<th>Closure Expressions</th>
</tr>
<tr>
<td>Have a name. Do not capture any values</td>
<td>Have a name. Capture values from enclosing function</td>
<td>Unnamed Closures capture values from the adjacent blocks</td>
</tr>
</table>
<p>Closure expressions in Swift language follow crisp, optimization and lightweight syntax styles which includes.</p>
<ul class="list">
<li>Inferring parameter and return value types from context.</li>
<li>Implicit returns from single-expression closures.</li>
<li>Shorthand argument names and</li>
<li>Trailing closure syntax</li>
</ul>
<h2>Syntax</h2>
<p>Following is a generic syntax to define closure which accepts parameters and returns a data type &minus;</p>
<pre class="result notranslate">
{(parameters) -> return type in
   statements
}
</pre>
<p>Following is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
let studname = { println("Welcome to Swift Closures") }
studname()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Welcome to Swift Closures
</pre>
<p>The following closure accepts two parameters and returns a Bool value &minus;</p>
<pre class="result notranslate">
{(Int, Int) -> Bool in
   Statement1
   Statement 2
    ---
   Statement n
}
</pre>
<p>Following is a simple example &minus;</p>
<pre class="prettyprint notranslate tryit">
let divide = {(val1: Int, val2: Int) -> Int in 
   return val1 / val2 
}
let result = divide(200, 20)
println (result)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
10
</pre>
<h2>Expressions in Closures</h2>
<p>Nested functions provide a convenient way of naming and defining blocks of code. Instead of representing the whole function declaration and name constructs are used to denote shorter functions. Representing the function in a clear brief statement with focused syntax is achieved through closure expressions.</p>
<h3>Ascending Order Program</h3>
<p>Sorting a string is achieved by the Swifts key reserved function "sorted" which is already available in the standard library. The function will sort the given strings in the ascending order and returns the elements in a new array with same size and data type mentioned in the old array. The old array remains the same.</p>
<p>Two arguments are represented inside the sorted function &minus;</p>
<ul class="list">
<li><p>Values of Known type represented as arrays.</p></li>
<li><p>Array contents (Int, Int) and returns a Boolean value (Bool) if the array is sorted properly it will return true value otherwise it will return false.</p></li>
</ul>
<p>A normal function with input string is written and passed to the sorted function to get the strings sorted to new array which is shown below &minus;</p>
<pre class="prettyprint notranslate tryit">
func ascend(s1: String, s2: String) -> Bool {
   return s1 &gt; s2
}
let stringcmp = ascend("swift", "great")
println (stringcmp)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
true
</pre>
<p>The initial array to be sorted for icecream is given as "Swift" and "great". Function to sort the array is declared as string datatype and its return type is mentioned as Boolean. Both the strings are compared and sorted in ascending order and stored in a new array. If the sorting is performed successful the function will return a true value else it will return false.</p>
<p>Closure expression syntax uses &minus;</p>
<ul class="list">
<li>constant parameters,</li>
<li>variable parameters, and</li>
<li>inout parameters.</li>
</ul>
<p>Closure expression did not support default values. Variadic parameters and Tuples can also be used as parameter types and return types.</p>
<pre class="prettyprint notranslate tryit">
let sum = {(no1: Int, no2: Int) -> Int in 
   return no1 + no2 
}
let digits = sum(10, 20)
println(digits)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
30
</pre>
<p>The parameters and return type declarations mentioned in the function statement can also be represented by the inline closure expression function with 'in' keyword. Once declaring parameter and return types 'in' keyword is used to denote that the body of the closure.</p>
<h2>Single Expression Implicit Returns</h2>
<p>Here, the function type of the sorted function's second argument makes it clear that a Bool value must be returned by the closure. Because the closure's body contains a single expression (s1 &gt; s2) that returns a Bool value, there is no ambiguity, and the return keyword can be omitted.</p>
<p>To return a Single expression statement in expression closures 'return' keyword is omitted in its declaration part.</p>
<pre class="prettyprint notranslate tryit">
let count = [5, 10, -6, 75, 20]
var descending = sorted(count, { n1, n2 in n1 &gt; n2 })
var ascending = sorted(count, { n1, n2 in n1 &lt; n2 })

println(descending)
println(ascending)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[75, 20, 10, 5, -6]
[-6, 5, 10, 20, 75]
</pre>
<p>The statement itself clearly defines that when string1 is greater than string 2 return true otherwise false hence return statement is omitted here.</p>
<h2>Known Type Closures</h2>
<p>Consider the addition of two numbers. We know that addition will return the integer datatype. Hence known type closures are declared as &minus;</p>
<pre class="prettyprint notranslate tryit">
let sub = {(no1: Int, no2: Int) -> Int in 
   return no1 - no2 
}
let digits = sub(10, 20)
println(digits)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
-10
</pre>
<h2>Declaring Shorthand Argument Names as Closures</h2>
<p>Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure's arguments by the names $0, $1, $2, and so on.</p>
<pre class="prettyprint notranslate tryit">
var shorthand: (String, String) -> String
shorthand = { $1 }
println(shorthand("100", "200"))
</pre>
<p>Here, $0 and $1 refer to the closure's first and second String arguments.</p>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
200
</pre>
<p>Swift facilitates the user to represent Inline closures as shorthand argument names by representing $0, $1, $2 --- $n.</p>
<p>Closures argument list is omitted in definition section when we represent shorthand argument names inside closure expressions. Based on the function type the shorthand argument names will be derived. Since the shorthand argument is defined in expression body the 'in' keyword is omitted.</p>
<h2>Closures as Operator Functions</h2>
<p>Swift provides an easy way to access the members by just providing operator functions as closures. In the previous examples keyword 'Bool' is used to return either 'true' when the strings are equal otherwise it returns 'false'.</p>
<p>The expression is made even simpler by operator function in closure as &minus;</p>
<pre class="prettyprint notranslate tryit">
let numb = [98, -20, -30, 42, 18, 35]
var sortedNumbers = numb.sorted({
   (left: Int, right: Int) -> Bool in
   return left &lt; right
})
let asc = numb.sorted(&lt;)
println(asc)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[-30, -20, 18, 35, 42, 98]
</pre>
<h2>Closures as Trailers</h2>
<p>Passing the function's final argument to a closure expression is declared with the help of 'Trailing Closures'. It is written outside the function () with {}. Its usage is needed when it is not possible to write the function inline on a single line.</p>
<pre class="result notranslate">
reversed = sorted(names) { $0 &gt; $1}
</pre>
<p>where {$0 &gt; $1} are represented as trailing closures declared outside (names).</p>
<pre class="prettyprint notranslate tryit">
import Foundation
var letters = ["North", "East", "West", "South"]
 
let twoletters = letters.map({ (state: String) -> String in
   return state.substringToIndex(advance(state.startIndex, 2)).uppercaseString
})
let stletters = letters.map() { $0.substringToIndex(advance($0.startIndex, 2)).uppercaseString }
println(stletters)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[NO, EA, WE, SO]
</pre>
<h2>Capturing Values and Reference Types</h2>
<p>In Swift, capturing constants and variables values is done with the help of closures. It further refers and modify the values for those constants and variables inside the closure body even though the variables no longer exists.</p>
<p>Capturing constant and variable values is achieved by using nested function by writing function with in the body of other function.</p>
<p>A nested function captures &minus;</p>
<ul class="list">
<li>Outer function arguments.</li>
<li>Capture constants and variables defined within the Outer function.</li>
</ul>
<p>In Swift, when a constant or a variable is declared inside a function, reference to that variables are also automatically created by the closure. It also provides the facility to refer more than two variables as the same closure as follows &minus;</p>
<pre class="prettyprint notranslate">
let decrem = calcDecrement(forDecrement: 18)
decrem()
</pre>
<p>Here <b>oneDecrement</b> and Decrement variables will both point the same memory block as closure reference.</p>
<pre class="prettyprint notranslate tryit">
func calcDecrement(forDecrement total: Int) -> () -> Int {
   var overallDecrement = 100
   func decrementer() -> Int {
      overallDecrement -= total
      println(overallDecrement)
      return overallDecrement
   }
   return decrementer
}
let decrem = calcDecrement(forDecrement: 18)
decrem()
decrem()
decrem()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
82
64
46
</pre>
<p>When each and every time the outer function calcDecrement is called it invokes the decrementer() function and decrements the value by 18 and returns the result with the help of outer function calcDecrement. Here calcDecrement acts as a closure.</p>
<p>Even though the function decrementer() does not have any arguments closure by default refers to variables 'overallDecrement' and 'total' by capturing its existing values. The copy of the values for the specified variables are stored with the new decrementer() function. Swift handles memory management functions by allocating and deallocating memory spaces when the variables are not in use.</p>
<h1>Swift - Enumerations</h1>
<p>An enumeration is a user-defined data type which consists of set of related values. Keyword <b>enum</b> is used to defined enumerated data type.</p>
<h2>Enumeration Functionality</h2>
<p>Enumeration in swift also resembles the structure of C and Objective C.</p>
<ul class="list">
<li><p>It is declared in a class and its values are accessed through the instance of that class.</p></li>
<li><p>Initial member value is defined using enum intializers.</p></li>
<li><p>Its functionality is also extended by ensuring standard protocol functionality.</p></li>
</ul>
<h3>Syntax</h3>
<p>Enumerations are introduced with the enum keyword and place their entire definition within a pair of braces &minus;</p>
<pre class="prettyprint notranslate">
enum enumname {
   // enumeration values are described here
}
</pre>
<p>For example, you can define an enumeration for days of week as follows &minus;</p>
<pre class="result notranslate">
enum DaysofaWeek {
   case Sunday
   case Monday
    ---
   case Saturday
}
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
enum names {
   case Swift
   case Closures
}
var lang = names.Closures
lang = .Closures
switch lang {
   case .Swift:
   println("Welcome to Swift")
   case .Closures:
   println("Welcome to Closures")
   default:
   println("Introduction")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Welcome to Closures
</pre>
<p>Swift enumeration does not assign its members default value like C and Objective C. Instead the members are explicitly defined by their enumeration names. Enumeration name should start with a capital letter (Ex: enum DaysofaWeek).</p>
<pre class="prettyprint notranslate">
var weekDay = DaysofaWeek.Sunday 
</pre>
<p>Here the Enumeration name 'DaysofaWeek' is assigned to a variable weekday.Sunday. It informs the compiler that the datatype belongs to Sunday will be assigned to subsequent enum members of that particular class. Once the enum member datatype is defined, the members can be accessed by passing values and further computations.</p>
<h2>Enumeration with Switch Statement</h2>
<p>Swift 'Switch' statement also follows the multi way selection. Only one variable is accessed at a particular time based on the specified condition. Default case in switch statement is used to trap unspecified cases.</p>
<pre class="prettyprint notranslate tryit">
enum Climate {
   case India
   case America
   case Africa
   case Australia
}

var season = Climate.America
season = .America
switch season {
   case .India:
      println("Climate is Hot")
   case .America:
      println("Climate is Cold")
   case .Africa:
      println("Climate is Moderate")
   case .Australia:
      println("Climate is Rainy")
   default:
      println("Climate is not predictable")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Climate is Cold
</pre>
<p>The program first defines Climate as the enumeration name. Then its members like 'India', 'America', 'Africa' and 'Australia' are declared belonging to class 'Climate'. Now the member America is assigned to a Season Variable. Further, Switch case will see the values corresponding to .America and it will branch to that particular statement. The output will be displayed as "Climate is Cold". Likewise all the members can be accessed through switch statements. When the condition is not satisfied it prints by default 'Climate is not predictable'.</p>
<p>Enumeration can be further classified in to associated values and raw values.</p>
<h2>Difference between Associated Values and Raw Values</h2>
<table class="table table-bordered">
<tr>
<td>Associated Values</td>
<td>Raw Values</td>
</tr>
<tr>
<td>Different Datatypes</td>
<td>Same Datatypes</td>
</tr>
<tr>
<td> Ex: enum {10,0.8,"Hello"}</td>
<td> Ex: enum {10,35,50}</td>
</tr>
<tr>
<td> Values are created based on constant or variable</td>
<td> Prepopulated Values</td>
</tr>
<tr>
<td> Varies when declared each time</td>
<td> Value for member is same</td>
</tr>
</table>
<h2>Enum with Associated Values</h2>
<pre class="prettyprint notranslate tryit">
enum Student {
   case Name(String)
   case Mark(Int,Int,Int)
}
var studDetails = Student.Name("Swift")
var studMarks = Student.Mark(98,97,95)
switch studMarks {
   case .Name(let studName):
      println("Student name is: \(studName).")
   case .Mark(let Mark1, let Mark2, let Mark3):
      println("Student Marks are: \(Mark1),\(Mark2),\(Mark3).")
   default:
      println("Nothing")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Swift
98
97
95
</pre>
<p>Consider for example to access the students name and marks secured in three subjects enumeration name is declared as student and the members present in enum class are name which belongs to string datatype, marks are represented as mark1, mark2 and mark3 of datatype Integer. To access either the student name or marks they have scored.</p>
<pre class="result notranslate">
var studDetails = Student.Name("Swift")
var studMarks = Student.Mark(98,97,95)
</pre>
<p>Now, the switch case will print student name if that case block is executed otherwise it will print the marks secured by the student. If both the conditions fail, the default block will be executed.</p>
<h2>Enum with Raw Values</h2>
<p>Raw values can be strings, characters, or any of the integer or floating-point number types. Each raw value must be unique within its enumeration declaration. When integers are used for raw values, they auto-increment if no value is specified for some of the enumeration members.</p>
<pre class="prettyprint notranslate tryit">
enum Month: Int {
   case January = 1, February, March, April, May, June, July, August, September, October, November, December
}

let yearMonth = Month.May.rawValue
println("Value of the Month is: \(yearMonth).")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Value of the Month is: 5.
</pre>
<h1>Swift - Structures</h1>
<p>Swift provides a flexible building block of making use of constructs as Structures. By making use of these structures once can define constructs methods and properties.</p>
<h2>Unlike C and Objective C</h2>
<ul class="list">
<li><p>Structure need not require implementation files and interface.</p></li>
<li><p>Structure allows us to create a single file and to extend its interface automatically to other blocks.</p></li>
</ul>
<p>In Structure the variable values are copied and passed in subsequent codes by returning a copy of the old values so that the values cannot be altered.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
Structures are defined with a 'Struct' Keyword.
struct nameStruct {
   Definition 1
   Definition 2
    --- 
   Definition N
}
</pre>
<h2>Definition of a Structure</h2>
<p>Consider for example, suppose we have to access students record containing marks of three subjects and to find out the total of three subjects. Here markStruct is used to initialize a structure with three marks as datatype 'Int'.</p>
<pre class="prettyprint notranslate">
struct MarkStruct {
   var mark1: Int
   var mark2: Int
   var mark3: Int
}
</pre>
<h2>Accessing the Structure and its Properties</h2>
<p>The members of the structure are accessed by its structure name. The instances of the structure are initialized by the 'let' keyword.</p>
<pre class="prettyprint notranslate tryit">
struct studentMarks {
   var mark1 = 100
   var mark2 = 200
   var mark3 = 300
}
let marks = studentMarks()
println("Mark1 is \(marks.mark1)")
println("Mark2 is \(marks.mark2)")
println("Mark3 is \(marks.mark3)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Mark1 is 100
Mark2 is 200
Mark3 is 300
</pre>
<p>Students marks are accessed by the structure name 'studentMarks'. The structure members are initialized as mark1, mark2, mark3 with integer type values. Then the structure studentMarks() is passed to the 'marks' with 'let' keyword. Hereafter 'marks' will contain the structure member values. Now the values are printed by accessing the structure member values by '.' with its initialized names.</p> 
<pre class="prettyprint notranslate tryit">
struct MarksStruct {
   var mark: Int

   init(mark: Int) {
      self.mark = mark
   }
}
var aStruct = MarksStruct(mark: 98)
var bStruct = aStruct // aStruct and bStruct are two structs with the same value!
bStruct.mark = 97
println(aStruct.mark) // 98
println(bStruct.mark) // 97
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
98
97
</pre>
<h2>Best Usage Practices of Structures</h2>
<p>Swift language provides the functionality to define structures as custom data types for building the function blocks. The instances of structure are passed by its value to the defined blocks for further manipulations.</p>
<h3>Need for having structures</h3>
<ul class="list">
<li><p>To encapsulate simple data values.</p></li>
<li><p>To copy the encapsulated data and its associated properties by 'values' rather than by 'references'.</p></li>
<li><p>Structure to 'Copy' and 'Reference'.</p></li>
</ul>
<p>Structures in swift pass their members with their values rather than by its references.</p>
<pre class="prettyprint notranslate tryit">
struct markStruct { 
   var mark1: Int
   var mark2: Int
   var mark3: Int

   init(mark1: Int, mark2: Int, mark3: Int) {
      self.mark1 = mark1
      self.mark2 = mark2
      self.mark3 = mark3
   }
}

var marks = markStruct(mark1: 98, mark2: 96, mark3:100)
println(marks.mark1)
println(marks.mark2)
println(marks.mark3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
98
96
100
</pre>
<h2>Another Example</h2>
<pre class="prettyprint notranslate tryit">
struct markStruct { 
   var mark1: Int
   var mark2: Int
   var mark3: Int

   init(mark1: Int, mark2: Int, mark3: Int){
      self.mark1 = mark1
      self.mark2 = mark2
      self.mark3 = mark3
   }
}

var fail = markStruct(mark1: 34, mark2: 42, mark3: 13)

println(fail.mark1)
println(fail.mark2)
println(fail.mark3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
34
42
13
</pre>
<p>The structure 'markStruct' is defined first with its members mark1, mark2 and mark3. Now the variables of member classes are initialized to hold integer values. Then the copy of the structure members are created with 'self' Keyword. Once the copy of the structure members are created structure block with its parameter marks are passed to 'marks' variable which will now hold the students marks. Then the marks are printed as 98, 96, 100. Next step for the same structure members another instance named 'fail' is used to point the same structure members with different marks. Then the results are now printed as 34, 42, 13. This clearly explains that structures will have a copy of the member variables then pass the members to their upcoming function blocks.</p>
<h1>Swift - Classes</h1>
<p>Classes in Swift are building blocks of flexible constructs. Similar to constants, variables and functions the user can define class properties and methods. Swift provides us the functionality that while declaring classes the users need not create interfaces or implementation files. Swift allows us to create classes as a single file and the external interfaces will be created by default once the classes are initialized.</p>
<h2>Benefits of having Classes</h2>
<ul class="list">
<li>Inheritance acquires the properties of one class to another class</li>
<li>Type casting enables the user to check class type at run time</li>
<li>Deinitializers take care of releasing memory resources</li> 
<li>Reference counting allows the class instance to have more than one reference</li>
</ul>
<h2>Common Characteristics of Classes and structures</h2>
<ul class="list">
<li>Properties are defined to store values</li>
<li>Subscripts are defined for providing access to values</li>
<li>Methods are initialized to improve functionality</li>
<li>Initial state are defined by initializers</li>
<li>Functionality are expanded beyond default values</li>
<li>Confirming protocol functionality standards</li>
</ul>
<h3>Syntax</h3>
<pre class="result notranslate">
Class classname {
   Definition 1
   Definition 2
    --- 
   Definition N
}
</pre>
<h2>Class Definition</h2>
<pre class="result notranslate">
class student {
   var studname: String
   var mark: Int 
   var mark2: Int 
}
</pre>
<p>The syntax for creating instances</p>
<pre class="result notranslate">
let studrecord = student()
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
class MarksStruct {
   var mark: Int
   init(mark: Int) {
      self.mark = mark
   }
}

class studentMarks {
   var mark = 300
}
let marks = studentMarks()
println("Mark is \(marks.mark)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Mark is 300
</pre>
<h2>Accessing Class Properties as Reference Types</h2>
<p>Class properties can be accessed by the '.' syntax. Property name is separated by a '.' after the instance name.</p>
<pre class="prettyprint notranslate tryit">
class MarksStruct {
   var mark: Int
   init(mark: Int) {
      self.mark = mark
   }
}

class studentMarks {
   var mark1 = 300
   var mark2 = 400
   var mark3 = 900
}
let marks = studentMarks()
println("Mark1 is \(marks.mark1)")
println("Mark2 is \(marks.mark2)")
println("Mark3 is \(marks.mark3)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Mark1 is 300
Mark2 is 400
Mark3 is 900
</pre>
<h2>Class Identity Operators</h2>
<p>Classes in Swift refers multiple constants and variables pointing to a single instance. To know about the constants and variables pointing to a particular class instance identity operators are used. Class instances are always passed by reference. In Classes NSString, NSArray, and NSDictionary instances are always assigned and passed around as a reference to an existing instance, rather than as a copy.</p>
<table class="table table-bordered">
<tr>
<th>Identical to Operators</th>
<th>Not Identical to Operators</th>
</tr>
<tr>
<td>Operator used is (===)</td>
<td>Operator used is (!==)</td>
</tr>
<tr>
<td>Returns true when two constants or variables pointing to a same instance</td>
<td>Returns true when two constants or variables pointing to a different instance</td>
</tr>
</table>
<pre class="prettyprint notranslate tryit">
class SampleClass: Equatable {
   let myProperty: String
   init(s: String) {
      myProperty = s
   }
}
func ==(lhs: SampleClass, rhs: SampleClass) -> Bool {
   return lhs.myProperty == rhs.myProperty
}

let spClass1 = SampleClass(s: "Hello")
let spClass2 = SampleClass(s: "Hello")

spClass1 === spClass2 // false
println("\(spClass1)")

spClass1 !== spClass2 // true
println("\(spClass2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
main.SampleClass
main.SampleClass
</pre>
<h1>Swift - Properties</h1>
<p>Swift language provides properties for class, enumeration or structure to associate values. Properties can be further classified into Stored properties and Computed properties.</p>
<p>Difference between Stored Properties and Computed Properties.</p>
<table class="table table-bordered">
<tr>
<th>Stored Property</th>
<th>Computed Property</th>
</tr>
<tr>
<td>Store constant and variable values as instance.</td>
<td>Calculate a value rather than storing the value.</td>
</tr>
<tr>
<td>Provided by classes and structures.</td>
<td>Provided by classes, enumerations and structures.</td>
</tr>
</table>
<p>Both Stored and Computed properties are associated with instances type. When the properties are associated with its type values then it is defined as 'Type Properties'. Stored and computed properties are usually associated with instances of a particular type. However, properties can also be associated with the type itself. Such properties are known as type properties. Property observers are also used.</p>
<ul class="list">
<li>To observe the value of the stored properties.</li>
<li>To observe the property of inherited subclass derived from superclass.</li>
</ul>
<h2>Stored Properties</h2>
<p>Swift introduces Stored Property concept to store the instances of constants and variables. Stored properties of constants are defined by the 'let' keyword and Stored properties of variables are defined by the 'var' keyword.</p>
<ul class="list">
<li>During definition Stored property provides 'default value'.</li>
<li>During Initialization the user can initialize and modify the initial values.</li>
</ul>
<pre class="prettyprint notranslate tryit">
struct Number{
   var digits: Int
   let pi = 3.1415
}

var n = Number(digits: 12345)
n.digits = 67

println("\(n.digits)")
println("\(n.pi)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
67
3.1415
</pre>
<p>Consider the following line in the above code &minus;</p>
<pre class="result notranslate">
let pi = 3.1415
</pre>
<p>Here, the variable pi is initialized as a stored property value with the instance pi = 3.1415. So, whenever the instance is referred it will hold the value 3.1415 alone.</p>
<p>Another method to have stored property is to have as constant structures. So the whole instance of the structures will be considered as 'Stored Properties of Constants'.</p>
<pre class="prettyprint notranslate tryit">
struct Number {
   var digits: Int
   let numbers = 3.1415
}

var n = Number(digits: 12345)
n.digits = 67

println("\(n.digits)")
println("\(n.numbers)")
n.numbers = 8.7
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
error: cannot assign to 'numbers' in 'n'
n.numbers = 8.7
</pre>
<p>Instead of reinitializing the 'number' to 8.7 it will return an error message indicating that the 'number' is declared as constant.</p>
<h2>Lazy Stored Property</h2>
<p>Swift provides a flexible property called 'Lazy Stored Property' where it won't calculate the initial values when the variable is initialized for the first time. 'lazy' modifier is used before the variable declaration to have it as a lazy stored property.</p>
<p>Lazy Properties are used &minus;</p>
<ul class="list">
<li>To delay object creation.</li>
<li>When the property is dependent on other parts of a class, that are not known yet.</li>
</ul>
<pre class="prettyprint notranslate tryit">
class sample {
   lazy var no = number() // `var` declaration is required.
}

class number {
   var name = "Swift"
}

var firstsample = sample()
println(firstsample.no.name)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Swift
</pre>
<h2>Instance Variables</h2>
<p>In Objective C, Stored properties also have instance variables for back up purposes to store the values declared in stored property.</p>
<p>Swift integrates both these concepts into a single 'stored property' declaration. Instead of having a corresponding instance variable and back up value 'stored property' contains all integrated information defined in a single location about the variables property by variable name, data type and memory management functionalities.</p>
<h2>Computed Properties</h2>
<p>Rather than storing the values computed properties provide a getter and an optional setter to retrieve and set other properties and values indirectly.</p>
<pre class="prettyprint notranslate tryit">
class sample {
   var no1 = 0.0, no2 = 0.0
   var length = 300.0, breadth = 150.0

   var middle: (Double, Double) {
      get{
         return (length / 2, breadth / 2)
      }set(axis) {
         no1 = axis.0 - (length / 2)
         no2 = axis.1 - (breadth / 2)
      }
   }
}

var result = sample()
println(result.middle)
result.middle = (0.0, 10.0)

println(result.no1)               
println(result.no2)  
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
(150.0, 75.0)
-150.0
-65.0
</pre>
<p>When a computed property left the new value as undefined, the default value will be set for that particular variable.</p>
<h3>Computed Properties as Read-Only Properties</h3>
<p>A read-only property in computed property is defined as a property with getter but no setter. It is always used to return a value. The variables are further accessed through a '.' Syntax but cannot be set to another value.</p>
<pre class="prettyprint notranslate tryit">
class film {
   var head = ""
   var duration = 0.0
   var metaInfo: [String:String] {
      return [
         "head": self.head,
         "duration":"\(self.duration)"
      ]
   }
}

var movie = film()
movie.head = "Swift Properties"
movie.duration = 3.09

println(movie.metaInfo["head"]!)      
println(movie.metaInfo["duration"]!)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Swift Properties
3.09
</pre>
<h3>Computed Properties as Property Observers</h3>
<p>In Swift to observe and respond to property values Property Observers are used. Each and every time when property values are set property observers are called. Except lazy stored properties we can add property observers to 'inherited' property by method 'overriding'.</p>
<p>Property Observers can be defined by either.</p>
<ul class="list">
<li><p>Before Storing the value - willset.</p></li>
<li><p>After Storing the new value - didset.</p></li>
<li><p>When a property is set in an initializer willset and didset observers cannot be called.</p></li>
</ul>
<pre class="prettyprint notranslate tryit">
class Samplepgm {
   var counter: Int = 0 {
      willSet(newTotal) {
         println("Total Counter is: \(newTotal)")
      }
      didSet {
         if counter &gt; oldValue {
            println("Newly Added Counter \(counter - oldValue)")
         }
      }
   }
}
let NewCounter = Samplepgm()
NewCounter.counter = 100
NewCounter.counter = 800
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Total Counter is: 100
Newly Added Counter 100
Total Counter is: 800
Newly Added Counter 700
</pre>
<h2>Local and Global Variables</h2>
<p>Local and global variable are declared for computing and observing the properties.</p>
<table class="table table-bordered">
<tr>
<th>Local Variables</th>
<th>Global Variables</th>
</tr>
<tr>
<td>Variables that are defined within a function, method, or closure context.</td>
<td>Variables that are defined outside function, method, closure, or type context.</td>
</tr>
<tr>
<td>Used to store and retrieve values.</td>
<td>Used to store and retrieve values.</td>
</tr>
<tr>
<td>Stored properties is used to get and set the values.</td>
<td>Stored properties is used to get and set the values.</td>
</tr>
<tr>
<td>Computed properties are also used.</td>
<td>Computed properties are also used.</td>
</tr>
</table>
<h2>Type Properties</h2>
<p>Properties are defined in the Type definition section with curly braces {} and scope of the variables are also defined previously. For defining type properties for value types 'static' keyword is used and for class types 'class' keyword is used.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
struct Structname {
   static var storedTypeProperty = " "
   static var computedTypeProperty: Int {
      // return an Int value here
   }
}

enum Enumname {
   static var storedTypeProperty = " "
   static var computedTypeProperty: Int {
      // return an Int value here
   }
}

class Classname {
   class var computedTypeProperty: Int {
      // return an Int value here
   }
}
</pre>
<h2>Querying and Setting Properties</h2>
<p>Just like instance properties Type properties are queried and set with '.' Syntax just on the type alone instead of pointing to the instance.</p>
<pre class="prettyprint notranslate tryit">
struct StudMarks {
   static let markCount = 97
   static var totalCount = 0
   var InternalMarks: Int = 0 {
      didSet {
         if InternalMarks &gt; StudMarks.markCount {
            InternalMarks = StudMarks.markCount
         }
         if InternalMarks &gt; StudMarks.totalCount {
            StudMarks.totalCount = InternalMarks
         }
      }
   }
}

var stud1Mark1 = StudMarks()
var stud1Mark2 = StudMarks()

stud1Mark1.InternalMarks = 98
println(stud1Mark1.InternalMarks) 

stud1Mark2.InternalMarks = 87
println(stud1Mark2.InternalMarks)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
97
87
</pre>
<h1>Swift - Methods</h1>
<p>In Swift language Functions associated with particular types are referred to as Methods. In Objective C Classes are used to define methods, whereas Swift language provides the user flexibility to have methods for Classes, Structures and Enumerations.</p>
<h2>Instance Methods</h2>
<p>In Swift language, Classes, Structures and Enumeration instances are accessed through the instance methods.</p>
<p>Instance methods provide functionality.</p>
<ul class="list">
<li>To access and modify instance properties.</li>
<li>functionality related to the instance's need.</li>
</ul>
<p>Instance method can be written inside the {} curly braces. It has implicit access to methods and properties of the type instance. When a specific instance of the type is called it will get access to that particular instance.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
func funcname(Parameters) -> returntype {
   Statement1
   Statement2
   ---
   Statement N
   return parameters
}
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
class calculations {
   let a: Int
   let b: Int
   let res: Int

   init(a: Int, b: Int) {
      self.a = a
      self.b = b
      res = a + b
   }
 
   func tot(c: Int) -> Int {
      return res - c
   }
 
   func result() {
      println("Result is: \(tot(20))")
      println("Result is: \(tot(50))")
   }
}
let pri = calculations(a: 600, b: 300)
pri.result()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Result is: 880
Result is: 850
</pre>
<p>Class Calculations defines two instance methods &minus;</p>
<ul class="list">
<li>init() is defined to add two numbers a and b and store it in result 'res'</li>
<li>tot() is used to subtract the 'res' from passing 'c' value</li>
</ul>
<p>Finally, to print the calculations methods with values for a and b is called. Instance methods are accessed with '.' dot syntax</p>
<h2>Local and External Parameter Names</h2>
<p>Swift Functions describe both local and global declarations for their variables. Similarly, Swift Methods naming conventions also resembles as that of Objective C. But the characteristics of local and global parameter name declarations are different for functions and methods. The first parameter in swift are referred by preposition names as 'with', 'for' and 'by' for easy to access naming conventions.</p>
<p>Swift provides the flexibility in methods by declaring first parameter name as local parameter names and the remaining parameter names to be of global parameter names. Here 'no1' is declared by swift methods as local parameter names. 'no2' is used for global declarations and accessed through out the program.</p>
<pre class="prettyprint notranslate tryit">
class division {
   var count: Int = 0
   func incrementBy(no1: Int, no2: Int) {
      count = no1 / no2
      println(count)
   }
}

let counter = division()
counter.incrementBy(1800, no2: 3)
counter.incrementBy(1600, no2: 5)
counter.incrementBy(11000, no2: 3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
600
320
3666
</pre>
<h2>External Parameter Name with # and _ Symbol</h2>
<p>Even though Swift methods provide first parameter names for local declarations, the user has the provision to modify the parameter names from local to global declarations. This can be done by prefixing '#' symbol with the first parameter name. By doing so, the first parameter can be accessed globally throughout the modules.</p>
<p>When the user needs to access the subsequent parameter names with an external name, the methods name is overridden with the help of '_' symbol.</p>
<pre class="prettyprint notranslate tryit">
class multiplication {
   var count: Int = 0
   func incrementBy(#no1: Int, no2: Int) {
      count = no1 * no2
      println(count)
   }
}

let counter = multiplication()
counter.incrementBy(no1: 800, no2: 3)
counter.incrementBy(no1: 100, no2: 5)
counter.incrementBy(no1: 15000, no2: 3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
2400
500
45000
</pre>
<h2>Self property in Methods</h2>
<p>Methods have an implicit property known as 'self' for all its defined type instances. 'Self' property is used to refer the current instances for its defined methods.</p>
<pre class="prettyprint notranslate tryit">
class calculations {
   let a: Int
   let b: Int
   let res: Int

   init(a: Int, b: Int) {
      self.a = a
      self.b = b
      res = a + b
      println("Inside Self Block: \(res)")
   }

   func tot(c: Int) -> Int {
      return res - c
   }

   func result() {
      println("Result is: \(tot(20))")
      println("Result is: \(tot(50))")
   }
}

let pri = calculations(a: 600, b: 300)
let sum = calculations(a: 1200, b: 300)

pri.result()
sum.result()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Inside Self Block: 900
Inside Self Block: 1500
Result is: 880
Result is: 850
Result is: 1480
Result is: 1450
</pre>
<h2>Modifying Value Types from Instance Methods</h2>
<p>In Swift language structures and enumerations belong to value types which cannot be altered by its instance methods. However, swift language provides flexibility to modify the value types by 'mutating' behavior. Mutate will make any changes in the instance methods and will return back to the original form after the execution of the method. Also, by the 'self' property new instance is created for its implicit function and will replace the existing method after its execution</p>
<pre class="prettyprint notranslate tryit">
struct area {
   var length = 1
   var breadth = 1
	
   func area() -> Int {
      return length * breadth
   }
 
   mutating func scaleBy(res: Int) {
      length *= res
      breadth *= res

      println(length)
      println(breadth)
   }
}

var val = area(length: 3, breadth: 5)
val.scaleBy(3)
val.scaleBy(30)
val.scaleBy(300)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
9
15
270
450
81000
135000
</pre>
<h2>Self Property for Mutating Method</h2>
<p>Mutating methods combined with 'self' property assigns a new instance to the defined method.</p>
<pre class="prettyprint notranslate tryit">
struct area {
   var length = 1
   var breadth = 1

   func area() -> Int {
      return length * breadth
   }

   mutating func scaleBy(res: Int) {
      self.length *= res
      self.breadth *= res
      println(length)
      println(breadth)
   }
}
var val = area(length: 3, breadth: 5)
val.scaleBy(13)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
39
65
</pre> 
<h2>Type Methods</h2>
<p>When a particular instance of a method is called, it is called as an Instance method; and when the method calls a particular type of a method, it is called as 'Type Methods'. Type methods for 'classes' are defined by the 'func' keyword and structures and enumerations type methods are defined with the 'static' keyword before the 'func' keyword.</p>
<p>Type methods are called and accessed by '.' syntax where instead of calling a particular instance the whole method is invoked.</p>
<pre class="prettyprint notranslate tryit">
class Math {
   class func abs(number: Int) -> Int {
      if number &lt; 0 {
         return (-number)
      }else {
         return number
      }
   }
}

struct absno {
   static func abs(number: Int) -> Int {
      if number &lt; 0 {
         return (-number)
      }else {
         return number
      }
   }
}

let no = Math.abs(-35)
let num = absno.abs(-5)

println(no)
println(num)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
35
5
</pre>
<h1>Swift - Subscripts</h1>
<p>Accessing the element members of a collection, sequence and a list in Classes, Structures and Enumerations are carried out with the help of subscripts. These subscripts are used to store and retrieve the values with the help of index. Array elements are accessed with the help of someArray[index] and its subsequent member elements in a Dictionary instance can be accessed as someDicitonary[key].</p>
<p>For a single type, subscripts can range from single to multiple declarations. We can use the appropriate subscript to overload the type of index value passed to the subscript. Subscripts also ranges from single dimension to multiple dimension according to the users requirements for their input data type declarations.</p>
<h2>Subscript Declaration Syntax and its Usage</h2>
<p>Let's have a recap to the computed properties. Subscripts too follow the same syntax as that of computed properties. For querying type instances, subscripts are written inside a square bracket followed with the instance name. Subscript syntax follows the same syntax structure as that of 'instance method' and 'computed property' syntax. 'subscript' keyword is used for defining subscripts and the user can specify single or multiple parameters with their return types. Subscripts can have read-write or read-only properties and the instances are stored and retrieved with the help of 'getter' and 'setter' properties as that of computed properties.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
subscript(index: Int) -> Int {
   get {
      // used for subscript value declarations
   }
   set(newValue) {
      // definitions are written here
   }
}
</pre>
<h3>Example1</h3>
<pre class="prettyprint notranslate tryit">
struct subexample {
   let decrementer: Int
   subscript(index: Int) -> Int {
      return decrementer / index
   }
}
let division = subexample(decrementer: 100)

println("The number is divisible by \(division[9]) times")
println("The number is divisible by \(division[2]) times")
println("The number is divisible by \(division[3]) times")
println("The number is divisible by \(division[5]) times")
println("The number is divisible by \(division[7]) times")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
The number is divisible by 11 times
The number is divisible by 50 times
The number is divisible by 33 times
The number is divisible by 20 times
The number is divisible by 14 times
</pre>
<h3>Example2</h3>
<pre class="prettyprint notranslate tryit">
class daysofaweek {
   private var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "saturday"]
   subscript(index: Int) -> String {
      get {
         return days[index]
      }

      set(newValue) {
         self.days[index] = newValue
      }
   }
}
var p = daysofaweek()

println(p[0])
println(p[1])
println(p[2])
println(p[3])
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Sunday
Monday
Tuesday
Wednesday
</pre>
<h2>Options in Subscript</h2>
<p>Subscripts takes single to multiple input parameters and these input parameters also belong to any datatype. They can also use variable and variadic parameters. Subscripts cannot provide default parameter values or use any in-out parameters.</p>
<p>Defining multiple subscripts are termed as 'subscript overloading' where a class or structure can provide multiple subscript definitions as required. These multiple subscripts are inferred based on the types of values that are declared within the subscript braces.</p> 
<pre class="prettyprint notranslate tryit">
struct Matrix {
   let rows: Int, columns: Int
   var print: [Double]
   init(rows: Int, columns: Int) {
      self.rows = rows
      self.columns = columns
      print = Array(count: rows * columns, repeatedValue: 0.0)
   }
   subscript(row: Int, column: Int) -> Double {
      get {
         return print[(row * columns) + column]
      }

      set {
         print[(row * columns) + column] = newValue
      }
   }
}
var mat = Matrix(rows: 3, columns: 3)

mat[0,0] = 1.0
mat[0,1] = 2.0
mat[1,0] = 3.0
mat[1,1] = 5.0

println("\(mat[0,0])")
println("\(mat[0,1])")
println("\(mat[1,0])")
println("\(mat[1,1])")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
1.0
2.0
3.0
5.0
</pre>
<p>Swift subscript supports single parameter to multiple parameter declarations for appropriate data types. The program declares 'Matrix' structure as a 2 * 2 dimensional array matrix to store 'Double' data types. The Matrix parameter is inputted with Integer data types for declaring rows and columns.</p>
<p>New instance for the Matrix is created by passing row and column count to the initialize as shown below.</p>
<pre class="result notranslate">
var mat = Matrix(rows: 3, columns: 3) 
</pre>
<p>Matrix values can be defined by passing row and column values into the subscript, separated by a comma as shown below.</p>
<pre class="result notranslate">
mat[0,0] = 1.0  
mat[0,1] = 2.0
mat[1,0] = 3.0
mat[1,1] = 5.0
</pre>
<h1>Swift - Inheritance</h1>
<p>The ability to take than more form is defined as Inheritance. Generally a class can inherit methods, properties and functionalities from another class. Classes can be further categorized in to sub class and super class.</p> 
<ul class="list">
<li><p><b>Sub Class &minus;</b> when a class inherits properties, methods and functions from another class it is called as sub class</p></li>
<li><p><b>Super Class &minus;</b> Class containing properties, methods and functions to inherit other classes from itself is called as a super class</p></li>
</ul>
<p>Swift classes contain superclass which calls and access methods, properties, functions and overriding methods. Also, property observers are also used to add a property and modify the stored or computed property methods.</p>
<h2>Base Class</h2>
<p>A Class that does not inherit methods, properties or functions from another class is called as 'Base Class'.</p>
<pre class="prettyprint notranslate tryit">
class StudDetails {
   var stname: String!
   var mark1: Int!
   var mark2: Int!
   var mark3: Int!
   init(stname: String, mark1: Int, mark2: Int, mark3: Int) {
      self.stname = stname
      self.mark1 = mark1
      self.mark2 = mark2
      self.mark3 = mark3
   }
}
let stname = "swift"
let mark1 = 98
let mark2 = 89
let mark3 = 76

println(stname)
println(mark1)
println(mark2)
println(mark3)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
swift
98
89
76
</pre>
<p>Class with classname StudDetails are defined as a base class here which is used to contain students name, and three subjects mark as mark1, mark2 and mark3. 'let' keyword is used to initialize the value for the base class and base class value is displayed in the playground with the help of 'println' function.</p>
<h2>Subclass</h2>
<p>The act of basing a new class on an existing class is defined as 'Subclass'. The subclass inherits the properties, methods and functions of its base class. To define a subclass ':' is used before the base class name.</p>
<pre class="prettyprint notranslate tryit">
class StudDetails {
   var mark1: Int;
   var mark2: Int;

   init(stm1:Int, results stm2:Int) {
      mark1 = stm1;
      mark2 = stm2;
   }

   func print() {
      println("Mark1:\(mark1), Mark2:\(mark2)")
   }
}

class display : StudDetails {
   init() {
      super.init(stm1: 93, results: 89)
   }
}

let marksobtained = display()
marksobtained.print()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Mark1:93, Mark2:89
</pre>
<p>Class 'StudDetails' is defined as super class where student marks are declared and the subclass 'display' is used to inherit the marks from its super class. Sub class defines students marks and calls the print() method to display the students mark.</p> 
<h2>Overriding</h2>
<p>Accessing the super class instance, type methods, instance, type properties and subscripts subclass provides the concept of overriding. 'override' keyword is used to override the methods declared in the superclass.</p> 
<h3>Access to Super class Methods, Properties and Subscripts</h3>
<p>'super' keyword is used as a prefix to access the methods, properties and subscripts declared in the super class.</p>
<table class="table table-bordered">
<tr>
<td>Overriding</td>
<td>Access to methods, properties and subscripts</td>
</tr>
<tr>
<td>Methods</td>
<td>super.somemethod()</td>
</tr>
<tr>
<td>Properties</td>
<td>super.someProperty()</td>
</tr>
<tr>
<td>Subscripts</td>
<td>super[someIndex]</td>
</tr>
</table>
<h2>Methods Overriding</h2>
<p>Inherited instance and type methods can be overridden by the 'override' keyword to our methods defined in our subclass. Here print() is overridden in subclass to access the type property mentioned in the super class print(). Also new instance of cricket() super class is created as 'cricinstance'.</p>
<pre class="prettyprint notranslate tryit">
class cricket {
   func print() {
      println("Welcome to Swift Super Class")
   }
}

class tennis: cricket {
   override func print() {
      println("Welcome to Swift Sub Class")
   }
}

let cricinstance = cricket()
cricinstance.print()

let tennisinstance = tennis()
tennisinstance.print()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Welcome to Swift Super Class
Welcome to Swift Sub Class
</pre>
<h2>Property Overriding</h2>
<p>You can override an inherited instance or class property to provide your own custom getter and setter for that property, or to add property observers to enable the overriding property to observe when the underlying property value changes.</p>
<h3>Overriding Property Getters and Setters</h3>
<p>Swift allows the user to provide custom getter and setter to override the inherited property whether it is a stored or computed property. The subclass does not know the inherited property name and type. Therefore it is essential that the user needs to specify in subclass, the name and type of the overriding property specified in super class.</p>
<p>This can be done in two ways &minus;</p>
<ul class="list">
<li><p>When setter is defined for overriding property the user has to define getter too.</p></li>
<li><p>When we don't want to modify the inherited property getter, we can simply pass the inherited value by the syntax 'super.someProperty' to the super class.</p></li>
</ul>
<pre class="prettyprint notranslate tryit">
class Circle {
   var radius = 12.5
   var area: String {
      return "of rectangle for \(radius) "
   }
}

class Rectangle: Circle {
   var print = 7
   override var area: String {
      return super.area + " is now overridden as \(print)"
   }
}

let rect = Rectangle()
rect.radius = 25.0
rect.print = 3
println("Radius \(rect.area)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Radius of rectangle for 25.0  is now overridden as 3
</pre>
<h2>Overriding Property Observers</h2>
<p>When a new property needs to be added for an inherited property, 'property overriding' concept is introduced in Swift. This notifies the user when the inherited property value is altered. But overriding is not applicable for inherited constant stored properties and inherited read-only computed properties.</p> 
<pre class="prettyprint notranslate tryit">
class Circle {
   var radius = 12.5
   var area: String {
      return "of rectangle for \(radius) "
   }
}

class Rectangle: Circle {
   var print = 7
   override var area: String {
      return super.area + " is now overridden as \(print)"
   }
}


let rect = Rectangle()
rect.radius = 25.0
rect.print = 3
println("Radius \(rect.area)")

class Square: Rectangle {
   override var radius: Double {
      didSet {
         print = Int(radius/5.0)+1
      }
   }
}


let sq = Square()
sq.radius = 100.0
println("Radius \(sq.area)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Radius of rectangle for 25.0  is now overridden as 3
Radius of rectangle for 100.0  is now overridden as 21
</pre>
<h2>Final Property to prevent Overriding</h2>
<p>When the user need not want others to access super class methods, properties or subscripts swift introduces 'final' property to prevent overriding. Once 'final' property is declared the subscripts won't allow the super class methods, properties and its subscripts to be overridden. There is no provision to have 'final' property in 'super class'. When 'final' property is declared the user is restricted to create further sub classes.</p>
<pre class="prettyprint notranslate tryit">
final class Circle {
   final var radius = 12.5
   var area: String {
      return "of rectangle for \(radius) "
   }
}
class Rectangle: Circle {
   var print = 7
   override var area: String {
      return super.area + " is now overridden as \(print)"
   }
}

let rect = Rectangle()
rect.radius = 25.0
rect.print = 3
println("Radius \(rect.area)")

class Square: Rectangle {
   override var radius: Double {
      didSet {
         print = Int(radius/5.0)+1
      }
   }
}

let sq = Square()
sq.radius = 100.0
println("Radius \(sq.area)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
&lt;stdin&gt;:14:18: error: var overrides a 'final' var
    override var area: String {
                 ^
&lt;stdin&gt;:7:9: note: overridden declaration is here
    var area: String {
        ^
&lt;stdin&gt;:12:11: error: inheritance from a final class 'Circle'
    class Rectangle: Circle {
          ^
&lt;stdin&gt;:25:14: error: var overrides a 'final' var
override var radius: Double {
             ^
&lt;stdin&gt;:6:14: note: overridden declaration is here
   final var radius = 12.5
</pre>
<p>Since the super class is declared as 'final' and its data types are also declared as 'final' the program won't allow to create subclasses further and it will throw errors.</p>
<h1>Swift - Initialization</h1>
<p>Classes, structures and enumerations once declared in Swift are initialized for preparing instance of a class. Initial value is initialized for stored property and also for new instances too the values are initialized to proceed further. The keyword to create initialization function is carried out by 'init()' method. Swift initializer differs from Objective-C that it does not return any values. Its function is to check for initialization of newly created instances before its processing. Swift also provides 'deinitialization' process for performing memory management operations once the instances are deallocated.</p>
<h2>Initializer Role for Stored Properties</h2>
<p>Stored property have to initialize the instances for its classes and structures before processing the instances. Stored properties use initializer to assign and initialize values thereby eradicating the need to call property observers. Initializer is used in stored property.</p>
<ul class="list">
<li><p>To create an initial value.</p></li>
<li><p>To assign default property value within the property definition.</p></li>
<li><p>To initialize an instance for a particular data type 'init()' is used. No arguments are passed inside the init() function.</p></li>
</ul>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
init() {
   //New Instance initialization goes here
}
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
struct rectangle {
   var length: Double
   var breadth: Double
   init() {
      length = 6
      breadth = 12
   }
}
var area = rectangle()
println("area of rectangle is \(area.length*area.breadth)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
area of rectangle is 72.0
</pre>
<p>Here the structure 'rectangle' is initialized with members length and breadth as 'Double' datatypes. Init() method is used to initialize the values for the newly created members length and double. Area of rectangle is calculated and returned by calling the rectangle function.</p>
<h2>Setting Property Values by Default</h2>
<p>Swift language provides Init() function to initialize the stored property values. Also, the user has provision to initialize the property values by default while declaring the class or structure members. When the property takes the same value alone throughout the program we can declare it in the declaration section alone rather than initializing it in init(). Setting property values by default enables the user when inheritance is defined for classes or structures.</p>
<pre class="prettyprint notranslate tryit">
struct rectangle {
   var length = 6
   var breadth = 12
}
var area = rectangle()
println("area of rectangle is \(area.length*area.breadth)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
area of rectangle is 72.0
</pre>
<p>Here instead of declaring length and breadth in init() the values are initialized in declaration itself.</p>
<h2>Parameters Initialization</h2>
<p>In Swift language the user has the provision to initialize parameters as part of the initializer's definition using init().</p>  
<pre class="prettyprint notranslate tryit">
struct Rectangle {
   var length: Double
   var breadth: Double
   var area: Double

   init(fromLength length: Double, fromBreadth breadth: Double) {
      self.length = length
      self.breadth = breadth
      area = length * breadth
   }

   init(fromLeng leng: Double, fromBread bread: Double) {
      self.length = leng
      self.breadth = bread
      area = leng * bread
   }
}

let ar = Rectangle(fromLength: 6, fromBreadth: 12)
println("area is: \(ar.area)")

let are = Rectangle(fromLeng: 36, fromBread: 12)
println("area is: \(are.area)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
area is: 72.0
area is: 432.0
</pre>
<h2>Local &amp; External Parameters</h2>
<p>Initialization parameters have both local and global parameter names similar to that of function and method parameters. Local parameter declaration is used to access within the initialize body and external parameter declaration is used to call the initializer. Swift initializers differ from function and method initializer that they do not identify which initializer are used to call which functions.</p>
<p>To overcome this, Swift introduces an automatic external name for each and every parameter in init(). This automatic external name is as equivalent as local name written before every initialization parameter.</p>
<pre class="prettyprint notranslate tryit">
struct Days {
   let sunday, monday, tuesday: Int
   init(sunday: Int, monday: Int, tuesday: Int) {
      self.sunday = sunday
      self.monday = monday
      self.tuesday = tuesday
   }

   init(daysofaweek: Int) {
      sunday = daysofaweek
      monday = daysofaweek
      tuesday = daysofaweek
   }
}

let week = Days(sunday: 1, monday: 2, tuesday: 3)
println("Days of a Week is: \(week.sunday)")
println("Days of a Week is: \(week.monday)")
println("Days of a Week is: \(week.tuesday)")

let weekdays = Days(daysofaweek: 4)
println("Days of a Week is: \(weekdays.sunday)")
println("Days of a Week is: \(weekdays.monday)")
println("Days of a Week is: \(weekdays.tuesday)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Days of a Week is: 1
Days of a Week is: 2
Days of a Week is: 3
Days of a Week is: 4
Days of a Week is: 4
Days of a Week is: 4
</pre>
<h2>Parameters without External Names</h2>
<p>When an external name is not needed for an initialize underscore '_' is used to override the default behavior.</p>
<pre class="prettyprint notranslate tryit">
struct Rectangle {
   var length: Double

   init(frombreadth breadth: Double) {
      length = breadth * 10
   }

   init(frombre bre: Double) {
      length = bre * 30
   }

   init(_ area: Double) {
      length = area
   }
}

let rectarea = Rectangle(180.0)
println("area is: \(rectarea.length)")

let rearea = Rectangle(370.0)
println("area is: \(rearea.length)")

let recarea = Rectangle(110.0)
println("area is: \(recarea.length)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
area is: 180.0
area is: 370.0
area is: 110.0
</pre>
<h2>Optional Property Types</h2>
<p>When the stored property at some instance does not return any value that property is declared with an 'optional' type indicating that 'no value' is returned for that particular type. When the stored property is declared as 'optional' it automatically initializes the value to be 'nil' during initialization itself.</p>
<pre class="prettyprint notranslate tryit">
struct Rectangle {
   var length: Double?

   init(frombreadth breadth: Double) {
      length = breadth * 10
   }

   init(frombre bre: Double) {
      length = bre * 30
   }

   init(_ area: Double) {
      length = area
   }
}

let rectarea = Rectangle(180.0)
println("area is: \(rectarea.length)")

let rearea = Rectangle(370.0)
println("area is: \(rearea.length)")

let recarea = Rectangle(110.0)
println("area is: \(recarea.length)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
area is: Optional(180.0)
area is: Optional(370.0)
area is: Optional(110.0)
</pre>
<h2>Modifying Constant Properties During Initialization</h2>
<p>Initialization also allows the user to modify the value of constant property too. During initialization, class property allows its class instances to be modified by the super class and not by the subclass. Consider for example in the previous program 'length' is declared as 'variable' in the main class. The below program variable 'length' is modified as 'constant' variable.</p>
<pre class="prettyprint notranslate tryit">
struct Rectangle {
   let length: Double?

   init(frombreadth breadth: Double) {
      length = breadth * 10
   }

   init(frombre bre: Double) {
      length = bre * 30
   }

   init(_ area: Double) {
      length = area
   }
}

let rectarea = Rectangle(180.0)
println("area is: \(rectarea.length)")

let rearea = Rectangle(370.0)
println("area is: \(rearea.length)")

let recarea = Rectangle(110.0)
println("area is: \(recarea.length)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
area is: Optional(180.0)
area is: Optional(370.0)
area is: Optional(110.0)
</pre>
<h2>Default Initializers</h2>
<p>Default initializers provide a new instance to all its declared properties of base class or structure with default values.</p> 
<pre class="prettyprint notranslate tryit">
class defaultexample {
   var studname: String?
   var stmark = 98
   var pass = true
}
var result = defaultexample()

println("result is: \(result.studname)")
println("result is: \(result.stmark)")
println("result is: \(result.pass)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
result is: nil
result is: 98
result is: true
</pre>
<p>The above program is defined with class name as 'defaultexample'. Three member functions are initialized by default as 'studname?' to store 'nil' values, 'stmark' as 98 and 'pass' as Boolean value 'true'. Likewise the member values in the class can be initialized as default before processing the class member types.</p>
<h2>Memberwise Initializers for Structure Types</h2>
<p>When the custom initializers are not provided by the user, Structure types in Swift will automatically receive the 'memberwise initializer'. Its main function is to initialize the new structure instances with the default memberwise initialize and then the new instance properties are passed to the memberwise initialize by name.</p>
<pre class="prettyprint notranslate tryit">
struct Rectangle {
   var length = 100.0, breadth = 200.0
}
let area = Rectangle(length: 24.0, breadth: 32.0)

println("Area of rectangle is: \(area.length)")
println("Area of rectangle is: \(area.breadth)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Area of rectangle is: 24.0
Area of rectangle is: 32.0
</pre>
<p>Structures are initialized by default for their membership functions during initialization for 'length' as '100.0' and 'breadth' as '200.0'. But the values are overridden during the processing of variables length and breadth as 24.0 and 32.0.</p>
<h2>Initializer Delegation for Value Types</h2>
<p>Initializer Delegation is defined as calling initializers from other initializers. Its main function is to act as reusability to avoid code duplication across multiple initializers.</p>
<pre class="prettyprint notranslate tryit">
struct Stmark {
   var mark1 = 0.0, mark2 = 0.0
}
struct stdb {
   var m1 = 0.0, m2 = 0.0
}

struct block {
   var average = stdb()
   var result = Stmark()

   init() {}

   init(average: stdb, result: Stmark) {
      self.average = average
      self.result = result
   }

   init(avg: stdb, result: Stmark) {
      let tot = avg.m1 - (result.mark1 / 2)
      let tot1 = avg.m2 - (result.mark2 / 2)
      self.init(average: stdb(m1: tot, m2: tot1), result: result)
   }
}

let set1 = block()
println("student result is: \(set1.average.m1, set1.average.m2) \(set1.result.mark1, set1.result.mark2)")

let set2 = block(average: stdb(m1: 2.0, m2: 2.0),
   result: Stmark(mark1: 5.0, mark2: 5.0))
println("student result is: \(set2.average.m1, set2.average.m2) \(set2.result.mark1, set2.result.mark2)")

let set3 = block(avg: stdb(m1: 4.0, m2: 4.0),
   result: Stmark(mark1: 3.0, mark2: 3.0))
println("student result is: \(set3.average.m1, set3.average.m2) \(set3.result.mark1, set3.result.mark2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
student result is: (0.0, 0.0) (0.0, 0.0)
student result is: (2.0, 2.0) (5.0, 5.0)
student result is: (2.5, 2.5) (3.0, 3.0)
</pre>
<h2>Rules for Initializer Delegation</h2>
<table class="table table-bordered">
<tr>
<th>Value Types</th>
<th>Class Types</th>
</tr>
<tr>
<td>Inheritance is not supported for value types like structures and enumerations. Referring other initializers is done through self.init.</td>
<td>Inheritance is supported. Checks all stored property values are initialized.</td>
</tr>
</table>
<h2>Class Inheritance and Initialization</h2>
<p>Class types have two kinds of initializers to check whether defined stored properties receive an initial value namely designated initializers and convenience initializers.</p>
<h3>Designated Initializers and Convenience Initializers</h3>
<table class="table table-bordered">
<tr>
<th>Designated Initializer</th>
<th>Convenience Initializer</th>
</tr>
<tr>
<td>Considered as primary initializes for a class.</td>
<td>Considered as supporting initialize for a class.</td>
</tr>
<tr>
<td>All class properties are initialized and appropriate superclass initializer are called for further initialization.</td>
<td>Designated initializer is called with convenience initializer to create class instance for a specific use case or input value type.</td>
</tr>
<tr>
<td>At least one designated initializer is defined for every class.</td>
<td>No need to have convenience initializers  compulsory defined when the class does not require initializers.</td>
</tr>
<tr>
<td>Init(parameters) { statements }
</td>
<td>convenience init(parameters) { statements }
</td>
</tr>
</table>
<h3>Program for Designated Initializers</h3>
<pre class="prettyprint notranslate tryit">
class mainClass {
   var no1 : Int // local storage
   init(no1 : Int) {
      self.no1 = no1 // initialization
   }
}
class subClass : mainClass {
   var no2 : Int // new subclass storage
   init(no1 : Int, no2 : Int) {
      self.no2 = no2 // initialization
      super.init(no1:no1) // redirect to superclass
   }
}

let res = mainClass(no1: 10)
let print = subClass(no1: 10, no2: 20)

println("res is: \(res.no1)")
println("res is: \(print.no1)")
println("res is: \(print.no2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
res is: 10
res is: 10
res is: 20
</pre>
<h3>Program for Convenience Initializers</h3>
<pre class="prettyprint notranslate tryit">
class mainClass {
   var no1 : Int // local storage
   init(no1 : Int) {
      self.no1 = no1 // initialization
   }
}

class subClass : mainClass {
   var no2 : Int
   init(no1 : Int, no2 : Int) {
      self.no2 = no2
      super.init(no1:no1)
   }
   // Requires only one parameter for convenient method
   override convenience init(no1: Int)  {
      self.init(no1:no1, no2:0)
   }
}
let res = mainClass(no1: 20)
let print = subClass(no1: 30, no2: 50)

println("res is: \(res.no1)")
println("res is: \(print.no1)")
println("res is: \(print.no2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
res is: 20
res is: 30
res is: 50
</pre>
<h2>Initializer Inheritance and Overriding</h2>
<p>Swift does not allow its subclasses to inherit its superclass initializers for their member types by default. Inheritance is applicable to Super class initializers only to some extent which will be discussed in Automatic Initializer Inheritance.</p>
<p>When the user needs to have initializers defined in super class, subclass with initializers has to be defined by the user as custom implementation. When overriding has to be taken place by the sub class to the super class 'override' keyword has to be declared.</p>
<pre class="prettyprint notranslate tryit">
class sides {
   var corners = 4
   var description: String {
      return "\(corners) sides"
   }
}
let rectangle = sides()
println("Rectangle: \(rectangle.description)")

class pentagon: sides {
   override init() {
      super.init()
      corners = 5
   }
}

let bicycle = pentagon()
println("Pentagon: \(bicycle.description)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Rectangle: 4 sides
Pentagon: 5 sides
</pre>
<h2>Designated and Convenience Initializers in Action</h2>
<pre class="prettyprint notranslate tryit">
class Planet {
   var name: String

   init(name: String) {
      self.name = name
   }

   convenience init() {
      self.init(name: "[No Planets]")
   }
}
let plName = Planet(name: "Mercury")
println("Planet name is: \(plName.name)")

let noplName = Planet()
println("No Planets like that: \(noplName.name)")

class planets: Planet {
   var count: Int
   init(name: String, count: Int) {
      self.count = count
      super.init(name: name)
   }

   override convenience init(name: String) {
      self.init(name: name, count: 1)
   }
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Planet name is: Mercury
No Planets like that: [No Planets]
</pre>
<h2>Failable Initializer</h2>
<p>The user has to be notified when there are any initializer failures while defining a class, structure or enumeration values. Initialization of variables sometimes become a failure one due to &minus;</p> 
<ul class="list">
<li>Invalid parameter values.</li>
<li>Absence of required external source.</li>
<li>Condition preventing initialization from succeeding.</li>
</ul>
<p>To catch exceptions thrown by initialization method, swift produces a flexible initialize called 'failable initializer' to notify the user that something is left unnoticed while initializing the structure, class or enumeration members. Keyword to catch the failable initializer is 'init?'. Also, failable and non failable initializers cannot be defined with same parameter types and names.</p>
<pre class="prettyprint notranslate tryit">
struct studrecord {
   let stname: String

   init?(stname: String) {
      if stname.isEmpty {return nil }
      self.stname = stname
   }
}

let stmark = studrecord(stname: "Swing")
if let name = stmark {
   println("Student name is specified")
}

let blankname = studrecord(stname: "")
if blankname == nil {
   println("Student name is left blank")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Student name is specified
Student name is left blank
</pre>
<h2>Failable Initializers for Enumerations</h2>
<p>Swift language provides the flexibility to have Failable initializers for enumerations too to notify the user when the enumeration members are left from initializing values.</p>
<pre class="prettyprint notranslate tryit">
enum functions {
   case a, b, c, d
   init?(funct: String) {
      switch funct {
         case "one":
            self = .a
         case "two":
            self = .b
         case "three":
            self = .c
         case "four":
            self = .d
         default:
            return nil
      }
   }
}

let result = functions(funct: "two")
if result != nil {
   println("With In Block Two")
}

let badresult = functions(funct: "five")
if badresult == nil {
    println("Block Does Not Exist")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
With In Block Two
Block Does Not Exist
</pre>
<h2>Failable Initializers for Classes</h2>
<p>A failable initializer when declared with enumerations and structures alerts an initialization failure at any circumstance within its implementation. However, failable initializer in classes will alert the failure only after the stored properties have been set to an initial value.</p>
<pre class="prettyprint notranslate tryit">
class studrecord {
   let studname: String!
   init?(studname: String) {
      self.studname = studname
      if studname.isEmpty { return nil }
   }
}
if let stname = studrecord(studname: "Failable Initializers") {
   println("Module is \(stname.studname)")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Module is Failable Initializers
</pre>
<h2>Overriding a Failable Initializer</h2>
<p>Like that of initialize the user also has the provision to override a superclass failable initializer inside the sub class. Super class failable initialize can also be overridden with in a sub class non-failable initializer.</p>
<p>Subclass initializer cannot delegate up to the superclass initializer when overriding a failable superclass initializer with a non-failable subclass initialize.</p>
<p>A non-failable initializer can never delegate to a failable initializer.</p>
<p>The program given below describes the failable and non-failable initializers.</p>
<pre class="prettyprint notranslate tryit">
class Planet {
   var name: String

   init(name: String) {
      self.name = name
   }

   convenience init() {
      self.init(name: "[No Planets]")
   }
}
let plName = Planet(name: "Mercury")
println("Planet name is: \(plName.name)")

let noplName = Planet()
println("No Planets like that: \(noplName.name)")

class planets: Planet {
   var count: Int

   init(name: String, count: Int) {
      self.count = count
      super.init(name: name)
   }

   override convenience init(name: String) {
      self.init(name: name, count: 1)
   }
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Planet name is: Mercury
No Planets like that: [No Planets]
</pre>
<h2>The init! Failable Initializer</h2>
<P>Swift provides 'init?' to define an optional instance failable initializer. To define an implicitly unwrapped optional instance of the specific type 'init!' is specified.</p>
<pre class="prettyprint notranslate tryit">
struct studrecord {
   let stname: String

   init!(stname: String) {
      if stname.isEmpty {return nil }
      self.stname = stname
   }
}

let stmark = studrecord(stname: "Swing")
if let name = stmark {
   println("Student name is specified")
}

let blankname = studrecord(stname: "")
if blankname == nil {
   println("Student name is left blank")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Student name is specified
Student name is left blank
</pre>
<h2>Required Initializers</h2>
<p>To declare each and every subclass of the initialize 'required' keyword needs to be defined before the init() function.</p>
<pre class="prettyprint notranslate tryit">
class classA {
   required init() {
      var a = 10
      println(a)
   }
}
class classB: classA {
   required init() {
      var b = 30
      println(b)
   }
}
let res = classA()
let print = classB()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
10
30
10
</pre>
<h1>Swift - Deinitialization</h1>
<p>Before a class instance needs to be deallocated 'deinitializer' has to be called to deallocate the memory space. The keyword 'deinit' is used to deallocate the memory spaces occupied by the system resources. Deinitialization is available only on class types.</p>
<h2>Deinitialization to Deallocate Memory Space</h2>
<p>Swift automatically deallocates your instances when they are no longer needed, to free up resources. Swift handles the memory management of instances through automatic reference counting (ARC), as described in Automatic Reference Counting. Typically you don't need to perform manual clean-up when your instances are deallocated. However, when you are working with your own resources, you might need to perform some additional clean-up yourself. For example, if you create a custom class to open a file and write some data to it, you might need to close the file before the class instance is deallocated.</p>
<pre class="prettyprint notranslate tryit">
var counter = 0;  // for reference counting
class baseclass {
   init() {
      counter++;
   }
   deinit {
      counter--;
   }
}

var print: baseclass? = baseclass()
println(counter)
print = nil
println(counter)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
1
0
</pre>
<p>When print = nil statement is omitted the values of the counter retains the same since it is not deinitialized.</p>
<pre class="prettyprint notranslate tryit">
var counter = 0;  // for reference counting

class baseclass {
   init() {
      counter++;
   }

   deinit {
      counter--;
   }
}

var print: baseclass? = baseclass()

println(counter)
println(counter)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
1
1
</pre>
<h1>Swift - ARC Overview</h1>
<p>Memory management functions and its usage are handled in Swift language through Automatic reference counting (ARC). ARC is used to initialize and deinitialize the system resources thereby releasing memory spaces used by the class instances when the instances are no longer needed. ARC keeps track of information about the relationships between our code instances to manage the memory resources effectively.</p>
<h2>Functions of ARC</h2>
<ul class="list">
<li><p>ARC allocates a chunk of memory to store the information each and every time when a new class instance is created by init().</p></li>
<li><p>Information about the instance type and its values are stored in memory.</p></li>
<li><p>When the class instance is no longer needed it automatically frees the memory space by deinit() for further class instance storage and retrieval.</p></li>
<li><p>ARC keeps in track of currently referring class instances properties, constants and variables so that deinit() is applied only to those unused instances.</p></li>
<li><p>ARC maintains a 'strong reference' to those class instance property, constants and variables to restrict deallocation when the class instance is currently in use.</p></li>
</ul>
<h2>ARC Program</h2>
<pre class="prettyprint notranslate tryit">
class StudDetails {
   var stname: String!
   var mark1: Int!
   init(stname: String, mark1: Int) {
      self.stname = stname
      self.mark1 = mark1
   }

   deinit {
      println("Deinitialized \(self.stname)")
      println("Deinitialized \(self.mark1)")
   }
}

let stname = "swift"
let mark1 = 98

println(stname)
println(mark1)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
swift
98
</pre>
<h2>ARC Strong Reference Cycles Class Instances</h2>
<pre class="prettyprint notranslate tryit">
class studmarks {
   let name: String
   var stud1: student?

   init (name: String) {
      println("Initializing: \(name)")
      self.name = name
   }

   deinit {
      println("Deallocating: \(self.name)")
   }
}

class student {
   let name: String
   var strname: studmarks?

   init (name: String) {
      println("Initializing: \(name)")
      self.name = name
   }
    
   deinit {
      println("Deallocating: \(self.name)")
   }
}

var shiba: studmarks?
var mari: student?

shiba = studmarks(name: "Swift")
mari = student(name: "ARC")

shiba!.stud1 = mari
mari!.strname = shiba
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Initializing: Swift
Initializing: ARC
</pre>
<h2>ARC Weak and Unowned References</h2>
<p>Class type properties has two ways to resolve strong reference cycles &minus;</p>
<ul class="list">
<li><p>Weak References</p></li>
<li><p>Unowned References</p></li>
</ul>
<p>These references are used to enable one instance to refer other instances in a reference cycle. Then the instances may refer to each and every instances instead of caring about strong reference cycle. When the user knows that some instance may return 'nil' values we may point that using weak reference. When the instance going to return something rather than nil then declare it with unowned reference.</p>
<h2>Weak Reference Program</h2>
<pre class="prettyprint notranslate tryit">
class module {
   let name: String
   init(name: String) { self.name = name }
   var sub: submodule?
   deinit { println("\(name) Is The Main Module") }
}

class submodule {
   let number: Int

   init(number: Int) { self.number = number }

   weak var topic: module?

   deinit { println("Sub Module with its topic number is \(number)") }
}

var toc: module?
var list: submodule?
toc = module(name: "ARC")
list = submodule(number: 4)
toc!.sub = list
list!.topic = toc

toc = nil
list = nil
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
ARC Is The Main Module
Sub Module with its topic number is 4
</pre>
<h2>Unowned Reference Program</h2>
<pre class="prettyprint notranslate tryit">
class student {
   let name: String
   var section: marks?

   init(name: String) {
      self.name = name
   }

   deinit { println("\(name)") }
}
class marks {
   let marks: Int
   unowned let stname: student
 
   init(marks: Int, stname: student) {
      self.marks = marks
      self.stname = stname
   }

   deinit { println("Marks Obtained by the student is \(marks)") }
}

var module: student?
module = student(name: "ARC")
module!.section = marks(marks: 98, stname: module!)
module = nil
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
ARC
Marks Obtained by the student is 98
</pre>
<h2>Strong Reference Cycles for Closures</h2>
<p>When we assign a closure to the class instance property and to the body of the closure to capture particular instance strong reference cycle can occur. Strong reference to the closure is defined by 'self.someProperty' or 'self.someMethod()'. Strong reference cycles are used as reference types for the closures.</p>
<pre class="prettyprint notranslate">
class HTMLElement {
   let samplename: String
   let text: String?

   lazy var asHTML: () -> String = {
      if let text = self.text {
         return "&lt;\(self.samplename)&gt;\(text)&lt;/\(self.samplename)&gt;"
      }else {
         return "&lt;\(self.samplename) /&gt;"
      }
   }

   init(samplename: String, text: String? = nil) {
      self.samplename = samplename
      self.text = text
   }

   deinit {
      println("\(samplename) is being deinitialized")
   }
}

var paragraph: HTMLElement? = HTMLElement(samplename: "p", text: "Welcome to Closure SRC")
println(paragraph!.asHTML())
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
&lt;p&gt;Welcome to Closure SRC&lt;/p&gt;
</pre>
<h2>Weak and Unowned References</h2>
<p>When the closure and the instance refer to each other the user may define the capture in a closure as an unowned reference. Then it would not allow the user to deallocate the instance at the same time. When the instance sometime return a 'nil' value define the closure with the weak instance.</p>
<pre class="prettyprint notranslate">
class HTMLElement {
   let module: String
   let text: String?

   lazy var asHTML: () -> String = {
      [unowned self] in
      if let text = self.text {
         return "&lt;\(self.module)&gt;\(text)&lt;/\(self.module)&gt;"
      }else {
         return "&lt;\(self.module) /&gt;"
      }
   }

   init(module: String, text: String? = nil) {
      self.module = module
      self.text = text
   }

   deinit {
      println("\(module) the deinit()")
   }
}

var paragraph: HTMLElement? = HTMLElement(module: "Inside", text: "ARC Weak References")
println(paragraph!.asHTML())
paragraph = nil
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
&lt;Inside&gt;ARC Weak References&lt;/Inside&gt;
Inside the deinit()
</pre>
<h1>Swift - Optional Chaining</h1>
<p>The process of querying, calling properties, subscripts and methods on an optional that may be 'nil' is defined as optional chaining. Optional chaining return two values &minus;</p>
<ul class="list">
<li><p>if the optional contains a 'value' then calling its related property, methods and subscripts returns values.</p></li>
<li><p>if the optional contains a 'nil' value all its its related property, methods and subscripts returns nil.</p></li>
</ul>
<p>Since multiple queries to methods, properties and subscripts are grouped together failure to one chain will affect the entire chain and results in 'nil' value.</p>
<h2>Optional Chaining as an Alternative to Forced Unwrapping</h2>
<p>Optional chaining is specified after the optional value with '?' to call a property, method or subscript when the optional value returns some values.</p>
<table class="table table-bordered">
<tr>
<td>Optional Chaining '?'</td>
<td>Access to methods,properties and subscriptsOptional Chaining '!' to force Unwrapping</td>
</tr>
<tr>
<td>? is placed after the optional value to call property, method or subscript</td>
<td>! is placed after the optional value to call property, method or subscript to force unwrapping of value</td>
</tr>
<tr>
<td>Fails gracefully when the optional is 'nil'</td>
<td>Forced unwrapping triggers a run time error when the optional is 'nil'</td>
</tr>
</table>
<h3>Program for Optional Chaining with '!'</h3>
<pre class="prettyprint notranslate tryit">
class ElectionPoll {
   var candidate: Pollbooth?
}
class Pollbooth {   
   var name = "MP"
}

let cand = ElectionPoll()

let candname = cand.candidate!.name
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
fatal error: unexpectedly found nil while unwrapping an Optional value
0  swift                    0x0000000103410b68 llvm::sys::PrintStackTrace(__sFILE*) + 40
1  swift                    0x0000000103411054 SignalHandler(int) + 452
2  libsystem_platform.dylib 0x00007fff9176af1a _sigtramp + 26
3  libsystem_platform.dylib 0x000000000000000b _sigtramp + 1854492939
4  libsystem_platform.dylib 0x00000001074a0214 _sigtramp + 1976783636
5  swift                    0x0000000102a85c39 llvm::JIT::runFunction(llvm::Function*, std::__1::vector&lt;llvm::GenericValue, std::__1::allocator&lt;llvm::GenericValue&gt; &gt; const&amp;) + 329
6  swift                    0x0000000102d320b3 llvm::ExecutionEngine::runFunctionAsMain(llvm::Function*, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt; const&, char const* const*) + 1523
7  swift                    0x000000010296e6ba swift::RunImmediately(swift::CompilerInstance&, std::__1::vector&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt;, std::__1::allocator&lt;std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; &gt; &gt; const&, swift::IRGenOptions&, swift::SILOptions const&) + 1066
8  swift                    0x000000010275764b frontend_main(llvm::ArrayRef&lt;char const*&gt;, char const*, void*) + 5275
9  swift                    0x0000000102754a6d main + 1677
10 libdyld.dylib            0x00007fff8bb9e5c9 start + 1
11 libdyld.dylib            0x000000000000000c start + 1950751300
Stack dump:
0.	Program arguments: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/swift -frontend -interpret - -target x86_64-apple-darwin14.0.0 -target-cpu core2 -sdk /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk -module-name main 
/bin/sh: line 47: 15672 Done                    cat  &lt;&lt;'SWIFT'
import Foundation
</pre>
<p>The above program declares 'election poll' as class name and contains 'candidate' as membership function. The subclass is declared as 'poll booth' and 'name' as its membership function which is initialized as 'MP'. The call to the super class is initialized by creating an instance 'cand' with optional '!'. Since the values are not declared in its base class, 'nil' value is stored thereby returning a fatal error by the force unwrapping procedure.</p>
<h3>Program for Optional Chaining with '?'</h3>
<pre class="prettyprint notranslate tryit">
class ElectionPoll {
   var candidate: Pollbooth?
}
class Pollbooth {
   var name = "MP"
}

let cand = ElectionPoll()
   
if let candname = cand.candidate?.name {
   println("Candidate name is \(candname)")
}else {
   println("Candidate name cannot be retreived")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Candidate name cannot be retreived
</pre>
<p>The program above declares 'election poll' as class name and contains 'candidate' as membership function. The subclass is declared as 'poll booth' and 'name' as its membership function which is initialized as 'MP'. The call to the super class is initialized by creating an instance 'cand' with optional '?'. Since the values are not declared in its base class 'nil' value is stored and printed in the console by the else handler block.</p>
<h2>Defining Model Classes for Optional Chaining &amp; Accessing Properties</h2>
<p>Swift language also provides the concept of optional chaining, to declare more than one subclasses as model classes. This concept will be very useful to define complex models and to access the properties, methods and subscripts sub properties.</p>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }

   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }
   func circleprint() {
      println("The number of rooms is \(cprint)")
   }
   var rectarea: circumference?
}

class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var street: String?

   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let rectname = rectangle()

if let rectarea = rectname.print?.cprint {
   println("Area of rectangle is \(rectarea)")
}  else {
   println("Rectangle Area is not specified")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Rectangle Area is not specified
</pre>
<h2>Calling Methods Through Optional Chaining</h2>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}
class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }
   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }

   func circleprint() {
      println("Area of Circle is: \(cprint)")
   }
   var rectarea: circumference?
}

class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?
   
   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let circname = rectangle()

if circname.print?.circleprint() != nil {
   println("Area of circle is specified)")
} else {
   println("Area of circle is not specified")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Area of circle is not specified
</pre>
<p>The function circleprint() declared inside the circle() sub class is called by creating an instance named 'circname'. The function will return a value if it contains some value otherwise it will return some user defined print message by checking the statement 'if circname.print?.circleprint() != nil'.</p>
<h2>Accessing Subscripts through Optional Chaining</h2>
<p>Optional chaining is used to set and retrieve a subscript value to validate whether call to that subscript returns a value. '?' is placed before the subscript braces to access the optional value on the particular subscript.</p>
<h3>Program 1</h3>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }

   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }

   func circleprint() {
      println("The number of rooms is \(cprint)")
   }
   var rectarea: circumference?
}


class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?
   
   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}


let circname = rectangle()

if let radiusName = circname.print?[0].radiusname {
   println("The first room name is \(radiusName).")
} else {
   println("Radius is not specified.")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Radius is not specified.
</pre>
<p>In the above program the instance values for the membership function 'radiusName' is not specified. Hence program call to the function will return only else part whereas to return the values we have to define the values for the particular membership function.</p>
<h3>Program 2</h3>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }

   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }
   func circleprint() {
      println("The number of rooms is \(cprint)")
   }
   var rectarea: circumference?
}

class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?

   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let circname = rectangle()
circname.print?[0] = radius(radiusname: "Diameter")

let printing = circle()
printing.area.append(radius(radiusname: "Units"))
printing.area.append(radius(radiusname: "Meter"))
circname.print = printing

if let radiusName = circname.print?[0].radiusname {
   println("Radius is measured in \(radiusName).")
}else {
   println("Radius is not specified.")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Radius is measured in Units.
</pre>
<p>In the above program, the instance values for the membership function 'radiusName' is specified. Hence program call to the function will now return values.</p>
<h2>Accessing Subscripts of Optional Type</h2>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }

   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }

   func circleprint() {
      println("The number of rooms is \(cprint)")
   }
   var rectarea: circumference?
}


class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?

   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let circname = rectangle()
circname.print?[0] = radius(radiusname: "Diameter")

let printing = circle()
printing.area.append(radius(radiusname: "Units"))
printing.area.append(radius(radiusname: "Meter"))
circname.print = printing

var area = ["Radius": [35, 45, 78, 101], "Circle": [90, 45, 56]]
area["Radius"]?[1] = 78
area["Circle"]?[1]--

println(area["Radius"]?[0])
println(area["Radius"]?[1])
println(area["Radius"]?[2])
println(area["Radius"]?[3])


println(area["Circle"]?[0])
println(area["Circle"]?[1])
println(area["Circle"]?[2])
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Optional(35)
Optional(78)
Optional(78)
Optional(101)
Optional(90)
Optional(44)
Optional(56)
</pre>
<p>The optional values for subscripts can be accessed by referring their subscript values. It can be accessed as subscript[0], subscript[1] etc. The default subscript values for 'radius' are first assigned as [35, 45, 78, 101] and for 'Circle' [90, 45, 56]]. Then the subscript values are changed as Radius[0] to 78 and Circle[1] to 45.</p>
<h2>Linking Multiple Levels of Chaining</h2>
<p>Multiple sub classes can also be linked with its super class methods, properties and subscripts by optional chaining.</p>
<p>Multiple chaining of optional can be linked &minus;</p>
<p>If retrieving type is not optional, optional chaining will return an optional value. For example if String through optional chaining it will return String? Value</p>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }
   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }
   func circleprint() {
      println("The number of rooms is \(cprint)")
   }
   var rectarea: circumference?
}


class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?
   
   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let circname = rectangle()

if let radiusName = circname.print?[0].radiusname {
   println("The first room name is \(radiusName).")
}else {
   println("Radius is not specified.")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Radius is not specified.
</pre>
<p>In the above program, the instance values for the membership function 'radiusName' is not specified. Hence, the program call to the function will return only else part whereas to return the values we have to define the values for the particular membership function.</p>
<p>If the retrieving type is already optional, then optional chaining will also return an optional value. For example if String? Is accessed through optional chaining it will return String? Value.</p>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }
   
   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }
   func circleprint() {
      println("The number of rooms is \(cprint)")
   }
   var rectarea: circumference?
}

class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?
   
   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let circname = rectangle()
circname.print?[0] = radius(radiusname: "Diameter")

let printing = circle()
printing.area.append(radius(radiusname: "Units"))
printing.area.append(radius(radiusname: "Meter"))
circname.print = printing

if let radiusName = circname.print?[0].radiusname {
   println("Radius is measured in \(radiusName).")
}else {
   println("Radius is not specified.")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Radius is measured in Units.
</pre>
<p>In the above program, the instance values for the membership function 'radiusName' is specified. Hence, the program call to the function will now return values.</p>
<h2>Chaining on Methods with Optional Return Values</h2>
<p>Optional chaining is used to access subclasses defined methods too.</p>
<pre class="prettyprint notranslate tryit">
class rectangle {
   var print: circle?
}

class circle {
   var area = [radius]()
   var cprint: Int {
      return area.count
   }

   subscript(i: Int) -> radius {
      get {
         return area[i]
      }set {
         area[i] = newValue
      }
   }
   func circleprint() {
      println("Area of Circle is: \(cprint)")
   }
   var rectarea: circumference?
}

class radius {
   let radiusname: String
   init(radiusname: String) { self.radiusname = radiusname }
}

class circumference {
   var circumName: String?
   var circumNumber: String?
   var circumarea: String?
   
   func buildingIdentifier() -> String? {
      if circumName != nil {
         return circumName
      }else if circumNumber != nil {
         return circumNumber
      }else {
         return nil
      }
   }
}

let circname = rectangle()
if circname.print?.circleprint() != nil {
   println("Area of circle is specified)")
}else {
   println("Area of circle is not specified")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Area of circle is not specified
</pre>
<h1>Swift - Type Casting</h1>
<p>To validate the type of an instance 'Type Casting' comes into play in Swift language. It is used to check whether the instance type belongs to a particular super class or subclass or it is defined in its own hierarchy.</p>
<p>Swift type casting provides two operators 'is' to check the type of a value and 'as' and to cast the type value to a different type. Type casting also checks whether the instance type follows particular protocol conformance standard.</p>
<h2>Defining a Class Hierarchy</h2>
<p>Type casting is used to check the type of instances to find out whether it belongs to particular class type. Also, it checks hierarchy of classes and its subclasses to check and cast those instances to make it as a same hierarchy.</p>
<pre class="prettyprint notranslate tryit">
class Subjects {
   var physics: String
   init(physics: String) {
      self.physics = physics
   }
}

class Chemistry: Subjects {
   var equations: String
   init(physics: String, equations: String) {
      self.equations = equations
      super.init(physics: physics)
   }
}

class Maths: Subjects {
   var formulae: String
   init(physics: String, formulae: String) {
      self.formulae = formulae
      super.init(physics: physics)
   }
}

let sa = [
   Chemistry(physics: "solid physics", equations: "Hertz"),
   Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz")]


let samplechem = Chemistry(physics: "solid physics", equations: "Hertz")
println("Instance physics is: \(samplechem.physics)")
println("Instance equation is: \(samplechem.equations)")


let samplemaths = Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz")
println("Instance physics is: \(samplemaths.physics)")
println("Instance formulae is: \(samplemaths.formulae)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Instance physics is: solid physics
Instance equation is: Hertz
Instance physics is: Fluid Dynamics
Instance formulae is: Giga Hertz
</pre>
<h2>Type Checking</h2>
<p>Type checking is done with the 'is' operator. The 'is' type check operator checks whether the instance belongs to particular subclass type and returns 'true' if it belongs to that instance else it will return 'false'.</p>
<pre class="prettyprint notranslate tryit">
class Subjects {
   var physics: String
   init(physics: String) {
      self.physics = physics
   }
}

class Chemistry: Subjects {
   var equations: String
   init(physics: String, equations: String) {
      self.equations = equations
      super.init(physics: physics)
   }
}

class Maths: Subjects {
   var formulae: String
   init(physics: String, formulae: String) {
      self.formulae = formulae
      super.init(physics: physics)
   }
}

let sa = [
   Chemistry(physics: "solid physics", equations: "Hertz"),
   Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz"),
   Chemistry(physics: "Thermo physics", equations: "Decibels"),
   Maths(physics: "Astro Physics", formulae: "MegaHertz"),
   Maths(physics: "Differential Equations", formulae: "Cosine Series")]


let samplechem = Chemistry(physics: "solid physics", equations: "Hertz")
println("Instance physics is: \(samplechem.physics)")
println("Instance equation is: \(samplechem.equations)")


let samplemaths = Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz")
println("Instance physics is: \(samplemaths.physics)")
println("Instance formulae is: \(samplemaths.formulae)")

var chemCount = 0
var mathsCount = 0
for item in sa {
   if item is Chemistry {
      ++chemCount
   }else if item is Maths {
      ++mathsCount
   }
}

println("Subjects in chemistry contains \(chemCount) topics and maths contains \(mathsCount) topics")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Instance physics is: solid physics
Instance equation is: Hertz
Instance physics is: Fluid Dynamics
Instance formulae is: Giga Hertz
Subjects in chemistry contains 2 topics and maths contains 3 topics
</pre>
<h2>Downcasting</h2>
<p>Downcasting the subclass type can be done with two operators (as? and as!).'as?' returns an optional value when the value returns nil. It is used to check successful downcast.</p>
<p>'as!' returns force unwrapping as discussed in the optional chaining when the downcasting returns nil value. It is used to trigger runtime error in case of downcast failure</p>
<pre class="prettyprint notranslate tryit">
class Subjects {
   var physics: String
   init(physics: String) {
      self.physics = physics
   }
}

class Chemistry: Subjects {
   var equations: String
   init(physics: String, equations: String) {
      self.equations = equations
      super.init(physics: physics)
   }
}

class Maths: Subjects {
   var formulae: String
   init(physics: String, formulae: String) {
      self.formulae = formulae
      super.init(physics: physics)
   }
}

let sa = [
   Chemistry(physics: "solid physics", equations: "Hertz"),
   Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz"),
   Chemistry(physics: "Thermo physics", equations: "Decibels"),
   Maths(physics: "Astro Physics", formulae: "MegaHertz"),
   Maths(physics: "Differential Equations", formulae: "Cosine Series")]


let samplechem = Chemistry(physics: "solid physics", equations: "Hertz")
println("Instance physics is: \(samplechem.physics)")
println("Instance equation is: \(samplechem.equations)")


let samplemaths = Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz")
println("Instance physics is: \(samplemaths.physics)")
println("Instance formulae is: \(samplemaths.formulae)")

var chemCount = 0
var mathsCount = 0

for item in sa {
   if let print = item as? Chemistry {
      println("Chemistry topics are: '\(print.physics)', \(print.equations)")
   }else if let example = item as? Maths {
      println("Maths topics are: '\(example.physics)',  \(example.formulae)")
   }
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Instance physics is: solid physics
Instance equation is: Hertz
Instance physics is: Fluid Dynamics
Instance formulae is: Giga Hertz
Chemistry topics are: 'solid physics', Hertz
Maths topics are: 'Fluid Dynamics', Giga Hertz
Chemistry topics are: 'Thermo physics', Decibels
Maths topics are: 'Astro Physics', MegaHertz
Maths topics are: 'Differential Equations', Cosine Series
</pre>
<h2>Typecasting: Any and Any Object</h2>
<p>The keyword 'Any' is used to represent an instance which belongs to any type including function types.</p>
<pre class="prettyprint notranslate tryit">
class Subjects {
   var physics: String
   init(physics: String) {
      self.physics = physics
   }
}

class Chemistry: Subjects {
   var equations: String
   init(physics: String, equations: String) {
      self.equations = equations
      super.init(physics: physics)
   }
}

class Maths: Subjects {
   var formulae: String
   init(physics: String, formulae: String) {
      self.formulae = formulae
      super.init(physics: physics)
   }
}

let sa = [
   Chemistry(physics: "solid physics", equations: "Hertz"),
   Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz"),
   Chemistry(physics: "Thermo physics", equations: "Decibels"),
   Maths(physics: "Astro Physics", formulae: "MegaHertz"),
   Maths(physics: "Differential Equations", formulae: "Cosine Series")]


let samplechem = Chemistry(physics: "solid physics", equations: "Hertz")
println("Instance physics is: \(samplechem.physics)")
println("Instance equation is: \(samplechem.equations)")


let samplemaths = Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz")
println("Instance physics is: \(samplemaths.physics)")
println("Instance formulae is: \(samplemaths.formulae)")

var chemCount = 0
var mathsCount = 0

for item in sa {
   if let print = item as? Chemistry {
      println("Chemistry topics are: '\(print.physics)', \(print.equations)")
   }else if let example = item as? Maths {
      println("Maths topics are: '\(example.physics)',  \(example.formulae)")
   }
}

var exampleany = [Any]()

exampleany.append(12)
exampleany.append(3.14159)
exampleany.append("Example for Any")
exampleany.append(Chemistry(physics: "solid physics", equations: "Hertz"))

for print in exampleany {
   switch print {
   case let someInt as Int:
      println("Integer value is \(someInt)")
   case let someDouble as Double where someDouble &gt; 0:
      println("Pi value is \(someDouble)")
   case let someString as String:
      println("\(someString)")
   case let phy as Chemistry:
      println("Topics '\(phy.physics)', \(phy.equations)")
   default:
      println("None")
   }
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Instance physics is: solid physics
Instance equation is: Hertz
Instance physics is: Fluid Dynamics
Instance formulae is: Giga Hertz
Chemistry topics are: 'solid physics', Hertz
Maths topics are: 'Fluid Dynamics',  Giga Hertz
Chemistry topics are: 'Thermo physics', Decibels
Maths topics are: 'Astro Physics',  MegaHertz
Maths topics are: 'Differential Equations',  Cosine Series
Integer value is 12
Pi value is 3.14159
Example for Any
Topics 'solid physics', Hertz
</pre>
<h2>AnyObject</h2>
<p>To represent the instance of any class type, 'AnyObject' keyword is used.</p>
<pre class="prettyprint notranslate tryit">
class Subjects {
   var physics: String
   init(physics: String) {
      self.physics = physics
   }
}

class Chemistry: Subjects {
   var equations: String
   init(physics: String, equations: String) {
      self.equations = equations
      super.init(physics: physics)
   }
}

class Maths: Subjects {
   var formulae: String
   init(physics: String, formulae: String) {
      self.formulae = formulae
      super.init(physics: physics)
   }
}

let saprint: [AnyObject] = [Chemistry(physics: "solid physics", equations: "Hertz"),
   Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz"),
   Chemistry(physics: "Thermo physics", equations: "Decibels"),
   Maths(physics: "Astro Physics", formulae: "MegaHertz"),
   Maths(physics: "Differential Equations", formulae: "Cosine Series")]


let samplechem = Chemistry(physics: "solid physics", equations: "Hertz")
println("Instance physics is: \(samplechem.physics)")
println("Instance equation is: \(samplechem.equations)")


let samplemaths = Maths(physics: "Fluid Dynamics", formulae: "Giga Hertz")
println("Instance physics is: \(samplemaths.physics)")
println("Instance formulae is: \(samplemaths.formulae)")

var chemCount = 0
var mathsCount = 0

for item in saprint {
   if let print = item as? Chemistry {
      println("Chemistry topics are: '\(print.physics)', \(print.equations)")
   }else if let example = item as? Maths {
      println("Maths topics are: '\(example.physics)',  \(example.formulae)")
   }
}

var exampleany = [Any]()
exampleany.append(12)
exampleany.append(3.14159)
exampleany.append("Example for Any")
exampleany.append(Chemistry(physics: "solid physics", equations: "Hertz"))

for print in exampleany {
   switch print {
   case let someInt as Int:
      println("Integer value is \(someInt)")
   case let someDouble as Double where someDouble &gt; 0:
      println("Pi value is \(someDouble)")
   case let someString as String:
      println("\(someString)")
   case let phy as Chemistry:
      println("Topics '\(phy.physics)', \(phy.equations)")
   default:
      println("None")
   }
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Instance physics is: solid physics
Instance equation is: Hertz
Instance physics is: Fluid Dynamics
Instance formulae is: Giga Hertz
Chemistry topics are: 'solid physics', Hertz
Maths topics are: 'Fluid Dynamics',  Giga Hertz
Chemistry topics are: 'Thermo physics', Decibels
Maths topics are: 'Astro Physics',  MegaHertz
Maths topics are: 'Differential Equations',  Cosine Series
Integer value is 12
Pi value is 3.14159
Example for Any
Topics 'solid physics', Hertz
</pre>
<h1>Swift - Extensions</h1>
<p>Functionality of an existing class, structure or enumeration type can be added with the help of extensions. Type functionality can be added with extensions but overriding the functionality is not possible with extensions.</p>
<p><b>Swift Extension Functionalities</b> &minus;</p>
<ul class="list">
<li>Adding computed properties and computed type properties.</li>
<li>Defining instance and type methods.</li>
<li>Providing new initializers.</li>
<li>Defining subscripts.</li>
<li>Defining and using new nested types.</li>
<li>Making an existing type conform to a protocol.</li>
</ul>
<p>Extensions are declared with the keyword 'extension'.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
extension SomeType {
   // new functionality can be added here
}
</pre>
<p>Existing type can also be added with extensions to make it as a protocol standard and its syntax is similar to that of classes or structures.</p>
<pre class="prettyprint notranslate">
extension SomeType: SomeProtocol, AnotherProtocol {
   // protocol requirements is described here
}
</pre>
<h2>Computed Properties</h2>
<p>Computed 'instance' and 'type' properties can also be extended with the help of extensions.</p>
<pre class="prettyprint notranslate tryit">
extension Int {
   var add: Int {return self + 100 }
   var sub: Int { return self - 10 }
   var mul: Int { return self * 10 }
   var div: Int { return self / 5 }
}

let addition = 3.add
println("Addition is \(addition)")

let subtraction = 120.sub
println("Subtraction is \(subtraction)")

let multiplication = 39.mul
println("Multiplication is \(multiplication)")

let division = 55.div
println("Division is \(division)")

let mix = 30.add + 34.sub
println("Mixed Type is \(mix)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Addition is 103
Subtraction is 110
Multiplication is 390
Division is 11
Mixed Type is 154
</pre>
<h2>Initializers</h2>
<p>Swift provides the flexibility to add new initializers to an existing type by extensions. The user can add their own custom types to extend the types already defined and additional initialization options are also possible. Extensions supports only init(). deinit() is not supported by the extensions.</p>
<pre class="prettyprint notranslate tryit">
struct sum {
   var num1 = 100, num2 = 200
}

struct diff {
   var no1 = 200, no2 = 100
}

struct mult {
   var a = sum()
   var b = diff()
}

let calc = mult()
println ("Inside mult block \(calc.a.num1, calc.a.num2)")
println("Inside mult block \(calc.b.no1, calc.b.no2)")

let memcalc = mult(a: sum(num1: 300, num2: 500),b: diff(no1: 300, no2: 100))

println("Inside mult block \(memcalc.a.num1, memcalc.a.num2)")
println("Inside mult block \(memcalc.b.no1, memcalc.b.no2)")

extension mult {
   init(x: sum, y: diff) {
      let X = x.num1 + x.num2
      let Y = y.no1 + y.no2
   }
}


let a = sum(num1: 100, num2: 200)
println("Inside Sum Block:\( a.num1, a.num2)")


let b = diff(no1: 200, no2: 100)
println("Inside Diff Block: \(b.no1, b.no2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Inside mult block (100, 200)
Inside mult block (200, 100)
Inside mult block (300, 500)
Inside mult block (300, 100)
Inside Sum Block:(100, 200)
Inside Diff Block: (200, 100)
</pre>
<h2>Methods</h2>
<p>New instance methods and type methods can be added further to the subclass with the help of extensions.</p>
<pre class="prettyprint notranslate tryit">
extension Int {
   func topics(summation: () -> ()) {
      for _ in 0..&lt;self {
         summation() 
      }
   }
}

4.topics({
   println("Inside Extensions Block")       
})    

3.topics({
   println("Inside Type Casting Block")       
})
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Inside Extensions Block
Inside Extensions Block
Inside Extensions Block
Inside Extensions Block
Inside Type Casting Block
Inside Type Casting Block
Inside Type Casting Block
</pre>
<p>topics() function takes argument of type '(summation: () &rarr; ())' to indicate the function does not take any arguments and it won't return any values. To call that function multiple number of times, for block is initialized and call to the method with topic() is initialized.</p>
<h2>Mutating Instance Methods</h2>
<p>Instance methods can also be mutated when declared as extensions.</p>
<p>Structure and enumeration methods that modify self or its properties must mark the instance method as mutating, just like mutating methods from an original implementation.</p>
<pre class="prettyprint notranslate tryit">
extension Double {
   mutating func square() {
      let pi = 3.1415
      self = pi * self * self
   }
}

var Trial1 = 3.3
Trial1.square()
println("Area of circle is: \(Trial1)")


var Trial2 = 5.8
Trial2.square()
println("Area of circle is: \(Trial2)")


var Trial3 = 120.3
Trial3.square()
println("Area of circle is: \(Trial3)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Area of circle is: 34.210935
Area of circle is: 105.68006
Area of circle is: 45464.070735
</pre>
<h2>Subscripts</h2>
<p>Adding new subscripts to already declared instances can also be possible with extensions.</p>
<pre class="prettyprint notranslate tryit">
extension Int {
   subscript(var multtable: Int) -> Int {
      var no1 = 1
      while multtable &gt; 0 {
         no1 *= 10
         --multtable
      }
      return (self / no1) % 10
   }
}

println(12[0])
println(7869[1])
println(786543[2])
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
2
6
5
</pre>
<h2>Nested Types</h2>
<p>Nested types for class, structure and enumeration instances can also be extended with the help of extensions.</p>
<pre class="prettyprint notranslate tryit">
extension Int {
   enum calc {
      case add
      case sub
      case mult
      case div
      case anything
   }

   var print: calc {
      switch self {
         case 0:
            return .add
         case 1:
            return .sub
         case 2:
            return .mult
         case 3:
            return .div
         default:
            return .anything
       }
   }
}

func result(numb: [Int]) {
   for i in numb {
      switch i.print {
         case .add:
            println(" 10 ")
          case .sub:
            println(" 20 ")
         case .mult:
         println(" 30 ")
         case .div:
         println(" 40 ")
         default:
         println(" 50 ")

      }
   }
}

result([0, 1, 2, 3, 4, 7])
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
10
20
30
40
50
50
</pre>
<h1>Swift - Protocols</h1>
<p>Protocols provide a blueprint for Methods, properties and other requirements functionality. It is just described as a methods or properties skeleton instead of implementation. Methods and properties implementation can further be done by defining classes, functions and enumerations. Conformance of a protocol is defined as the methods or properties satisfying the requirements of the protocol.</p>
<h3>Syntax</h3>
<p>Protocols also follow the similar syntax as that of classes, structures, and enumerations &minus;</p>
<pre class="prettyprint notranslate">
protocol SomeProtocol {
   // protocol definition 
}
</pre>
<p>Protocols are declared after the class, structure or enumeration type names. Single and Multiple protocol declarations are also possible. If multiple protocols are defined they have to be separated by commas.</p>
<pre class="prettyprint notranslate">
struct SomeStructure: Protocol1, Protocol2 {
   // structure definition 
}
</pre>
<p>When a protocol has to be defined for super class, the protocol name should follow the super class name with a comma.</p>
<pre class="prettyprint notranslate">
class SomeClass: SomeSuperclass, Protocol1, Protocol2 {
   // class definition 
}
</pre>
<h2>Property and Method Requirements</h2>
<p>Protocol is used to specify particular class type property or instance property. It just specifies the type or instance property alone rather than specifying whether it is a stored or computed property. Also, it is used to specify whether the property is 'gettable' or 'settable'.</p>
<p>Property requirements are declared by 'var' keyword as property variables. {get set} is used to declare gettable and settable properties after their type declaration. Gettable is mentioned by {get} property after their type declaration.</p>
<pre class="prettyprint notranslate tryit">
protocol classa {
   
   var marks: Int { get set }
   var result: Bool { get }
   
   func attendance() -> String
   func markssecured() -> String

}

protocol classb: classa {

   var present: Bool { get set }
   var subject: String { get set }
   var stname: String { get set }
   
}

class classc: classb {
   var marks = 96
   let result = true
   var present = false
   var subject = "Swift Protocols"
   var stname = "Protocols"

   func attendance() -> String {
      return "The \(stname) has secured 99% attendance"
   }

   func markssecured() -> String {
      return "\(stname) has scored \(marks)"
   }
}

let studdet = classc()
studdet.stname = "Swift"
studdet.marks = 98
studdet.markssecured()

println(studdet.marks)
println(studdet.result)
println(studdet.present)
println(studdet.subject)
println(studdet.stname)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
98
true
false
Swift Protocols
Swift
</pre>
<h2>Mutating Method Requirements</h2>
<pre class="prettyprint notranslate tryit">
protocol daysofaweek {
   mutating func print()
}

enum days: daysofaweek {
   case sun, mon, tue, wed, thurs, fri, sat
   mutating func print() {
      switch self {
      case sun:
         self = sun
         println("Sunday")
      case mon:
         self = mon
         println("Monday")
      case tue:
         self = tue
         println("Tuesday")
      case wed:
         self = wed
         println("Wednesday")
      case mon:
         self = thurs
         println("Thursday")
      case tue:
         self = fri
         println("Friday")
      case sat:
         self = sat
         println("Saturday")
      default:
         println("NO Such Day")
      }
   }
}

var res = days.wed
res.print()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Wednesday
</pre>
<h2>Initializer Requirements</h2>
<p>Swing allows the user to initialize protocols to follow type conformance similar to that of normal initializers.</p> 
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
protocol SomeProtocol {
   init(someParameter: Int)
}
</pre>
<h3>For example</h3>
<pre class="prettyprint notranslate">
protocol tcpprotocol {
   init(aprot: Int)
}
</pre>
<h2>Class Implementations of Protocol Initializer Requirements</h2>
<p>Designated or convenience initializer allows the user to initialize a protocol to conform its standard by the reserved 'required' keyword.</p> 
<pre class="prettyprint notranslate">
class SomeClass: SomeProtocol {
   required init(someParameter: Int) {
      // initializer implementation statements
   }
}

protocol tcpprotocol {
   init(aprot: Int)
}

class tcpClass: tcpprotocol {
   required init(aprot: Int) {}
}
</pre>
<p>Protocol conformance is ensured on all subclasses for explicit or inherited implementation by 'required' modifier.</p>
<p>When a subclass overrides its super class initialization requirement it is specified by the 'override' modifier keyword.</p>
<pre class="prettyprint notranslate tryit">
protocol tcpprotocol {
   init(no1: Int)
}

class mainClass {
   var no1: Int // local storage
   init(no1: Int) {
      self.no1 = no1 // initialization
   }
}

class subClass: mainClass, tcpprotocol {
   var no2: Int
   init(no1: Int, no2 : Int) {
      self.no2 = no2
      super.init(no1:no1)
   }
   // Requires only one parameter for convenient method
   required override convenience init(no1: Int)  {
      self.init(no1:no1, no2:0)
   }
}
let res = mainClass(no1: 20)
let print = subClass(no1: 30, no2: 50)

println("res is: \(res.no1)")
println("res is: \(print.no1)")
println("res is: \(print.no2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
res is: 20
res is: 30
res is: 50
</pre>
<h2>Protocols as Types</h2>
<p>Instead of implementing functionalities in a protocol they are used as types for functions, classes, methods etc.</p>
<p>Protocols can be accessed as types in &minus;</p>
<ul class="list">
<li>Function, method or initialize as a parameter or return type.</li>
<li>Constant, variable or property.</li>
<li>Arrays, dictionaries or other containers as items.</li>
</ul>
<pre class="prettyprint notranslate tryit">
protocol Generator {
   typealias members
   func next() -> members?
}

var items = [10,20,30].generate()
while let x = items.next() {
   println(x)
}

for lists in map([1,2,3], {i in i*5}) {
   println(lists)
}

println([100,200,300])
println(map([1,2,3], {i in i*10}))
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
10
20
30
5
10
15
[100, 200, 300]
[10, 20, 30]
</pre>
<h2>Adding Protocol Conformance with an Extension</h2>
<p>Existing type can be adopted and conformed to a new protocol by making use of extensions. New properties, methods and subscripts can be added to existing types with the help  of extensions.</p>
<pre class="prettyprint notranslate">
protocol AgeClasificationProtocol {
   var age: Int { get }
   func agetype() -> String
}

class Person {
   let firstname: String
   let lastname: String
   var age: Int
   init(firstname: String, lastname: String) {
      self.firstname = firstname
      self.lastname = lastname
      self.age = 10
   }
}

extension Person : AgeClasificationProtocol {
   func fullname() -> String {
      var c: String
      c = firstname + " " + lastname
      return c
   }

   func agetype() -> String {
      switch age {
      case 0...2:
         return "Baby"
      case 2...12:
         return "Child"
      case 13...19:
         return "Teenager"
      case let x where x &gt; 65:
         return "Elderly"
      default:
         return "Normal"
      }
   }
}
</pre>
<h2>Protocol Inheritance</h2>
<p>Swift allows protocols to inherit properties from its defined properties. It is similar to that of class inheritance, but with the choice of listing multiple inherited protocols separated by commas.</p>
<pre class="prettyprint notranslate tryit">
protocol classa {
   var no1: Int { get set }
   func calc(sum: Int)
}

protocol result {
   func print(target: classa)
}

class student2: result {
   func print(target: classa) {
      target.calc(1)
   }
}

class classb: result {
   func print(target: classa) {
      target.calc(5)
   }
}

class student: classa {
   var no1: Int = 10
   
   func calc(sum: Int) {
      no1 -= sum
      println("Student attempted \(sum) times to pass")
      
      if no1 &lt;= 0 {
         println("Student is absent for exam")
      }
   }
}

class Player {
   var stmark: result!
   
   init(stmark: result) {
      self.stmark = stmark
   }
   
   func print(target: classa) {
      stmark.print(target)
   }
}

var marks = Player(stmark: student2())
var marksec = student()

marks.print(marksec)
marks.print(marksec)
marks.print(marksec)
marks.stmark = classb()
marks.print(marksec)
marks.print(marksec)
marks.print(marksec)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Student attempted 1 times to pass
Student attempted 1 times to pass
Student attempted 1 times to pass
Student attempted 5 times to pass
Student attempted 5 times to pass
Student is absent for exam
Student attempted 5 times to pass
Student is absent for exam
</pre>
<h2>Class Only Protocols</h2>
<p>When protocols are defined and the user wants to define protocol with classes it should  be added by defining class first followed by protocol's inheritance list.</p>
<pre class="prettyprint notranslate tryit">
protocol tcpprotocol {
   init(no1: Int)
}

class mainClass {
   var no1: Int // local storage
   init(no1: Int) {
      self.no1 = no1 // initialization
   }
}

class subClass: mainClass, tcpprotocol {
   var no2: Int
   init(no1: Int, no2 : Int) {
      self.no2 = no2
      super.init(no1:no1)
   }
   // Requires only one parameter for convenient method
   required override convenience init(no1: Int)  {
      self.init(no1:no1, no2:0)
   }
}

let res = mainClass(no1: 20)
let print = subClass(no1: 30, no2: 50)

println("res is: \(res.no1)")
println("res is: \(print.no1)")
println("res is: \(print.no2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
res is: 20
res is: 30
res is: 50
</pre>
<h2>Protocol Composition</h2>
<p>Swift allows multiple protocols to be called at once with the help of protocol composition.</p>
<h3>Syntax</h3>
<pre class="prettyprint notranslate">
protocol&lt;SomeProtocol, AnotherProtocol&gt;
</pre>
<h3>Example</h3>
<pre class="prettyprint notranslate tryit">
protocol stname {
   var name: String { get }
}

protocol stage {
   var age: Int { get }
}

struct Person: stname, stage {
   var name: String
   var age: Int
}

func print(celebrator: protocol&lt;stname, stage&gt;) {
   println("\(celebrator.name) is \(celebrator.age) years old")
}

let studname = Person(name: "Priya", age: 21)
print(studname)

let stud = Person(name: "Rehan", age: 29)
print(stud)

let student = Person(name: "Roshan", age: 19)
print(student)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Priya is 21 years old
Rehan is 29 years old
Roshan is 19 years old
</pre>
<h2>Checking for Protocol Conformance</h2>
<p>Protocol conformance is tested by 'is' and 'as' operators similar to that of type casting.</p>
<ul class="list">
<li><p>The is operator returns true if an instance conforms to protocol standard and returns false if it fails.</p></li>
<li><p>The <b>as?</b> version of the downcast operator returns an optional value of the protocol's type, and this value is nil if the instance does not conform to that protocol.</p></li>
<li><p>The as version of the downcast operator forces the downcast to the protocol type and triggers a runtime error if the downcast does not succeed.</p></li>
</ul>
<pre class="prettyprint notranslate tryit">
import Foundation

@objc protocol rectangle {
   var area: Double { get }
}

@objc class Circle: rectangle {
   let pi = 3.1415927
   var radius: Double
   var area: Double { return pi * radius * radius }
   init(radius: Double) { self.radius = radius }
}

@objc class result: rectangle {
   var area: Double
   init(area: Double) { self.area = area }
}


class sides {
   var rectsides: Int
   init(rectsides: Int) { self.rectsides = rectsides }
}

let objects: [AnyObject] = [Circle(radius: 2.0),result(area: 198),sides(rectsides: 4)]

for object in objects {
   if let objectWithArea = object as? rectangle {
      println("Area is \(objectWithArea.area)")
   } else {
      println("Rectangle area is not defined")
   }
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Area is 12.5663708
Area is 198.0
Rectangle area is not defined
</pre>
<h1>Swift - Generics</h1>
<p>Swift language provides 'Generic' features to write flexible and reusable functions and types. Generics are used to avoid duplication and to provide abstraction. Swift standard libraries are built with generics code. Swifts 'Arrays' and 'Dictionary' types belong to generic collections. With the help of arrays and dictionaries the arrays are defined to hold 'Int' values and 'String' values or any other types.</p>
<pre class="prettyprint notranslate tryit">
func exchange(inout a: Int, inout b: Int) {
   let temp = a
   a = b
   b = temp
}

var numb1 = 100
var numb2 = 200

println("Before Swapping values are: \(numb1) and \(numb2)")
exchange(&amp;numb1, &amp;numb2)
println("After Swapping values are: \(numb1) and \(numb2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Before Swapping values are: 100 and 200
After Swapping values are: 200 and 100
</pre>
<h2>Generic Functions: Type Parameters</h2>
<p>Generic functions can be used to access any data type like 'Int' or 'String'.</p>
<pre class="prettyprint notranslate tryit">
func exchange&lt;T&gt;(inout a: T, inout b: T) {
   let temp = a
   a = b
   b = temp
}

var numb1 = 100
var numb2 = 200

println("Before Swapping Int values are: \(numb1) and \(numb2)")
exchange(&amp;numb1, &amp;numb2)
println("After Swapping Int values are: \(numb1) and \(numb2)")

var str1 = "Generics"
var str2 = "Functions"

println("Before Swapping String values are: \(str1) and \(str2)")
exchange(&amp;str1, &amp;str2)
println("After Swapping String values are: \(str1) and \(str2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Before Swapping Int values are: 100 and 200
After Swapping Int values are: 200 and 100
Before Swapping String values are: Generics and Functions
After Swapping String values are: Functions and Generics
</pre>
<p>The function exchange() is used to swap values which is described in the above program and &lt;T&gt; is used as a type parameter. For the first time, function exchange() is called to return 'Int' values and second call to the function exchange() will return 'String' values. Multiple parameter types can be included inside the angle brackets separated by commas.</p>
<p>Type parameters are named as user defined to know the purpose of the type parameter that it holds. Swift provides &lt;T&gt; as generic type parameter name. However type parameters like Arrays and Dictionaries can also be named as key, value to identify that they belong to type 'Dictionary'.</p>
<h2>Generic Types</h2>
<pre class="prettyprint notranslate tryit">
struct TOS&lt;T&gt; {
   var items = [T]()
   mutating func push(item: T) {
      items.append(item)
   }
   
   mutating func pop() -> T {
      return items.removeLast()
   }
}

var tos = TOS&lt;String&gt;()
tos.push("Swift")
println(tos.items)

tos.push("Generics")
println(tos.items)

tos.push("Type Parameters")
println(tos.items)

tos.push("Naming Type Parameters")
println(tos.items)

let deletetos = tos.pop()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[Swift]
[Swift, Generics]
[Swift, Generics, Type Parameters]
[Swift, Generics, Type Parameters, Naming Type Parameters]
</pre>
<h2>Extending a Generic Type</h2>
<p>Extending the stack property to know the top of the item is included with 'extension' keyword.</p>
<pre class="prettyprint notranslate tryit">
struct TOS&lt;T&gt; {
   var items = [T]()
   mutating func push(item: T) {
      items.append(item)
   }

   mutating func pop() -> T {
      return items.removeLast()
   }
}

var tos = TOS&lt;String&gt;()
tos.push("Swift")
println(tos.items)

tos.push("Generics")
println(tos.items)

tos.push("Type Parameters")
println(tos.items)

tos.push("Naming Type Parameters")
println(tos.items)

extension TOS {
   var first: T? {
      return items.isEmpty ? nil : items[items.count - 1]
   }
}

if let first = tos.first {
   println("The top item on the stack is \(first).")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[Swift]
[Swift, Generics]
[Swift, Generics, Type Parameters]
[Swift, Generics, Type Parameters, Naming Type Parameters]
</pre>
<p>The top item on the stack is Naming Type Parameters.</p>
<h2>Type Constraints</h2>
<p>Swift language allows 'type constraints' to specify whether the  type parameter inherits from a specific class, or to ensure protocol conformance standard.</p>
<pre class="prettyprint notranslate tryit">
func exchange&lt;T&gt;(inout a: T, inout b: T) {
   let temp = a
   a = b
   b = temp
}

var numb1 = 100
var numb2 = 200

println("Before Swapping Int values are: \(numb1) and \(numb2)")
exchange(&amp;numb1, &amp;numb2)
println("After Swapping Int values are: \(numb1) and \(numb2)")

   
var str1 = "Generics"
var str2 = "Functions"

println("Before Swapping String values are: \(str1) and \(str2)")
exchange(&amp;str1, &amp;str2)
println("After Swapping String values are: \(str1) and \(str2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Before Swapping Int values are: 100 and 200
After Swapping Int values are: 200 and 100
Before Swapping String values are: Generics and Functions
After Swapping String values are: Functions and Generics
</pre>
<h2>Associated Types</h2>
<p>Swift allows associated types to be declared inside the protocol definition by the keyword 'typealias'.</p>
<pre class="prettyprint notranslate tryit">
protocol Container {
   typealias ItemType
   mutating func append(item: ItemType)
   var count: Int { get }
   subscript(i: Int) -> ItemType { get }
}

struct TOS&lt;T&gt;: Container {
   // original Stack&lt;T&gt; implementation
   var items = [T]()
   mutating func push(item: T) {
      items.append(item)
   }
   
   mutating func pop() -> T {
      return items.removeLast()
   }

   // conformance to the Container protocol
   mutating func append(item: T) {
      self.push(item)
   }
   
   var count: Int {
      return items.count
   }

   subscript(i: Int) -> T {
      return items[i]
   }
}

var tos = TOS&lt;String&gt;()
tos.push("Swift")
println(tos.items)

tos.push("Generics")
println(tos.items)

tos.push("Type Parameters")
println(tos.items)

tos.push("Naming Type Parameters")
println(tos.items)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[Swift]
[Swift, Generics]
[Swift, Generics, Type Parameters]
[Swift, Generics, Type Parameters, Naming Type Parameters]
</pre>
<h2>Where Clauses</h2>
<p>Type constraints enable the user to define requirements on the type parameters associated with a generic function or type. For defining requirements for associated types 'where' clauses are declared as part of type parameter list. 'where' keyword is placed immediately after the list of type parameters followed by constraints of associated types, equality relationships between types and associated types.</p>
<pre class="prettyprint notranslate tryit">
protocol Container {
   typealias ItemType
   mutating func append(item: ItemType)
   var count: Int { get }
   subscript(i: Int) -> ItemType { get }
}

struct Stack&lt;T&gt;: Container {
   // original Stack&lt;T&gt; implementation
   var items = [T]()
   mutating func push(item: T) {
      items.append(item)
   }

   mutating func pop() -> T {
      return items.removeLast()
   }

   // conformance to the Container protocol
   mutating func append(item: T) {
      self.push(item)
   }
   
   var count: Int {
      return items.count
   }

   subscript(i: Int) -> T {
      return items[i]
   }
}

func allItemsMatch&lt;
   C1: Container, C2: Container
   where C1.ItemType == C2.ItemType, C1.ItemType: Equatable&gt;

   (someContainer: C1, anotherContainer: C2) -> Bool {

      // check that both containers contain the same number of items
      if someContainer.count != anotherContainer.count {
         return false
      }

      // check each pair of items to see if they are equivalent
      for i in 0..&lt;someContainer.count {
         if someContainer[i] != anotherContainer[i] {
            return false
         }
      }
      // all items match, so return true
      return true
   }

var tos = Stack&lt;String&gt;()
tos.push("Swift")
println(tos.items)

tos.push("Generics")
println(tos.items)

tos.push("Where Clause")
println(tos.items)

var eos = ["Swift", "Generics", "Where Clause"]
println(eos)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[Swift]
[Swift, Generics]
[Swift, Generics, Where Clause]
[Swift, Generics, Where Clause]
</pre>
<h1>Swift - Access Control</h1>
<p>To restrict access to code blocks, modules and abstraction is done through access control. Classes, structures and enumerations can be accessed according to their properties, methods, initializers and subscripts by access control mechanisms. Constants, variables and functions in a protocol are restricted and allowed access as global and local through access control. Access control applied to properties, types and functions can be referred as 'entities'.</p>
<p>Access control model is based on modules and source files.</p>
<p>Module is defined as a single unit of code distribution and can be imported using the keyword 'import'.  A source file is defined as a single source code file with in a module to access multiple types and functions.</p>  
<p>Three different access levels are provided by Swift language. They are Public, Internal and Private access.</p>
<table class="table table-bordered">
<tr>
<th>S.No</th>
<th>Access Levels &amp; Definition</th>
</tr>
<tr>
<td>1</td>
<td><p><b>Public</b></p> 
<p>Enables entities to be processed with in any source file from their defining module, a source file from another module that imports the defining module.</p></td>
</tr>
<tr>
<td>2</td>
<td><p><b>Internal</b></p>
<p>Enables entities to be used within any source file from their defining module, but not in any source file outside of that module.</p></td>
</tr>
<tr>
<td>3</td>
<td><p><b>Private</b></p>
<p>Restricts the use of an entity to its own defining source file. Private access plays role to hide the implementation details of a specific code functionality.</p></td>
</tr>
</table>
<h3>Syntax</h3>
<pre class="result notranslate">
public class SomePublicClass {}
internal class SomeInternalClass {}
private class SomePrivateClass {}

public var somePublicVariable = 0
internal let someInternalConstant = 0
private func somePrivateFunction() {}
</pre>
<h2>Access Control for Function types</h2>
<p>Some functions may have arguments declared inside the function without any return values. The following program declares a and b as arguments to the sum() function. Inside the function itself the values for arguments a and b are passed by invoking the function call sum() and its values are printed thereby eliminating return values. To make the function's return type as private, declare the function's overall access level with the private modifier.</p>
<pre class="prettyprint notranslate tryit">
private func sum(a: Int, b: Int) {
   let a = a + b
   let b = a - b
   println(a, b)
}

sum(20, 10)
sum(40,10)
sum(24,6)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
(30, 20)
(50, 40)
(30, 24)
</pre>
<h2>Access Control for Enumeration types</h2>
<pre class="prettyprint notranslate tryit">
public enum Student {
   case Name(String)
   case Mark(Int,Int,Int)
}

var studDetails = Student.Name("Swift")
var studMarks = Student.Mark(98,97,95)

switch studMarks {
   case .Name(let studName):
      println("Student name is: \(studName).")
   case .Mark(let Mark1, let Mark2, let Mark3):
      println("Student Marks are: \(Mark1),\(Mark2),\(Mark3).")
   default:
      println("Nothing")
}
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Student Marks are: 98,97,95
</pre>
<p>Enumeration in Swift language automatically receive the same access level for individual cases of an enumeration. Consider for example to access the students name and marks secured in three subjects enumeration name is declared as student and the members present in enum class are name which belongs to string datatype, marks are represented as mark1, mark2 and mark3 of datatype Integer. To access either the student name or marks they have scored. Now, the switch case will print student name if that case block is executed otherwise it will print the marks secured by the student. If both condition fails the default block will be executed.</p>
<h2>Access Control for SubClasses</h2>
<p>Swift allows the user to subclass any class that can be accessed in the current access context. A subclass cannot have a higher access level than its superclass. The user is restricted from writing a public subclass of an internal superclass.</p>
<pre class="prettyprint notranslate tryit">
public class cricket {
   private func print() {
      println("Welcome to Swift Super Class")
   }
}

internal class tennis: cricket  {
   override internal func print() {
      println("Welcome to Swift Sub Class")
   }
}

let cricinstance = cricket()
cricinstance.print()

let tennisinstance = tennis()
tennisinstance.print()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Welcome to Swift Super Class
Welcome to Swift Sub Class
</pre>
<h2>Access Control for Constants, variables, properties and subscripts</h2>
<p>Swift constant, variable, or property cannot be defined as public than its type. It is not valid to write a public property with a private type. Similarly, a subscript cannot be more public than its index  or return type.</p>
<p>When a constant, variable, property, or subscript makes use of a private type, the constant, variable, property, or subscript must also be marked as private &minus;</p>
<pre class="prettyprint notranslate">
private var privateInstance = SomePrivateClass()
</pre>
<h2>Getters and Setters</h2>
<p>Getters and setters for constants, variables, properties, and subscripts automatically receive the same access level as the constant, variable, property, or subscript they belong to.</p>
<pre class="prettyprint notranslate tryit">
class Samplepgm {
   private var counter: Int = 0 {
      willSet(newTotal) {
         println("Total Counter is: \(newTotal)")
      }
      didSet{
         if counter &gt; oldValue {
            println("Newly Added Counter \(counter - oldValue)")
         }
      }
   }
}

let NewCounter = Samplepgm()
NewCounter.counter = 100
NewCounter.counter = 800
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
Total Counter is: 100
Newly Added Counter 100
Total Counter is: 800
Newly Added Counter 700
</pre>
<h2>Access Control for Initializers and Default Initializers</h2>
<p>Custom initializers can be assigned an access level less than or equal to the type that they initialize. A required initializer must have the same access level as the class it belongs to. The types of an initializer's parameters cannot be more private than the initializer's own access level.</p>
<p>To declare each and every subclass of the initialize 'required' keyword needs to be defined before the init() function.</p>
<pre class="prettyprint notranslate tryit">
class classA {
   required init() {
      var a = 10
      println(a)
   }
}

class classB: classA {
   required init() {
      var b = 30
      println(b)
   }
}

let res = classA()
let print = classB()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
10
30
10
</pre>
<p>A default initializer has the same access level as the type it initializes, unless that type is defined as public. When default initialize is defined as public it is considered internal. When the user needs a public type to be initializable with a no-argument initializer  in another module,  provide explicitly a public no-argument initializer as part of the type's definition.</p>
<h2>Access Control for Protocols</h2>
<p>When we define a new protocol to inherit functionalities from an existing protocol, both has to be declared the same access levels to inherit the properties of each other. Swift access control won't allow the users to define a 'public' protocol that inherits from an 'internal' protocol.</p>
<pre class="prettyprint notranslate tryit">
public protocol tcpprotocol {
   init(no1: Int)
}

public class mainClass {
   var no1: Int // local storage
   init(no1: Int) {
      self.no1 = no1 // initialization
   }
}

class subClass: mainClass, tcpprotocol {
   var no2: Int
   init(no1: Int, no2 : Int) {
      self.no2 = no2
      super.init(no1:no1)
   }

   // Requires only one parameter for convenient method
   required override convenience init(no1: Int)  {
      self.init(no1:no1, no2:0)
   }
}

let res = mainClass(no1: 20)
let print = subClass(no1: 30, no2: 50)

println("res is: \(res.no1)")
println("res is: \(print.no1)")
println("res is: \(print.no2)")
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
res is: 20
res is: 30
res is: 50
</pre>
<h2>Access Control for Extensions</h2>
<p>Swift does not allow the users to provide an explicit access level modifier for an extension when the user uses that extension to add protocol conformance. The default access level for each protocol requirement implementation within the extension is provided with its own protocol access level.</p>
<h2>Access Control for Generics</h2>
<p>Generics allow the user to specify minimum access levels to access the type constraints on its type parameters.</p>
<pre class="prettyprint notranslate tryit">
public struct TOS&lt;T&gt; {
   var items = [T]()
   private mutating func push(item: T) {
      items.append(item)
   }

   mutating func pop() -> T {
      return items.removeLast()
   }
}

var tos = TOS&lt;String&gt;()
tos.push("Swift")
println(tos.items)

tos.push("Generics")
println(tos.items)

tos.push("Type Parameters")
println(tos.items)

tos.push("Naming Type Parameters")
println(tos.items)
let deletetos = tos.pop()
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[Swift]
[Swift, Generics]
[Swift, Generics, Type Parameters]
[Swift, Generics, Type Parameters, Naming Type Parameters]
</pre>
<h2>Access Control for Type Aliases</h2>
<p>The user can define type aliases to treat distinct access control types. Same access level or different access levels can be defined by the user. When type alias is 'private' its associated members can be declared as 'private, internal of public type'. When type alias is public the members cannot be alias as an 'internal' or 'private' name</p>
<p>Any type aliases you define are treated as distinct types for the purposes of access control. A type alias can have an access level less than or equal to the access level of the type it aliases. For example, a private type alias can alias a private, internal, or public type, but a public type alias cannot alias an internal or private type.</p>
<pre class="prettyprint notranslate tryit">
public protocol Container {
   typealias ItemType
   mutating func append(item: ItemType)
      var count: Int { get }
      subscript(i: Int) -> ItemType { get }
}

struct Stack&lt;T&gt;: Container {
   // original Stack&lt;T&gt; implementation
   var items = [T]()
   mutating func push(item: T) {
      items.append(item)
   }

   mutating func pop() -> T {
      return items.removeLast()
   }

   // conformance to the Container protocol
   mutating func append(item: T) {
      self.push(item)
   }
   
   var count: Int {
      return items.count
   }

   subscript(i: Int) -> T {
      return items[i]
   }
}

func allItemsMatch&lt;
   C1: Container, C2: Container
   where C1.ItemType == C2.ItemType, C1.ItemType: Equatable>
   (someContainer: C1, anotherContainer: C2) -> Bool {
   // check that both containers contain the same number of items
   if someContainer.count != anotherContainer.count {
      return false
   }

   // check each pair of items to see if they are equivalent
   for i in 0..&lt;someContainer.count {
      if someContainer[i] != anotherContainer[i] {
         return false
      }
   }

   // all items match, so return true
   return true
}

var tos = Stack&lt;String&gt;()
tos.push("Swift")
println(tos.items)

tos.push("Generics")
println(tos.items)

tos.push("Where Clause")
println(tos.items)

var eos = ["Swift", "Generics", "Where Clause"]
println(eos)
</pre>
<p>When we run the above program using playground, we get the following result &minus;</p>
<pre class="result notranslate">
[Swift]
[Swift, Generics]
[Swift, Generics, Where Clause]
[Swift, Generics, Where Clause]
</pre>
<hr />
<div class="pre-btn">
<a href="swift_access_control.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="../cgi-bin/printpage.html" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="swift_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/swift/swift_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/swift/swift_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/swift/swift_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/swift/swift_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/swift/swift_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/swift/swift_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="../images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="../index-2.html" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="../scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="../about/tutorials_writing.html">Write for us</a></li>
         <li><a href="../about/faq.html">FAQ's</a></li>
         <li><a href="../about/about_helping.html">Helping</a></li>
         <li><a href="../about/contact_us.html">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="../theme/js/custom-min7b30.js?v=4"></script>
<script src="../../www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
<script type="text/javascript" src="../theme/js/jquery.colorbox-min.js"></script>
<script type="text/javascript">
   var tryit = new $.TryIt('try_swift.html');
   tryit.compile();
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Swift Quick Guide",
    "name": "Swift Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/swift/swift_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/swift/images/xcode.jpg",
        "width": 600,
        "height": 326
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "July 23 2017 03:34:49.",
    "dateModified": "July 23 2017 03:34:49.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": "Swift is a new programming language developed by Apple Inc for iOS and OS X development. Swift adopts the best of C and Objective-C, without the constraints of C compatibility...."
}
</script><script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Computer Programming",
                "@id": "https://www.tutorialspoint.com/computer_programming_tutorials.htm"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": "Swift",
                "@id": "https://www.tutorialspoint.com/swift"
            }
        },
        {
            "@type": "ListItem",
            "position": 4,
            "item": {
                "name": "Swift - Quick Guide"
            }
        }
    ]
}
</script></div>
</body>

<!-- Mirrored from www.tutorialspoint.com/swift/swift_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 16:16:05 GMT -->
</html>
