<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/dbms/dbms_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:20:02 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>DBMS Quick Guide</title>
<meta name="description" content="DBMS Quick Guide - Learn DBMS in simple and easy steps starting from its overview, Architecture, data models, data schemas, data independence, ED Diagram, Generalization, Aggregation, Codd's Rules, Relational Data Model, Relational Algebra, Database Design, Normalization, Database Joins, Database Storage, Database File System, Indexing, Hashing, Transaction, Concurrency Control, Deadlock, Backup and Recovery." />
<meta name="keywords" content="DBMS, Tutorial, Network Architecture, Overview, Architecture, data models, data schemas, data independence, ED Diagram, Generalization, Aggregation, Codd's Rules, Relational Data Model, Relational Algebra, Database Design, Normalization, Database Joins, Database Storage, Database File System, Indexing, Hashing, Transaction, Concurrency Control, Deadlock, Backup and Recovery." />
<base  />
<link rel="shortcut icon" href="https://www.tutorialspoint.com/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="https://www.tutorialspoint.com/theme/css/style-min.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #fbb42b url(https://www.tutorialspoint.com/images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #fbb42b !important;}
.submenu-item{ border-bottom: 2px solid #fbb42b !important; border-top: 2px solid #fbb42b !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="https://www.tutorialspoint.com/images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="https://www.tutorialspoint.com/index.htm" title="tutorialspoint">
      <img alt="tutorialspoint" src="https://www.tutorialspoint.com/dbms/images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="https://www.tutorialspoint.com/about/about_careers.htm" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="https://www.tutorialspoint.com/whiteboard.htm"><img src="https://www.tutorialspoint.com/theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="https://www.tutorialspoint.com/netmeeting.php"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="https://www.tutorialspoint.com/online_dev_tools.htm"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="https://www.tutorialspoint.com/articles/index.php"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="https://www.tutorialspoint.com/index.htm"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/codingground.htm"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/tutor_connect/index.php"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="https://www.tutorialspoint.com/dbms/images/dbms-mini-logo.jpg" alt="DBMS Tutorial" />
</div>
<ul class="nav nav-list primary left-menu">
<li class="heading">DBMS Tutorial</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/index.htm">DBMS - Home</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_overview.htm">DBMS - Overview</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_architecture.htm">DBMS - Architecture</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_data_models.htm">DBMS - Data Models</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_data_schemas.htm">DBMS - Data Schemas</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_data_independence.htm">DBMS - Data Independence</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Entity Relationship Model</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/er_model_basic_concepts.htm">DBMS - ER Model Basic Concepts</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/er_diagram_representation.htm">DBMS - ER Diagram Representation</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_generalization_aggregation.htm">DBMS - Generalization, Aggregation</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Relational Model</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_codds_rules.htm">DBMS - Codd's Rules</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/relational_data_model.htm">DBMS - Relational Data Model</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/relational_algebra.htm">DBMS - Relational Algebra</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/er_model_to_relational_model.htm">DBMS - ER to Relational Model</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/sql_overview.htm">DBMS- SQL Overview</a></li>
</ul>                                                                
<ul class="nav nav-list primary left-menu">
<li class="heading">Relational Database Design</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/database_normalization.htm">DBMS - Database Normalization</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/database_joins.htm">DBMS - Database Joins</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Storage and File Structure </li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_storage_system.htm">DBMS - Storage System</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_file_structure.htm">DBMS - File Structure</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Indexing and Hashing</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_indexing.htm">DBMS - Indexing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_hashing.htm">DBMS - Hashing</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Transaction And Concurrency</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_transaction.htm">DBMS - Transaction</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_concurrency_control.htm">DBMS - Concurrency Control</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_deadlock.htm">DBMS - Deadlock</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">Backup and Recovery</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_data_backup.htm">DBMS - Data Backup</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_data_recovery.htm">DBMS - Data Recovery</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">DBMS Useful Resources</li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_quick_guide.htm">DBMS - Quick Guide</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_useful_resources.htm">DBMS - Useful Resources</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/dbms/dbms_discussion.htm">DBMS - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="https://www.tutorialspoint.com/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>DBMS - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/dbms/dbms_data_recovery.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/dbms/dbms_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>DBMS - Overview</h1>
<p><b>Database</b> is a collection of related data and data is a collection of facts and figures that can be processed to produce information.</p>
<p>Mostly data represents recordable facts. Data aids in producing information, which is based on facts. For example, if we have data about marks obtained by all students, we can then conclude about toppers and average marks.</p>
<p>A <b>database management system</b> stores data in such a way that it becomes easier to retrieve, manipulate, and produce information.</p>
<h2>Characteristics</h2>
<p>Traditionally, data was organized in file formats. DBMS was a new concept then, and all the research was done to make it overcome the deficiencies in traditional style of data management. A modern DBMS has the following characteristics &minus;</p>
<ul class="list">
<li><p><b>Real-world entity</b> &minus; A modern DBMS is more realistic and uses real-world entities to design its architecture. It uses the behavior and attributes too. For example, a school database may use students as an entity and their age as an attribute.</p></li>
<li><p><b>Relation-based tables</b> &minus; DBMS allows entities and relations among them to form tables. A user can understand the architecture of a database just by looking at the table names.</p></li>
<li><p><b>Isolation of data and application</b> &minus; A database system is entirely different than its data. A database is an active entity, whereas data is said to be passive, on which the database works and organizes. DBMS also stores metadata, which is data about data, to ease its own process.</p></li>
<li><p><b>Less redundancy</b> &minus; DBMS follows the rules of normalization, which splits a relation when any of its attributes is having redundancy in values. Normalization is a mathematically rich and scientific process that reduces data redundancy.</p></li> 
<li><p><b>Consistency</b> &minus; Consistency is a state where every relation in a database remains consistent. There exist methods and techniques, which can detect attempt of leaving database in inconsistent state. A DBMS can provide greater consistency as compared to earlier forms of data storing applications like file-processing systems.</p></li>
<li><p><b>Query Language</b> &minus; DBMS is equipped with query language, which makes it more efficient to retrieve and manipulate data. A user can apply as many and as different filtering options as required to retrieve a set of data. Traditionally it was not possible where file-processing system was used.<p></li>
<li><p><b>ACID Properties</b> &minus; DBMS follows the concepts of <b>A</b>tomicity, <b>C</b>onsistency, <b>I</b>solation, and <b>D</b>urability (normally shortened as ACID). These concepts are applied on transactions, which manipulate data in a database. ACID properties help the database stay healthy in multi-transactional environments and in case of failure.</p></li>
<li><p><b>Multiuser and Concurrent Access</b> &minus; DBMS supports multi-user environment and allows them to access and manipulate data in parallel. Though there are restrictions on transactions when users attempt to handle the same data item, but users are always unaware of them.</p></li>
<li><p><b>Multiple views</b> &minus; DBMS offers multiple views for different users. A user who is in the Sales department will have a different view of database than a person working in the Production department. This feature enables the users to have a concentrate view of the database according to their requirements.</p></li>
<li><p><b>Security</b> &minus; Features like multiple views offer security to some extent where users are unable to access data of other users and departments. DBMS offers methods to impose constraints while entering data into the database and retrieving the same at a later stage. DBMS offers many different levels of security features, which enables multiple users to have different views with different features. For example, a user in the Sales department cannot see the data that belongs to the Purchase department. Additionally, it can also be managed how much data of the Sales department should be displayed to the user. Since a DBMS is not saved on the disk as traditional file systems, it is very hard for miscreants to break the code.</p></li>
</ul>
<h2>Users</h2>
<p>A typical DBMS has users with different rights and permissions who use it for different purposes. Some users retrieve data and some back it up. The users of a DBMS can be broadly categorized as follows &minus;</p>
<img src="https://www.tutorialspoint.com/dbms/images/dbms_users.png" caption="DBMS Users" />
<ul class="list">
<li><p><b>Administrators</b> &minus; Administrators maintain the DBMS and are responsible for administrating the database. They are responsible to look after its usage and by whom it should be used. They create access profiles for users and apply limitations to maintain isolation and force security. Administrators also look after DBMS resources like system license, required tools, and other software and hardware related maintenance.</p></li>
<li><p><b>Designers</b> &minus; Designers are the group of people who actually work on the designing part of the database. They keep a close watch on what data should be kept and in what format. They identify and design the whole set of entities, relations, constraints, and views.</p></li>
<li><p><b>End Users</b> &minus; End users are those who actually reap the benefits of having a DBMS. End users can range from simple viewers who pay attention to the logs or market rates to sophisticated users such as business analysts.</p></li>
</ul>
<h1>DBMS - Architecture</h1>
<p>The design of a DBMS depends on its architecture. It can be centralized or decentralized or hierarchical. The architecture of a DBMS can be seen as either single tier or multi-tier. An n-tier architecture divides the whole system into related but independent <b>n</b> modules, which can be independently modified, altered, changed, or replaced.</p>
<p>In 1-tier architecture, the DBMS is the only entity where the user directly sits on the DBMS and uses it. Any changes done here will directly be done on the DBMS itself. It does not provide handy tools for end-users. Database designers and programmers normally prefer to use single-tier architecture.</p>
<p>If the architecture of DBMS is 2-tier, then it must have an application through which the DBMS can be accessed. Programmers use 2-tier architecture where they access the DBMS by means of an application. Here the application tier is entirely independent of the database in terms of operation, design, and programming.</p>
<h2>3-tier Architecture</h2>
<p>A 3-tier architecture separates its tiers from each other based on the complexity of the users and how they use the data present in the database. It is the most widely used architecture to design a DBMS.</p>
<img src="https://www.tutorialspoint.com/dbms/images/dbms_architecture.png" caption="3-tier architecture" />
<ul class="list">
<li><p><b>Database (Data) Tier</b> &minus; At this tier, the database resides along with its query processing languages. We also have the relations that define the data and their constraints at this level.</p></li>
<li><p><b>Application (Middle) Tier</b> &minus; At this tier reside the application server and the programs that access the database. For a user, this application tier presents an abstracted view of the database. End-users are unaware of any existence of the database beyond the application. At the other end, the database tier is not aware of any other user beyond the application tier. Hence, the application layer sits in the middle and acts as a mediator between the end-user and the database.</p></li> 
<li><p><b>User (Presentation) Tier</b> &minus; End-users operate on this tier and they know nothing about any existence of the database beyond this layer. At this layer, multiple views of the database can be provided by the application. All views are generated by applications that reside in the application tier.</p></li>
</ul>
<p>Multiple-tier database architecture is highly modifiable, as almost all its components are independent and can be changed independently.</p>
<h1>DBMS - Data Models</h1>
<p>Data models define how the logical structure of a database is modeled. Data Models are fundamental entities to introduce abstraction in a DBMS. Data models define how data is connected to each other and how they are processed and stored inside the system.</p>
<p>The very first data model could be flat data-models, where all the data used are to be kept in the same plane. Earlier data models were not so scientific, hence they were prone to introduce lots of duplication and update anomalies.</p>
<h2>Entity-Relationship Model</h2>
<p>Entity-Relationship (ER) Model is based on the notion of real-world entities and relationships among them. While formulating real-world scenario into the database model, the ER Model creates entity set, relationship set, general attributes and constraints.</p>
<p>ER Model is best used for the conceptual design of a database.</p>
<p>ER Model is based on &minus;</p>
<ul class="list">
<li><p><b>Entities</b> and their <i>attributes.</i></p></li>
<li><p><b>Relationships</b> among entities.</p></li>
</ul>
<p>These concepts are explained below.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_model_intro.png" caption="ER Model"  />
<ul class="list">
<li><p><b>Entity</b> &minus; An entity in an ER Model is a real-world entity having properties called <b>attributes</b>. Every <b>attribute</b> is defined by its set of values called <b>domain</b>. For example, in a school database, a student is considered as an entity. Student has various attributes like name, age, class, etc.</p></li>
<li><p><b>Relationship</b> &minus; The logical association among entities is called <b><i>relationship</i></b>. Relationships are mapped with entities in various ways. Mapping cardinalities define the number of association between two entities.</p>
<p>Mapping cardinalities &minus;</p>
<ul class="list">
<li>one to one</li>
<li>one to many</li>
<li>many to one</li>
<li>many to many</li>
</ul>
</li>
</ul>
<h2>Relational Model</h2>
<p>The most popular data model in DBMS is the Relational Model. It is more scientific a model than others. This model is based on first-order predicate logic and defines a table as an <b>n-ary relation</b>.</p>
<img src="https://www.tutorialspoint.com/dbms/images/relational_model_table.png" alt="Relational Model Table" />
<p>The main highlights of this model are &minus;</p>
<ul class="list">
<li>Data is stored in tables called <b>relations</b>.</li>
<li>Relations can be normalized.</li>
<li>In normalized relations, values saved are atomic values.</li>
<li>Each row in a relation contains a unique value.</li>
<li>Each column in a relation contains values from a same domain.</li>
</ul>
<h1>DBMS - Data Schemas</h1>
<h2>Database Schema</h2>
<p>A database schema is the skeleton structure that represents the logical view of the entire database. It defines how the data is organized and how the relations among them are associated. It formulates all the constraints that are to be applied on the data.</p>
<p>A database schema defines its entities and the relationship among them. It contains a descriptive detail of the database, which can be depicted by means of schema diagrams. It’s the database designers who design the schema to help programmers understand the database and make it useful.</p>
<img src="https://www.tutorialspoint.com/dbms/images/dbms_schemas.png" caption="Database Schemas" />
<p>A database schema can be divided broadly into two categories &minus;</p>
<ul class="list">
<li><p><b>Physical Database Schema</b> &minus; This schema pertains to the actual storage of data and its form of storage like files, indices, etc. It defines how the data will be stored in a secondary storage.</p></li>
<li><p><b>Logical Database Schema</b> &minus; This schema defines all the logical constraints that need to be applied on the data stored. It defines tables, views, and integrity constraints.</p></li>
</ul>
<h2>Database Instance</h2>
<p>It is important that we distinguish these two terms individually. Database schema is the skeleton of database. It is designed when the database doesn't exist at all. Once the database is operational, it is very difficult to make any changes to it. A database schema does not contain any data or information.</p>
<p>A database instance is a state of operational database with data at any given time. It contains a snapshot of the database. Database instances tend to change with time. A DBMS ensures that its every instance (state) is in a valid state, by diligently following all the validations, constraints, and conditions that the database designers have imposed.</p>
<h1>DBMS - Data Independence</h1>
<p>If a database system is not multi-layered, then it becomes difficult to make any changes in the database system. Database systems are designed in multi-layers as we learnt earlier.</p>
<h2>Data Independence</h2>
<p>A database system normally contains a lot of data in addition to users’ data. For example, it stores data about data, known as metadata, to locate and retrieve data easily. It is rather difficult to modify or update a set of metadata once it is stored in the database. But as a DBMS expands, it needs to change over time to satisfy the requirements of the users. If the entire data is dependent, it would become a tedious and highly complex job.</p>
<img src="https://www.tutorialspoint.com/dbms/images/data_independence.png" alt="Data independence" />
<p>Metadata itself follows a layered architecture, so that when we change data at one layer, it does not affect the data at another level. This data is independent but mapped to each other.</p>
<h2>Logical Data Independence</h2>
<p>Logical data is data about database, that is, it stores information about how data is managed inside. For example, a table (relation) stored in the database and all its constraints, applied on that relation.</p>
<p>Logical data independence is a kind of mechanism, which liberalizes itself from actual data stored on the disk. If we do some changes on table format, it should not change the data residing on the disk.</p>
<h2>Physical Data Independence</h2>
<p>All the schemas are logical, and the actual data is stored in bit format on the disk. Physical data independence is the power to change the physical data without impacting the schema or logical data.</p>
<p>For example, in case we want to change or upgrade the storage system itself &minus; suppose we want to replace hard-disks with SSD &minus; it should not have any impact on the logical data or schemas.</p>
<h1>ER Model - Basic Concepts</h1>
<p>The ER model defines the conceptual view of a database. It works around real-world entities and the associations among them. At view level, the ER model is considered a good option for designing databases.</p>
<h2>Entity</h2>
<p>An entity can be a real-world object, either animate or inanimate, that can be easily identifiable. For example, in a school database, students, teachers, classes, and courses offered can be considered as entities. All these entities have some attributes or properties that give them their identity.</p>
<p>An entity set is a collection of similar types of entities. An entity set may contain entities with attribute sharing similar values. For example, a Students set may contain all the students of a school; likewise a Teachers set may contain all the teachers of a school from all faculties. Entity sets need not be disjoint.</p>
<h2>Attributes</h2>
<p>Entities are represented by means of their properties, called <b>attributes</b>. All attributes have values. For example, a student entity may have name, class, and age as attributes.</p>
<p>There exists a domain or range of values that can be assigned to attributes. For example, a student's name cannot be a numeric value. It has to be alphabetic. A student's age cannot be negative, etc.</p>
<h3>Types of Attributes</h3>
<ul class="list">
<li><p><b>Simple attribute</b> &minus; Simple attributes are atomic values, which cannot be divided further. For example, a student's phone number is an atomic value of 10 digits.</p></li>
<li><p><b>Composite attribute</b> &minus; Composite attributes are made of more than one simple attribute. For example, a student's complete name may have first_name and last_name.</p></li>
<li><p><b>Derived attribute</b> &minus; Derived attributes are the attributes that do not exist in the physical database, but their values are derived from other attributes present in the database. For example, average_salary in a department should not be saved directly in the database, instead it can be derived. For another example, age can be derived from data_of_birth.</p></li>
<li><p><b>Single-value attribute</b> &minus; Single-value attributes contain single value. For example &minus; Social_Security_Number.</p></li>
<li><p><b>Multi-value attribute</b> &minus; Multi-value attributes may contain more than one values. For example, a person can have more than one phone number, email_address, etc.</p></li>
</ul>
<p>These attribute types can come together in a way like &minus;</p>
<ul class="list">
<li>simple single-valued attributes</li>
<li>simple multi-valued attributes</li>
<li>composite single-valued attributes</li>
<li>composite multi-valued attributes</li>
</ul>
<h3>Entity-Set and Keys</h3>
<p>Key is an attribute or collection of attributes that uniquely identifies an entity among entity set.</p>
<p>For example, the roll_number of a student makes him/her identifiable among students.</p>
<ul class="list">
<li><p><b>Super Key</b> &minus; A set of attributes (one or more) that collectively identifies an entity in an entity set.</p></li>
<li><p><b>Candidate Key</b> &minus; A minimal super key is called a candidate key. An entity set may have more than one candidate key.</p></li>
<li><p><b>Primary Key</b> &minus; A primary key is one of the candidate keys chosen by the database designer to uniquely identify the entity set.</p></li>
</ul>
<h2>Relationship</h2>
<p>The association among entities is called a relationship. For example, an employee <b>works_at</b> a department, a student <b>enrolls</b> in a course. Here, Works_at and Enrolls are called relationships.</p>
<h3>Relationship Set</h3>
<p>A set of relationships of similar type is called a relationship set. Like entities, a relationship too can have attributes. These attributes are called <b>descriptive attributes</b>.</p>
<h3>Degree of Relationship</h3>
<p>The number of participating entities in a relationship defines the degree of the relationship.</p>
<ul class="list">
<li>Binary = degree 2</li>
<li>Ternary = degree 3</li>
<li>n-ary = degree</li>
</ul>
<h3>Mapping Cardinalities</h3>
<p><b>Cardinality</b> defines the number of entities in one entity set, which can be associated with the number of entities of other set via relationship set.</p>
<ul class="list">
<li><p><b>One-to-one</b> &minus; One entity from entity set A can be associated with at most one entity of entity set B and vice versa.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/one_to_one_relation.png" alt="One-to-one relation" />
<li><p><b>One-to-many</b> &minus; One entity from entity set A can be associated with more than one entities of entity set B however an entity from entity set B, can be associated with at most one entity.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/one_to_many_relation.png" alt="One-to-many relation" />
<li><p><b>Many-to-one</b> &minus; More than one entities from entity set A can be associated with at most one entity of entity set B, however an entity from entity set B can be associated with more than one entity from entity set A.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/many_to_one_relation.png" alt="Many-to-one relation" />
<li><p><b>Many-to-many</b> &minus; One entity from A can be associated with more than one entity from B and vice versa.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/many_to_many_relation.png" alt="Many-to-many relation" />
</ul>
<h1>ER Diagram Representation</h1>
<p>Let us now learn how the ER Model is represented by means of an ER diagram. Any object, for example, entities, attributes of an entity, relationship sets, and attributes of relationship sets, can be represented with the help of an ER diagram.</p>
<h2>Entity</h2>
<p>Entities are represented by means of rectangles. Rectangles are named with the entity set they represent.</p>
<img src="https://www.tutorialspoint.com/dbms/images/entities.png" alt="Entities in a school database" />
<h2>Attributes</h2>
<p>Attributes are the properties of entities. Attributes are represented by means of ellipses. Every ellipse represents one attribute and is directly connected to its entity (rectangle).</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes.png" alt="Simple Attributes" />
<p>If the attributes are <b>composite</b>, they are further divided in a tree like structure. Every node is then connected to its attribute. That is, composite attributes are represented by ellipses that are connected with an ellipse.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes_composite.png" alt="Composite Attributes" />
<p><b>Multivalued</b> attributes are depicted by double ellipse.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes_multivalued.png" alt="Multivalued Attributes" />
<p><b>Derived</b> attributes are depicted by dashed ellipse.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes_derived.png" alt="Derived Attributes" />
<h2>Relationship</h2>
<p>Relationships are represented by diamond-shaped box. Name of the relationship is written inside the diamond-box. All the entities (rectangles) participating in a relationship, are connected to it by a line.</p>
<h3>Binary Relationship and Cardinality</h3>
<p>A relationship where two entities are participating is called a <b>binary relationship</b>. Cardinality is the number of instance of an entity from a relation that can be associated with the relation.</p>
<ul class="list">
<li><p><b>One-to-one</b> &minus; When only one instance of an entity is associated with the relationship, it is marked as '1:1'. The following image reflects that only one instance of each entity should be associated with the relationship. It depicts one-to-one relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_one_to_one.png" alt="One-to-one" />
<li><p><b>One-to-many</b> &minus; When more than one instance of an entity is associated with a relationship, it is marked as '1:N'. The following image reflects that only one instance of entity on the left and more than one instance of an entity on the right can be associated with the relationship. It depicts one-to-many relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_one_to_many.png" alt="One-to-many" />
<li><p><b>Many-to-one</b> &minus; When more than one instance of entity is associated with the relationship, it is marked as 'N:1'. The following image reflects that more than one instance of an entity on the left and only one instance of an entity on the right can be associated with the relationship. It depicts many-to-one relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_many_to_one.png" alt="Many-to-one" />
<li><p><b>Many-to-many</b> &minus; The following image reflects that more than one instance of an entity on the left and more than one instance of an entity on the right can be associated with the relationship. It depicts many-to-many relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_many_to_many.png" alt="Many-to-many" />
</ul>
<h3>Participation Constraints</h3>
<ul class="list">
<li><p><b>Total Participation</b> &minus; Each entity is involved in the relationship. Total participation is represented by double lines.</p></li>
<li><p><b>Partial participation</b> &minus; Not all entities are involved in the relationship. Partial participation is represented by single lines.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_participation.png" alt="Participation Constraints" />
<h1>Generalization Aggregation</h1>
<p>Let us now learn how the ER Model is represented by means of an ER diagram. Any object, for example, entities, attributes of an entity, relationship sets, and attributes of relationship sets, can be represented with the help of an ER diagram.</p>
<h2>Entity</h2>
<p>Entities are represented by means of rectangles. Rectangles are named with the entity set they represent.</p>
<img src="https://www.tutorialspoint.com/dbms/images/entities.png" alt="Entities in a school database" />
<h2>Attributes</h2>
<p>Attributes are the properties of entities. Attributes are represented by means of ellipses. Every ellipse represents one attribute and is directly connected to its entity (rectangle).</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes.png" alt="Simple Attributes" />
<p>If the attributes are <b>composite</b>, they are further divided in a tree like structure. Every node is then connected to its attribute. That is, composite attributes are represented by ellipses that are connected with an ellipse.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes_composite.png" alt="Composite Attributes" />
<p><b>Multivalued</b> attributes are depicted by double ellipse.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes_multivalued.png" alt="Multivalued Attributes" />
<p><b>Derived</b> attributes are depicted by dashed ellipse.</p>
<img src="https://www.tutorialspoint.com/dbms/images/er_attributes_derived.png" alt="Derived Attributes" />
<h2>Relationship</h2>
<p>Relationships are represented by diamond-shaped box. Name of the relationship is written inside the diamond-box. All the entities (rectangles) participating in a relationship, are connected to it by a line.</p>
<h3>Binary Relationship and Cardinality</h3>
<p>A relationship where two entities are participating is called a <b>binary relationship</b>. Cardinality is the number of instance of an entity from a relation that can be associated with the relation.</p>
<ul class="list">
<li><p><b>One-to-one</b> &minus; When only one instance of an entity is associated with the relationship, it is marked as '1:1'. The following image reflects that only one instance of each entity should be associated with the relationship. It depicts one-to-one relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_one_to_one.png" alt="One-to-one" />
<li><p><b>One-to-many</b> &minus; When more than one instance of an entity is associated with a relationship, it is marked as '1:N'. The following image reflects that only one instance of entity on the left and more than one instance of an entity on the right can be associated with the relationship. It depicts one-to-many relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_one_to_many.png" alt="One-to-many" />
<li><p><b>Many-to-one</b> &minus; When more than one instance of entity is associated with the relationship, it is marked as 'N:1'. The following image reflects that more than one instance of an entity on the left and only one instance of an entity on the right can be associated with the relationship. It depicts many-to-one relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_many_to_one.png" alt="Many-to-one" />
<li><p><b>Many-to-many</b> &minus; The following image reflects that more than one instance of an entity on the left and more than one instance of an entity on the right can be associated with the relationship. It depicts many-to-many relationship.</p></li>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_many_to_many.png" alt="Many-to-many" />
</ul>
<h3>Participation Constraints</h3>
<ul class="list">
<li><p><b>Total Participation</b> &minus; Each entity is involved in the relationship. Total participation is represented by double lines.</p></li>
<li><p><b>Partial participation</b> &minus; Not all entities are involved in the relationship. Partial participation is represented by single lines.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/er_relation_participation.png" alt="Participation Constraints" />
<h1>Generalization Aggregation</h1>
<p>The ER Model has the power of expressing database entities in a conceptual hierarchical manner. As the hierarchy goes up, it generalizes the view of entities, and as we go deep in the hierarchy, it gives us the detail of every entity included.</p>
<p>Going up in this structure is called <b>generalization</b>, where entities are clubbed together to represent a more generalized view. For example, a particular student named Mira can be generalized along with all the students. The entity shall be a student, and further, the student is a person. The reverse is called <b>specialization</b> where a person is a student, and that student is Mira.</p>
<h2>Generalization</h2>
<p>As mentioned above, the process of generalizing entities, where the generalized entities contain the properties of all the generalized entities, is called generalization. In generalization, a number of entities are brought together into one generalized entity based on their similar characteristics. For example, pigeon, house sparrow, crow and dove can all be generalized as Birds.</p>
<img src="https://www.tutorialspoint.com/dbms/images/generalization.png" alt="Generalization" />
<h2>Specialization</h2>
<p>Specialization is the opposite of generalization. In specialization, a group of entities is divided into sub-groups based on their characteristics. Take a group ‘Person’ for example. A person has name, date of birth, gender, etc. These properties are common in all persons, human beings. But in a company, persons can be identified as employee, employer, customer, or vendor, based on what role they play in the company.</p>
<img src="https://www.tutorialspoint.com/dbms/images/specialization.png" alt="Specialization" />
<p>Similarly, in a school database, persons can be specialized as teacher, student, or a staff, based on what role they play in school as entities.</p>
<h2>Inheritance</h2>
<p>We use all the above features of ER-Model in order to create classes of objects in object-oriented programming. The details of entities are generally hidden from the user; this process known as <b>abstraction</b>.</p>
<p>Inheritance is an important feature of Generalization and Specialization. It allows lower-level entities to inherit the attributes of higher-level entities.</p>
<img src="https://www.tutorialspoint.com/dbms/images/inheritance.png" alt="Inheritance" />
<p>For example, the attributes of a Person class such as name, age, and gender can be inherited by lower-level entities such as Student or Teacher.</p>
<h1>Codd's 12 Rules</h1>
<p>Dr Edgar F. Codd, after his extensive research on the Relational Model of database systems, came up with twelve rules of his own, which according to him, a database must obey in order to be regarded as a true relational database.</p>
<p>These rules can be applied on any database system that manages stored data using only its relational capabilities. This is a foundation rule, which acts as a base for all the other rules.</p>
<h2>Rule 1: Information Rule</h2>
<p>The data stored in a database, may it be user data or metadata, must be a value of some table cell. Everything in a database must be stored in a table format.</p>
<h2>Rule 2: Guaranteed Access Rule</h2>
<p>Every single data element (value) is guaranteed to be accessible logically with a combination of table-name, primary-key (row value), and attribute-name (column value). No other means, such as pointers, can be used to access data.</p>
<h2>Rule 3: Systematic Treatment of NULL Values</h2>
<p>The NULL values in a database must be given a systematic and uniform treatment. This is a very important rule because a NULL can be interpreted as one the following &minus; data is missing, data is not known, or data is not applicable.</p>
<h2>Rule 4: Active Online Catalog</h2>
<p>The structure description of the entire database must be stored in an online catalog, known as <b>data dictionary</b>, which can be accessed by authorized users. Users can use the same query language to access the catalog which they use to access the database itself.</p>
<h2>Rule 5: Comprehensive Data Sub-Language Rule</h2>
<p>A database can only be accessed using a language having linear syntax that supports data definition, data manipulation, and transaction management operations. This language can be used directly or by means of some application. If the database allows access to data without any help of this language, then it is considered as a violation.</p>
<h2>Rule 6: View Updating Rule</h2>
<p>All the views of a database, which can theoretically be updated, must also be updatable by the system.</p>
<h2>Rule 7: High-Level Insert, Update, and Delete Rule</h2>
<p>A database must support high-level insertion, updation, and deletion. This must not be limited to a single row, that is, it must also support union, intersection and minus operations to yield sets of data records.</p>
<h2>Rule 8: Physical Data Independence</h2>
<p>The data stored in a database must be independent of the applications that access the database. Any change in the physical structure of a database must not have any impact on how the data is being accessed by external applications.</p>
<h2>Rule 9: Logical Data Independence</h2>
<p>The logical data in a database must be independent of its user’s view (application). Any change in logical data must not affect the applications using it. For example, if two tables are merged or one is split into two different tables, there should be no impact or change on the user application. This is one of the most difficult rule to apply.</p>
<h2>Rule 10: Integrity Independence</h2>
<p>A database must be independent of the application that uses it. All its integrity constraints can be independently modified without the need of any change in the application. This rule makes a database independent of the front-end application and its interface.</p>
<h2>Rule 11: Distribution Independence</h2>
<p>The end-user must not be able to see that the data is distributed over various locations. Users should always get the impression that the data is located at one site only. This rule has been regarded as the foundation of distributed database systems.</p>
<h2>Rule 12: Non-Subversion Rule</h2>
<p>If a system has an interface that provides access to low-level records, then the interface must not be able to subvert the system and bypass security and integrity constraints.</p>
<h1>Relation Data Model</h1>
<p>Relational data model is the primary data model, which is used widely around the world for data storage and processing. This model is simple and it has all the properties and capabilities required to process data with storage efficiency.</p>
<h2>Concepts</h2>
<p><b>Tables</b> &minus; In relational data model, relations are saved in the format of Tables. This format stores the relation among entities. A table has rows and columns, where rows represents records and columns represent the attributes.</p>
<p><b>Tuple</b> &minus; A single row of a table, which contains a single record for that relation is called a tuple.</p>
<p><b>Relation instance</b> &minus; A finite set of tuples in the relational database system represents relation instance. Relation instances do not have duplicate tuples.</p>
<p><b>Relation schema</b> &minus; A relation schema describes the relation name (table name), attributes, and their names.</p>
<p><b>Relation key</b> &minus; Each row has one or more attributes, known as relation key, which can identify the row in the relation (table) uniquely.</p> 
<p><b>Attribute domain</b> &minus; Every attribute has some pre-defined value scope, known as attribute domain.</p>
<h2>Constraints</h2>
<p>Every relation has some conditions that must hold for it to be a valid relation.  These conditions are called <b>Relational Integrity Constraints</b>. There are three main integrity constraints &minus;</p>
<ul class="list">
<li>Key constraints</li>
<li>Domain constraints</li>
<li>Referential integrity constraints</li>
</ul>
<h3>Key Constraints</h3>
<p>There must be at least one minimal subset of attributes in the relation, which can identify a tuple uniquely. This minimal subset of attributes is called <b>key</b> for that relation. If there are more than one such minimal subsets, these are called <b><i>candidate keys</i></b>.</p>
<p>Key constraints force that &minus;</p>
<ul class="list">
<li><p>in a relation with a key attribute, no two tuples can have identical values for key attributes.</p></li>
<li><p>a key attribute can not have NULL values.</p></li>
</ul>
<p>Key constraints are also referred to as Entity Constraints.</p>
<h3>Domain Constraints</h3>
<p>Attributes have specific values in real-world scenario. For example, age can only be a positive integer. The same constraints have been tried to employ on the attributes of a relation. Every attribute is bound to have a specific range of values. For example, age cannot be less than zero and telephone numbers cannot contain a digit outside 0-9.</p>
<h3>Referential integrity Constraints</h3>
<p>Referential integrity constraints work on the concept of Foreign Keys. A foreign key is a key attribute of a relation that can be referred in other relation.</p>
<p>Referential integrity constraint states that if a relation refers to a key attribute of a different or same relation, then that key element must exist.</p>
<h1>Relational Algebra</h1>
<p>Relational database systems are expected to be equipped with a query language that can assist its users to query the database instances. There are two kinds of query languages &minus; relational algebra and relational calculus.</p>
<h2>Relational Algebra</h2>
<p>Relational algebra is a procedural query language, which takes instances of relations as input and yields instances of relations as output. It uses operators to perform queries. An operator can be either <b>unary</b> or <b>binary</b>.  They accept relations as their input and yield relations as their output. Relational algebra is performed recursively on a relation and intermediate results are also considered relations.</p>
<p>The fundamental operations of relational algebra are as follows &minus;</p>
<ul class="list">
<li>Select</li>
<li>Project</li>
<li>Union</li>
<li>Set different</li>
<li>Cartesian product</li>
<li>Rename</li>
</ul>
<p>We will discuss all these operations in the following sections.</p>
<h2>Select Operation (&#963;)</h2>
<p>It selects tuples that satisfy the given predicate from a relation.</p>
<p><b>Notation</b> &minus; &#963;<sub><i>p</i></sub>(r)</p>
<p>Where <b>&#963;</b> stands for selection predicate and <b>r</b> stands for relation. <i>p</i> is prepositional logic formula which may use connectors like <b>and, or,</b> and <b>not</b>. These terms may use relational operators like &minus; &#61;,&nbsp;&#8800;,&nbsp;&ge;,&nbsp;&lt; ,&nbsp; &gt;, &nbsp;&le;.</p>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
<p>&#963;<sub><i>subject="database"</i></sub>(Books)</p>
</pre>
<p><b>Output</b> &minus; Selects tuples from books where subject is 'database'.</p>
<pre class="result notranslate">
<p>&#963;<sub>subject="database" and price="450"</sub>(Books)</p>
</pre>
<p><b>Output</b> &minus; Selects tuples from books where subject is 'database' and 'price' is 450.</p>
<pre class="result notranslate">
<p>&#963;<sub>subject="database" and price &#60; "450" or year &gt; "2010"</sub>(Books)</p>
</pre>
<p><b>Output</b> &minus; Selects tuples from books where subject is 'database' and 'price' is 450 or those books published after 2010.</p>
<h2>Project Operation (&#8719;)</h2>
<p>It projects column(s) that satisfy a given predicate.</p>
<p>Notation &minus; &#8719;<sub>A<sub><small>1</small></sub>, A<sub><small>2</small></sub>, A<sub><small>n</small></sub></sub> (r)</p>
<p>Where A<sub><small>1</small></sub>, A<sub><small>2</small></sub> , A<sub><small>n</small></sub> are attribute names of relation <b>r</b>.</p>
<p>Duplicate rows are automatically eliminated, as relation is a set.</p>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
<p> &#8719;<sub>subject, author</sub> (Books)</p>
</pre>
<p>Selects and projects columns named as subject and author from the relation Books.</p>
<h2>Union Operation (&#8746;)</h2>
<p>It performs binary union between two given relations and is defined as &minus;</p>
<pre class="result notranslate">
<p> r &#8746; s = { t | t &#8712; r or t &#8712; s} </p>
</pre>
<p><b>Notation</b> &minus; r U s </p>
<p>Where <b>r</b> and <b>s</b> are either database relations or relation result set (temporary relation).</p>
<p>For a union operation to be valid, the following conditions must hold &minus;</p>
<ul class="list">
<li><b>r</b>, and <b>s</b> must have the same number of attributes.</li>
<li>Attribute domains must be compatible.</li>
<li>Duplicate tuples are automatically eliminated.</li>
</ul>
<pre class="result notranslate">
<p> &#8719; <sub>author</sub> (Books) &#8746; &#8719; <sub>author</sub> (Articles)</p>
</pre>
<p><b>Output</b> &minus; Projects the names of the authors who have either written a book or an article or both.</p>
<h2>Set Difference (&#8722;)</h2>
<p>The result of set difference operation is tuples, which are present in one relation but are not in the second relation.</p>
<p><b>Notation</b> &minus; <b>r</b> &#8722; <b>s</b></p>
<p>Finds all the tuples that are present in <b>r</b> but not in <b>s</b>.</p>
<pre class="result notranslate">
<p> &#8719; <sub>author</sub> (Books) &#8722; &#8719; <sub>author</sub> (Articles)</p>
</pre>
<p><b>Output</b> &minus; Provides the name of authors who have written books but not articles.</p>
<h2>Cartesian Product (&#935;)</h2>
<p>Combines information of two different relations into one. </p>
<p><b>Notation</b> &minus; r &#935; s</p>
<p>Where <b>r</b> and <b>s</b> are relations and their output will be defined as &minus;</p>
<p>r &#935;  s = { q t | q &#8712;  r and t &#8712; s}</p>
<pre class="result notranslate">
<p> &#8719; <sub>author = 'tutorialspoint'</sub>(Books &#935; Articles) </p>
</pre>
<p><b>Output</b> &minus; Yields a relation, which shows all the books and articles written by tutorialspoint.</p>
<h2>Rename Operation (&#961;)</h2>
<p>The results of relational algebra are also relations but without any name. The rename operation allows us to rename the output relation. 'rename' operation is denoted with small Greek letter <b>rho</b> <i>&#961;</i>.</p>
<p><b>Notation</b> &minus; <i>&#961;</i> <sub>x</sub> (E)</p>
<p>Where the result of expression <b>E</b> is saved with name of <b>x</b>.</p>
<p>Additional operations are &minus;</p>
<ul class="list">
<li>Set intersection</li>
<li>Assignment</li>
<li>Natural join</li>
</ul>
<h2>Relational Calculus</h2>
<p>In contrast to Relational Algebra, Relational Calculus is a non-procedural query language, that is, it tells what to do but never explains how to do it.</p>
<p>Relational calculus exists in two forms &minus;</p>
<h3>Tuple Relational Calculus (TRC)</h3>
<p>Filtering variable ranges over tuples</p>
<p><b>Notation</b> &minus; {T | Condition} </p>
<p>Returns all tuples T that satisfies a condition.</p>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
{ T.name |  Author(T) AND T.article = 'database' }
</pre>
<p><b>Output</b> &minus; Returns tuples with 'name' from Author who has written article on 'database'.</p>
<p>TRC can be quantified. We can use Existential (&#8707;) and Universal Quantifiers (&#8704;).</p>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
{ R| &#8707;T &nbsp; &#8712; Authors(T.article='database' AND R.name=T.name)}
</pre>
<p><b>Output</b> &minus; The above query will yield the same result as the previous one.</p>
<h3>Domain Relational Calculus (DRC)</h3>
<p>In DRC, the filtering variable uses the domain of attributes instead of entire tuple values (as done in TRC, mentioned above).</p>
<p><b>Notation</b> &minus;</p>
<p>{ a<sub><small>1</small></sub>, a<sub><small>2</small></sub>, a<sub><small>3</small></sub>, ..., a<sub><small>n</small></sub> | P (a<sub><small>1</small></sub>, a<sub><small>2</small></sub>, a<sub><small>3</small></sub>, ... ,a<sub><small>n</small></sub>)}</p>
<p>Where a1, a2 are attributes and <b>P</b> stands for formulae built by inner attributes.</p>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
<p>{< article, page, subject > | <article, page, subject > &#8712; TutorialsPoint &#8743; subject = 'database'}</p>
</pre>
<p><b>Output</b> &minus; Yields Article, Page, and Subject from the relation TutorialsPoint, where subject is database.</p>
<p>Just like TRC, DRC can also be written using existential and universal quantifiers.  DRC also involves relational operators.</p>
<p>The expression power of Tuple Relation Calculus and Domain Relation Calculus is equivalent to Relational Algebra.</p>
<h1>ER Model to Relational Model</h1>
<p>ER Model, when conceptualized into diagrams, gives a good overview of entity-relationship, which is easier to understand. ER diagrams can be mapped to relational schema, that is, it is possible to create relational schema using ER diagram. We cannot import all the ER constraints into relational model, but an approximate schema can be generated.</p>
<p>There are several processes and algorithms available to convert ER Diagrams into Relational Schema. Some of them are automated and some of them are manual. We may focus here on the mapping diagram contents to relational basics.</p>
<p>ER diagrams mainly comprise of &minus;</p>
<ul class="list">
<li>Entity and its attributes</li>
<li>Relationship, which is association among entities.</li>
</ul>
<h2>Mapping Entity</h2>
<p>An entity is a real-world object with some attributes.</p>
<img src="https://www.tutorialspoint.com/dbms/images/mapping_entities.png" alt="Mapping Entity" />
<h3>Mapping Process (Algorithm)</h3>
<ul class="list">
<li>Create table for each entity.</li>
<li>Entity's attributes should become fields of tables with their respective data types.</li>
<li>Declare primary key.</li>
</ul>
<h2>Mapping Relationship</h2>
<p>A relationship is an association among entities.</p>
<img src="https://www.tutorialspoint.com/dbms/images/mapping_relationship.png" alt="Mapping relationship" />
<h3>Mapping Process</h3>
<ul class="list">
<li>Create table for a relationship.</li>
<li>Add the primary keys of all participating Entities as fields of table with their respective data types.</li>
<li>If relationship has any attribute, add each attribute as field of table.</li>
<li>Declare a primary key composing all the primary keys of participating entities.</li>
<li>Declare all foreign key constraints.</li>
</ul>
<h2>Mapping Weak Entity Sets</h2>
<p>A weak entity set is one which does not have any primary key associated with it.</p>
<img src="https://www.tutorialspoint.com/dbms/images/mapping_weak_entity_sets.png" alt="Mapping Weak Entity Sets" />
<h3>Mapping Process</h3>
<ul class="list">
<li>Create table for weak entity set.</li>
<li>Add all its attributes to table as field.</li>
<li>Add the primary key of identifying entity set.</li>
<li>Declare all foreign key constraints.</li>
</ul>
<h2>Mapping Hierarchical Entities</h2>
<p>ER specialization or generalization comes in the form of hierarchical entity sets.</p>
<img src="https://www.tutorialspoint.com/dbms/images/inheritance.png" alt="Mapping hierarchical entities" />
<h3>Mapping Process</h3>
<ul class="list">
<li><p>Create tables for all higher-level entities.</p></li>
<li><p>Create tables for lower-level entities.</p></li>
<li><p>Add primary keys of higher-level entities in the table of lower-level entities.</p></li>
<li><p>In lower-level tables, add all other attributes of lower-level entities.</p></li>
<li><p>Declare primary key of higher-level table and the primary key for lower-level table.</p></li>
<li><p>Declare foreign key constraints.</p></li>
</ul>
<h1>SQL Overview</h1>
<p>SQL is a programming language for Relational Databases. It is designed over relational algebra and tuple relational calculus. SQL comes as a package with all major distributions of RDBMS.</p>
<p>SQL comprises both data definition and data manipulation languages. Using the data definition properties of SQL, one can design and modify database schema, whereas data manipulation properties allows SQL to store and retrieve data from database.</p>
<h2>Data Definition Language</h2>
<p>SQL uses the following set of commands to define database schema &minus;</p>
<h3>CREATE</h3>
<p>Creates new databases, tables and views from RDBMS.</p>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
Create database tutorialspoint;
Create table article;
Create view for_students;
</pre>
<h3>DROP</h3>
<p>Drops commands, views, tables, and databases from RDBMS.</p>
<p><b>For example</b>&minus;</p>
<pre class="result notranslate">
Drop object_type object_name;
Drop database tutorialspoint;
Drop table article;
Drop view for_students;
</pre>
<h3>ALTER</h3>
<p>Modifies database schema.</p>
<pre class="result notranslate">
Alter object_type object_name parameters;
</pre>
<p><b>For example</b>&minus;</p>
<pre class="result notranslate">
Alter table article add subject varchar;
</pre>
<p>This command adds an attribute in the relation <b>article</b> with the name <b>subject</b> of string type.</p>
<h2>Data Manipulation Language</h2>
<p>SQL is equipped with data manipulation language (DML). DML modifies the database instance by inserting, updating and deleting its data. DML is responsible for all froms data modification in a database. SQL contains the following set of commands in its DML section &minus;</p>
<ul class="list">
<li>SELECT/FROM/WHERE</li>
<li>INSERT INTO/VALUES</li>
<li>UPDATE/SET/WHERE</li>
<li>DELETE FROM/WHERE</li>
</ul>
<p>These basic constructs allow database programmers and users to enter data and information into the database and retrieve efficiently using a number of filter options.</p>
<h3>SELECT/FROM/WHERE</h3>
<ul class="list">
<li><p><b>SELECT</b> &minus; This is one of the fundamental query command of SQL. It is similar to the projection operation of relational algebra. It selects the attributes based on the condition described by WHERE clause.</p></li>
<li><p><b>FROM</b> &minus; This clause takes a relation name as an argument from which attributes are to be selected/projected. In case more than one relation names are given, this clause corresponds to Cartesian product.</p></li>
<li><p><b>WHERE</b> &minus; This clause defines predicate or conditions, which must match in order to qualify the attributes to be projected.</p></li>
</ul>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
Select author_name
From book_author
Where age &gt; 50;
</pre>
<p>This command will yield the names of authors from the relation <b>book_author</b> whose age is greater than 50.</p>
<h3>INSERT INTO/VALUES</h3>
<p>This command is used for inserting values into the rows of a table (relation).</p>
<p><b>Syntax</b>&minus;</p>
<pre class="result notranslate">
INSERT INTO table (column1 [, column2, column3 ... ]) VALUES (value1 [, value2, value3 ... ])
</pre>
<p>Or</p>
<pre class="result notranslate">
INSERT INTO table VALUES (value1, [value2, ... ])
</pre>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
INSERT INTO tutorialspoint (Author, Subject) VALUES ("anonymous", "computers");
</pre>
<h3>UPDATE/SET/WHERE</h3>
<p>This command is used for updating or modifying the values of columns in a table (relation).</p>
<p><b>Syntax</b> &minus;</p>
<pre class="result notranslate">
UPDATE table_name SET column_name = value [, column_name = value ...] [WHERE condition]
</pre>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
UPDATE tutorialspoint SET Author="webmaster" WHERE Author="anonymous";
</pre>
<h3>DELETE/FROM/WHERE</h3>
<p>This command is used for removing one or more rows from a table (relation).</p>
<p><b>Syntax</b> &minus;</p>
<pre class="result notranslate">
DELETE FROM table_name [WHERE condition];
</pre>
<p><b>For example</b> &minus;</p>
<pre class="result notranslate">
DELETE FROM tutorialspoints
   WHERE Author="unknown";
</pre>
<h1>DBMS - Normalization</h1>
<h2>Functional Dependency</h2>
<p>Functional dependency (FD) is a set of constraints between two attributes in a relation. Functional dependency says that if two tuples have same values for attributes A1, A2,..., An, then those two tuples must have to have same values for attributes B1, B2, ..., Bn.</p>
<p>Functional dependency is represented by an arrow sign (&#8594;) that is, X&#8594;Y, where X functionally determines Y. The left-hand side attributes determine the values of attributes on the right-hand side.</p>
<h2>Armstrong's Axioms</h2>
<p>If F is a set of functional dependencies then the closure of F, denoted as F<sup>+</sup>, is the set of all functional dependencies logically implied by F. Armstrong's Axioms are a set of rules, that when applied repeatedly, generates a closure of functional dependencies.</p>
<ul class="list">
<li><p><b>Reflexive rule</b> &minus; If alpha is a set of attributes and beta is_subset_of alpha, then alpha holds beta.</p></li>
<li><p><b>Augmentation rule</b> &minus; If a &#8594; b holds and y is attribute set, then ay &#8594; by also holds. That is adding attributes in dependencies, does not change the basic dependencies.</p></li>
<li><p><b>Transitivity rule</b> &minus; Same as transitive rule in algebra, if a &#8594; b holds and b &#8594; c holds, then a &#8594; c also holds. a &#8594; b is called as a functionally that determines b.</p></li>
</ul>
<h2>Trivial Functional Dependency</h2>
<ul class="list">
<li><p><b>Trivial</b> &minus; If a functional dependency (FD) X &#8594; Y holds, where Y is a subset of X, then it is called a trivial FD. Trivial FDs always hold.</p></li>
<li><p><b>Non-trivial</b> &minus; If an FD X &#8594; Y holds, where Y is not a subset of X, then it is called a non-trivial FD.</p></li>
<li><p><b>Completely non-trivial</b> &minus; If an FD X &#8594; Y holds, where x intersect Y = &#934;, it is said to be a completely non-trivial FD.</p></li>
</ul>
<h2>Normalization</h2>
<p>If a database design is not perfect, it may contain anomalies, which are like a bad dream for any database administrator. Managing a database with anomalies is next to impossible.</p>
<ul class="list">
<li><p><b>Update anomalies</b> &minus; If data items are scattered and are not linked to each other properly, then it could lead to strange situations. For example, when we try to update one data item having its copies scattered over several places, a few instances get updated properly while a few others are left with old values. Such instances leave the database in an inconsistent state.</p></li>
<li><p><b>Deletion anomalies</b> &minus; We tried to delete a record, but parts of it was left undeleted because of unawareness, the data is also saved somewhere else.</p></li>
<li><p><b>Insert anomalies</b> &minus; We tried to insert data in a record that does not exist at all.</p></li>
</ul>
<p>Normalization is a method to remove all these anomalies and bring the database to a consistent state.</p>
<h2>First Normal Form</h2>
<p>First Normal Form is defined in the definition of relations (tables) itself. This rule defines that all the attributes in a relation must have atomic domains. The values in an atomic domain are indivisible units.</p>
<img src="https://www.tutorialspoint.com/dbms/images/unorganized_relation.png" alt="unorganized relation" />
<p>We re-arrange the relation (table) as below, to convert it to First Normal Form.</p>
<img src="https://www.tutorialspoint.com/dbms/images/1nf.png" alt="Relation in 1NF" />
<p>Each attribute must contain only a single value from its pre-defined domain.</p>
<h2>Second Normal Form</h2>
<p>Before we learn about the second normal form, we need to understand the following &minus;</p>
<ul class="list">
<li><p><b>Prime attribute</b> &minus; An attribute, which is a part of the prime-key, is known as a prime attribute.</p></li>
<li><p><b>Non-prime attribute</b> &minus; An attribute, which is not a part of the prime-key, is said to be a non-prime attribute.</p></li>
</ul>
<p>If we follow second normal form, then every non-prime attribute should be fully functionally dependent on prime key attribute. That is, if X &#8594; A holds, then there should not be any proper subset Y of X, for which Y &#8594; A also holds true.</p>
<img src="https://www.tutorialspoint.com/dbms/images/not_2nf.png" alt="Relation not in 2NF" />
<p>We see here in Student_Project relation that the prime key attributes are Stu_ID and Proj_ID. According to the rule, non-key attributes, i.e. Stu_Name and Proj_Name must be dependent upon both and not on any of the prime key attribute individually. But we find that Stu_Name can be identified by Stu_ID and Proj_Name can be identified by Proj_ID independently. This is called <b>partial dependency</b>, which is not allowed in Second Normal Form.</p>
<img src="https://www.tutorialspoint.com/dbms/images/2nf.png" alt="Relation  in 2NF" />
<p>We broke the relation in two as depicted in the above picture. So there exists no partial dependency.</p>
<h2>Third Normal Form</h2>
<p>For a relation to be in Third Normal Form, it must be in Second Normal form and the following must satisfy &minus;</p>
<ul class="list">
<li>No non-prime attribute is transitively dependent on prime key attribute.</li>
<li>For any non-trivial functional dependency, X &#8594; A, then either &minus;
<ul class="list">
<li>X is a superkey or,</li>
<li>A is prime attribute.</li>
</ul>
</li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/not_3nf.png" alt="Relation not in 3NF" />
<p>We find that in the above Student_detail relation, Stu_ID is the key and only prime key attribute. We find that City can be identified by Stu_ID as well as Zip itself.  Neither Zip is a superkey nor is City a prime attribute. Additionally, Stu_ID &#8594; Zip &#8594; City, so there exists <b>transitive dependency</b>.</p>
<p>To bring this relation into third normal form, we break the relation into two relations as follows &minus;</p>
<img src="https://www.tutorialspoint.com/dbms/images/3nf.png" alt="Relation in 3NF" />
<h2>Boyce-Codd Normal Form</h2>
<p>Boyce-Codd Normal Form (BCNF) is an extension of Third Normal Form on strict terms. BCNF states that &minus;</p>
<ul class="list">
<li>For any non-trivial functional dependency, X &#8594; A, X must be a super-key.</li>
</ul>
<p>In the above image, Stu_ID is the super-key in the relation Student_Detail and Zip is the super-key in the relation ZipCodes. So,</p>
<p style="padding-left:20px;">Stu_ID &#8594; Stu_Name, Zip</p>
<p>and</p>
<p style="padding-left:20px;">Zip &#8594; City</p>
<p>Which confirms that both the relations are in BCNF.</p>
<h1>DBMS - Joins</h1>
<p>We understand the benefits of taking a Cartesian product of two relations, which gives us all the possible tuples that are paired together. But it might not be feasible for us in certain cases to take a Cartesian product where we encounter huge relations with thousands of tuples having a considerable large number of attributes.</p>
<p><b>Join</b> is a combination of a Cartesian product followed by a selection process. A Join operation pairs two tuples from different relations, if and only if a given join condition is satisfied.</p>
<p>We will briefly describe various join types in the following sections.</p>
<h2>Theta (&#952;) Join </h2>
<p>Theta join combines tuples from different relations provided they satisfy the theta condition. The join condition is denoted by the symbol <b>&#952;</b>.</p>
<h3>Notation</h3>
<pre class="result notranslate">
R1 &#8904;<sub>&#952;</sub> R2
</pre>
<p>R1 and R2 are relations having attributes (A1, A2, .., An) and (B1, B2,.. ,Bn) such that the attributes don’t have anything in common, that is R1 &#8745; R2 = &#934;.</p>
<p>Theta join can use all kinds of comparison operators.</p>
<table class="table table-bordered">
<tr>
<th colspan="3" style="text-align:center;">Student</th>
</tr>
<tr>
<th>SID</th>
<th>Name</th>
<th>Std</th>
</tr>
<tr>
<td>101</td>
<td>Alex</td>
<td>10</td>
</tr>
<tr>
<td>102</td>
<td>Maria</td>
<td>11</td>
</tr>
</table>
<table class="table table-bordered">
<tr>
<th colspan="2" style="text-align:center">Subjects</th>
</tr>
<tr>
<th>Class</th>
<th>Subject</th>
</tr>
<tr>
<td>10</th>
<td>Math</td>
</tr>
<tr>
<td>10</th>
<td>English</td>
</tr>
<tr>
<td>11</th>
<td>Music</td>
</tr>
<tr>
<td>11</th>
<td>Sports</td>
</tr>
</table>
<p>Student_Detail =</p>
<pre class="result notranslate">
STUDENT <big>&#8904;</big><sub>Student.Std = Subject.Class</sub> SUBJECT</p>
</pre>
<p></p>
<table class="table table-bordered">
<tr>
<th colspan="5" style="text-align:center">Student_detail</th>
</tr>
<tr>
<th>SID</th>
<th>Name</th>
<th>Std</th>
<th>Class</th>
<th>Subject</th>
</tr>
<tr>
<td>101</th>
<td>Alex</td>
<td>10</td>
<td>10</th>
<td>Math</td>
</tr>
<tr>
<td>101</th>
<td>Alex</td>
<td>10</td>
<td>10</th>
<td>English</td>
</tr>
<tr>
<td>102</th>
<td>Maria</td>
<td>11</td>
<td>11</th>
<td>Music</td>
</tr>
<tr>
<td>102</th>
<td>Maria</td>
<td>11</td>
<td>11</th>
<td>Sports</td>
</tr>
</table>
<h2>Equijoin</h2>
<p>When Theta join uses only <b>equality</b> comparison operator, it is said to be equijoin. The above example corresponds to equijoin.</p>
<h2>Natural Join (<big>&#8904;</big>)</h2>
<p>Natural join does not use any comparison operator. It does not concatenate the way a Cartesian product does. We can perform a Natural Join only if there is at least one common attribute that exists between two relations. In addition, the attributes must have the same name and domain.</p>
<p>Natural join acts on those matching attributes where the values of attributes in both the relations are same.</p>
<table class="table table-bordered">
<tr>
<th colspan="3" style="text-align:center;">Courses</th>
</tr>
<tr>
<th>CID</th>
<th>Course</th>
<th>Dept</th>
</tr>
<tr>
<td>CS01</td>
<td>Database</td>
<td>CS</td>
</tr>
<tr>
<td>ME01</td>
<td>Mechanics</td>
<td>ME</td>
</tr>
<tr>
<td>EE01</td>
<td>Electronics</td>
<td>EE</td>
</tr>
</table>
<table class="table table-bordered">
<tr>
<th colspan="2" style="text-align:center;">HoD</th>
</tr>
<tr>
<th>Dept</th>
<th>Head</th>
</tr>
<tr>
<td>CS</td>
<td>Alex</td>
</tr>
<tr>
<td>ME</td>
<td>Maya</td>
</tr>
<tr>
<td>EE</td>
<td>Mira</td>
</tr>
</table>
<table class="table table-bordered">
<tr>
<th colspan="4" style="text-align:center;">Courses &#8904; HoD</th>
</tr>
<tr>
<th>Dept</th>
<th>CID</th>
<th>Course</th>
<th>Head</th>
</tr>
<tr>
<td>CS</td>
<td>CS01</td>
<td>Database</td>
<td>Alex</td>
</tr>
<tr>
<td>ME</td>
<td>ME01</td>
<td>Mechanics</td>
<td>Maya</td>
</tr>
<tr>
<td>EE</td>
<td>EE01</td>
<td>Electronics</td>
<td>Mira</td>
</tr>
</table>
<h2>Outer Joins</h2>
<p>Theta Join, Equijoin, and Natural Join are called inner joins. An inner join includes only those tuples with matching attributes and the rest are discarded in the resulting relation. Therefore, we need to use outer joins to include all the tuples from the participating relations in the resulting relation. There are three kinds of outer joins &minus; left outer join, right outer join, and full outer join.</p>
<h2>Left Outer Join(R <img src="https://www.tutorialspoint.com/dbms/images/left_outer_join.png" width="14" style="display:inline; padding-bottom: 0px;" alt="Left Outer Join" /> S)</h2>
<p>All the tuples from the Left relation, R, are included in the resulting relation. If there are tuples in R without any matching tuple in the Right relation S, then the S-attributes of the resulting relation are made NULL.</p>
<table class="table table-bordered">
<tr>
<th colspan="2" style="text-align:center;">Left</th>
</tr>
<tr>
<th>A</th>
<th>B</th>
</tr>
<tr>
<td>100</td>
<td>Database</td>
</tr>
<tr>
<td>101</td>
<td>Mechanics</td>
</tr>
<tr>
<td>102</td>
<td>Electronics</td>
</tr>
</table>
<table class="table table-bordered">
<tr>
<th colspan="2" style="text-align:center;">Right</th>
</tr>
<tr>
<th>A</th>
<th>B</th>
</tr>
<tr>
<td>100</td>
<td>Alex</td>
</tr>
<tr>
<td>102</td>
<td>Maya</td>
</tr>
<tr>
<td>104</td>
<td>Mira</td>
</tr>
</table>
<table class="table table-bordered">
<tr>
<th colspan="4" style="text-align:center;">Courses <img src="https://www.tutorialspoint.com/dbms/images/left_outer_join.png" width="13" style="display:inline; padding-bottom: 0px;" alt="Left Outer Join" /> HoD</th>
</tr>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
<tr>
<td>100</td>
<td>Database</td>
<td>100</td>
<td>Alex</td>
</tr>
<tr>
<td>101</td>
<td>Mechanics</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>102</td>
<td>Electronics</td>
<td>102</td>
<td>Maya</td>
</tr>
</table>
<h2>Right Outer Join: ( R <img src="https://www.tutorialspoint.com/dbms/images/right_outer_join.png" width="13" style="display:inline; padding-bottom: 0px;" alt="Right Outer Join" /> S )</h2>
<p>All the tuples from the Right relation, S, are included in the resulting relation. If there are tuples in S without any matching tuple in R, then the R-attributes of resulting relation are made NULL.</p>
<table class="table table-bordered">
<tr>
<th colspan="4" style="text-align:center;">Courses <img src="https://www.tutorialspoint.com/dbms/images/right_outer_join.png" width="13" style="display:inline; padding-bottom: 0px;" alt="Right Outer Join" /> HoD</th>
</tr>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
<tr>
<td>100</td>
<td>Database</td>
<td>100</td>
<td>Alex</td>
</tr>
<tr>
<td>102</td>
<td>Electronics</td>
<td>102</td>
<td>Maya</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
<td>104</td>
<td>Mira</td>
</tr>
</table>
<h2>Full Outer Join: ( R <img src="https://www.tutorialspoint.com/dbms/images/full_outer_join.png" width="16" style="display:inline; padding-bottom: 0px;" alt="Full Outer Join" /> S)</h2>
<p>All the tuples from both participating relations are included in the resulting relation. If there are no matching tuples for both relations, their respective unmatched attributes are made NULL.</p>
<table class="table table-bordered">
<tr>
<th colspan="4" style="text-align:center;">Courses <img src="https://www.tutorialspoint.com/dbms/images/full_outer_join.png" width="13" style="display:inline; padding-bottom: 0px;" alt="Full Outer Join" /> HoD</th>
</tr>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
<tr>
<td>100</td>
<td>Database</td>
<td>100</td>
<td>Alex</td>
</tr>
<tr>
<td>101</td>
<td>Mechanics</td>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>102</td>
<td>Electronics</td>
<td>102</td>
<td>Maya</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
<td>104</td>
<td>Mira</td>
</tr>
</table>
<h1>DBMS - Storage System</h1>
<p>Databases are stored in file formats, which contain records. At physical level, the actual data is stored in electromagnetic format on some device. These storage devices can be broadly categorized into three types &minus;</p>
<img src="https://www.tutorialspoint.com/dbms/images/memory_types.png" alt="Memory Types" />
<ul class="list">
<li><p><b>Primary Storage</b> &minus; The memory storage that is directly accessible to the CPU comes under this category. CPU's internal memory (registers), fast memory (cache), and main memory (RAM) are directly accessible to the CPU, as they are all placed on the motherboard or CPU chipset. This storage is typically very small, ultra-fast, and volatile. Primary storage requires continuous power supply in order to maintain its state. In case of a power failure, all its data is lost.</p></li>
<li><p><b>Secondary Storage</b> &minus; Secondary storage devices are used to store data for future use or as backup. Secondary storage includes memory devices that are not a part of the CPU chipset or motherboard, for example, magnetic disks, optical disks (DVD, CD, etc.), hard disks, flash drives, and magnetic tapes.</p></li>
<li><p><b>Tertiary Storage</b> &minus; Tertiary storage is used to store huge volumes of data. Since such storage devices are external to the computer system, they are the slowest in speed. These storage devices are mostly used to take the back up of an entire system. Optical disks and magnetic tapes are widely used as tertiary storage.</p></li>
</ul>
<h2>Memory Hierarchy</h2>
<p>A computer system has a well-defined hierarchy of memory. A CPU has direct access to it main memory as well as its inbuilt registers. The access time of the main memory is obviously less than the CPU speed. To minimize this speed mismatch, cache memory is introduced. Cache memory provides the fastest access time and it contains data that is most frequently accessed by the CPU.</p>
<p>The memory with the fastest access is the costliest one. Larger storage devices offer slow speed and they are less expensive, however they can store huge volumes of data as compared to CPU registers or cache memory.</p>
<h2>Magnetic Disks</h2>
<p>Hard disk drives are the most common secondary storage devices in present computer systems. These are called magnetic disks because they use the concept of magnetization to store information. Hard disks consist of metal disks coated with magnetizable material. These disks are placed vertically on a spindle. A read/write head moves in between the disks and is used to magnetize or de-magnetize the spot under it. A magnetized spot can be recognized as 0 (zero) or 1 (one).</p>
<p>Hard disks are formatted in a well-defined order to store data efficiently. A hard disk plate has many concentric circles on it, called <b>tracks</b>. Every track is further divided into <b>sectors</b>. A sector on a hard disk typically stores 512 bytes of data.</p>
<h2>RAID</h2>
<p>RAID stands for <b>R</b>edundant <b>A</b>rray of <b>I</b>ndependent <b>D</b>isks, which is a technology to connect multiple secondary storage devices and use them as a single storage media.</p>
<p>RAID consists of an array of disks in which multiple disks are connected together to achieve different goals. RAID levels define the use of disk arrays.</p>
<ul class="list">
<li><p><b>RAID 0</b> &minus; In this level, a striped array of disks is implemented. The data is broken down into blocks and the blocks are distributed among disks. Each disk receives a block of data to write/read in parallel. It enhances the speed and performance of the storage device. There is no parity and backup in Level 0.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_0.png" alt="RAID 0" />
<ul class="list">
<li><p><b>RAID 1</b> &minus; RAID 1 uses mirroring techniques. When data is sent to a RAID controller, it sends a copy of data to all the disks in the array. RAID level 1 is also called <b>mirroring</b> and provides 100% redundancy in case of a failure.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_1.png" alt="RAID 1" />
<ul class="list">
<li><p><b>RAID 2</b> &minus; RAID 2 records Error Correction Code using Hamming distance for its data, striped on different disks. Like level 0, each data bit in a word is recorded on a separate disk and ECC codes of the data words are stored on a different set disks. Due to its complex structure and high cost, RAID 2 is not commercially available.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_2.png" alt="RAID 2" />
<ul class="list">
<li><p><b>RAID 3</b> &minus; RAID 3 stripes the data onto multiple disks. The parity bit generated for data word is stored on a different disk. This technique makes it to overcome single disk failures.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_3.png" alt="RAID 3" />
<ul class="list"> 
<li><p><b>RAID 4</b> &minus; In this level, an entire block of data is written onto data disks and then the parity is generated and stored on a different disk. Note that level 3 uses byte-level striping, whereas level 4 uses block-level striping. Both level 3 and level 4 require at least three disks to implement RAID.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_4.png" alt="RAID 4" />
<ul class="list">  
<li><p><b>RAID 5</b> &minus; RAID 5 writes whole data blocks onto different disks, but the parity bits generated for data block stripe are distributed among all the data disks rather than storing them on a different dedicated disk.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_5.png" alt="RAID 5" />
<ul class="list">
<li><p><b>RAID 6</b> &minus; RAID 6 is an extension of level 5. In this level, two independent parities are generated and stored in distributed fashion among multiple disks. Two parities provide additional fault tolerance. This level requires at least four disk drives to implement RAID.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/raid_6.png" caption="RAID 6" />
<h1>DBMS - File Structure</h1>
<p>Relative data and information is stored collectively in file formats. A file is a sequence of records stored in binary format. A disk drive is formatted into several blocks that can store records. File records are mapped onto those disk blocks.</p>
<h2>File Organization</h2>
<p>File Organization defines how file records are mapped onto disk blocks. We have four types of File Organization to organize file records &minus;</p>
<img src="https://www.tutorialspoint.com/dbms/images/file_organization.png" alt="File Organization" /> 
<h2>Heap File Organization</h2>
<p>When a file is created using Heap File Organization, the Operating System allocates memory area to that file without any further accounting details. File records can be placed anywhere in that memory area. It is the responsibility of the software to manage the records. Heap File does not support any ordering, sequencing, or indexing on its own.</p>
<h2>Sequential File Organization</h2>
<p>Every file record contains a data field (attribute) to uniquely identify that record. In sequential file organization, records are placed in the file in some sequential order based on the unique key field or search key. Practically, it is not possible to store all the records sequentially in physical form.</p>
<h2>Hash File Organization</h2>
<p>Hash File Organization uses Hash function computation on some fields of the records. The output of the hash function determines the location of disk block where the records are to be placed.</p>
<h2>Clustered File Organization</h2>
<p>Clustered file organization is not considered good for large databases. In this mechanism, related records from one or more relations are kept in the same disk block, that is, the ordering of records is not based on primary key or search key.</p>
<h2>File Operations</h2>
<p>Operations on database files can be broadly classified into two categories &minus;</p>
<ul class="list">
<li><p><b>Update Operations</b></p></li>
<li><p><b>Retrieval Operations</b></p></li>
</ul>
<p>Update operations change the data values by insertion, deletion, or update. Retrieval operations, on the other hand, do not alter the data but retrieve them after optional conditional filtering. In both types of operations, selection plays a significant role. Other than creation and deletion of a file, there could be several operations, which can be done on files.</p>
<ul class="list">
<li><p><b>Open</b> &minus; A file can be opened in one of the two modes, <b>read mode</b> or <b>write mode</b>. In read mode, the operating system does not allow anyone to alter data. In other words, data is read only. Files opened in read mode can be shared among several entities. Write mode allows data modification. Files opened in write mode can be read but cannot be shared.<p></li>
<li><p><b>Locate</b> &minus; Every file has a file pointer, which tells the current position where the data is to be read or written. This pointer can be adjusted accordingly. Using find (seek) operation, it can be moved forward or backward.</p></li>
<li><p><b>Read</b> &minus; By default, when files are opened in read mode, the file pointer points to the beginning of the file. There are options where the user can tell the operating system where to locate the file pointer at the time of opening a file. The very next data to the file pointer is read.</p></li>
<li><p><b>Write</b> &minus; User can select to open a file in write mode, which enables them to edit its contents. It can be deletion, insertion, or modification. The file pointer can be located at the time of opening or can be dynamically changed if the operating system allows to do so.</p></li>
<li><p><b>Close</b> &minus; This is the most important operation from the operating system’s point of view. When a request to close a file is generated, the operating system</p>
<ul class="list">
<li>removes all the locks (if in shared mode),</li>
<li>saves the data (if altered) to the secondary storage media, and</li>
<li>releases all the buffers and file handlers associated with the file.</li>
</ul>
</li>
</ul>
<p>The organization of data inside a file plays a major role here. The process to locate the file pointer to a desired record inside a file various based on whether the records are arranged sequentially or clustered.</p>
<h1>DBMS - Indexing</h1>
<p>We know that data is stored in the form of records. Every record has a key field, which helps it to be recognized uniquely.</p>
<p>Indexing is a data structure technique to efficiently retrieve records from the database files based on some attributes on which the indexing has been done. Indexing in database systems is similar to what we see in books.</p>
<p>Indexing is defined based on its indexing attributes. Indexing can be of the following types &minus;</p>
<ul class="list">
<li><p><b>Primary Index</b> &minus; Primary index is defined on an ordered data file. The data file is ordered on a <b>key field</b>. The key field is generally the primary key of the relation.</p></li>
<li><p><b>Secondary Index</b> &minus; Secondary index may be generated from a field which is a candidate key and has a unique value in every record, or a non-key with duplicate values.</p></li>
<li><p><b>Clustering Index</b> &minus; Clustering index is defined on an ordered data file. The data file is ordered on a non-key field.</p></li>
</ul>
<p>Ordered Indexing is of two types &minus;</p>
<ul class="list">
<li>Dense Index</li>
<li>Sparse Index</li>
</ul>
<h2>Dense Index</h2>
<p>In dense index, there is an index record for every search key value in the database. This makes searching faster but requires more space to store index records itself. Index records contain search key value and a pointer to the actual record on the disk.</p>
<img src="https://www.tutorialspoint.com/dbms/images/dense_index.png" alt="Dense Index" />
<h2>Sparse Index</h2>
<p>In sparse index, index records are not created for every search key. An index record here contains a search key and an actual pointer to the data on the disk. To search a record, we first proceed by index record and reach at the actual location of the data. If the data we are looking for is not where we directly reach by following the index, then the system starts sequential search until the desired data is found.</p>
<img src="https://www.tutorialspoint.com/dbms/images/sparse_index.png" alt="Sparse Index" />
<h2>Multilevel Index</h2>
<p>Index records comprise search-key values and data pointers. Multilevel index is stored on the disk along with the actual database files. As the size of the database grows, so does the size of the indices. There is an immense need to keep the index records in the main memory so as to speed up the search operations. If single-level index is used, then a large size index cannot be kept in memory which leads to multiple disk accesses.</p>
<img src="https://www.tutorialspoint.com/dbms/images/multi_level_index.png" alt="Multi-level Index" />
<p>Multi-level Index helps in breaking down the index into several smaller indices in order to make the outermost level so small that it can be saved in a single disk block, which can easily be accommodated anywhere in the main memory.</p>
<h2>B<sup><small>+</small></sup> Tree</h2>
<p>A B<sup><small>+</small></sup> tree is a balanced binary search tree that follows a multi-level index format. The leaf nodes of a B<sup><small>+</small></sup> tree denote actual data pointers. B<sup><small>+</small></sup> tree ensures that all leaf nodes remain at the same height, thus balanced. Additionally, the leaf nodes are linked using a link list; therefore, a B<sup><small>+</small></sup> tree can support random access as well as sequential access.</p>
<h3>Structure of B<sup><small>+</small></sup> Tree</h3>
<p>Every leaf node is at equal distance from the root node. A B<sup><small>+</small></sup> tree is of the order <b>n</b> where <b>n</b> is fixed for every B<sup><small>+</small></sup> tree.</p>
<img src="https://www.tutorialspoint.com/dbms/images/b_plus_tree.png" alt="B+ tree" />
<p><b>Internal nodes</b> &minus;</p>
<ul class="list">
<li>Internal (non-leaf) nodes contain at least &#8968;n/2&#8969; pointers, except the root node.</li>
<li>At most, an internal node can contain <b>n</b> pointers.</li>
</ul>
<p><b>Leaf nodes</b> &minus;</p>
<ul class="list">
<li>Leaf nodes contain at least &#8968;n/2&#8969; record pointers and &#8968;n/2&#8969; key values.</li>
<li>At most, a leaf node can contain <b>n</b> record pointers and <b>n</b> key values.</li>
<li>Every leaf node contains one block pointer <b>P</b> to point to next leaf node and forms a linked list.</li>
</ul>
<h3>B<sup><small>+</small></sup> Tree Insertion</h3>
<ul class="list">
<li><p>B<sup><small>+</small></sup> trees are filled from bottom and each entry is done at the leaf node.</p></li>
<li>If a leaf node overflows &minus;
<ul class="list">
<li><p>Split node into two parts.</p></li>
<li><p>Partition at <b>i = &#8970;(m+1)<sub><small>/2</small></sub>&#8971;.</b></p></li>
<li><p>First <b>i</b> entries are stored in one node.</p></li>
<li><p>Rest of the entries (i+1 onwards) are moved to a new node.</p></li>
<li><p><b>i<sup><small><i>th</b></i></small></sup> key is duplicated at the parent of the leaf.</p></li>
</ul>
</li>
<li><p>If a non-leaf node overflows &minus;</p>
<ul class="list">
<li><p>Split node into two parts.</p></li>
<li><p>Partition the node at <b>i = &#8968;(m+1)<sub><small>/2</small></sub>&#8969;</b>.</p></li>
<li><p>Entries up to <b>i</b> are kept in one node.</p></li>
<li><p>Rest of the entries are moved to a new node.</p></li>
</ul>
</li>
</ul>
<h3>B<sup><small>+</small></sup> Tree Deletion</h3>
<ul class="list">
<li><p>B<sup><small>+</small></sup> tree entries are deleted at the leaf nodes.</p></li>
<li><p>The target entry is searched and deleted.</p>
<ul class="list">
<li><p>If it is an internal node, delete and replace with the entry from the left position.</p></li>
</ul>
</li>
<li><p>After deletion, underflow is tested,</p>
<ul class="list">
<li><p>If underflow occurs, distribute the entries from the nodes left to it.</p></li>
</ul>
</li>
<li><p>If distribution is not possible from left, then</p>
<ul class="list">
<li><p>Distribute from the nodes right to it.</p></li>
</ul>
</li>
<li><p>If distribution is not possible from left or from right, then</p>
<ul class="list">  
<li><p>Merge the node with left and right to it.</p></li>
</ul>
</li>
</ul>
<h1>DBMS - Hashing</h1>
<p>For a huge database structure, it can be almost next to impossible to search all the index values through all its level and then reach the destination data block to retrieve the desired data. Hashing is an effective technique to calculate the direct location of a data record on the disk without using index structure.</p>
<p>Hashing uses hash functions with search keys as parameters to generate the address of a data record.</p>
<h2>Hash Organization</h2>
<ul class="list">
<li><p><b>Bucket</b> &minus; A hash file stores data in bucket format. Bucket is considered a unit of storage. A bucket typically stores one complete disk block, which in turn can store one or more records.</p></li>
<li><p><b>Hash Function</b> &minus; A hash function, <b>h,</b> is a mapping function that maps all the set of search-keys <b>K</b> to the address where actual records are placed. It is a function from search keys to bucket addresses.</p></li>
</ul>
<h2>Static Hashing</h2>
<p>In static hashing, when a search-key value is provided, the hash function always computes the same address. For example, if mod-4 hash function is used, then it shall generate only 5 values. The output address shall always be same for that function. The number of buckets provided remains unchanged at all times.</p>
<img src="https://www.tutorialspoint.com/dbms/images/static_hash.png" alt="Static Hashing" />
<h3>Operation</h3>
<ul class="list">
<li><p><b>Insertion</b> &minus; When a record is required to be entered using static hash, the hash function <b>h</b> computes the bucket address for search key <b>K</b>, where the record will be stored.</p>
<p>Bucket address = h(K)</p></li>
<li><p><b>Search</b> &minus; When a record needs to be retrieved, the same hash function can be used to retrieve the address of the bucket where the data is stored.</p></li>
<li><p><b>Delete</b> &minus; This is simply a search followed by a deletion operation.</p></li>
</ul>
<h2>Bucket Overflow</h2>
<p>The condition of bucket-overflow is known as <b>collision</b>. This is a fatal state for any static hash function. In this case, overflow chaining can be used.</p>
<ul class="list">
<li><p><b>Overflow Chaining</b> &minus; When buckets are full, a new bucket is allocated for the same hash result and is linked after the previous one. This mechanism is called <b>Closed Hashing</b>.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/hash_chaining.png" alt="Overflow chaining" />
<ul class="list">
<li><p><b>Linear Probing</b> &minus; When a hash function generates an address at which data is already stored, the next free bucket is allocated to it. This mechanism is called <b>Open Hashing</b>.</p></li>
</ul>
<img src="https://www.tutorialspoint.com/dbms/images/hash_linear_probing.png" alt="Linear Probing" />
<h2>Dynamic Hashing</h2>
<p>The problem with static hashing is that it does not expand or shrink dynamically as the size of the database grows or shrinks. Dynamic hashing provides a mechanism in which data buckets are added and removed dynamically and on-demand. Dynamic hashing is also known as <b>extended hashing</b>.</p>
<p>Hash function, in dynamic hashing, is made to produce a large number of values and only a few are used initially.</p>
<img src="https://www.tutorialspoint.com/dbms/images/dynamic_hashing.png" alt="Dynamic Hashing" /> 
<h2>Organization</h2>
<p>The prefix of an entire hash value is taken as a hash index. Only a portion of the hash value is used for computing bucket addresses. Every hash index has a depth value to signify how many bits are used for computing a hash function. These bits can address 2n buckets. When all these bits are consumed &minus; that is, when all the buckets are full &minus; then the depth value is increased linearly and twice the buckets are allocated.</p>
<h2>Operation</h2>
<ul class="list">
<li><p><b>Querying</b> &minus; Look at the depth value of the hash index and use those bits to compute the bucket address.</p></li>
<li><p><b>Update</b> &minus; Perform a query as above and update the data.</p></li>
<li><p><b>Deletion</b> &minus; Perform a query to locate the desired data and delete the same.</p></li>
<li><p><b>Insertion</b> &minus; Compute the address of the bucket</p>
<ul class="list">
<li>If the bucket is already full.
<ul class="list">
<li>Add more buckets.</li>
<li>Add additional bits to the hash value.</li>
<li>Re-compute the hash function.</li>
</ul>
</li>
<li>Else
<ul class="list">
<li>Add data to the bucket,</li>
</ul>
</li>
<li>If all the buckets are full, perform the remedies of static hashing.</li>
</ul>
</li>
</ul>
<p>Hashing is not favorable when the data is organized in some ordering and the queries require a range of data. When data is discrete and random, hash performs the best.</p>
<p>Hashing algorithms have high complexity than indexing. All hash operations are done in constant time.</p>
<h1>DBMS - Transaction</h1>
<p>A transaction can be defined as a group of tasks. A single task is the minimum processing unit which cannot be divided further.</p>
<p>Let’s take an example of a simple transaction. Suppose a bank employee transfers Rs 500 from A's account to B's account. This very simple and small transaction involves several low-level tasks.</p>
<p><b>A’s Account</b></p>
<pre class="result notranslate">
Open_Account(A)
Old_Balance = A.balance
New_Balance = Old_Balance - 500
A.balance = New_Balance
Close_Account(A)
</pre>
<p><b>B’s Account</b></p>
<pre class="result notranslate">
Open_Account(B)
Old_Balance = B.balance
New_Balance = Old_Balance + 500
B.balance = New_Balance
Close_Account(B)
</pre>
<h2>ACID Properties</h2>
<p>A transaction is a very small unit of a program and it may contain several lowlevel tasks. A transaction in a database system must maintain <b>A</b>tomicity, <b>C</b>onsistency, <b>I</b>solation, and <b>D</b>urability &minus; commonly known as ACID properties &minus; in order to ensure accuracy, completeness, and data integrity.</p>
<ul class="list">
<li><p><b>Atomicity</b> &minus; This property states that a transaction must be treated as an atomic unit, that is, either all of its operations are executed or none. There must be no state in a database where a transaction is left partially completed. States should be defined either before the execution of the transaction or after the execution/abortion/failure of the transaction.</p></li>
<li><p><b>Consistency</b> &minus; The database must remain in a consistent state after any transaction. No transaction should have any adverse effect on the data residing in the database. If the database was in a consistent state before the execution of a transaction, it must remain consistent after the execution of the transaction as well.</p></li>
<li><p><b>Durability</b> &minus; The database should be durable enough to hold all its latest updates even if the system fails or restarts. If a transaction updates a chunk of data in a database and commits, then the database will hold the modified data. If a transaction commits but the system fails before the data could be written on to the disk, then that data will be updated once the system springs back into action.</p></li>
<li><p><b>Isolation</b> &minus; In a database system where more than one transaction are being executed simultaneously and in parallel, the property of isolation states that all the transactions will be carried out and executed as if it is the only transaction in the system. No transaction will affect the existence of any other transaction.</p></li>
</ul>
<h2>Serializability</h2>
<p>When multiple transactions are being executed by the operating system in a multiprogramming environment, there are possibilities that instructions of one transactions are interleaved with some other transaction.</p>
<ul class="list">
<li><p><b>Schedule</b> &minus; A chronological execution sequence of a transaction is called a schedule. A schedule can have many transactions in it, each comprising of a number of instructions/tasks.</p></li>
<li><p><b>Serial Schedule</b> &minus; It is a schedule in which transactions are aligned in such a way that one transaction is executed first. When the first transaction completes its cycle, then the next transaction is executed. Transactions are ordered one after the other. This type of schedule is called a serial schedule, as transactions are executed in a serial manner.</p></li>
</ul>
<p>In a multi-transaction environment, serial schedules are considered as a benchmark. The execution sequence of an instruction in a transaction cannot be changed, but two transactions can have their instructions executed in a random fashion. This execution does no harm if two transactions are mutually independent and working on different segments of data; but in case these two transactions are working on the same data, then the results may vary. This ever-varying result may bring the database to an inconsistent state.</p>
<p>To resolve this problem, we allow parallel execution of a transaction schedule, if its transactions are either serializable or have some equivalence relation among them.</p>
<h2>Equivalence Schedules</h2>
<p>An equivalence schedule can be of the following types &minus;</p>
<h3>Result Equivalence</h3>
<p>If two schedules produce the same result after execution, they are said to be result equivalent. They may yield the same result for some value and different results for another set of values. That's why this equivalence is not generally considered significant.</p>
<h3>View Equivalence</h3>
<p>Two schedules would be view equivalence if the transactions in both the schedules perform similar actions in a similar manner.</p>
<p>For example &minus;</p>
<ul class="list">
<li><p>If T reads the initial data in S1, then it also reads the initial data in S2.</p></li>
<li><p>If T reads the value written by J in S1, then it also reads the value written by J in S2.</p></li>
<li><p>If T performs the final write on the data value in S1, then it also performs the final write on the data value in S2.</p></li>
</ul>
<h3>Conflict Equivalence</h3>
<p>Two schedules would be conflicting if they have the following properties &minus;</p>
<ul class="list">
<li>Both belong to separate transactions.</li>
<li>Both accesses the same data item.</li>
<li>At least one of them is "write" operation.</li>
</ul>
<p>Two schedules having multiple transactions with conflicting operations are said to be conflict equivalent if and only if &minus;</p>
<ul class="list">
<li>Both the schedules contain the same set of Transactions.</li>
<li>The order of conflicting pairs of operation is maintained in both the schedules.</li>
</ul>
<p><b>Note</b> &minus; View equivalent schedules are view serializable and conflict equivalent schedules are conflict serializable. All conflict serializable schedules are view serializable too.</p>
<h2>States of Transactions</h2>
<p>A transaction in a database can be in one of the following states &minus;</p>
<img src="https://www.tutorialspoint.com/dbms/images/transaction_states.png" alt="Transaction States" />
<ul class="list">
<li><p><b>Active</b> &minus; In this state, the transaction is being executed. This is the initial state of every transaction.</p></li>
<li><p><b>Partially Committed</b> &minus; When a transaction executes its final operation, it is said to be in a partially committed state.</p></li>
<li><p><b>Failed</b> &minus; A transaction is said to be in a failed state if any of the checks made by the database recovery system fails. A failed transaction can no longer proceed further.</p></li>
<li><p><b>Aborted</b> &minus; If any of the checks fails and the transaction has reached a failed state, then the recovery manager rolls back all its write operations on the database to bring the database back to its original state where it was prior to the execution of the transaction. Transactions in this state are called aborted. The database recovery module can select one of the two operations after a transaction aborts &minus;</p>
<ul class="list">
<li>Re-start the transaction</li>
<li>Kill the transaction</li>
</ul>
</li>
<li><p><b>Committed</b> &minus; If a transaction executes all its operations successfully, it is said to be committed. All its effects are now permanently established on the database system.</p></li>
</ul>
<h1>DBMS - Concurrency Control</h1>
<p>In a multiprogramming environment where multiple transactions can be executed simultaneously, it is highly important to control the concurrency of transactions. We have concurrency control protocols to ensure atomicity, isolation, and serializability of concurrent transactions. Concurrency control protocols can be broadly divided into two categories &minus;</p>
<ul class="list">
<li>Lock based protocols</li>
<li>Time stamp based protocols</li>
</ul>
<h2>Lock-based Protocols</h2>
<p>Database systems equipped with lock-based protocols use a mechanism by which any transaction cannot read or write data until it acquires an appropriate lock on it. Locks are of two kinds &minus;</p>
<ul class="list">  
<li><p><b>Binary Locks</b> &minus; A lock on a data item can be in two states; it is either locked or unlocked.</p></li>
<li><p><b>Shared/exclusive</b> &minus; This type of locking mechanism differentiates the locks based on their uses. If a lock is acquired on a data item to perform a write operation, it is an exclusive lock. Allowing more than one transaction to write on the same data item would lead the database into an inconsistent state. Read locks are shared because no data value is being changed.</p></li>
</ul>
<p>There are four types of lock protocols available &minus;</p>
<h3>Simplistic Lock Protocol</h3>
<p>Simplistic lock-based protocols allow transactions to obtain a lock on every object before a 'write' operation is performed. Transactions may unlock the data item after completing the ‘write’ operation.</p>
<h3>Pre-claiming Lock Protocol</h3>
<p>Pre-claiming protocols evaluate their operations and create a list of data items on which they need locks. Before initiating an execution, the transaction requests the system for all the locks it needs beforehand. If all the locks are granted, the transaction executes and releases all the locks when all its operations are over. If all the locks are not granted, the transaction rolls back and waits until all the locks are granted.</p>
<img src="https://www.tutorialspoint.com/dbms/images/pre_claiming.png" alt="Pre-claiming" />
<h3>Two-Phase Locking 2PL</h3>
<p>This locking protocol divides the execution phase of a transaction into three parts. In the first part, when the transaction starts executing, it seeks permission for the locks it requires. The second part is where the transaction acquires all the locks. As soon as the transaction releases its first lock, the third phase starts. In this phase, the transaction cannot demand any new locks; it only releases the acquired locks.</p>
<img src="https://www.tutorialspoint.com/dbms/images/2PL.png" alt="Two Phase Locking" />
<p>Two-phase locking has two phases, one is <b>growing</b>, where all the locks are being acquired by the transaction; and the second phase is shrinking, where the locks held by the transaction are being released.</p>
<p>To claim an exclusive (write) lock, a transaction must first acquire a shared (read) lock and then upgrade it to an exclusive lock.</p>
<h3>Strict Two-Phase Locking</h3>
<p>The first phase of Strict-2PL is same as 2PL. After acquiring all the locks in the first phase, the transaction continues to execute normally. But in contrast to 2PL, Strict-2PL does not release a lock after using it. Strict-2PL holds all the locks until the commit point and releases all the locks at a time.</p>
<img src="https://www.tutorialspoint.com/dbms/images/strict_2PL.png" alt="Strict Two Phase Locking" />
<p>Strict-2PL does not have cascading abort as 2PL does.</p>
<h2>Timestamp-based Protocols</h2>
<p>The most commonly used concurrency protocol is the timestamp based protocol. This protocol uses either system time or logical counter as a timestamp.</p>
<p>Lock-based protocols manage the order between the conflicting pairs among transactions at the time of execution, whereas timestamp-based protocols start working as soon as a transaction is created.</p>
<p>Every transaction has a timestamp associated with it, and the ordering is determined by the age of the transaction. A transaction created at 0002 clock time would be older than all other transactions that come after it. For example, any transaction 'y' entering the system at 0004 is two seconds younger and the priority would be given to the older one.</p>
<p>In addition, every data item is given the latest read and write-timestamp. This lets the system know when the last ‘read and write’ operation was performed on the data item.</p>
<h2>Timestamp Ordering Protocol</h2>
<p>The timestamp-ordering protocol ensures serializability among transactions in their conflicting read and write operations. This is the responsibility of the protocol system that the conflicting pair of tasks should be executed according to the timestamp values of the transactions.</p>
<ul class="list">
<li>The timestamp of transaction T<sub><small>i</small></sub> is denoted as TS(T<sub><small>i</small></sub>).</li>
<li>Read time-stamp of data-item X is denoted by R-timestamp(X).</li>
<li>Write time-stamp of data-item X is denoted by W-timestamp(X).</li>
</ul>
<p>Timestamp ordering protocol works as follows &minus;</p>
<ul class="list">
<li><p><b>If a transaction Ti issues a read(X) operation &minus;</b></p></li>
<ul class="list">
<li>If TS(Ti) &lt; W-timestamp(X)
<ul class="list">
<li>Operation rejected.</li>
</ul>
</li>
<li>If TS(Ti) >= W-timestamp(X)
<ul class="list">
<li>Operation executed.</li>
</ul>
</li>
<li>All data-item timestamps updated.</li>
</ul>
<li><p><b>If a transaction Ti issues a write(X) operation &minus;</b></p></li>
<ul class="list">
<li>If TS(Ti) &lt; R-timestamp(X)</li>
<ul class="list">
<li>Operation rejected.</li>
</ul>
<li>If TS(Ti) &lt; W-timestamp(X)</li>
<ul class="list">
<li>Operation rejected and Ti rolled back.</li>
</ul>
<li>Otherwise, operation executed.</li>
</ul>
</ul>
<h3>Thomas' Write Rule</h3>
<p>This rule states if TS(Ti) &lt; W-timestamp(X), then the operation is rejected and T<sub><small>i</small></sub> is rolled back.</p>
<p>Time-stamp ordering rules can be modified to make the schedule view serializable.</p>
<p>Instead of making T<sub><small>i</small></sub> rolled back, the 'write' operation itself is ignored.</p>
<h1>DBMS - Deadlock</h1>
<p>In a multi-process system, deadlock is an unwanted situation that arises in a shared resource environment, where a process indefinitely waits for a resource that is held by another process.</p>
<p>For example, assume a set of transactions {T<sub><small>0</small></sub>, T<sub><small>1</small></sub>, T<sub><small>2</small></sub>, ...,T<sub><small>n</small></sub>}.  T<sub><small>0</small></sub> needs a resource X to complete its task.  Resource X is held by T<sub><small>1</small></sub>, and T<sub><small>1</small></sub> is waiting for a resource Y, which is held by T<sub><small>2</small></sub>.  T<sub><small>2</small></sub> is waiting for resource Z, which is held by T<sub><small>0</small></sub>.  Thus, all the processes wait for each other to release resources. In this situation, none of the processes can finish their task. This situation is known as a deadlock.</p>
<p>Deadlocks are not healthy for a system. In case a system is stuck in a deadlock, the transactions involved in the deadlock are either rolled back or restarted.</p>
<h2>Deadlock Prevention</h2>
<p>To prevent any deadlock situation in the system, the DBMS aggressively inspects all the operations, where transactions are about to execute. The DBMS inspects the operations and analyzes if they can create a deadlock situation. If it finds that a deadlock situation might occur, then that transaction is never allowed to be executed.</p>
<p>There are deadlock prevention schemes that use timestamp ordering mechanism of transactions in order to predetermine a deadlock situation.</p>
<h3>Wait-Die Scheme</h3>
<p>In this scheme, if a transaction requests to lock a resource (data item), which is already held with a conflicting lock by another transaction, then one of the two possibilities may occur &minus;</p>
<ul class="list">
<li><p>If TS(T<sub><small>i</small></sub>) &lt; TS(T<sub><small>j</small></sub>) &minus; that is T<sub><small>i</small></sub>, which is requesting a conflicting lock, is older than T<sub><small>j</small></sub> &minus; then  T<sub><small>i</small></sub> is allowed to wait until the data-item is available.</p></li>
<li><p>If TS(T<sub><small>i</small></sub>) &gt; TS(t<sub><small>j</small></sub>) &minus; that is T<sub><small>i</small></sub> is younger than T<sub><small>j</small></sub> &minus; then T<sub><small>i</small></sub> dies.  T<sub><small>i</small></sub> is restarted later with a random delay but with the same timestamp.</p></li>
</ul>
<p>This scheme allows the older transaction to wait but kills the younger one.</p>
<h3>Wound-Wait Scheme</h3>
<p>In this scheme, if a transaction requests to lock a resource (data item), which is already held with conflicting lock by some another transaction, one of the two possibilities may occur &minus;</p>
<ul class="list">
<li><p>If TS(T<sub><small>i</small></sub>) &lt; TS(T<sub><small>j</small></sub>), then T<sub><small>i</small></sub> forces T<sub><small>j</small></sub> to be rolled back &minus; that is T<sub><small>i</small></sub> wounds T<sub><small>j</small></sub>. T<sub><small>j</small></sub> is restarted later with a random delay but with the same timestamp.</p></li>
<li><p>If TS(T<sub><small>i</small></sub>) &gt; TS(T<sub><small>j</small></sub>), then T<sub><small>i</small></sub> is forced to wait until the resource is available.</p></li>
</ul>
<p>This scheme, allows the younger transaction to wait; but when an older transaction requests an item held by a younger one, the older transaction forces the younger one to abort and release the item.</p>
<p>In both the cases, the transaction that enters the system at a later stage is aborted.</p>
<h2>Deadlock Avoidance</h2>
<p>Aborting a transaction is not always a practical approach. Instead, deadlock avoidance mechanisms can be used to detect any deadlock situation in advance. Methods like "wait-for graph" are available but they are suitable for only those systems where transactions are lightweight having fewer instances of resource. In a bulky system, deadlock prevention techniques may work well.</p>
<h3>Wait-for Graph</h3>
<p>This is a simple method available to track if any deadlock situation may arise. For each transaction entering into the system, a node is created. When a transaction T<sub><small>i</small></sub> requests for a lock on an item, say X, which is held by some other transaction T<sub><small>j</small></sub>, a directed edge is created from T<sub><small>i</small></sub> to T<sub><small>j</small></sub>. If T<sub><small>j</small></sub> releases item X, the edge between them is dropped and T<sub><small>i</small></sub> locks the data item.</p>
<p>The system maintains this wait-for graph for every transaction waiting for some data items held by others. The system keeps checking if there's any cycle in the graph.</p>
<img src="https://www.tutorialspoint.com/dbms/images/wait_for_graph.png" alt="Wait-for Graph" /> 
<p>Here, we can use any of the two following approaches &minus;</p>
<ul class="list">
<li><p>First, do not allow any request for an item, which is already locked by another transaction. This is not always feasible and may cause starvation, where a transaction indefinitely waits for a data item and can never acquire it.</p></li>
<li><p>The second option is to roll back one of the transactions. It is not always feasible to roll back the younger transaction, as it may be important than the older one. With the help of some relative algorithm, a transaction is chosen, which is to be aborted. This transaction is known as the <b>victim</b> and the process is known as <b>victim selection</b>.</p></li>
</ul>
<h1>DBMS - Data Backup</h1>
<h2>Loss of Volatile Storage</h2>
<p>A volatile storage like RAM stores all the active logs, disk buffers, and related data. In addition, it stores all the transactions that are being currently executed. What happens if such a volatile storage crashes abruptly? It would obviously take away all the logs and active copies of the database. It makes recovery almost impossible, as everything that is required to recover the data is lost.</p>
<p>Following techniques may be adopted in case of loss of volatile storage &minus;</p>
<ul class="list">
<li><p>We can have <b>checkpoints</b> at multiple stages so as to save the contents of the database periodically.</p></li>
<li><p>A state of active database in the volatile memory can be periodically <b>dumped</b> onto a stable storage, which may also contain logs and active transactions and buffer blocks.</p></li>
<li><p>&lt;dump&gt; can be marked on a log file, whenever the database contents are dumped from a non-volatile memory to a stable one.</p></li>
</ul>
<h3>Recovery</h3>
<ul class="list">
<li><p>When the system recovers from a failure, it can restore the latest dump.</p></li>
<li><p>It can maintain a redo-list and an undo-list as checkpoints.</p></li>
<li><p>It can recover the system by consulting undo-redo lists to restore the state of all transactions up to the last checkpoint.</p></li>
</ul>
<h2>Database Backup &amp; Recovery from Catastrophic Failure</h2>
<p>A catastrophic failure is one where a stable, secondary storage device gets corrupt. With the storage device, all the valuable data that is stored inside is lost. We have two different strategies to recover data from such a catastrophic failure &minus;</p>
<ul class="list">
<li><p>Remote backup &minu; Here a backup copy of the database is stored at a remote location from where it can be restored in case of a catastrophe.</p></li>
<li><p>Alternatively, database backups can be taken on magnetic tapes and stored at a safer place. This backup can later be transferred onto a freshly installed database to bring it to the point of backup.</p></li>
</ul>
<p>Grown-up databases are too bulky to be frequently backed up. In such cases, we have techniques where we can restore a database just by looking at its logs. So, all that we need to do here is to take a backup of all the logs at frequent intervals of time. The database can be backed up once a week, and the logs being very small can be backed up every day or as frequently as possible.</p>
<h2>Remote Backup</h2>
<p>Remote backup provides a sense of security in case the primary location where the database is located gets destroyed. Remote backup can be offline or real-time or online. In case it is offline, it is maintained manually.</p>
<img src="https://www.tutorialspoint.com/dbms/images/remote_data_backup.png" alt="Remote Data Backup" />
<p>Online backup systems are more real-time and lifesavers for database administrators and investors. An online backup system is a mechanism where every bit of the real-time data is backed up simultaneously at two distant places. One of them is directly connected to the system and the other one is kept at a remote place as backup.</p>
<p>As soon as the primary database storage fails, the backup system senses the failure and switches the user system to the remote storage. Sometimes this is so instant that the users can’t even realize a failure.</p>
<h1>DBMS - Data Recovery</h1>
<h2>Crash Recovery</h2>
<p>DBMS is a highly complex system with hundreds of transactions being executed every second. The durability and robustness of a DBMS depends on its complex architecture and its underlying hardware and system software. If it fails or crashes amid transactions, it is expected that the system would follow some sort of algorithm or techniques to recover lost data.</p>
<h2>Failure Classification</h2>
<p>To see where the problem has occurred, we generalize a failure into various categories, as follows &minus;</p>
<h3>Transaction failure</h3>
<p>A transaction has to abort when it fails to execute or when it reaches a point from where it can’t go any further. This is called transaction failure where only a few transactions or processes are hurt.</p>
<p>Reasons for a transaction failure could be &minus;</p>
<ul class="list">
<li><p><b>Logical errors</b> &minus; Where a transaction cannot complete because it has some code error or any internal error condition.</p></li>
<li><p><b>System errors</b> &minus; Where the database system itself terminates an active transaction because the DBMS is not able to execute it, or it has to stop because of some system condition. For example, in case of deadlock or resource unavailability, the system aborts an active transaction.</p></li>
</ul>
<h3>System Crash</h3>
<p>There are problems &minus; external to the system &minus; that may cause the system to stop abruptly and cause the system to crash. For example, interruptions in power supply may cause the failure of underlying hardware or software failure.</p>
<p>Examples may include operating system errors.</p>
<h3>Disk Failure</h3>
<p>In early days of technology evolution, it was a common problem where hard-disk drives or storage drives used to fail frequently.</p>
<p>Disk failures include formation of bad sectors, unreachability to the disk, disk head crash or any other failure, which destroys all or a part of disk storage.</p>
<h2>Storage Structure</h2>
<p>We have already described the storage system. In brief, the storage structure can be divided into two categories &minus;</p>
<ul class="list">
<li><p><b>Volatile storage</b> &minus; As the name suggests, a volatile storage cannot survive system crashes. Volatile storage devices are placed very close to the CPU; normally they are embedded onto the chipset itself. For example, main memory and cache memory are examples of volatile storage. They are fast but can store only a small amount of information.</p></li>
<li><p><b>Non-volatile storage</b> &minus; These memories are made to survive system crashes. They are huge in data storage capacity, but slower in accessibility. Examples may include hard-disks, magnetic tapes, flash memory, and non-volatile (battery backed up) RAM.</p></li>
</ul>
<h2>Recovery and Atomicity</h2>
<p>When a system crashes, it may have several transactions being executed and various files opened for them to modify the data items. Transactions are made of various operations, which are atomic in nature. But according to ACID properties of DBMS, atomicity of transactions as a whole must be maintained, that is, either all the operations are executed or none.</p>
<p>When a DBMS recovers from a crash, it should maintain the following &minus;</p>
<ul class="list">
<li><p>It should check the states of all the transactions, which were being executed.</p></li>
<li><p>A transaction may be in the middle of some operation; the DBMS must ensure the atomicity of the transaction in this case.</p></li>
<li><p>It should check whether the transaction can be completed now or it needs to be rolled back.</p></li>
<li><p>No transactions would be allowed to leave the DBMS in an inconsistent state.</p></li>
</ul>
<p>There are two types of techniques, which can help a DBMS in recovering as well as maintaining the atomicity of a transaction &minus;</p>
<ul class="list">
<li><p>Maintaining the logs of each transaction, and writing them onto some stable storage before actually modifying the database.</p></li>
<li><p>Maintaining shadow paging, where the changes are done on a volatile memory, and later, the actual database is updated.</p></li>
</ul>
<h2>Log-based Recovery</h2>
<p>Log is a sequence of records, which maintains the records of actions performed by a transaction. It is important that the logs are written prior to the actual modification and stored on a stable storage media, which is failsafe.</p>
<p>Log-based recovery works as follows &minus;</p>
<ul class="list">
<li><p>The log file is kept on a stable storage media.</p></li>
<li><p>When a transaction enters the system and starts execution, it writes a log about it.</p></li>
</ul>
<pre class="result notranslate">
&#60;T<sub><small>n</small></sub>, Start&#62;
</pre>
<ul class="list">
<li><p>When the transaction modifies an item X, it write logs as follows &minus;</p></li>
</ul>
<pre class="result notranslate">
&#60;T<sub><small>n</small></sub>, X, V<sub><small>1</small></sub>, V<sub><small>2</small></sub>&#62;
</pre>
<p>It reads T<sub><small>n</small></sub> has changed the value of X, from V<sub><small>1</small></sub> to V<sub><small>2</small></sub>.</p>
<ul class="list">
<li>When the transaction finishes, it logs &minus;</li>
</ul>
<pre class="result notranslate">
&#60;T<sub><small>n</small></sub>, commit&#62;
</pre>
<p>The database can be modified using two approaches &minus;</p>
<ul class="list">
<li><p><b>Deferred database modification</b> &minus; All logs are written on to the stable storage and the database is updated when a transaction commits.</p></li>
<li><p><b>Immediate database modification</b> &minus; Each log follows an actual database modification. That is, the database is modified immediately after every operation.</p></li>
</ul>
<h2>Recovery with Concurrent Transactions</h2>
<p>When more than one transaction are being executed in parallel, the logs are interleaved. At the time of recovery, it would become hard for the recovery system to backtrack all logs, and then start recovering. To ease this situation, most modern DBMS use the concept of 'checkpoints'.</p>
<h3>Checkpoint</h3>
<p>Keeping and maintaining logs in real time and in real environment may fill out all the memory space available in the system. As time passes, the log file may grow too big to be handled at all. Checkpoint is a mechanism where all the previous logs are removed from the system and stored permanently in a storage disk. Checkpoint declares a point before which the DBMS was in consistent state, and all the transactions were committed.</p>
<h3>Recovery</h3>
<p>When a system with concurrent transactions crashes and recovers, it behaves in the following manner &minus;</p>
<img src="https://www.tutorialspoint.com/dbms/images/recovery.png" alt="Recovery" />
<ul class="list">
<li><p>The recovery system reads the logs backwards from the end to the last checkpoint.</p></li>
<li><p>It maintains two lists, an undo-list and a redo-list.</p></li>
<li><p>If the recovery system sees a log with &#60;T<sub><small>n</small></sub>, Start&#62; and &#60;T<sub><small>n</small></sub>, Commit&#62; or just &#60;T<sub><small>n</small></sub>, Commit&#62;, it puts the transaction in the redo-list.</p></li>
<li><p>If the recovery system sees a log with &#60;T<sub><small>n</small></sub>, Start&#62; but no commit or abort log found, it puts the transaction in undo-list.</p></li>
</ul>
<p>All the transactions in the undo-list are then undone and their logs are removed. All the transactions in the redo-list and their previous logs are removed and then redone before saving their logs.</p>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/dbms/dbms_data_recovery.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="https://www.tutorialspoint.com/cgi-bin/printpage.cgi" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="pdf-btn">
<a href="https://www.tutorialspoint.com/dbms/pdf/dbms_quick_guide.pdf" title="DBMS Quick Guide" target="_blank"><i class="icon icon-file-pdf-o big-font"></i> PDF</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/dbms/dbms_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/dbms/dbms_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/dbms/dbms_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/dbms/dbms_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/dbms/dbms_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/dbms/dbms_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/dbms/dbms_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="https://www.tutorialspoint.com/index.htm" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="https://www.tutorialspoint.com/scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="https://www.tutorialspoint.com/about/tutorials_writing.htm">Write for us</a></li>
         <li><a href="https://www.tutorialspoint.com/about/faq.htm">FAQ's</a></li>
         <li><a href="https://www.tutorialspoint.com/about/about_helping.htm">Helping</a></li>
         <li><a href="https://www.tutorialspoint.com/about/contact_us.htm">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/custom-min.js?v=5"></script>
<script src="https://www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "DBMS Quick Guide",
    "name": "DBMS Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/dbms/dbms_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/dbms/images/dbms_users.png",
        "width": 400,
        "height": 200
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "July 23 2017 03:34:50.",
    "dateModified": "July 23 2017 03:34:50.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": "Database is a collection of related data and data is a collection of facts and figures that can be processed to produce information...."
}
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Dbms",
                "@id": "https://www.tutorialspoint.com/dbms"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": "DBMS - Quick Guide"
            }
        }
    ]
}
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/dbms/dbms_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:20:02 GMT -->
</html>
