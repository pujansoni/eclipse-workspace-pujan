<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/elixir/elixir_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 16:06:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>Elixir Quick Guide</title>
<meta name="description" content="Elixir Quick Guide - Learn Elixir in simple and easy steps starting from basic to advanced concepts with examples including Overview, Environment, Basic Syntax, Data Types, Variables, Operators, Decision Making, Loops, Strings, Char Lists, Arrays, Keyword Lists, Maps, Pattern Matching, Enumerables, Streams, Structs, Protocols, File IO, Functions, Modules, Recursion, Aliases, Processes, Sigils, Comprehensions, Typespecs, Behaviours, Errors Handling, Macros, Libraries, Project." />
<meta name="keywords" content="Elixir, Tutorial, Learning, Overview, Environment, Basic Syntax, Data Types, Variables, Operators, Decision Making, Loops, Strings, Char Lists, Arrays, Keyword Lists, Maps, Pattern Matching, Enumerables, Streams, Structs, Protocols, File IO, Functions, Modules, Recursion, Aliases, Processes, Sigils, Comprehensions, Typespecs, Behaviours, Errors Handling, Macros, Libraries, Project." />
<base  />
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="../theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="../theme/css/style-min5e1f.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
pre.prettyprint.tryit {min-height:37px; background: #eee url(images/try-it.jpg) top right no-repeat !important}select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #4d2e60 url(../images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #4d2e60 !important;}
.submenu-item{ border-bottom: 2px solid #4d2e60 !important; border-top: 2px solid #4d2e60 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="../images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="../index-2.html" title="tutorialspoint">
      <img alt="tutorialspoint" src="images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="../about/about_careers.html" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="../whiteboard.html"><img src="../theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="../netmeeting.html"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="../online_dev_tools.html"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="../articles/index.html"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="../index-2.html"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../codingground.html"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../tutor_connect/index.html"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../videotutorials/index.html"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="images/elixir-mini-logo.jpg" alt="Elixir Tutorial" />
</div>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Elixir Tutorial</li>
<li><a href="index.html">Elixir - Home</a></li>
<li><a href="elixir_overview.html">Elixir - Overview</a></li>
<li><a href="elixir_environment.html">Elixir - Environment</a></li>
<li><a href="elixir_basic_syntax.html">Elixir - Basic Syntax</a></li>
<li><a href="elixir_data_types.html">Elixir - Data Types</a></li>
<li><a href="elixir_variables.html">Elixir - Variables</a></li>
<li><a href="elixir_operators.html">Elixir - Operators</a></li>
<li><a href="elixir_pattern_matching.html">Elixir - Pattern Matching</a></li>
<li><a href="elixir_decision_making.html">Elixir - Decision Making</a></li>
<li><a href="elixir_strings.html">Elixir - Strings</a></li>
<li><a href="elixir_char_lists.html">Elixir - Char Lists</a></li>
<li><a href="elixir_lists_and_tuples.html">Elixir - Lists and Tuples</a></li>
<li><a href="elixir_keyword_lists.html">Elixir - Keyword Lists</a></li>
<li><a href="elixir_maps.html">Elixir - Maps</a></li>
<li><a href="elixir_modules.html">Elixir - Modules</a></li>
<li><a href="elixir_aliases.html">Elixir - Aliases</a></li>
<li><a href="elixir_functions.html">Elixir - Functions</a></li>
<li><a href="elixir_recursion.html">Elixir - Recursion</a></li>
<li><a href="elixir_loops.html">Elixir - Loops</a></li>
<li><a href="elixir_enumerables.html">Elixir - Enumerables</a></li>
<li><a href="elixir_streams.html">Elixir - Streams</a></li>
<li><a href="elixir_structs.html">Elixir - Structs</a></li>
<li><a href="elixir_protocols.html">Elixir - Protocols</a></li>
<li><a href="elixir_file_io.html">Elixir - File I/O</a></li>
<li><a href="elixir_processes.html">Elixir - Processes</a></li>
<li><a href="elixir_sigils.html">Elixir - Sigils</a></li>
<li><a href="elixir_comprehensions.html">Elixir - Comprehensions</a></li>
<li><a href="elixir_typespecs.html">Elixir - Typespecs</a></li>
<li><a href="elixir_behaviours.html">Elixir - Behaviours</a></li>
<li><a href="elixir_errors_handling.html">Elixir - Errors Handling</a></li>
<li><a href="elixir_macros.html">Elixir - Macros</a></li>
<li><a href="elixir_libraries.html">Elixir - Libraries</a></li>
<!--<li><a href="/elixir/elixir_project.htm">Elixir - Project</a></li>-->
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Elixir Useful Resources</li>
<li><a href="elixir_quick_guide.html">Elixir - Quick Guide</a></li>
<li><a href="elixir_useful_resources.html">Elixir - Useful Resources</a></li>
<li><a href="elixir_discussion.html">Elixir - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../questions_and_answers.html">Questions and Answers</a></li>
<li><a target="_top" href="../effective_resume_writing.html">Effective Resume Writing</a></li>
<li><a target="_top" href="../hr_interview_questions/index.html">HR Interview Questions</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>Elixir - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="elixir_libraries.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="elixir_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>Elixir - Overview</h1>
<p>Elixir is a dynamic, functional language designed for building scalable and maintainable applications. It leverages the Erlang VM, known for running low-latency, distributed and fault-tolerant systems, while also being successfully used in web development and the embedded software domain.</p>
<p>Elixir is a functional, dynamic language built on top of Erlang and the Erlang VM. Erlang is a language that was originally written in 1986 by Ericsson to help solve telephony problems like distribution, fault-tolerance, and concurrency. Elixir, written by José Valim, extends Erlang and provides a friendlier syntax into the Erlang VM. It does this while keeping the performance of the same level as Erlang.</p>
<h2>Features of Elixir</h2>
<p>Let us now discuss a few important features of Elixir &minus;</p>
<ul class="list">
<li><p><b>Scalability</b> &minus; All Elixir code runs inside lightweight processes that are isolated and exchange information via messages.</p></li>
<li><p><b>Fault Tolerance</b> &minus; Elixir provides supervisors which describe how to restart parts of your system when things go wrong, going back to a known initial state that is guaranteed to work. This ensures your application/platform is never down.</p></li>
<li><p><b>Functional Programming</b> &minus; Functional programming promotes a coding style that helps developers write code that is short, fast, and maintainable.</p></li>
<li><p><b>Build tools</b> &minus; Elixir ships with a set of development tools. Mix is one such tool that makes it easy to create projects, manage tasks, run tests, etc. It also has its own package manager - Hex.</p></li>
<li><p><b>Erlang Compatibility</b> &minus; Elixir runs on the Erlang VM giving developers complete access to Erlang’s ecosystem.</p></li>
</ul>
<h1>Elixir - Environment</h1>
<p>In order to run Elixir, you need to set it up locally on your system.</p>
<p>To install Elixir, you will first require Erlang. On some platforms, Elixir packages come with Erlang in them.</p>
<h2>Installing Elixir</h2>
<p>Let us now understand the installation of Elixir in different Operating Systems.</p>
<h3>Windows Setup</h3>
<p>To install Elixir on windows, download installer from <a target=
"_blank" rel="nofollow" href ="https://repo.hex.pm/elixirwebsetup.exe">https://repo.hex.pm/elixirwebsetup.exe</a> and simply click <b>Next</b> to proceed through all steps. You will have it on your local system.</p>
<p>If you have any problems while installing it, you can check <a target="_blank" rel="nofollow" href="http://elixir-lang.org/install.html">this page</a>for more info.</p>
<h3>Mac Setup</h3>
<p>If you have Homebrew installed, make sure that it is the latest version. For updating, use the following command &minus;</p>
<pre class="result notranslate">
brew update
</pre>
<p>Now, install Elixir using the command given below &minus;</p>
<pre class="result notranslate">
brew install elixir
</pre>
<h3>Ubuntu/Debian Setup</h3>
<p>The steps to install Elixir in an Ubuntu/Debian setup is as follows &minus;</p>
<p>Add Erlang Solutions repo &minus;</p>
<pre class="result notranslate">
wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb &amp;&amp; sudo 
dpkg -i erlang-solutions_1.0_all.deb 
sudo apt-get update 
</pre>
<p>Install the Erlang/OTP platform and all of its applications &minus;</p>
<pre class="result notranslate">
sudo apt-get install esl-erlang 
</pre>
<p>Install Elixir &minus;</p>
<pre class="result notranslate">
sudo apt-get install elixir
</pre>
<h3>Other Linux Distros</h3>
<p>If you have any other Linux distribution, please visit <a target="_blank" rel="nofollow" href="https://elixir-lang.org/install.html">this page</a> to set up elixir on your local system.</p>
<h2>Testing the Setup</h2>
<p>To test the Elixir setup on your system, open your terminal and enter iex in it. It will open the interactive elixir shell like the following &minus;</p>
<pre class="result notranslate">
Erlang/OTP 19 [erts-8.0] [source-6dc93c1] [64-bit] 
[smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]  

Interactive Elixir (1.3.1) - press Ctrl+C to exit (type h() ENTER for help) 
iex(1)&gt;
</pre>
<p>Elixir is now successfully set up on your system.</p>
<h1>Elixir - Basic Syntax</h1>
<p>We will start with the customary 'Hello World' program.</p>
<p>To start the Elixir interactive shell, enter the following command.</p>
<pre class="result notranslate">
iex
</pre>
<p>After the shell starts, use the <b>IO.puts</b> function to "put" the string on the console output. Enter the following in your Elixir shell &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts "Hello world"
</pre>
<p>In this tutorial, we will use the Elixir script mode where we will keep the Elixir code in a file with the extension <b>.ex</b>. Let us now keep the above code in the <b>test.ex</b> file. In the succeeding step, we will execute it using <b>elixirc</b>&minus;</p> 
<pre class="prettyprint notranslate tryit">
IO.puts "Hello world"
</pre>
<p>Let us now try to run the above program as follows &minus;</p>
<pre class="prettyprint notranslate tryit">
$elixirc test.ex
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
Hello World
</pre>
<p>Here we are calling a function <b>IO.puts</b> to generate a string to our console as output. This function can also be called the way we do in C, C++, Java, etc., providing arguments in parentheses following the function name &minus;</p>
<pre class="result notranslate">
IO.puts("Hello world") 
</pre>
<h2>Comments</h2>
<p>Single line comments start with a '#' symbol. There's no multi-line comment, but you can stack multiple comments. For example &minus;</p>
<pre class="result notranslate">
#This is a comment in Elixir
</pre>
<h2>Line Endings</h2>
<p>There are no required line endings like ';' in Elixir. However, we can have multiple statements in the same line, using ';'. For example,</p>
<pre class="prettyprint notranslate tryit">
IO.puts("Hello"); IO.puts("World!")
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
Hello 
World!
</pre>
<h2>Identifiers</h2>
<p>Identifiers like variables, function names are used to identify a variable, function, etc. In Elixir, you can name your identifiers starting with a lower case alphabet with numbers, underscores and upper case letters thereafter. This naming convention is commonly known as snake_case. For example, following are some valid identifiers in Elixir &minus;</p>
<pre class="result notranslate">
var1       variable_2      one_M0r3_variable
</pre>
<p>Please note that variables can also be named with a leading underscore. A value that is not meant to be used must be assigned to _ or to a variable starting with underscore &minus;</p>
<pre class="result notranslate">
_some_random_value = 42
</pre>
<p>Also elixir relies on underscores to make functions private to modules. If you name a function with a leading underscore in a module, and import that module, this function will not be imported.</p>
<p>There are many more intricacies related to function naming in Elixir which we will discuss in coming chapters.</p>
<h2>Reserved Words</h2>
<p>Following words are reserved and cannot be used as variables, module or function names.</p>
<pre class="result notranslate">
after     and     catch     do     inbits     inlist     nil     else     end 
not     or     false     fn     in     rescue     true     when     xor 
__MODULE__    __FILE__    __DIR__    __ENV__    __CALLER__ 
</pre>
<h1>Elixir - Data Types</h1>
<p>For using any language, you need to understand the basic data types the language supports. In this chapter, we will discuss 7 basic data types supported by the elixir language: integers, floats, Booleans, atoms, strings, lists and tuples.</p>
<h2>Numerical Types</h2>
<p>Elixir, like any other programming language, supports both integers and floats. If you open your elixir shell and input any integer or float as input, it'll return its value. For example, </p>
<pre class="prettyprint notranslate">
42
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
42
</pre>
<p>You can also define numbers in octal, hex and binary bases.</p>
<h3>Octal</h3>
<p>To define a number in octal base, prefix it with '0o'. For example, 0o52 in octal is equivalent to 42 in decimal.</p>
<h3>Hexadecimal</h3>
<p>To define a number in decimal base, prefix it with '0x'. For example, 0xF1 in hex is equivalent to 241 in decimal.</p>
<h3>Binary</h3>
<p>To define a number in binary base, prefix it with '0b'. For example, 0b1101 in binary is equivalent to 13 in decimal.</p>
<p>Elixir supports 64bit double precision for floating point numbers. And they can also be defined using an exponentiation style. For example, 10145230000 can be written as 1.014523e10</p>
<h3>Atoms</h3>
<p>Atoms are constants whose name is their value. They can be created using the color(:) symbol. For example, </p>
<pre class="prettyprint notranslate">
:hello
</pre>
<h3>Booleans</h3>
<p>Elixir supports <b>true</b> and <b>false</b> as Booleans. Both these values are in fact attached to atoms :true and :false respectively.</p>
<h3>Strings</h3>
<p>Strings in Elixir are inserted between double quotes, and they are encoded in UTF-8. They can span multiple lines and contain interpolations. To define a string simply enter it in double quotes &minus;</p>
<pre class="prettyprint notranslate">
"Hello world"
</pre>
<p>To define multiline strings, we use a syntax similar to python with triple double quotes &minus;</p>
<pre class="prettyprint notranslate">
"""
Hello
World!
"""
</pre>
<p>We'll learn about strings, binaries and char lists(similar to strings) in depth in the strings chapter.</p>
<h3>Binaries</h3>
<p>Binaries are sequences of bytes enclosed in &lt;&lt;  &gt;&gt; separated with a comma. For example, 
<pre class="prettyprint notranslate">
&lt;&lt; 65, 68, 75&gt;&gt;
</pre>
Binaries are mostly used to handle bits and bytes related data, if you have any. They can, by default, store 0 to 255 in each value. This size limit can be increased by using the size function that says how many bits it should take to store that value. For example, </p>
<pre class="result notranslate">
&lt;&lt;65, 255, 289::size(15)&gt;&gt;
</pre>
<h3>Lists</h3>
<p>Elixir uses square brackets to specify a list of values. Values can be of any type. For example,</p>
<pre class="result notranslate">
[1, "Hello", :an_atom, true]
</pre>
<p>Lists come with inbuilt functions for head and tail of the list named hd and tl which return the head and tail of the list respectively. Sometimes when you create a list, it'll return a char list. This is because when elixir sees a list of printable ASCII characters, it prints it as a char list. Please note that strings and char lists are not equal. We'll discuss lists further in later chapters.</p>
<h3>Tuples</h3>
<p>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value.</p>
<pre class="prettyprint notranslate">
{ 1, "Hello", :an_atom, true 
</pre>
<p>A question arises here, - why provide both <b>lists</b> and <b>tuples</b> when they both work in the same way? Well they have different implementations.</p> 
<ul class="list">
<li><p>Lists are actually stored as linked lists, so insertions, deletions are very fast in lists.</p></li> 
<li><p>Tuples on the other hand, are stored in contiguous memory block, which make accessing them faster but adds an additional cost on insertions and deletions.</p></li>
</ul>
<h1>Elixir - Variables</h1>
<p>A variable provides us with named storage that our programs can manipulate. Each variable in Elixir has a specific type, which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.</p>
<h2>Types of Variables</h2>
<p>Elixir supports the following basic types of variables.</p>
<h3>Integer</h3>
<p>These are used for Integers. They are of size 32bit on a 32bit architecture and 64 bits on a 64-bit architecture. Integers are always signed in elixir. If an integer starts to expand in size above its limit, elixir convers it in a Big Integer which takes up memory in range 3 to n words whichever can fit it in memory.</p>
<h3>Floats</h3>
<p>Floats have a 64-bit precision in elixir. They are also like integers in terms of memory. When defining a float, exponential notation can be used.</p>
<h3>Boolean</h3>
<p>They can take up 2 values which is either true or false.</p>
<h3>Strings</h3>
<p>Strings are utf-8 encoded in elixir. They have a strings module which provides a lot of functionality to the programmer to manipulate strings.</p>
<h3>Anonymous Functions/Lambdas</h3>
<p>These are functions that can be defined and assigned to a variable, which can then be used to call this function.</p>
<h3>Collections</h3>
<p>There are a lot of collection types available in Elixir. Some of them are Lists, Tuples, Maps, Binaries, etc. These will be discussed in subsequent chapters.</p>
<h2>Variable Declaration</h2>
<p>A variable declaration tells the interpreter where and how much to create the storage for the variable. Elixir does not allow us to just declare a variable. A variable must be declared and assigned a value at the same time. For example, to create a variable named life and assign it a value 42, we do the following &minus;</p>
<pre class="prettyprint notranslate">
life = 42
</pre>
<p>This will <i>bind</i> the variable life to value 42. If we want to reassign this variable a new value, we can do this by using the same syntax as above, i.e.,</p>
<pre class="result notranslate">
life = "Hello world"
</pre>
<h2>Variable Naming</h2>
<p>Naming variables follow a <b>snake_case</b> convention in Elixir, i.e., all variables must start with a lowercase letter, followed by 0 or more letters(both upper and lower case), followed at the end by an optional '?' OR '!'.</p>
<p>Variable names can also be started with a leading underscore but that must be used only when ignoring the variable, i.e., that variable will not be used again but is needed to be assigned to something.</p>
<h2>Printing Variables</h2>
<p>In the interactive shell, variables will print if you just enter the variable name. For example, if you create a variable &minus;</p>
<pre class="prettyprint notranslate">
life = 42 
</pre>
<p>And enter 'life' in your shell, you'll get the output as &minus;</p>
<pre class="result notranslate">
42
</pre>
<p>But if you want to output a variable to the console (When running an external script from a file), you need to provide the variable as input to <b>IO.puts</b> function &minus;</p>
<pre class="prettyprint notranslate tryit">
life = 42  
IO.puts life 
</pre>
<p>or</p>
<pre class="prettyprint notranslate tryit">
life = 42 
IO.puts(life) 
</pre>
<p>This will give you the following output &minus;</p>
<pre class="result notranslate">
42
</pre>
<h1>Elixir - Operators</h1>
<p>An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations. There are a LOT of operators provided by elixir. They are divided in the following categories &minus;</p>
<ul class="list">
<li>Arithmetic operators</li>
<li>Comparison operators</li>
<li>Boolean operators</li>
<li>Misc operators</li>
</ul>
<h2>Arithmetic Operators</h2>
<p>The following table shows all the arithmetic operators supported by Elixir language. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="elixir_example_arithematic.html">Show Examples</a></p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Example</th>
</tr>
<tr>
<td>+</td>
<td>Adds 2 numbers.</td>
<td>A + B will give 30</td>
</tr>
<tr>
<td>-</td>
<td>Subtracts second number from first.</td>
<td>A-B will give -10</td>
</tr>
<tr>
<td>*</td>
<td>Multiplies two numbers.</td>
<td>A*B will give 200</td>
</tr>
<tr>
<td>/</td>
<td>Divides first number from second. This casts the numbers in floats and gives a float result</td>
<td>A/B will give 0.5.</td>
</tr>
<tr>
<td>div</td>
<td>This function is used to get the quotient on division.</td>
<td>div(10,20) will give 0</td>
</tr>
<tr>
<td>rem</td>
<td>This function is used to get the remainder on division.</td>
<td>rem(A, B) will give 10</td>
</tr>
</table>
<h2>Comparison Operators</h2>
<p>The comparison operators in Elixir are mostly common to those provided in most other languages. The following table sums up comparison operators in Elixir. Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="elixir_example_comparision.html">Show Examples</a></p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Example</th>
</tr>
<tr>
<td>==</td>
<td>Checks if value on left is equal to value on right(Type casts values if they are not the same type).</td>
<td>A == B will give false</td>
</tr>
<tr>
<td>!=</td>
<td>Checks if value on left is not equal to value on right.</td>
<td>A != B will give true</td>
</tr>
<tr>
<td>===</td>
<td>Checks if type of value on left equals type of value on right, if yes then check the same for value.</td>
<td>A === B will give false</td>
</tr>
<tr>
<td>!==</td>
<td>Same as above but checks for inequality instead of equality.</td>
<td>A !== B will give true</td>
</tr>
<tr>
<td>&gt;</td>
<td>Checks if the value of left operand is greater than the value of right operand; if yes, then the condition becomes true.</td>
<td>A &gt; B will give false</td>
</tr>
<tr>
<td>&lt;</td>
<td>Checks if the value of left operand is less than the value of right operand; if yes, then the condition becomes true.</td>
<td>A &lt; B will give true</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Checks if the value of left operand is greater than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td>A &gt;= B will give false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Checks if the value of left operand is less than or equal to the value of right operand; if yes, then the condition becomes true.</td>
<td>A &lt;= B will give true</td>
</tr>
</table>
<h2>Logical operators</h2>
<p>Elixir provides 6 logical operators: and, or, not, &amp;&amp;, || and !. The first three, <b>and or not</b> are strict Boolean operators, meaning that they expect their first argument to be a Boolean. Non Boolean argument will raise an error. While the next three, <b>&amp;&amp;, || and !</b> are non strict, do not require us to have the first value strictly as a boolean. They work in the same way as their strict counterparts. Assume variable <b>A</b> holds true and variable <b>B</b> holds 20, then &minus;</p>
<p><a href="elixir_example_logical.html">Show Examples</a></p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Example</th>
</tr>
<tr>
<td>and</td>
<td>Checks if both values provided are truthy, if yes then returns the value of second variable. (Logical and).</td>
<td>A and B will give 20</td>
</tr>
<tr>
<td>or</td>
<td>Checks if either value provided is truthy. Returns whichever value is truthy. Else returns false. (Logical or).</td>
<td>A or B will give true</td>
</tr>
<tr>
<td>not</td>
<td>Unary operator which inverts the value of given input.</td>
<td>not A will give false</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Non-strict <b>and</b>. Works same as <b>and</b> but does not expect first argument to be a Boolean.</td>
<td>B &amp;&amp; A will give 20</td>
</tr>
<tr>
<td>||</td>
<td>Non-strict <b>or</b>. Works same as <b>or</b> but does not expect first argument to be a Boolean.</td>
<td>B || A will give true</td>
</tr>
<tr>
<td>!</td>
<td>Non-strict <b>not</b>. Works same as <b>not</b> but does not expect the argument to be a Boolean.</td>
<td>!A will give false</td>
</tr>
</table>
<p><b>NOTE &minus;</b><i>and</i>, <i>or</i>, <i>&amp;&amp;</i> and <i>||</i> || are short circuit operators. This means that if the first argument of <b>and</b> is false, then it will not further check for the second one. And if the first argument of <b>or</b> is true, then it will not check for the second one. For example, </p>
<pre class="prettyprint notranslate">
false and raise("An error")  
#This won't raise an error as raise function wont get executed 
   because of short circuiting nature of and operator
</pre> 
<h2>Bitwise Operators</h2>
<p>Bitwise operators work on bits and perform bit by bit operation. Elixir provides bitwise modules as part of the package <b>Bitwise</b>, so in order to use these, you need to <i>use</i> the bitwise module. To use it, enter the following command in your shell &minus;</p>
<pre class="prettyprint notranslate tryit">
use Bitwise
</pre>
<p> Assume A to be 5 and B to be 6 for the following examples &minus;</p>
<p><a href="elixir_example_bitwise.html">Show Examples</a></p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operator</th>
<th style="text-align:center">Description</th>
<th style="text-align:center">Example</th>
</tr>
<tr>
<td>&amp;&amp;&amp;</td>
<td>Bitwise and operator copies a bit to result if it exists in both operands.</td>
<td>A &amp;&amp;&amp; B will give 4</td>
</tr>
<tr>
<td>|||</td>
<td>Bitwise or operator copies a bit to result if it exists in either operand.</td>
<td>A ||| B will give 7</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>Bitwise right shift operator shifts first operand bits to the right by the number specified in second operand.</td>
<td>A &gt;&gt;&gt; B will give 0</td>
</tr>
<tr>
<td>&lt;&lt;&lt;</td>
<td>Bitwise left shift operator shifts first operand bits to the left by the number specified in second operand.</td>
<td>A &lt;&lt;&lt; B will give 320</td>
</tr>
<tr>
<td>^^^</td>
<td>Bitwise XOR operator copies a bit to result only if it is different on both operands.</td>
<td>A ^^^ B will give 3</td>
</tr>
<tr>
<td>~~~</td>
<td>Unary bitwise not inverts the bits on the given number.</td>
<td>~~~A will give -6</td>
</tr>
</table>
<h2>Misc Operators</h2>
<p>Other than the above operators, Elixir also provides a range of other operators like <b><i>Concatenation Operator, Match Operator, Pin Operator, Pipe  Operator, String Match Operator, Code Point Operator, Capture Operator, Ternary Operator</i></b> that make it quite a powerful language.</p>
<p><a href="elixir_example_misc.html">Show Examples</a></p>
<h1>Elixir - Pattern Matching</h1>
<p>Pattern matching is a technique which Elixir inherits form Erlang. It is a very powerful technique that allows us to extract simpler substructures from complicated data structures like lists, tuples, maps, etc.</p>
<p>A match has 2 main parts, a <b>left</b> and a <b>right</b> side. The right side is a data structure of any kind. The left side attempts to match the data structure on the right side and bind any variables on the left to the respective substructure on the right. If a match is not found, the operator raises an error.</p>
<p>The simplest match is a lone variable on the left and any data structure on the right. <b>This variable will match anything</b>. For example,</p>
<pre class="prettyprint notranslate tryit">
x = 12
x = "Hello"
IO.puts(x)
</pre>
<p>You can place variables inside a structure so that you can capture a substructure. For example, </p>
<pre class="prettyprint notranslate">
[var_1, _unused_var, var_2] = [{"First variable"}, 25, "Second variable" ]
IO.puts(var_1)
IO.puts(var_2)
</pre>
<p>This will store the values, <b>{"First variable"}</b> in <i>var_1</i> and <b>"Second variable"</b> in <i>var_2</i>. There is also a special <b>_</b> variable(or variables prefixed with '_') that works exactly like other variables but tells elixir, <b>"Make sure something is here, but I don't care exactly what it is."</b>. In the previous example, <i>_unused_var</i> was one such variable.</p>
<p>We can match more complicated patterns using this technique. For <b>example</b> if you want to unwrap and get a number in a tuple which is inside a list which itself is in a list, you can use the following command &minus;</p>
<pre class="prettyprint notranslate tryit">
[_, [_, {a}]] = ["Random string", [:an_atom, {24}]]
IO.puts(a)
</pre>
<p>This will bind <b>a</b> to 24. Other values are ignored as we are using '_'.</p>
<p>In pattern matching, if we use a variable on the <b>right</b>, its value is used. If you want to use the value of a variable on the left, you'll need to use the pin operator.</p> 
<p>For example, if you have a variable "a" having value 25 and you want to match it with another variable "b" having value 25, then you need to enter &minus;</p>
<pre class="prettyprint notranslate">
a = 25
b = 25
^a = b
</pre>
<p>The last line matches the current value of <b>a</b>, instead of assigning it, to the value of <b>b</b>. If we have a non-matching set of left and right hand side, the match operator raises an error. For example, if we try to match a tuple with a list or a list of size 2 with a list of size 3, an error will be displayed.</p>
<h1>Elixir - Decision Making</h1>
<p>Decision making structures require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be <b>true</b>, and optionally, other statements to be executed if the condition is determined to be <b>false</b>.</p>
<p>Following is the general from of a typical decision making structure found in most of the programming language &minus;</p>
<img src="images/decision_making.jpg" alt="Decision Making" />
<p>Elixir provides if/else conditional constructs like many other programming languages. It also has a <b>cond</b> statement which calls the first true value it finds. Case is another control flow statement which uses pattern matching to control the flow of the program. Let's have a deep look at them.</p>
<p>Elixir provides the following types of decision making statements. Click the following links to check their detail.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center">S.No.</th>
<th style="text-align:center">Statement &amp; Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">1</td>
<td><a href="elixir_decision_if_statement.html">if statement</a><p>An if statement consists of a Boolean expression followed by <b>do</b>, one or more executable statements and finally an <b>end</b> keyword. Code in if statement executes only if Boolean condition evaluates to true.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">2</td>
<td><a href="elixir_decision_if_else.html">if..else statement</a><p>An if statement can be followed by an optional else statement(within the do..end block), which executes when the Boolean expression is false.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">3</td>
<td><a href="elixir_decision_unless.html">unless statement</a><p>An unless statement has the same body as an if statement. The code within unless statement executes only when the condition specified is false. </p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">4</td>
<td><a href="elixir_decision_unless_else.html">unless..else statement</a><p>An unless..else statement has the same body as an if..else statement. The code within unless statement executes only when the condition specified is false. </p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">5</td>
<td><a href="elixir_decision_cond.html">cond</a><p>A cond statement is used where we want to execute code on basis of several conditions. It kind of works like an if...else if….else construct in several other programming languages.</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">6</td>
<td><a href="elixir_decision_case.html">case</a><p>Case statement can be considered as a replacement for switch statement in imperative languages. Case takes a variable/literal and applies pattern matching to it with different cases. If any case matches, Elixir executes code associated with that case and exits case statement.</p></td>
</tr>
</table>
<h1>Elixir - Strings</h1>
<p>Strings in Elixir are inserted between double quotes, and they are encoded in UTF-8. Unlike C and C++ where the default strings are ASCII encoded and only 256 different characters are possible, UTF-8 consists of <b>66536 code points</b>. This means that UTF-8 encoding consists of those many different possible characters. Since the strings use utf-8, we can also use symbols like: ö, ł, etc.</p>
<h3>Create a String</h3>
<p>To create a string variable, simply assign a string to a variable &minus;</p>
<pre class="prettyprint notranslate">
str = "Hello world"
</pre>
<p>To print this to your console, simply call the <b>IO.puts</b> function and pass it the variable str &minus;</p>
<pre class="prettyprint notranslate tryit">
str = str = "Hello world" 
IO.puts(str)
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
Hello World
</pre>
<h3>Empty Strings</h3>
<p>You can create an empty string using the string literal, <b>""</b>. For example,</p>
<pre class="prettyprint notranslate tryit">a = ""
if String.length(a) === 0 do
   IO.puts("a is an empty string")
end
</pre>
<p>The above program generates the following result.</p>
<pre class="result notranslate">
a is an empty string
</pre>
<h3>String Interpolation</h3>
<p>String interpolation is a way to construct a new String value from a mix of constants, variables, literals, and expressions by including their values inside a string literal. Elixir supports string interpolation, to use a variable in a string, when writing it, wrap it with curly braces and prepend the curly braces with a '#' sign.</p>
<p>For example,</p>
<pre class="prettyprint notranslate tryit">
x = "Apocalypse" 
y = "X-men #{x}"
IO.puts(y)
</pre>
<p>This will take the value of x and substitute it in y. The above code will generate the following result &minus;</p>
<pre class="result notranslate">
X-men Apocalypse
</pre>
<h3>String Concatenation</h3>
<p>We have already seen the use of String concatenation in previous chapters. The '&lt;&gt;' operator is used to concatenate strings in Elixir. To concatenate 2 strings,</p>
<pre class="prettyprint notranslate tryit">
x = "Dark"
y = "Knight"
z = x &lt;&gt; " " &lt;&gt; y
IO.puts(z)
</pre>
<p>The above code generates the following result &minus;</p>
<pre class="result notranslate">
Dark Knight
</pre>
<h3>String Length</h3>
<p>To get the length of the string, we use the <b>String.length</b> function. Pass the string as a parameter and it will show you its size. For example, </p>
<pre class="prettyprint notranslate tryit">IO.puts(String.length("Hello"))
</pre>
<p>When running above program, it produces following result &minus;</p>
<pre class="result notranslate">
5
</pre>
<h3>Reversing a String</h3>
<p>To reverse a string, pass it to the String.reverse function. For example,</p>
<pre class="prettyprint notranslate tryit">IO.puts(String.reverse("Elixir"))
</pre>
<p>The above program generates the following result &minus;</p> 
<pre class="result notranslate">
rixilE
</pre>
<h3>String Comparison</h3>
<p>To compare 2 strings, we can use the == or the === operators. For example,</p>
<pre class="prettyprint notranslate tryit">
var_1 = "Hello world"
var_2 = "Hello Elixir"
if var_1 === var_2 do
   IO.puts("#{var_1} and #{var_2} are the same")
else
   IO.puts("#{var_1} and #{var_2} are not the same")
end
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
Hello world and Hello elixir are not the same.
</pre>
<h3>String Matching</h3>
<p>We have already seen the use of the =~ string match operator. To check if a string matches a regex, we can also use the string match operator or the String.match? function. For example,</p>
<pre class="prettyprint notranslate tryit">IO.puts(String.match?("foo", ~r/foo/))
IO.puts(String.match?("bar", ~r/foo/))
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
true 
false
</pre>
<p>This same can also be achieved by using the =~ operator. For example,</p>
<pre class="prettyprint notranslate tryit">
IO.puts("foo" =~ ~r/foo/)
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
true
</pre>
<h2>String Functions</h2>
<p>Elixir supports a large number of functions related to strings, some of the most used are listed in the following table.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center">S.No.</th>
<th style="text-align:center">Function and its Purpose</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">1</td>
<td><p><b>at(string, position)</b></p>
<p>Returns the grapheme at the position of the given utf8 string. If position is greater than string length, then it returns nil</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">2</td>
<td><p><b>capitalize(string)</b></p><p>Converts the first character in the given string to uppercase and the remainder to lowercase</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">3</td>
<td><p><b>contains?(string, contents)</b></p><p>Checks if string contains any of the given contents</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">4</td>
<td><p><b>downcase(string)</b></p><p>Converts all characters in the given string to lowercase</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">5</td>
<td><p><b>ends_with?(string, suffixes)</b></p><p>Returns true if string ends with any of the suffixes given</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">6</td>
<td><p><b>first(string)</b></p><p>Returns the first grapheme from a utf8 string, nil if the string is empty</p></td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">7</td>
<td>
<p>
<b>last(string)</b></p>
<p>Returns the last grapheme from a utf8 string, nil if the string is empty</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">8</td>
<td>
<p>
<b>replace(subject, pattern, replacement, options \\ [])</b></p>
<p>Returns a new string created by replacing occurrences of pattern in subject with replacement</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">9</td>
<td>
<p><b>slice(string, start, len)</b></p>
<p>Returns a substring starting at the offset start, and of length len</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">10</td>
<td>
<p><b>split(string)</b></p>
<p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">11</td>
<td>
<p><b>upcase(string)</b></p>
<p>Converts all characters in the given string to uppercase</p>
</td>
</tr>
</table>
<h2>Binaries</h2>
<p>A binary is just a sequence of bytes. Binaries are defined using <b>&lt;&lt; &gt;&gt;</b>. For example: </p>
<pre class="result notranslate">
&lt;&lt; 0, 1, 2, 3 &gt;&gt;
</pre>
<p>Of course, those bytes can be organized in any way, even in a sequence that does not make them a valid string. For example, </p>
<pre class="result notranslate">
&lt;&lt; 239, 191, 191 &gt;&gt;
</pre>
<p>Strings are also binaries. And the string concatenation operator <b>&lt;&gt;</b> is actually a Binary concatenation operator: </p>
<pre class="prettyprint notranslate tryit">
IO.puts(&lt;&lt; 0, 1 &gt;&gt; &lt;&gt; &lt;&lt; 2, 3 &gt;&gt;)
</pre>
<p>The above code generates the following result &minus;</p>
<pre class="result notranslate">
&lt;&lt; 0, 1, 2, 3 &gt;&gt;
</pre>
<p>Note the ł character. Since this is utf-8 encoded, this character representation takes up 2 bytes. </p>
<p>Since each number represented in a binary is meant to be a byte, when this value goes up from 255, it is truncated. To prevent this, we use size modifier to specify how many bits we want that number to take. For example &minus;</p>
<pre class="prettyprint notranslate">
IO.puts(&lt;&lt; 256 &gt;&gt;) # truncated, it'll print &lt;&lt; 0 &gt;&gt;
IO.puts(&lt;&lt; 256 :: size(16) &gt;&gt;) #Takes 16 bits/2 bytes, will print &lt;&lt; 1, 0 &gt;&gt;
</pre>
<p>The above program will generate the following result &minus;</p>
<pre class="result notranslate">
&lt;&lt; 0 &gt;&gt;
&lt;&lt; 1, 0 &gt;&gt;
</pre>
<p>We can also use the utf8 modifier, if a character is code point then, it will be produced in the output; else the bytes &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts(&lt;&lt; 256 :: utf8 &gt;&gt;)</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
Ā
</pre>
<p>We also have a function called <b>is_binary</b> that checks if a given variable is a binary. Note that only variables which are stored as multiples of 8bits are binaries.</p>
<h3>Bitstrings</h3>
<p>If we define a binary using the size modifier and pass it a value that is not a multiple of 8, we end up with a bitstring instead of a binary. For example, </p>
<pre class="prettyprint notranslate">
bs = &lt;&lt; 1 :: size(1) &gt;&gt;
IO.puts(bs)
IO.puts(is_binary(bs))
IO.puts(is_bitstring(bs))
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
&lt;&lt; 1::size(1) &gt;&gt;
false
true
</pre>
<p>This means that variable <b>bs</b> is not a binary but rather a bitstring. We can also say that a binary is a bitstring where the number of bits is divisible by 8. Pattern matching works on binaries as well as bitstrings in the same way.</p>
<h1>Elixir - Char lists</h1>
<p>A char list is nothing more than a list of characters. Consider the following program to understand the same.</p>
<pre class="prettyprint notranslate tryit">
IO.puts('Hello')
IO.puts(is_list('Hello'))
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
Hello
true
</pre>
<p>Instead of containing bytes, a char list contains the code points of the characters between single-quotes. <b>So while the double-quotes represent a string (i.e. a binary), singlequotes represent a char list (i.e. a list)</b>. Note that IEx will generate only code points as output if any of the chars is outside the ASCII range.</p>
<p>Char lists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a char list to a string and back by using the to_string(char_list) and <i>to_char_list(string)</i> functions &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts(is_list(to_char_list("hełło")))
IO.puts(is_binary(to_string ('hełło')))
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
true
true
</pre>
<p><b>NOTE</b> &minus; The functions <b>to_string</b> and <b>to_char_list</b> are polymorphic, i.e., they can take multiple types of input like atoms, integers and convert them to strings and char lists respectively. </p>
<h1>Elixir - Lists and Tuples</h1>
<h2>(Linked) Lists</h2>
<p>A linked list is a heterogeneous list of elements that are stored at different locations in memory and are kept track of by using references. Linked lists are data structures especially used in functional programming.</p>
<p>Elixir uses square brackets to specify a list of values. Values can be of any type &minus;</p>
<pre class="prettyprint notranslate">
[1, 2, true, 3]
</pre>
<p>When Elixir sees a list of printable ASCII numbers, Elixir will print that as a char list (literally a list of characters). Whenever you see a value in IEx and you are not sure what it is, you can use the <b>i</b> function to retrieve information about it.</p>
<pre class="prettyprint notranslate tryit">
IO.puts([104, 101, 108, 108, 111])
</pre>
<p>The above characters in the list are all printable. When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
'hello'
</pre>
<p>You can also define lists the other way round, using single quotes &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts(is_list('Hello'))
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
true
</pre>
<p>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types.</p>
<h3>Length of a List</h3>
<p>To find the length of a list, we use the length function as in the following program &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts(length([1, 2, :true, "str"]))
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
4
</pre>
<h3>Concatenation and Subtraction</h3>
<p>Two lists can be concatenated and subtracted using the <b>++</b> and <b>--</b> operators. Consider the following example to understand the functions.</p>
<pre class="prettyprint notranslate">
IO.puts([1, 2, 3] ++ [4, 5, 6])
IO.puts([1, true, 2, false, 3, true] -- [true, false])
</pre>
<p>This will give you a concatenated string in the first case and a subtracted string in the second. The above program generates the following result &minus;</p>
<pre class="result notranslate">
[1, 2, 3, 4, 5, 6]
[1, 2, 3, true]
</pre>
<h3>Head and Tail of a List</h3>
<p>The head is the first element of a list and the tail is the remainder of a list. They can be retrieved with the functions <b>hd</b> and <b>tl</b>. Let us assign a list to a variable and retrieve its head and tail.</p>
<pre class="prettyprint notranslate">
list = [1, 2, 3]
IO.puts(hd(list))
IO.puts(tl(list))
</pre>
<p>This will give us the head and tail of the list as output. The above program generates the following result &minus;</p>
<pre class="result notranslate">
1
[2, 3]
</pre>
<p><b>Note</b> &minus; Getting the head or the tail of an empty list is an error.</p>
<h2>Other List functions</h2>
<p>Elixir standard library provides a whole lot of functions to deal with lists. We will have a look at some of those here. You can check out the rest here <a href="http://elixir-lang.org/docs/stable/elixir/List.html" rel="nofollow" target="_blank">List</a>.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center">S.no.</th>
<th style="text-align:center">Function Name and Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">1</td>
<td>
<p><b>delete(list, item)</b></p>
<p>Deletes the given item from the list. Returns a list without the item. If the item occurs more than once in the list, just the first occurrence is removed.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">2</td>
<td>
<p><b>delete_at(list, index)</b></p> 
<p>Produces a new list by removing the value at the specified index. Negative indices indicate an offset from the end of the list. If index is out of bounds, the original list is returned.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">3</td>
<td>
<p><b>first(list)</b></p>
<p>Returns the first element in list or nil if list is empty.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">4</td>
<td>
<p><b>flatten(list)</b></p>
<p>Flattens the given list of nested lists.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">5</td>
<td>
<p><b>insert_at(list, index, value)</b></p>
<p>Returns a list with value inserted at the specified index. Note that index is capped at the list length. Negative indices indicate an offset from the end of the list.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">6</td>
<td>
<p><b>last(list)</b></p>
<p>Returns the last element in list or nil if list is empty.</p>
</td>
</tr>
</table>
<h2>Tuples</h2>
<p>Tuples are also data structures which store a number of other structures within them. Unlike lists, they store elements in a contiguous block of memory. This means accessing a tuple element per index or getting the tuple size is a fast operation. Indexes start from zero.</p>
<p>Elixir uses curly brackets to define tuples. Like lists, tuples can hold any value &minus;</p>
<pre class="result notranslate">
{:ok, "hello"}
</pre>
<h3>Length of a Tuple</h3>
<p>To get the length of a tuple, use the <b>tuple_size</b> function as in the following program &minus;</p>
<pre class="result notranslate">
IO.puts(tuple_size({:ok, "hello"}))
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
2
</pre>
<h3>Appending a Value</h3>
<p>To append a value to the tuple, use the Tuple.append function &minus;</p>
<pre class="prettyprint notranslate">
tuple = {:ok, "Hello"}
Tuple.append(tuple, :world)
</pre>
<p>This will create and return a new tuple: {:ok, "Hello", :world}</p>
<h3>Insertng a Value</h3>
<p>To insert a value at a given position, we can either use the <b>Tuple.insert_at</b> function or the <b>put_elem</b> function. Consider the following example to understand the same &minus;</p>
<pre class="prettyprint notranslate">
tuple = {:bar, :baz}
new_tuple_1 = Tuple.insert_at(tuple, 0, :foo)
new_tuple_2 = put_elem(tuple, 1, :foobar)
</pre>
<p>Notice that <b>put_elem</b> and <b>insert_at</b> returned new tuples. The original tuple stored in the tuple variable was not modified because Elixir data types are immutable. By being immutable, Elixir code is easier to reason about as you never need to worry if a particular code is mutating your data structure in place.</p>
<h2>Tuples vs. Lists</h2>
<p>What is the difference between lists and tuples?</p>
<p>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. We call each pair of value and pointer a cons cell. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size. Updating a list is fast as long as we are prepending elements.</p>
<p>Tuples, on the other hand, are stored contiguously in memory. This means getting the tuple size or accessing an element by index is fast. However, updating or adding elements to tuples is expensive because it requires copying the whole tuple in memory.</p>
<h1>Elixir - Keyword lists</h1>
<p>So far, we have not discussed any associative data structures, i.e., data structures that can associate a certain value (or multiple values) to a key. Different languages call these features with different names like dictionaries, hashes, associative arrays, etc.</p>
<p>In Elixir, we have two main associative data structures: keyword lists and maps. In this chapter, we will focus on Keyword lists.</p> 
<p>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of an associative data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list. Consider the following example to understand the same &minus;</p>
<pre class="result notranslate">
list = [{:a, 1}, {:b, 2}]
</pre>
<p>Elixir supports a special syntax for defining such lists. We can place the colon at the end of each atom and get rid of the tuples entirely. For example, </p>
<pre class="prettyprint notranslate tryit">
list_1 = [{:a, 1}, {:b, 2}]
list_2 = [a: 1, b: 2]
IO.puts(list_1 == list_2)
</pre>
<p>The above program will generate the following result &minus;</p>
<pre class="result notranslate">
true
</pre>
<p>Both of these represent a keyword list. Since keyword lists are also lists, we can use all the operations we used on lists on them.</p>
<p>To retrieve the value associated with an atom in the keyword list, pass the atom as to [] after the name of the list &minus;</p>
<pre class="prettyprint notranslate tryit">
list = [a: 1, b: 2]
IO.puts(list[:a])
</pre>
<p>The above program generates the following result &minus;</p> 
<pre class="result notranslate">
1
</pre>
<p>Keyword lists have three special characteristics &minus;</p>
<ul class="list">
<li>Keys must be atoms.</li>
<li>Keys are ordered, as specified by the developer.</li>
<li>Keys can be given more than once.</li>
</ul>
<p>In order to manipulate keyword lists, Elixir provides <a rel="nofollow" target="_blank" href="http://elixir-lang.org/docs/stable/elixir/Keyword.html" >the Keyword module</a>. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly as options. If you need to store many items or guarantee one-key associates with a maximum one-value, you should use maps instead.</p>
<h2>Accessing a key</h2>
<p>To access values associated with a given key, we use the <b>Keyword.get</b> function. It returns the first value associated with the given key. To get all the values, we use the Keyword.get_values function. For example &minus;</p>
<pre class="prettyprint notranslate">
kl = [a: 1, a: 2, b: 3] 
IO.puts(Keyword.get(kl, :a)) 
IO.puts(Keyword.get_values(kl)) 
</pre>
<p>The above program will generate the following result &minus;</p>
<pre class="result notranslate">
1
[1, 2]
</pre>
<h2>Inserting a key</h2>
<p>To add a new value, use <b>Keyword.put_new</b>. If the key already exists, its value remains unchanged &minus;</p>
<pre class="prettyprint notranslate tryit">
kl = [a: 1, a: 2, b: 3]
kl_new = Keyword.put_new(kl, :c, 5)
IO.puts(Keyword.get(kl_new, :c))
</pre>
<p>When the above program is run, it produces a new Keyword list with additional key, c and generates the following result &minus;</p>
<pre class="result notranslate">
5
</pre>
<h2>Deleting a key</h2>
<p>If you want to delete all entries for a key, use <b>Keyword.delete;</b> to delete only the first entry for a key, use <b>Keyword.delete_first</b>.</p>
<pre class="prettyprint notranslate tryit">
kl = [a: 1, a: 2, b: 3, c: 0]
kl = Keyword.delete_first(kl, :b)
kl = Keyword.delete(kl, :a)

IO.puts(Keyword.get(kl, :a))
IO.puts(Keyword.get(kl, :b))
IO.puts(Keyword.get(kl, :c))
</pre>
<p>This will delete the first <b>b</b> in the List and all the <b>a</b> in the list. When the above program is run, it will generate the following result &minus;</p>
<pre class="result notranslate">
0
</pre>
<h1>Elixir - Maps</h1>
<p>Keyword lists are a convenient way to address content stored in lists by key, but underneath, Elixir is still walking through the list. That might be suitable if you have other plans for that list requiring walking through all of it, but it can be an unnecessary overhead if you are planning to use keys as your only approach to the data.</p>
<p>This is where maps come to your rescue. Whenever you need a key-value store, maps are the “go to” data structure in Elixir.</p>
<h3>Creating a Map</h3>
<p>A map is created using the %{} syntax &minus;</p>
<pre class="prettyprint notranslate">
map = %{:a =&gt; 1, 2 =&gt; :b}
</pre>
<p>Compared to the keyword lists, we can already see two differences &minus;</p>
<ul class="list">
<li>Maps allow any value as a key.</li>
<li>Maps’ keys do not follow any ordering.</li>
</ul>
<h3>Accessing a key</h3>
<p>In order to acces value associated with a key, Maps use the same syntax as Keyword lists &minus;</p>
<pre class="prettyprint notranslate tryit">
map = %{:a =&gt; 1, 2 =&gt; :b}
IO.puts(map[:a])
IO.puts(map[2])
</pre>
<p>When the above program is run, it generates the following result &minus;</p>
<pre class="result notranslate">
1
b
</pre>
<h3>Inserting a key</h3>
<p>To insert a key in a map, we use the <b>Dict.put_new</b> function which takes the map, new key and new value as arguments &minus;</p>
<pre class="prettyprint notranslate tryit">
map = %{:a =&gt; 1, 2 =&gt; :b}
new_map = Dict.put_new(map, :new_val, "value") 
IO.puts(new_map[:new_val])
</pre>
<p>This will insert the key-value pair <b>:new_val - "value"</b> in a new map. When the above program is run, it generates the following result &minus;</p>
<pre class="result notranslate">
"value"
</pre>
<h3>Updating a Value</h3>
<p>To update a value already present in the map, you can use the following syntax &minus;</p>
<pre class="prettyprint notranslate tryit">
map = %{:a =&gt; 1, 2 =&gt; :b}
new_map = %{ map | a: 25}
IO.puts(new_map[:a])
</pre>
<p>When the above program is run, it generates the following result &minus;</p>
<pre class="result notranslate">
25
</pre>
<h3>Pattern Matching</h3>
<p>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value &minus;</p>
<pre class="prettyprint notranslate tryit">
%{:a =&gt; a} = %{:a =&gt; 1, 2 =&gt; :b}
IO.puts(a)
</pre>
<p>This will match <b>a</b> with <b>1</b>. And hence, it will generate the output as <b>1</b>.</p>
<p>As shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.</p>
<p>Variables can be used when accessing, matching and adding map keys &minus;</p>
<pre class="prettyprint notranslate">
n = 1
map = %{n =&gt; :one}
%{^n =&gt; :one} = %{1 =&gt; :one, 2 =&gt; :two, 3 =&gt; :three}
</pre>
<p><a href="http://elixir-lang.org/docs/stable/elixir/Map.html" rel="nofollow" target="_blank">The Map module</a> provides a very similar API to the Keyword module with convenience functions to manipulate maps. You can use functions such as the <b>Map.get, Map.delete</b>, to manipulate maps. </p>
<h3>Maps with Atom keys</h3>
<p>Maps come with a few interesting properties. When all the keys in a map are atoms, you can use the keyword syntax for convenience &minus;</p>
<pre class="prettyprint notranslate">
map = %{:a =&gt; 1, 2 =&gt; :b} 
IO.puts(map.a) 
</pre>
<p>Another interesting property of maps is that they provide their own syntax for updating and accessing atom keys &minus;</p>
<pre class="prettyprint notranslate tryit">
map = %{:a =&gt; 1, 2 =&gt; :b}
IO.puts(map.a)
</pre>
<p>Note that to access atom keys in this way, it should exist or the program will fail to work.</p>
<h1>Elixir - Modules</h1>
<p>In Elixir, we group several functions into modules. We have already used different modules in the previous chapters such as the String module, Bitwise module, Tuple module, etc.</p>
<p>In order to create our own modules in Elixir, we use the <b>defmodule</b> macro. We use the <b>def</b> macro to define functions in that module &minus;</p>
<pre class="prettyprint notranslate">
defmodule Math do
   def sum(a, b) do
      a + b
   end
end
</pre>
<p>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. We need to learn how to compile Elixir code and also how to run Elixir scripts.</p>
<h2>Compilation</h2>
<p>It is always convenient to write modules into files so they can be compiled and reused. Let us assume we have a file named math.ex with the following content &minus;</p>
<pre class="prettyprint notranslate">
defmodule Math do
   def sum(a, b) do
      a + b
   end
end
</pre>
<p>We can compile the files using the command &minus;<b>elixirc</b> :</p>
<pre class="result notranslate">
$ elixirc math.ex
</pre>
<p>This will generate a file named <b>Elixir.Math.beam</b> containing the bytecode for the defined module. If we start <b>iex</b> again, our module definition will be available (provided that iex is started in the same directory the bytecode file is in). For example,</p>
<pre class="prettyprint notranslate">IO.puts(Math.sum(1, 2))
</pre>
<p>The above program will generate the following result &minus;</p>
<pre class="result notranslate">
3
</pre>
<h2>Scripted Mode</h2>
<p>In addition to the Elixir file extension <b>.ex</b>, Elixir also supports <b>.exs</b> files for scripting. Elixir treats both files exactly the same way, the only difference is in the objective. <b>.ex</b> files are meant to be compiled while .exs files are used for <b>scripting</b>. When executed, both extensions compile and load their modules into memory, although only <b>.ex</b> files write their bytecode to disk in the format of .beam files.</p>
<p>For example, if we wanted to run the <b>Math.sum</b> in the same file, we can use the .exs in following way &minus;</p>
<h3>Math.exs</h3>
<pre class="prettyprint notranslate">
defmodule Math do
   def sum(a, b) do
      a + b
   end
end
IO.puts(Math.sum(1, 2))
</pre>
<p>We can run it using the Elixir command &minus;</p>
<pre class="result notranslate">
$ elixir math.exs
</pre>
<p>The file will be compiled in memory and executed, printing “3” as the result. No bytecode file will be created.</p>
<h2>Module Nesting</h2>
<p>Modules can be nested in Elixir. This feature of the language helps us organize our code in a better way. To create nested modules, we use the following syntax &minus;</p>
<pre class="result notranslate">
defmodule Foo do
   #Foo module code here
   defmodule Bar do
      #Bar module code here
   end
end
</pre>
<p>The example given above will define two modules: <b>Foo</b> and <b>Foo.Bar</b>. The second can be accessed as <b>Bar</b> inside <b>Foo</b> as long as they are in the same lexical scope. If, later, the <b>Bar</b> module is moved outside the Foo module definition, it must be referenced by its full name (Foo.Bar) or an alias must be set using the alias directive discussed in the alias chapter.</p>
<p><b>Note</b> &minus; In Elixir, there is no need to define the Foo module in order to define the Foo.Bar module, as the language translates all module names to atoms. You can define arbitrarilynested modules without defining any module in the chain. For example, you can define <b>Foo.Bar.Baz</b> without defining <b>Foo</b> or <b>Foo.Bar</b>.</p>
<h1>Elixir - Aliases</h1>
<p>In order to facilitate software reuse, Elixir provides three directives – <b>alias, require</b> and <b>import</b>. It also provides a macro called use which is summarized below &minus;</p>
<pre class="prettyprint notranslate">
# Alias the module so it can be called as Bar instead of Foo.Bar
alias Foo.Bar, as: Bar

# Ensure the module is compiled and available (usually for macros)
require Foo

# Import functions from Foo so they can be called without the `Foo.` prefix
import Foo

# Invokes the custom code defined in Foo as an extension point
use Foo
</pre>
<p>Let us now understand in detail about each directive.</p>
<h2>alias</h2>
<p>The alias directive allows you to set up aliases for any given module name. For example, if you want to give an alias <b>'Str'</b> to the String module, you can simply write &minus;</p>
<pre class="prettyprint notranslate tryit">
alias String, as: Str
IO.puts(Str.length("Hello")) 
</pre>
<p>The above program generates the following result &minus;</p>
<pre class="result notranslate">
5
</pre>
<p>An alias is given to the <b>String</b> module as <b>Str</b>. Now when we call any function using the Str literal, it actually references to the <b>String</b> module. This is very helpful when we use very long module names and want to substitute those with shorter ones in the current scope.</p>
<p><b>NOTE</b> &minus; Aliases <b>MUST</b> start with a capital letter.</p>
<p>Aliases are valid only within the <b>lexical scope</b> they are called in. For example, if you have 2 modules in a file and make an alias within one of the modules, that alias will not be accessible in the second module.</p>
<p>If you give the name of an in built module, like String or Tuple, as an alias to some other module, to access the inbuilt module, you will need to prepend it with <b>"Elixir."</b>. For example,</p>
<pre class="prettyprint notranslate">
alias List, as: String
#Now when we use String we are actually using List.
#To use the string module: 
IO.puts(Elixir.String.length("Hello"))
</pre>
<p>When the above program is run, it generates the following result &minus;</p>
<pre class="result notranslate">
5
</pre>
<h2>require</h2>
<p>Elixir provides macros as a mechanism for meta-programming (writing code that generates code). </p>
<p>Macros are chunks of code that are executed and expanded at compilation time. This means, in order to use a macro, we need to guarantee that its module and implementation are available during compilation. This is done with the <b>require</b> directive.</p>
<pre class="prettyprint notranslate">
Integer.is_odd(3)
</pre>
<p>When the above program is run, it will generate the following result &minus;</p>
<pre class="result notranslate">
** (CompileError) iex:1: you must require Integer before invoking the macro Integer.is_odd/1
</pre>
<p>In Elixir, <b>Integer.is_odd</b> is defined as a <b>macro</b>. This macro can be used as a guard. This means that, in order to invoke <b>Integer.is_odd</b>, we will need the Integer module.</p>
<p>Use the <b>require Integer</b> function and run the program as shown below.</p>
<pre class="prettyprint notranslate">
require Integer
Integer.is_odd(3)
</pre>
<p>This time the program will run and produce the output as: <b>true</b>.</p>
<p>In general, a module is not required before usage, except if we want to use the macros available in that module. An attempt to call a macro that was not loaded will raise an error. Note that like the alias directive, <i>require is also lexically scoped</i>. We will talk more about macros in a later chapter.</p>
<h2>import</h2>
<p>We use the <b>import</b> directive to easily access functions or macros from other modules without using the fully-qualified name. For instance, if we want to use the <b>duplicate</b> function from the List module several times, we can simply import it.</p>
<pre class="prettyprint notranslate">
import List, only: [duplicate: 2]
</pre>
<p>In this case, we are importing only the function duplicate (with argument list length 2) from List. Although <b>:only</b> is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. :except could also be given as an option in order to import everything in a module except a list of functions.</p>
<p>The <b>import</b> directive also supports <b>:macros</b> and <b>:functions</b> to be given to <b>:only</b>. For example, to import all macros, a user can write &minus;</p>
<pre class="prettyprint notranslate">
import Integer, only: :macros
</pre>
<p>Note that import too is <b>Lexically scoped</b> just like the require and the alias directives. Also note that <b>'import'ing a module also 'require's it</b>.</p>
<h2>use</h2>
<p>Although not a directive, <b>use</b> is a macro tightly related to <b>require</b> that allows you to use a module in the current context. The use macro is frequently used by developers to bring external functionality into the current lexical scope, often modules. Let us understand the use directive through an example &minus;</p>
<pre class="prettyprint notranslate">
defmodule Example do 
   use Feature, option: :value 
end 
</pre>
<p>Use is a macro that transforms the above into &minus;</p>
<pre class="prettyprint notranslate">
defmodule Example do
   require Feature
   Feature.__using__(option: :value)
end
</pre>
<p>The <b>use Module</b> first requires the module and then calls the <b>__using__</b> macro on Module. Elixir has great metaprogramming capabilities and it has macros to generate code at compile time. The _<i>_using__</i> macro is called in the above instance, and the code is injected into our local context. The local context is where the <i>use macro</i> was called at the time of compilation.</p>
<h1>Elixir - Functions</h1>
<p>A function is a set of statements organized together to perform a specific task. Functions in programming work mostly like function in Math. You give functions some input, they generate output based on the input provided.</p>
<p>There are 2 types of functions in Elixir &minus;</p>
<h3>Anonymous function</h3>
<p>Functions defined using the <b>fn..end construct</b> are anonymous functions. These functions are sometimes also called as lambdas. They are used by assigning them to variable names.</p>
<h3>Named function</h3>
<p>Functions defined using the <b>def keyword</b> are named functions. These are native functions provided in Elixir.</p>
<h2>Anonymous Functions</h2>
<p>Just as the name implies, an anonymous function has no name. These are frequently passed to other functions. To define an anonymous function in Elixir, we need the <b>fn</b> and <b>end</b> keywords. Within these, we can define any number of parameters and function bodies separated by <b>-&gt;</b>. For example,</p>
<pre class="prettyprint notranslate tryit">
sum = fn (a, b) -&gt; a + b end
IO.puts(sum.(1, 5))
</pre>
<p>When running above program, is run, it generates the following result &minus;</p>
<pre class="result notranslate">
6
</pre>
<p>Note that these functions are not called like the named functions. We have a '<b>.</b>' between the function name and its arguments. </p>
<h3>Using the Capture Operator</h3>
<p>We can also define these functions using the capture operator. This is an easier method to create functions. We will now define the above sum function using the capture operator,</p>
<pre class="prettyprint notranslate tryit">
sum = &amp;(&amp;1 + &amp;2) 
IO.puts(sum.(1, 2))
</pre>
<p>When the above program is run, it generates the following result &minus;</p>
<pre class="result notranslate">
3
</pre>
<p>In the shorthand version, our parameters are not named but are available to us as &amp;1, &amp;2, &amp;3, and so on.</p>
<h3>Pattern Matching Functions</h3>
<p>Pattern matching is not only limited to variables and data structures. We can use pattern matching to make our functions polymorphic. For example, we will declare a function that can either take 1 or 2 inputs (within a tuple) and print them to the console,</p>
<pre class="prettyprint notranslate">
handle_result = fn
   {var1} -&gt; IO.puts("#{var1} found in a tuple!")
   {var_2, var_3} -&gt; IO.puts("#{var_2} and #{var_3} found!")
end
handle_result.({"Hey people"})
handle_result.({"Hello", "World"})
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Hey people found in a tuple!
Hello and World found!
</pre>
<h2>Named Functions</h2>
<p>We can define functions with names so we can easily refer to them later. Named functions are defined within a module using the def keyword. Named functions are always defined in a module. To call named functions, we need to reference them using their module name.</p>
<p>The following is the syntax for named functions &minus;</p>
<pre class="result notranslate">
def function_name(argument_1, argument_2) do
   #code to be executed when function is called
end
</pre>
<p>Let us now define our named function sum within the Math module.</p>
<pre class="prettyprint notranslate tryit">
defmodule Math do
   def sum(a, b) do
      a + b
   end
end

IO.puts(Math.sum(5, 6))
</pre>
<p>When running above program, it produces following result &minus;</p>
<pre class="result notranslate">
11
</pre>
<p>For 1-liner functions, there is a shorthand notation to define these functions, using <b>do:</b>. For example &minus;</p>
<pre class="prettyprint notranslate tryit">
defmodule Math do
   def sum(a, b), do: a + b
end
IO.puts(Math.sum(5, 6))
</pre>
<p>When running above program, it produces following result &minus;</p>
<pre class="result notranslate">
11
</pre>
<h3>Private Functions</h3>
<p>Elixir provides us the ability to define private functions that can be accessed from within the module in which they are defined. To define a private function, use <b>defp</b> instead of <b>def</b>. For example, </p>
<pre class="prettyprint notranslate">
defmodule Greeter do
   def hello(name), do: phrase &lt;&gt; name
   defp phrase, do: "Hello "
end

Greeter.hello("world")
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello world
</pre>
<p>But if we just try to explicitly call phrase function, using the <b>Greeter.phrase()</b> function, it will raise an error.</p>
<h3>Default arguments</h3>
<p>If we want a default value for an argument, we use the <b>argument \\ value</b> syntax &minus;</p>
<pre class="prettyprint notranslate">
defmodule Greeter do
   def hello(name, country \\ "en") do
      phrase(country) &lt;&gt; name
   end

   defp phrase("en"), do: "Hello, "
   defp phrase("es"), do: "Hola, "
end

Greeter.hello("Ayush", "en")
Greeter.hello("Ayush")
Greeter.hello("Ayush", "es")
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello, Ayush
Hello, Ayush
Hola, Ayush
</pre>
<h1>Elixir - Recursion</h1>
<p>Recursion is a method where the solution to a problem depends on the solutions to smaller instances of the same problem. Most computer programming languages support recursion by allowing a function to call itself within the program text.</p>
<p>Ideally recursive functions have an ending condition. This ending condition, also known as the base case stops reentering the function and adding function calls to the stack. This is where the recursive function call stops. Let us consider the following example to further understand the recursive function.</p>
<pre class="prettyprint notranslate">
defmodule Math do
   def fact(res, num) do
   if num === 1 do
      res
   else
      new_res = res * num
      fact(new_res, num-1)
      end
   end
end

IO.puts(Math.fact(1,5))</pre>
<p>When the above program is run, it generates the following result &minus;</p>
<pre class="result notranslate">
120
</pre>
<p>So in the above function, <b>Math.fact</b>, we are calculating the factorial of a number. Note that we are calling the function within itself. Let us now understand how this works.</p>
<p>We have provided it with 1 and the number whose factorial we want to calculate. The function checks if the number is 1 or not and returns res if it is 1<b>(Ending condition)</b>. If not then it creates a variable new_res and assigns it the value of previous res * current num. It returns the value returned by our function call <i>fact(new_res, num-1)</i>. This repeats until we get num as 1. Once that happens, we get the result. </p>
<p>Let us consider another example, printing each element of the list one by one. To do this, we will utilize the <b>hd</b> and <b>tl</b> functions of lists and pattern matching in functions &minus;</p>
<pre class="prettyprint notranslate tryit">
a = ["Hey", 100, 452, :true, "People"]
defmodule ListPrint do
   def print([]) do
   end
   def print([head | tail]) do 
      IO.puts(head)
      print(tail)
   end
end

ListPrint.print(a)
</pre>
<p>The first print function is called when we have an empty list<b>(ending condition)</b>. If not, then the second print function will be called which will divide the list in 2 and assign the first element of the list to head and the remaining of the list to tail. The head then gets printed and we call the print function again with the rest of the list, i.e., tail. When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
"Hey"
100
452
:true
"People"
</pre>
<h1>Elixir - Loops</h1>
<p>Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, you will write &minus;</p>
<pre class="prettyprint notranslate">
for(i = 0; i &lt; 10; i++) {
   printf("%d", array[i]);
}
</pre>
<p>In the example given above, we are mutating both the array and the variable <b>i</b>. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. </p>
<p>Let us now write a simple loop using recursion that prints hello <b>n</b> times.</p>
<pre class="prettyprint notranslate tryit">defmodule Loop do
   def print_multiple_times(msg, n) when n &lt;= 1 do
      IO.puts msg
   end

   def print_multiple_times(msg, n) do
      IO.puts msg
      print_multiple_times(msg, n - 1)
   end
end

Loop.print_multiple_times("Hello", 10)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
Hello
</pre>
<p>We have utilized function's pattern matching techniques and recursion to successfully implement a loop. Recursive definitions are difficult to understand but converting loops to recursion is easy.</p>
<p>Elixir provides us the <b>Enum module</b>. This module is used for the most iterative looping calls as it is much easier to use those than trying to figure out recursive definitions for the same. We will discuss those in the next chapter. Your own recursive definitions should only be used when you dont find a solution using that module. Those functions are tail call optimized and quite fast.</p>
<h1>Elixir - Enumerables</h1>
<p>An enumerable is an object that may be enumerated. "Enumerated" means to count off the members of a set/collection/category one by one (usually in order, usually by name).</p>
<p>Elixir provides the concept of enumerables and the <a rel="nofollow" target="_blank" href="http://elixir-lang.org/docs/stable/elixir/Enum.html">Enum module</a> to work with them. The functions in the Enum module are limited to, as the name says, enumerating values in data structures. Example of an enumerable data structure is a list, tuple, map, etc. The Enum module provides us with a little over 100 functions to deal with enums. We will discuss a few important functions in this chapter.</p>
<h3>all?</h3>
<p>When we use <b>all</b>? function, the entire collection must evaluate to true otherwise false will be returned. For example, to check if all of the elements in the list are odd numbers, then.</p>
<pre class="prettyprint notranslate tryit">
res = Enum.all?([1, 2, 3, 4], fn(s) -&gt; rem(s,2) == 1 end) 
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
false
</pre>
<p>This is because not all elements of this list are odd.</p>
<h3>any?</h3>
<p>As the name suggests, this function returns true if any element of the collection evaluates to true. For example &minus;</p>
<pre class="prettyprint notranslate tryit">
res = Enum.any?([1, 2, 3, 4], fn(s) -&gt; rem(s,2) == 1 end)
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
true
</pre>
<h3>chunk</h3>
<p>This function divides our collection into small chunks of the size provided as the second argument. For example &minus;</p>
<pre class="prettyprint notranslate">
res = Enum.chunk([1, 2, 3, 4, 5, 6], 2)
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
[[1, 2], [3, 4], [5, 6]]
</pre>
<h3>each</h3>
<p>It may be necessary to iterate over a collection without producing a new value, for this case we use the <b>each</b> function &minus;</p>
<pre class="prettyprint notranslate tryit">
Enum.each(["Hello", "Every", "one"], fn(s) -&gt; IO.puts(s) end)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello
Every
one
</pre>
<h3>map</h3>
<p>To apply our function to each item and produce a new collection we use the map function. It is one of the most useful constructs in functional programming as it is quite expressive and short. Let us consider an example to understand this. We will double the values stored in a list and store it in a new list <b>res</b> &minus;</p>
<pre class="prettyprint notranslate">
res = Enum.map([2, 5, 3, 6], fn(a) -&gt; a*2 end)
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
[4, 10, 6, 12]
</pre>
<h3>reduce</h3>
<p>The <b>reduce</b> function helps us reduce our enumerable to a single value. To do this, we supply an optional accumulator (5 in this example) to be passed into our function; if no accumulator is provided, the first value is used &minus;</p>
<pre class="prettyprint notranslate tryit">
res = Enum.reduce([1, 2, 3, 4], 5, fn(x, accum) -&gt; x + accum end)
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
15
</pre>
<p>The accumulator is the initial value passed to the <b>fn</b>. From the second call onwards the value returned from previous call is passed as accum. We can also use reduce without the accumulator &minus;</p>
<pre class="prettyprint notranslate tryit">
res = Enum.reduce([1, 2, 3, 4], fn(x, accum) -&gt; x + accum end)
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
10
</pre>
<h3>uniq</h3>
<p>The uniq function removes duplicates from our collection and returns only the set of elements in the collection. For example &minus;</p>
<pre class="prettyprint notranslate">
res = Enum.uniq([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])
IO.puts(res)
</pre>
<p>When running above program, it produces the following result &minus;</p>
<pre class="result notranslate">
[1, 2, 3, 4]
</pre>
<h2>Eager Evaluation</h2>
<p>All the functions in the Enum module are eager. Many functions expect an enumerable and return a list back. This means that when performing multiple operations with Enum, each operation is going to generate an intermediate list until we reach the result. Let us consider the following example to understand this &minus;</p> 
<pre class="prettyprint notranslate">
odd? = &amp;(odd? = &amp;(rem(&amp;1, 2) != 0) 
res = 1..100_000 |&gt; Enum.map(&amp;(&amp;1 * 3)) |&gt; Enum.filter(odd?) |&gt; Enum.sum 
IO.puts(res) 
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
7500000000
</pre>
<p>The example above has a pipeline of operations. We start with a range and then multiply each element in the range by 3. This first operation will now create and return a list with 100_000 items. Then we keep all odd elements from the list, generating a new list, now with 50_000 items, and then we sum all entries.</p>
<p>The <b>|&gt;</b> symbol used in the snippet above is the <b>pipe operator</b>: it simply takes the output from the expression on its left side and passes it as the first argument to the function call on its right side. It’s similar to the Unix | operator. Its purpose is to highlight the flow of data being transformed by a series of functions.</p>
<p>Without the <b>pipe</b> operator, the code looks complicated &minus;</p>
<pre class="prettyprint notranslate">
Enum.sum(Enum.filter(Enum.map(1..100_000, &amp;(&amp;1 * 3)), odd?))
</pre>
<p>We have many other functions, however, only a few important ones have been described here.</p>
<h1>Elixir - Streams</h1>
<p>Many functions expect an enumerable and return a <b>list</b> back. It means, while performing multiple operations with Enum, each operation is going to generate an intermediate list until we reach the result.</p> 
<p>Streams support lazy operations as opposed to eager operations by enums. In short, <b>streams are lazy, composable enumerables</b>. What this means is Streams do not perform an operation unless it is absolutely needed. Let us consider an example to understand this &minus;</p>
<pre class="prettyprint notranslate tryit">
odd? = &amp;(rem(&amp;1, 2) != 0)
res = 1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3)) |&gt; Stream.filter(odd?) |&gt; Enum.sum
IO.puts(res)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
7500000000
</pre>
<p>In the example given above, <b>1..100_000 |&gt; Stream.map(&amp;(&amp;1 * 3))</b> returns a data type, an actual stream, that represents the map computation over the range 1..100_000. It has not yet evaluated this representation. Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the Enum module. Streams are useful when working with large, possibly infinite, collections.</p>
<p>Streams and enums have many functions in common. Streams mainly provide the same functions provided by the Enum module which generated Lists as their return values after performing computations on input enumerables. Some of them are listed in the following table &minus;</p>
<table class="table table-bordered">
<tr>
<th style="width:12%;">S. No.</th>
<th style="text-align:center">Function and its Description</th>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">1</td>
<td>
<p><b>chunk(enum, n, step, leftover \\ nil)</b></p>
<p>Streams the enumerable in chunks, containing n items each, where each new chunk starts step elements into the enumerable.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">2</td>
<td>
<p><b>concat(enumerables)</b></p>
<p>Creates a stream that enumerates each enumerable in an enumerable.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">3</td>
<td>
<p><b>each(enum, fun)</b></p>
<p>Executes the given function for each item.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">4</td>
<td>
<p><b>filter(enum, fun)</b></p>
<p>Creates a stream that filters elements according to the given function on enumeration.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">5</td>
<td>
<p><b>map(enum, fun)</b></p>
<p>Creates a stream that will apply the given function on enumeration.</p>
</td>
</tr>
<tr>
<td style="text-align:center;vertical-align:middle">6</td>
<td>
<p><b>drop(enum, n)</b></p> 
<p>Lazily drops the next n items from the enumerable.</p>
</td>
</tr>
</table>
<h1>Elixir - Structs</h1>
<p>Structs are extensions built on top of maps that provide compile-time checks and default values.</p>
<h2>Defining Structs</h2>
<p>To define a struct, the defstruct construct is used:</p>
<pre class="prettyprint notranslate">
defmodule User do
   defstruct name: "John", age: 27
end
</pre>
<p>The keyword list used with defstruct defines what fields the struct will have along with their default values. Structs take the name of the module they are defined in. In the example given above, we defined a struct named User. We can now create User structs by using a syntax similar to the one used to create maps &minus;</p>
<pre class="prettyprint notranslate">
new_john = %User{})
ayush = %User{name: "Ayush", age: 20}
megan = %User{name: "Megan"})
</pre>
<p>The above code will generate three different structs with values &minus;</p>
<pre class="result notranslate">
%User{age: 27, name: "John"}
%User{age: 20, name: "Ayush"}
%User{age: 27, name: "Megan"}
</pre>
<p>Structs provide compile-time guarantees that only the fields (and all of them) defined through defstruct will be allowed to exist in a struct. So you cannot define your own fields once you have created the struct in the module.</p>
<h2>Accessing and Updating Structs</h2>
<p>When we discussed maps, we showed how we can access and update the fields of a map. The same techniques (and the same syntax) apply to structs as well. For example, if we want to update the user we created in the earlier example, then &minus;</p>
<pre class="prettyprint notranslate">
defmodule User do
   defstruct name: "John", age: 27
end
john = %User{}
#john right now is: %User{age: 27, name: "John"}

#To access name and age of John, 
IO.puts(john.name)
IO.puts(john.age)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
John
27
</pre>
<p>To update a value in a struct, we will again use the same procedure that we used in the map chapter,</p>
<pre class="prettyprint notranslate">
meg = %{john | name: "Meg"}
</pre>
<p>Structs can also be used in pattern matching, both for matching on the value of specific keys as well as for ensuring that the matching value is a struct of the same type as the matched value.</p>
<h1>Elixir - Protocols</h1>
<p>Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a protocol is available to any data type as long as it implements the protocol.</p>
<p>Let us consider an example of using protocols. We used a function called to_string in the previous chapters to convert from other types to the string type. This is actually a protocol. It acts according to the input that is given without producing an error. This might seem like we are discussing pattern matching functions, but as we proceed further, it turns out different.</p>
<p>Consider the following example to further understand the protocol mechanism.</p>
<p>Let us create a protocol that will display if the given input is empty or not. We will call this protocol <b>blank?</b>.</p>
<h2>Defining a Protocol</h2>
<p>We can define a protocol in Elixir in the following way &minus;</p>
<pre class="notranslate prettyprint">
defprotocol Blank do
   def blank?(data)
end
</pre>
<p>As you can see, we do not need to define a body for the function. If you are familiar with interfaces in other programming languages, you can think of a Protocol as essentially the same thing.</p>
<p>So this Protocol is saying that anything that implements it must have an <b>empty?</b> function, although it is up to the implementor as to how the function responds. With the protocol defined, let us understand how to add a couple of implementations.</p>
<h2>Implementing a Protocol</h2>
<p>Since we have defined a protocol, we now need to tell it how to handle the different inputs that it might get. Let us build on the example we had taken earlier. We will implement the blank protocol for lists, maps and strings. This will show if the thing we passed is blank or not.</p>
<pre class="prettyprint notranslate">
#Defining the protocol
defprotocol Blank do
   def blank?(data)
end

#Implementing the protocol for lists
defimpl Blank, for: List do
   def blank?([]), do: true
   def blank?(_), do: false
end

#Implementing the protocol for strings
defimpl Blank, for: BitString do
   def blank?(""), do: true
   def blank?(_), do: false
end

#Implementing the protocol for maps
defimpl Blank, for: Map do
   def blank?(map), do: map_size(map) == 0
end

IO.puts(Blank.blank? [])
IO.puts(Blank.blank? [:true, "Hello"])
IO.puts(Blank.blank? "")
IO.puts(Blank.blank? "Hi")
</pre>
<p>You can implement your Protocol for as many or as few types as you want, whatever makes sense for the usage of your Protocol. This was a pretty basic use case of protocols. When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
true
false
true
false
</pre>
<p><b>Note</b> &minus; If you use this for any types other than those you defined the protocol for, it will produce an error.</p>
<h1>Elixir - File IO</h1>
<p>File IO is an integral part of any programming language as it allows the language to interact with the files on the file system. In this chapter, we will discuss two modules – Path and File. </p>
<h2>The Path Module</h2>
<p>The <b>path</b> module is a very small module that can be considered as a helper module for filesystem operations. The majority of the functions in the File module expect paths as arguments. Most commonly, those paths will be regular binaries. The Path module provides facilities for working with such paths. Using functions from the Path module as opposed to just manipulating binaries is preferred since the Path module takes care of different operating systems transparently. It is to be observed that Elixir will automatically convert slashes (/) into backslashes (\) on Windows when performing file operations.</p>
<p>Let us consider the following example to further understand the Path module &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts(Path.join("foo", "bar"))
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
foo/bar
</pre>
<p>There are a lot of methods that the path module provides. You can have a look at the different methods <a href="http://elixir-lang.org/docs/stable/elixir/Path.html" rel="nofollow" target="_blank">here</a>. These methods are frequently used if you are performing many file manipulation operations.</p>
<h2>The File Module</h2>
<p>The file module contains functions that allow us to open files as IO devices. By default, files are opened in binary mode, which requires developers to use the specific <b>IO.binread</b> and <b>IO.binwrite</b> functions from the IO module. Let us create a file called <b>newfile</b> and write some data to it.</p>
<pre class="prettyprint notranslate">
{:ok, file} = File.read("newfile", [:write]) 
# Pattern matching to store returned stream
IO.binwrite(file, "This will be written to the file")
</pre>
<p>If you go to open the file we just wrote into, content will be displayed in the following way &minus;</p>
<pre class="result notranslate">
This will be written to the file 
</pre>
<p>Let us now understand how to use the file module.</p>
<h3>Opening a file</h3>
<p>To open a file, we can use any one of the following 2 functions &minus;</p>
<pre class="prettyprint notranslate">
{:ok, file} = File.open("newfile")
file = File.open!("newfile")
</pre>
<p>Let us now understand the difference between the File.open function and the File.open!() function.</p>
<ul class="list">
<li><p>The <b>File.open</b> function always returns a tuple. If file is successfully opened, it returns the first value in the tuple as <b>:ok</b> and the second value is literal of type io_device. If an error is caused, it will return a tuple with first value as <b>:error</b> and second value as the reason.</p></li>
<li><p>The <b>File.open!()</b> function on the other hand will return a <b>io_device</b> if file is successfully opened else it will raise an error. NOTE: This is the pattern followed in all of the file module functions we are going to discuss.</p></li>
</ul>
<p>We can also specify the modes in which we want to open this file. To open a file as read only and in utf-8 encoding mode, we use the following code &minus;</p>
<pre class="prettyprint notranslate">
file = File.open!("newfile", [:read, :utf8])
</pre>
<h3>Writing to a File</h3>
<p>We have two ways to write to files. Let us see the first one using the write function from the File module.</p>
<pre class="prettyprint notranslate">
File.write("newfile", "Hello")
</pre>
<p>But this should not be used if you are making multiple writes to the same file. Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. If you are doing multiple writes in a loop, open the file via File.open and write to it using the methods in IO module. Let us consider an example to understand the same &minus;</p>
<pre class="prettyprint notranslate">
#Open the file in read, write and utf8 modes. 
file = File.open!("newfile_2", [:read, :utf8, :write])

#Write to this "io_device" using standard IO functions
IO.puts(file, "Random text")
</pre>
<p>You can use other IO module methods like <b>IO.write</b> and <b>IO.binwrite</b> to write to files opened as io_device.</p>
<h3>Reading from a File</h3>
<p>We have two ways to read from files. Let us see the first one using the read function from the File module.</p>
<pre class="prettyprint notranslate">
IO.puts(File.read("newfile"))
</pre>
<p>When running this code, you should get a tuple with the first element as <b>:ok</b> and the second one as the contents of newfile</p>
<p>We can also use the File.read! function to just get the contents of the files returned to us.</p>
<h3>Closing an Open File</h3>
<p>Whenever you open a file using the File.open function, after you are done using it, you should close it using the <b>File.close</b> function &minus;</p>
<pre class="prettyprint notranslate">
File.close(file)
</pre>
<h1>Elixir - Processes</h1>
<p>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Elixir’s processes should not be confused with operating system processes. Processes in Elixir are extremely lightweight in terms of memory and CPU (unlike threads in many other programming languages). Because of this, it is not uncommon to have tens or even hundreds of thousands of processes running simultaneously. </p>
<p>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between different processes.</p>
<h2>The Spawn Function</h2>
<p>The easiest way to create a new process is to use the <b>spawn</b> function. The <b>spawn</b> accepts a function that will be run in the new process. For example &minus;</p>
<pre class="prettyprint notranslate">
pid = spawn(fn -&gt; 2 * 2 end)
Process.alive?(pid)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
false
</pre>
<p>The return value of the spawn function is a PID. This is a unique identifier for the process and so if you run the code above your PID, it will be different. As you can see in this example, the process is dead when we check to see if it alive. This is because the process will exit as soon as it has finished running the given function.</p>
<p>As already mentioned, all Elixir codes run inside processes. If you run the self function you will see the PID for your current session &minus;</p>
<pre class="prettyprint notranslate">
pid = self
 
Process.alive?(pid)
</pre>
<p>When the above program is run, it produces following result &minus;</p>
<pre class="result notranslate">
true
</pre>
<h2>Message Passing</h2>
<p>We can send messages to a process with <b>send</b> and receive them with <b>receive</b>. Let us pass a message to the current process and receive it on the same.</p>
<pre class="prettyprint notranslate">
send(self(), {:hello, "Hi people"})

receive do
   {:hello, msg} -&gt; IO.puts(msg)
   {:another_case, msg} -&gt; IO.puts("This one won't match!")
end
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Hi people
</pre>
<p>We sent a message to the current process using the send function and passed it to the PID of self. Then we handled the incoming message using the <b>receive</b> function.</p>
<p>When a message is sent to a process, the message is stored in the <b>process mailbox</b>. The receive block goes through the current process mailbox searching for a message that matches any of the given patterns. The receive block supports guards and many clauses, such as case.</p>
<p>If there is no message in the mailbox matching any of the patterns, the current process will wait until a matching message arrives. A timeout can also be specified. For example,</p>
<pre class="prettyprint notranslate">
receive do
   {:hello, msg}  -&gt; msg
after
   1_000 -&gt; "nothing after 1s"
end
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
nothing after 1s
</pre>
<p><b>NOTE</b> &minus; A timeout of 0 can be given when you already expect the message to be in the mailbox.</p>
<h2>Links</h2>
<p>The most common form of spawning in Elixir is actually via <b>spawn_link</b> function. Before taking a look at an example with spawn_link, let us understand what happens when a process fails.</p>
<pre class="prettyprint notranslate">
spawn fn -&gt; raise "oops" end
</pre>
<p>When the above program is run, it produces the following error &minus;</p>
<pre class="result notranslate">
[error] Process #PID&lt;0.58.00&gt; raised an exception
** (RuntimeError) oops
   :erlang.apply/2
</pre>
<p>It logged an error but the spawning process is still running. This is because processes are isolated. If we want the failure in one process to propagate to another one, we need to link them. This can be done with the <b>spawn_link</b> function. Let us consider an example to understand the same &minus;</p>
<pre class="prettyprint notranslate tryit">
spawn_link fn -&gt; raise "oops" end
</pre>
<p>When the above program is run, it produces the following error &minus;</p>
<pre class="result notranslate">
** (EXIT from #PID&lt;0.41.0&gt;) an exception was raised:
   ** (RuntimeError) oops
      :erlang.apply/2
</pre>
<p>If you are running this in <b>iex</b> shell then the shell handles this error and does not exit. But if you run by first making a script file and then using <b>elixir &lt;file-name&gt;.exs</b>, the parent process will also be brought down due to this failure.</p>
<p>Processes and links play an important role when building fault-tolerant systems. In Elixir applications, we often link our processes to supervisors which will detect when a process dies and start a new process in its place. This is only possible because processes are isolated and don’t share anything by default. And since processes are isolated, there is no way a failure in a process will crash or corrupt the state of another. While other languages will require us to catch/handle exceptions; in Elixir, we are actually fine with letting processes fail because we expect supervisors to properly restart our systems.</p>
<h2>State</h2>
<p>If you are building an application that requires state, for example, to keep your application configuration, or you need to parse a file and keep it in memory, where would you store it? Elixir's process functionality can come in handy when doing such things.</p>
<p>We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let us write a module that starts new processes that work as a key-value store in a file named <b>kv.exs</b>.</p>
<pre class="prettyprint notranslate">
defmodule KV do
   def start_link do
      Task.start_link(fn -&gt; loop(%{}) end)
   end

   defp loop(map) do
      receive do
         {:get, key, caller} -&gt;
         send caller, Map.get(map, key)
         loop(map)
         {:put, key, value} -&gt;
         loop(Map.put(map, key, value))
      end
   end
end
</pre>
<p>Note that the <b>start_link</b> function starts a new process that runs the <b>loop</b> function, starting with an empty map. The <b>loop</b> function then waits for messages and performs the appropriate action for each message. In the case of a <b>:get</b> message, it sends a message back to the caller and calls loop again, to wait for a new message. While the <b>:put</b> message actually invokes <b>loop</b> with a new version of the map, with the given key and value stored.</p>
<p>Let us now run the following &minus;</p>
<pre class="prettyprint notranslate">
iex kv.exs
</pre>
<p>Now you should be in your <b>iex</b> shell. To test out our module, try the following &minus;</p>
<pre class="prettyprint notranslate">
{:ok, pid} = KV.start_link

# pid now has the pid of our new process that is being 
# used to get and store key value pairs 

# Send a KV pair :hello, "Hello" to the process
send pid, {:put, :hello, "Hello"}

# Ask for the key :hello
send pid, {:get, :hello, self()}

# Print all the received messages on the current process.
flush()
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
"Hello"
</pre>
<h1>Elixir - Sigils</h1>
<p>In this chapter, we are going to explore sigils, the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (~) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</p>
<h2>Regex</h2>
<p>Regexes in Elixir are sigils. We have seen their use in the String chapter. Let us again take an example to see how we can use regex in Elixir.</p>
<pre class="prettyprint notranslate tryit">
# A regular expression that matches strings which contain "foo" or "bar":
regex = ~r/foo|bar/
IO.puts("foo" =~ regex)
IO.puts("baz" =~ regex)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
true
false
</pre>
<p>Sigils support 8 different delimiters &minus;</p>
<pre class="result notranslate">
~r/hello/
~r|hello|
~r"hello"
~r'hello'
~r(hello)
~r[hello]
~r{hello}
~r&lt;hello&gt;
</pre>
<p>The reason behind supporting different delimiters is that different delimiters can be more suited for different sigils. For example, using parentheses for regular expressions may be a confusing choice as they can get mixed with the parentheses inside the regex. However, parentheses can be handy for other sigils, as we will see in the next section.</p>
<p>Elixir supports Perl compatible regexes and also support modifiers. You can read up more about the use of regexes <a href="../perl/perl_regular_expressions.html">here</a>.</p>
<h2>Strings, Char lists and Word lists</h2>
<p>Other than regexes, Elixir has 3 more inbuilt sigils. Let us have a look at the sigils.</p>
<h3>Strings</h3>
<p>The ~s sigil is used to generate strings, like double quotes are. The ~s sigil is useful, for example, when a string contains both double and single quotes &minus;</p>
<pre class="result notranslate">
new_string = ~s(this is a string with "double" quotes, not 'single' ones)
IO.puts(new_string)
</pre>
<p>This sigil generates strings. When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
"this is a string with \"double\" quotes, not 'single' ones"
</pre>
<h3>Char Lists</h3>
<p>The ~c sigil is used to generate char lists &minus;</p>
<pre class="prettyprint notranslate tryit">new_char_list = ~c(this is a char list containing 'single quotes')
IO.puts(new_char_list)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
this is a char list containing 'single quotes'
</pre>
<h3>Word Lists</h3>
<p>The ~w sigil is used to generate lists of words (words are just regular strings). Inside the ~w sigil, words are separated by whitespace.</p>
<pre class="prettyprint notranslate tryit">
new_word_list = ~w(foo bar bat)
IO.puts(new_word_list)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
foobarbat
</pre>
<p>The ~w sigil also accepts the <b>c, s</b> and <b>a</b> modifiers (for char lists, strings and atoms, respectively), which specify the data type of the elements of the resulting list &minus;</p>
<pre class="prettyprint notranslate">
new_atom_list = ~w(foo bar bat)a
IO.puts(new_atom_list)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
[:foo, :bar, :bat]
</pre>
<h2>Interpolation and Escaping in Sigils</h2>
<p>Besides lowercase sigils, Elixir supports uppercase sigils to deal with escaping characters and interpolation. While both ~s and ~S will return strings, the former allows escape codes and interpolation while the latter does not. Let us consider an example to understand this &minus;</p>
<pre class="result notranslate">
~s(String with escape codes \x26 #{"inter" &lt;&gt; "polation"})
# "String with escape codes &amp; interpolation"
~S(String without escape codes \x26 without #{interpolation})
# "String without escape codes \\x26 without \#{interpolation}"
</pre>
<h2>Custom Sigils</h2>
<p>We can easily create our own custom sigils. In this example, we will create a sigil to convert a string to uppercase.</p>
<pre class="prettyprint notranslate">
defmodule CustomSigil do
   def sigil_u(string, []), do: String.upcase(string)
end

import CustomSigil

IO.puts(~u/tutorials point/)
</pre>
<p>When we run the above code, it produces the following result &minus;</p>
<pre class="result notranslate">
TUTORIALS POINT
</pre>
<p>First we define a module called CustomSigil and within that module, we created a function called sigil_u. As there is no existing ~u sigil in the existing sigil space, we will use it. The _u indicates that we wish use u as the character after the tilde. The function definition must take two arguments, an input and a list.</p>
<h1>Elixir - Comprehensions</h1>
<p>List comprehensions are syntactic sugar for looping through enumerables in Elixir. In this chapter we will use comprehensions for iteration and generation.</p>
<h2>Basics</h2>
<p>When we looked at the Enum module in the enumerables chapter, we came across the map function.</p>
<pre class="prettyprint notranslate">
Enum.map(1..3, &amp;(&amp;1 * 2))
</pre>
<p>In this example, we will pass a function as the second argument. Each item in the range will be passed into the function, and then a new list will be returned containing the new values.</p>
<p>Mapping, filtering, and transforming are very common actions in Elixir and so there is a slightly different way of achieving the same result as the previous example &minus;</p>
<pre class="prettyprint notranslate">
for n &lt;- 1..3, do: n * 2
</pre>
<p>When we run the above code, it produces the following result &minus;</p>
<pre class="result notranslate">
[2, 4, 6]
</pre>
<p>The second example is a comprehension, and as you can probably see, it is simply syntactic sugar for what you can also achieve if you use the Enum.map function. However, there are no real benefits to using a comprehension over a function from the Enum module in terms of performance.</p>
<p>Comprehensions are not limited to lists but can be used with all enumerables.</p>
<h2>Filter</h2>
<p>You can think of filters as a sort of guard for comprehensions. When a filtered value returns <b>false</b> or <b>nil</b> it is excluded from the final list. Let us loop over a range and only worry about even numbers. We will use the <b>is_even</b> function from the Integer module to check if a value is even or not.</p>
<pre class="prettyprint notranslate">
import Integer
IO.puts(for x &lt;- 1..10, is_even(x), do: x)
</pre>
<p>When the above code is run, it produces the following result &minus;</p>
<pre class="result notranslate">
[2, 4, 6, 8, 10]
</pre>
<p>We can also use multiple filters in the same comprehension. Add another filter that you want after the <b>is_even</b> filter separated by a comma.</p>
<h2>:into Option</h2>
<p>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the <b>:into</b> option to the comprehension.</p>
<p>For example, a <b>bitstring</b> generator can be used with the :into option in order to easily remove all spaces in a string &minus;</p>
<pre class="prettyprint notranslate tryit">
IO.puts(for &lt;&lt;c &lt;- " hello world "&gt;&gt;, c != ?\s, into: "", do: &lt;&lt;c&gt;&gt;)
</pre>
<p>When the above code is run, it produces the following result &minus;</p>
<pre class="result notranslate">
helloworld
</pre>
<p>The above code removes all spaces from the string using <b>c != ?\s</b> filter and then using the :into option, it puts all the returned characters in a string.</p>
<h1>Elixir - Typespecs</h1>
<p>Elixir is a dynamically typed language, so all types in Elixir are inferred by the runtime. Nonetheless, Elixir comes with typespecs, which are a notation used for <b>declaring custom data types and declaring typed function signatures (specifications)</b>.</p>
<h2>Function Specifications(specs)</h2>
<p>By default, Elixir provides some basic types, such as integer or pid, and also complex types: for example, the <b>round</b> function, which rounds a float to its nearest integer, takes a number as an argument (an integer or a float) and returns an integer. In the related <a href="http://elixir-lang.org/docs/stable/elixir/Kernel.html#round/1" rel="nofollow" target="_blank">documentation</a>, the round typed signature is written as &minus;</p>
<pre class="result notranslate">
round(number) :: integer
</pre>
<p>The above description implies that the function on the left takes as argument what is specified in parenthesis and returns what is on the right of ::, i.e., Integer. Function specs are written with the <b>@spec</b> directive, placed right before the function definition. The round function can be written as &minus;</p>
<pre class="prettyprint notranslate">
@spec round(number) :: integer
def round(number), do: # Function implementation
...
</pre>
<p>Typespecs support complex types as well, for example, if you want to return a list of integers, then you can use <b>[Integer]</b></p>
<h2>Custom Types</h2>
<p>While Elixir provides a lot of useful inbuilt types, it is convenient to define custom types when appropriate. This can be done when defining modules through the @type directive. Let us consider an example to understand the same &minus;</p>
<pre class="prettyprint notranslate tryit">
defmodule FunnyCalculator do
  @type number_with_joke :: {number, String.t}

  @spec add(number, number) :: number_with_joke
  def add(x, y), do: {x + y, "You need a calculator to do that?"}

  @spec multiply(number, number) :: number_with_joke
  def multiply(x, y), do: {x * y, "It is like addition on steroids."}
end

{result, comment} = FunnyCalculator.add(10, 20)
IO.puts(result)
IO.puts(comment)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
30
You need a calculator to do that?
</pre>
<p><b>NOTE</b> &minus; Custom types defined through @type are exported and available outside the module they are defined in. If you want to keep a custom type private, you can use the <b>@typep</b> directive instead of <b>@type</b>.</p>
<h1>Elixir - Behaviours</h1>
<p>Behaviors in Elixir (and Erlang) are a way to separate and abstract the generic part of a component (which becomes the behavior module) from the specific part (which becomes the callback module). Behaviors provide a way to &minus;</p>
<ul class="list">
<li>Define a set of functions that have to be implemented by a module.</li>
<li>Ensure that a module implements all the functions in that set.</li>
</ul>
<p>If you have to, you can think of behaviors like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</p>
<h2>Defining a Behaviour</h2>
<p>Let us consider an example to create our own behavior and then use this generic behavior to create a module. We will define a behavior that greets people hello and goodbye in different languages.</p>
<pre class="prettyprint notranslate">
defmodule GreetBehaviour do
   @callback say_hello(name :: string) :: nil
   @callback say_bye(name :: string) :: nil
end
</pre>
<p>The <b>@callback</b> directive is used to list the functions that adopting modules will need to define. It also specifies the no. of arguments, their type and their return values.</p>
<h2>Adopting a Behaviour</h2>
<p>We have successfully defined a behavior. Now we will adopt and implement it in multiple modules. Let us create two modules implementing this behavior in English and Spanish.</p>
<pre class="prettyprint notranslate tryit">
defmodule GreetBehaviour do
   @callback say_hello(name :: string) :: nil
   @callback say_bye(name :: string) :: nil
end

defmodule EnglishGreet do
   @behaviour GreetBehaviour
   def say_hello(name), do: IO.puts("Hello " <> name)
   def say_bye(name), do: IO.puts("Goodbye, " <> name)
end

defmodule SpanishGreet do
   @behaviour GreetBehaviour
   def say_hello(name), do: IO.puts("Hola " <> name)
   def say_bye(name), do: IO.puts("Adios " <> name)
end

EnglishGreet.say_hello("Ayush")
EnglishGreet.say_bye("Ayush")
SpanishGreet.say_hello("Ayush")
SpanishGreet.say_bye("Ayush")
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Hello Ayush
Goodbye, Ayush
Hola Ayush
Adios Ayush
</pre>
<p>As you have already seen, we adopt a behaviour using the <b>@behaviour</b> directive in the module. We have to define all the functions implemented in the behaviour for all the <i>child</i> modules. This can roughly be considered equivalent to interfaces in OOP languages.</p>
<h1>Elixir - Error Handling</h1>
<p>Elixir has three error mechanisms: errors, throws and exits. Let us explore each mechanism in detail.</p>
<h2>Error</h2>
<p>Errors (or exceptions) are used when exceptional things happen in the code. A sample error can be retrieved by trying to add a number into a string &minus;</p>
<pre class="prettyprint notranslate">
IO.puts(1 + "Hello")
</pre>
<p>When the above program is run, it produces the following error &minus;
</p>
<pre class="result notranslate">
** (ArithmeticError) bad argument in arithmetic expression
   :erlang.+(1, "Hello")
</pre>
<p>This was a sample inbuilt error.</p>
<h3>Raising Errors</h3>
<p>We can <b>raise</b> errors using the raise functions. Let us consider an example to understand the same &minus;</p>
<pre class="prettyprint notranslate">
#Runtime Error with just a message
raise "oops"  # ** (RuntimeError) oops
</pre>
<p>Other errors can be raised with raise/2 passing the error name and a list of keyword arguments</p>
<pre class="prettyprint notranslate">
#Other error type with a message
raise ArgumentError, message: "invalid argument foo"
</pre>
<p>You can also define your own errors and raise those. Consider the following example &minus;</p>
<pre class="prettyprint notranslate">
defmodule MyError do
   defexception message: "default message"
end

raise MyError  # Raises error with default message
raise MyError, message: "custom message"  # Raises error with custom message
</pre>
<h3>Rescuing Errors</h3>
<p>We do not want our programs to abruptly quit but rather the errors need to be handled carefully. For this we use error handling. We rescue errors using the try/rescue construct. Let us consider the following example to understand the same &minus;</p>
<pre class="prettyprint notranslate tryit">
err = try do
   raise "oops"
rescue
   e in RuntimeError -&gt; e
end

IO.puts(err.message)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
oops
</pre>
<p>We have handled errors in the rescue statement using pattern matching. If we do not have any use of the error, and just want to use it for identification purposes, we can also use the form &minus;</p>
<pre class="prettyprint notranslate tryit">
err = try do
   1 + "Hello"
rescue
   RuntimeError -&gt; "You've got a runtime error!"
   ArithmeticError -&gt; "You've got a Argument error!"
end

IO.puts(err)
</pre>
<p>When running above program, it produces the following result &minus;</p>
<pre class="result notranslate">
You've got a Argument error!
</pre>
<p><b>NOTE</b> &minus; Most functions in the Elixir standard library are implemented twice, once returning tuples and the other time raising errors. For example, the File.read and the File.read! functions. The first one returned a tuple if the file was read successfully and if an error was encountered, this tuple was used to give the reason for the error. The second one raised an error if an error was encountered.</p>
<p>If we use the first function approach, then we need to use case for pattern matching the error and take action according to that. In the second case, we use the try rescue approach for error prone code and handle errors accordingly.</p>
<h2>Throws</h2>
<p>In Elixir, a value can be thrown and later be caught. Throw and Catch are reserved for situations where it is not possible to retrieve a value unless by using throw and catch.</p>
<p>The instances are quite uncommon in practice except when interfacing with libraries. For example, let us now assume that the Enum module did not provide any API for finding a value and that we needed to find the first multiple of 13 in a list of numbers &minus;</p>
<pre class="prettyprint notranslate tryit">
val = try do
   Enum.each 20..100, fn(x) -&gt;
      if rem(x, 13) == 0, do: throw(x)
   end
   "Got nothing"
catch
   x -&gt; "Got #{x}"
end

IO.puts(val)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
Got 26
</pre>
<h2>Exit</h2>
<p>When a process dies of “natural causes” (for example, unhandled exceptions), it sends an exit signal. A process can also die by explicitly sending an exit signal. Let us consider the following example &minus;</p>
<pre class="prettyprint notranslate">
spawn_link fn -&gt; exit(1) end
</pre>
<p>In the example above, the linked process died by sending an exit signal with value of 1. Note that exit can also be “caught” using try/catch. For example &minus;</p>
<pre class="prettyprint notranslate tryit">
val = try do
   exit "I am exiting"
catch
   :exit, _ -&gt; "not really"
end

IO.puts(val)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
not really
</pre>
<h2>After</h2>
<p>Sometimes it is necessary to ensure that a resource is cleaned up after some action that can potentially raise an error. The try/after construct allows you to do that. For example, we can open a file and use an after clause to close it–even if something goes wrong.</p>
<pre class="prettyprint notranslate">
{:ok, file} = File.open "sample", [:utf8, :write]
try do
   IO.write file, "olá"
   raise "oops, something went wrong"
after
   File.close(file)
end
</pre>
<p>When we run this program, it will give us an error. But the <b>after</b> statement will ensure that the file descriptor is closed upon any such event.</p>
<h1>Elixir - Macros</h1>
<p>Macros are one of the most advanced and powerful features of Elixir. As with all advanced features of any language, macros should be used sparingly. They make it possible to perform powerful code transformations in compilation time. We will now understand what macros are and how to use them in brief.</p>
<h2>Quote</h2>
<p>Before we start talking about macros, let us first look at Elixir internals. An Elixir program can be represented by its own data structures. The building block of an Elixir program is a tuple with three elements. For example, the function call sum(1, 2, 3) is represented internally as &minus;</p>
<pre class="prettyprint notranslate">
{:sum, [], [1, 2, 3]}
</pre>
<p>The first element is the function name, the second is a keyword list containing metadata and the third is the arguments list. You can get this as the output in iex shell if you write the following &minus;</p>
<pre class="prettyprint notranslate">
quote do: sum(1, 2, 3)
</pre>
<p>Operators are also represented as such tuples. Variables are also represented using such triplets, except that the last element is an atom, instead of a list. When quoting more complex expressions, we can see that the code is represented in such tuples, which are often nested inside each other in a structure resembling a tree. Many languages would call such representations an <b>Abstract Syntax Tree (AST)</b>. Elixir calls these quoted expressions.</p>
<h2>Unquote</h2>
<p>Now that we can retrieve the internal structure of our code, how do we modify it? To inject new code or values, we use <b>unquote</b>. When we unquote an expression it will be evaluated and injected into the AST. Let us consider an example(in iex shell) to understand the concept &minus;</p>
<pre class="prettyprint notranslate">
num = 25

quote do: sum(15, num)

quote do: sum(15, unquote(num))
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
{:sum, [], [15, {:num, [], Elixir}]}
{:sum, [], [15, 25]} 
</pre>
<p>In the example for the quote expression, it did not automatically replace num with 25. We need to unquote this variable if we want to modify the AST.</p>
<h2>Macros</h2>
<p>So now that we are familiar with quote and unquote, we can explore metaprogramming in Elixir using macros.</p>
<p>In the simplest of terms macros are special functions designed to return a quoted expression that will be inserted into our application code. Imagine the macro being replaced with the quoted expression rather than called like a function. With macros we have everything necessary to extend Elixir and dynamically add code to our applications</p>
<p>Let us implement unless as a macro. We will begin by defining the macro using the <b>defmacro</b> macro. Remember that our macro needs to return a quoted expression.</p>
<pre class="prettyprint notranslate">
defmodule OurMacro do
   defmacro unless(expr, do: block) do
      quote do
         if !unquote(expr), do: unquote(block)
      end
   end
end

require OurMacro

OurMacro.unless true, do: IO.puts "True Expression"

OurMacro.unless false, do: IO.puts "False expression"
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
False expression 
</pre>
<p>What is happening here is our code is being replaced by the quoted code returned by the <i>unless</i> macro. We have unquoted the expression to evaluate it in current context and also unquoted the do block to execute it in its context. This example shows us metaprogramming using macros in elixir.</p>
<p>Macros can be used in much more complex tasks but should be used sparingly. This is because metaprogramming in general is considered a bad practice and should be used only when necessary.</p>
<h1>Elixir - Libraries</h1>
<p>Elixir provides excellent interoperability with Erlang libraries. Let us discuss a few libraries in brief.</p>
<h2>The Binary Module</h2>
<p>The built-in Elixir String module handles binaries that are UTF-8 encoded. The binary module is useful when you are dealing with binary data that is not necessarily UTF-8 encoded. Let us consider an example to further understand the Binary module &minus;</p>
<pre class="prettyprint notranslate">
# UTF-8
IO.puts(String.to_char_list("Ø"))

# binary
IO.puts(:binary.bin_to_list "Ø")
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
[216]
[195, 152]
</pre>
<p>The above example shows the difference; the String module returns UTF-8 codepoints, while :binary deals with raw data bytes.</p>
<h2>The Crypto Module</h2>
<p>The crypto module contains hashing functions, digital signatures, encryption and more. This module is not part of the Erlang standard library, but is included with the Erlang distribution. This means you must list :crypto in your project’s applications list whenever you use it. Let us see an example using the crypto module &minus; </p>
<pre class="prettyprint notranslate tryit">IO.puts(Base.encode16(:crypto.hash(:sha256, "Elixir")))
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
3315715A7A3AD57428298676C5AE465DADA38D951BDFAC9348A8A31E9C7401CB
</pre>
<h2>The Digraph Module</h2>
<p>The digraph module contains functions for dealing with directed graphs built of vertices and edges. After constructing the graph, the algorithms in there will help finding, for instance, the shortest path between two vertices, or loops in the graph. Note that the functions <b>in :digraph</b> alter the graph structure indirectly as a side effect, while returning the added vertices or edges.</p>
<pre class="prettyprint notranslate tryit">
digraph = :digraph.new()
coords = [{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}]
[v0, v1, v2] = (for c &lt;- coords, do: :digraph.add_vertex(digraph, c))
:digraph.add_edge(digraph, v0, v1)
:digraph.add_edge(digraph, v1, v2)
for point &lt;- :digraph.get_short_path(digraph, v0, v2) do 
   {x, y} = point
   IO.puts("#{x}, #{y}")
end
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">0.0, 0.0
1.0, 0.0
1.0, 1.0
</pre>
<h2>The Math Module</h2>
<p>The math module contains common mathematical operations covering trigonometry, exponential and logarithmic functions. Let us consider the following example to understand how the Math module works &minus;</p>
<pre class="prettyprint notranslate tryit">
# Value of pi
IO.puts(:math.pi())

# Logarithm
IO.puts(:math.log(7.694785265142018e23))

# Exponentiation
IO.puts(:math.exp(55.0))

#...
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
3.141592653589793
55.0
7.694785265142018e23
</pre>
<h2>The Queue Module</h2>
<p>The queue is a data structure that implements (double-ended) FIFO (first-in first-out) queues efficiently. The following example shows how a Queue module works &minus;</p>
<pre class="prettyprint notranslate tryit">
q = :queue.new
q = :queue.in("A", q)
q = :queue.in("B", q)
{{:value, val}, q} = :queue.out(q)
IO.puts(val)
{{:value, val}, q} = :queue.out(q)
IO.puts(val)
</pre>
<p>When the above program is run, it produces the following result &minus;</p>
<pre class="result notranslate">
A
B
</pre>
<hr />
<div class="pre-btn">
<a href="elixir_libraries.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="../cgi-bin/printpage.html" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="elixir_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/elixir/elixir_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/elixir/elixir_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/elixir/elixir_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/elixir/elixir_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/elixir/elixir_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/elixir/elixir_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="../images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="../index-2.html" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="../scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="../about/tutorials_writing.html">Write for us</a></li>
         <li><a href="../about/faq.html">FAQ's</a></li>
         <li><a href="../about/about_helping.html">Helping</a></li>
         <li><a href="../about/contact_us.html">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="../theme/js/custom-min7b30.js?v=4"></script>
<script src="../../www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
<script type="text/javascript" src="../theme/js/jquery.colorbox-min.js"></script>
<script type="text/javascript">
   var tryit = new $.TryIt('try_elixir.html');
   tryit.compile();
</script></div>
</body>

<!-- Mirrored from www.tutorialspoint.com/elixir/elixir_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 16:06:50 GMT -->
</html>
