<!doctype html> 
<!--[if lt IE 7 ]> <html lang="en" class="no-js ie6"> <![endif]-->
<!--[if IE 7 ]> <html lang="en" class="no-js ie7"> <![endif]-->
<!--[if IE 8 ]> <html lang="en" class="no-js ie8"> <![endif]-->
<!--[if IE 9 ]> <html lang="en" class="no-js ie9"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--><html lang="en"><!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/webgl/webgl_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:14:56 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="utf-8">
<title>WebGL Quick Guide</title>
<meta name="description" content="WebGL Quick Guide - Learn WebGL in simple and easy steps starting from Introduction, Html5 Canvas Overview, Basics, Graphics Pipeline, Sample Application, Context, Geometry, Shaders, Associating Attributes and Buffer Objects, Drawing a Model, Drawing Points, Drawing a Triangle, Modes of Drawing, Drawing a Quad, Colors, Translation, Scaling, Rotation, Cube Rotation, Interactive Cube." />
<meta name="keywords" content="WebGL, Tutorial, Introduction, Html5 Canvas Overview, Basics, Graphics Pipeline, Sample Application, Context, Geometry, Shaders, Associating Attributes and Buffer Objects, Drawing a Model, Drawing Points, Drawing a Triangle, Modes of Drawing, Drawing a Quad, Colors, Translation, Scaling, Rotation, Cube Rotation, Interactive Cube." />
<base  />
<link rel="shortcut icon" href="https://www.tutorialspoint.com/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="https://www.tutorialspoint.com/theme/css/style-min.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
pre.prettyprint.tryit {min-height:37px; background: #eee url(https://www.tutorialspoint.com/webgl/images/try-it.jpg) top right no-repeat !important}select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #990303 url(https://www.tutorialspoint.com/images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #990303 !important;}
.submenu-item{ border-bottom: 2px solid #990303 !important; border-top: 2px solid #990303 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="https://www.tutorialspoint.com/images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="https://www.tutorialspoint.com/index.htm" title="tutorialspoint">
      <img alt="tutorialspoint" src="https://www.tutorialspoint.com/webgl/images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="https://www.tutorialspoint.com/about/about_careers.htm" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="https://www.tutorialspoint.com/whiteboard.htm"><img src="https://www.tutorialspoint.com/theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="https://www.tutorialspoint.com/netmeeting.php"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="https://www.tutorialspoint.com/online_dev_tools.htm"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="https://www.tutorialspoint.com/articles/index.php"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="https://www.tutorialspoint.com/index.htm"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/codingground.htm"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/tutor_connect/index.php"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="https://www.tutorialspoint.com/webgl/images/webgl-mini-logo.jpg" alt="WebGL Tutorial" />
</div>
<ul class="nav nav-list primary left-menu">
<li class="heading">WebGL Tutorial</li>
<li><a href="https://www.tutorialspoint.com/webgl/index.htm">WebGL - Home</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_introduction.htm">WebGL - Introduction</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_graphics_basics.htm">Basic Graphics Concepts</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/html5_canvas_overview.htm">WebGL - Html5 Canvas Overview</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_basics.htm">WebGL - Basics</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_shader_program.htm">WebGL - Shader Program</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_graphics_pipeline.htm">WebGL - Graphics Pipeline</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">WebGL Application</li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_sample_application.htm">WebGL - Sample Application</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_context.htm">WebGL - Context</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_geometry.htm">WebGL - Geometry</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_shaders.htm">WebGL - Shaders</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/associating_attributes_buffer_objects.htm"><span style="font-size:.97em;">Associating Attributes &amp; Buffer Objects</span></a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_drawing_a_model.htm">WebGL - Drawing a Model</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">WebGL Examples</li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_drawing_points.htm">WebGL - Drawing Points</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_drawing_a_triangle.htm">WebGL - Drawing a Triangle</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_modes_of_drawing.htm">WebGL - Modes of Drawing</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_drawing_a_quad.htm">WebGL - Drawing a Quad</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_colors.htm">WebGL - Colors</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_translation.htm">WebGL - Translation</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_scaling.htm">WebGL - Scaling</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_rotation.htm">WebGL - Rotation</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_cube_rotation.htm">WebGL - Cube Rotation</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_interactive_cube.htm">WebGL - Interactive Cube</a></li>
</ul>
<ul class="nav nav-list primary left-menu">
<li class="heading">WebGL Useful Resources</li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_quick_guide.htm">WebGL - Quick Guide</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_useful_resources.htm">WebGL - Useful Resources</a></li>
<li><a href="https://www.tutorialspoint.com/webgl/webgl_discussion.htm">WebGL - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="https://www.tutorialspoint.com/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_whoiswho.htm">Who is Who</a></li>
</ul>
 </aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>WebGL - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/webgl/webgl_interactive_cube.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/webgl/webgl_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>WebGL - Introduction</h1>
<p>A few years back, Java applications &minus; as a combination of applets and JOGL &minus; were used to process 3D graphics on the Web by addressing the GPU (Graphical Processing Unit). As applets require a JVM to run, it became difficult to rely on Java applets. A few years later, people stopped using Java applets.</p>
<p>The Stage3D APIs provided by Adobe (Flash, AIR) offered GPU hardware accelerated architecture. Using these technologies, programmers could develop applications with 2D and 3D capabilities on web browsers as well as on IOS and Android platforms. Since Flash was a proprietary software, it was not used as web standard.</p>
<h2>OpenGL</h2>
<p>OpenGL (Open Graphics Library) is cross-language, cross-platform API for 2D and 3D graphics. It is a collection of commands. OpenGL4.5 is the latest version of OpenGL. The following table lists a set of technologies related to OpenGL.</p>
<table class="table table-bordered">
<tr>
<th style="width:15%;">API</th>
<th>Technology Used</th>
</tr>
<tr>
<td>OpenGL ES</td>
<td>It is the library for 2D and 3D graphics on embedded systems &minus; including consoles, phones, appliances, and vehicles. OpenGL ES 3.1 is its latest version. It is maintained by the Khronos Group <a rel="nofollow" target="_blank" href="https://www.khronos.org/">www.khronos.org</a></td>
</tr>
<tr>
<td>JOGL</td>
<td>It is the Java binding for OpenGL. JOGL 4.5 is its latest version and it is maintained by <a rel="nofollow" target="_blank" href="https://jogamp.org/">jogamp.org.</a></td>
</tr>
<tr>
<td>WebGL</td>
<td>It is the JavaScript binding for OpenGL. WebGL 1.0 is its latest version and it is maintained by the <a rel="nofollow" target="_blank" href="https://www.khronos.org/">khronos group</a>.</td>
</tr>
<tr>
<td>OpenGLSL</td>
<td><b>OpenGL Shading Language</b>. It is a programming language which is a companion to OpenGL 2.0 and higher. It is a part of the core OpenGL 4.4 specification. It is an API specifically tailored for embedded systems, such as those present on mobile phones and tablets.</td>
</tr>
</table>
<p><b>Note</b> &minus; In WebGL, we use GLSL to write shaders.</p>
<h2>What is WebGL?</h2>
<p>WebGL (Web Graphics Library) is the new standard for 3D graphics on the Web, It is designed for the purpose of rendering 2D graphics and interactive 3D graphics. It is derived from OpenGL's ES 2.0 library which is a low-level 3D API for phones and other mobile devices. WebGL provides similar functionality of ES 2.0 (Embedded Systems) and performs well on modern 3D graphics hardware.</p>
<p>It is a JavaScript API that can be used with HTML5.  HTML5 has several features to support 3D graphics such as 2D Canvas, WebGL, SVG, 3D CSS transforms, and SMIL.</p>
<p>WebGL code is written within the <b>&lt;canvas&gt;</b> tag of HTML5. It is a specification that allows Internet browsers access to Graphic Processing Units (GPUs) on those computers where they were used.</p>
<h2>Who Developed WebGL</h2>
<p>An American-Serbian software engineer named <b>Vladimir Vukicevic</b> did the foundation work and led the creation of WebGL.</p>
<ul class="list">
<li><p>In 2007, Vladimir started working on an <b>OpenGL</b> prototype for Canvas element of the HTML document.</p></li>
<li><p>In March 2011, Kronos Group created WebGL.</p></li>
</ul>
<h2>Browsers Supported</h2>
<p>The following tables show a list of browsers that support WebGL &minus;</p>
<h3>Web Browsers</h3>
<table class="table table-bordered">
<tr>
<th>Browser Name</th>
<th>Version</th>
<th>Support</th>
</tr>
<tr>
<td><b>I</b>nternet <b>E</b>xplorer</td>
<td>11 and above</td>
<td>Complete support</td>
</tr>
<tr>
<td>Google Chrome</td>
<td>39 and above</td>
<td>Complete support</td>
</tr>
<tr>
<td>Safari</td>
<td>8</td>
<td>Complete support</td>
</tr>
<tr>
<td>Firefox</td>
<td>36 and above</td>
<td>Partial support</td>
</tr>
<tr>
<td>Opera</td>
<td>27 and above</td>
<td>Partial support</td>
</tr>
</table>
<h3>Mobile Browsers</h3>
<table class="table table-bordered"> 
<tr>
<th>Browser Name</th>
<th>Version</th>
<th>Support</th>
</tr>
<tr>
<td>Chrome for Android</td>
<td>42</td>
<td>Partial support</td>
</tr>
<tr>
<td>Android browser</td>
<td>40</td>
<td>Partial support</td>
</tr>
<tr>
<td>IOS Safari</td>
<td>8.3</td>
<td>Complete support</td>
</tr>
<tr>
<td>Opera Mini</td>
<td>8</td>
<td>Does not support</td>
</tr>
<tr>
<td>Blackberry Browser</td>
<td>10</td>
<td>Complete support</td>
</tr>
<tr>
<td>IE mobile</td>
<td>10</td>
<td>Partial support</td>
</tr>
</table>
<h2>Advantages of WebGL</h2>
<p>Here are the advantages of using WebGL &minus;</p>
<ul class="list">
<li><p><b>JavaScript programming</b> &minus; WebGL applications are written in JavaScript. Using these applications, you can directly interact with other elements of the HTML Document. You can also use other JavaScript libraries (e.g. JQuery) and HTML technologies to enrich the WebGL application.</p></li>
<li><p><b>Increasing support with mobile browsers</b> &minus; WebGL also supports Mobile browsers such as iOS safari, Android Browser, and Chrome for Android.</p></li>
<li><p><b>Open source</b> &minus; WebGL is an open source. You can access the source code of the library and understand how it works and how it was developed.</p></li>
<li><p><b>No need for compilation</b> &minus; JavaScript is a half-programming and half-HTML component. To execute this script, there is no need to compile the file. Instead, you can directly open the file using any of the browsers and check the result. Since WebGL applications are developed using JavaScript, there is no need to compile WebGL applications as well.</p></li>
<li><p><b>Automatic memory management</b> &minus; JavaScript supports automatic memory management. There is no need for manual allocation of memory. WebGL inherits this feature of JavaScript.</p></li>
<li><p><b>Easy to set up</b> &minus; Since WebGL is integrated within HTML 5, there is no need for additional set up. To write a WebGL application, all that you need is a text editor and a web browser.</p></li>
</ul>
<h2>Environment Setup</h2>
<p>There is no need to set a different environment for WebGL. The browsers supporting WebGL have their own in-built setup for WebGL.</p>
<h1>WebGL - Basic Graphics Concepts</h1>
<h2>Rendering</h2>
<p>Rendering is the process of generating an image from a model using computer programs. In graphics, a virtual scene is described using information like geometry, viewpoint, texture, lighting, and shading, which is passed through a render program. The output of this render program will be a digital image.</p>
<p>There are two types of rendering &minus;</p>
<ul class="list">
<li><p><b>Software Rendering</b> &minus; All the rendering calculations are done with the help of CPU.</p></li>
<li><p><b>Hardware Rendering</b> &minus; All the graphics computations are done by the GPU (Graphical processing unit).</p></li>
</ul>
<p>Rendering can be done locally or remotely. If the image to be rendered is way too complex, then rendering is done remotely on a dedicated server having enough of hardware resources required to render complex scenes. It is also called as <b>server-based rendering</b>. Rendering can also be done locally by the CPU. It is called as <b>client-based rendering</b>.</p>
<p>WebGL follows a client-based rendering approach to render 3D scenes. All the processing required to obtain an image is performed locally using the client's graphics hardware.</p>
<h2>GPU</h2>
<p>According to NVIDIA, a GPU is "a single chip processor with integrated transform, lighting, triangle setup/clipping, and rendering engines capable of processing a minimum of 10 million polygons per second."</p>
<p>Unlike multi-core processors with a few cores optimized for sequential processing, a GPU consists of thousands of smaller cores that process parallel workloads efficiently. Therefore, the GPU accelerates the creation of images in a frame buffer (a portion of ram which contains a complete frame data) intended for output to a display.</p>
<img src="https://www.tutorialspoint.com/webgl/images/cpu_and_gpu.jpg" alt="CPU and GPU" />
<h2>GPU Accelerated Computing</h2>
<p>In GPU accelerated computing, the application is loaded into the CPU. Whenever it encounters a <b>compute-intensive</b> portion of the code, then that portion of code will be loaded and run on the GPU. It gives the system the ability to process graphics in an efficient way.</p>
<img src="https://www.tutorialspoint.com/webgl/images/gpu_accelerated_computing.jpg" alt="GPU Accelerated Computing" />
<p>GPU will have a separate memory and it runs multiple copies of a small portion of the code at a time. The GPU processes all the data which is in its local memory, not the central memory. Therefore, the data that is needed to be processed by the GPU should be loaded/copied to the GPU memory and then be processed.</p>
<p>In the systems having the above architecture, the communication overhead between the CPU and GPU should be reduced to achieve faster processing of 3D programs. For this, we have to copy all the data and keep it on the GPU, instead of communicating with the GPU repeatedly.</p>
<h1>Html5 Canvas Overview</h1>
<p>To create graphical applications on the web, HTML-5 provides a rich set of features such as 2D Canvas, WebGL, SVG, 3D CSS transforms, and SMIL. To write WebGL applications, we use the existing canvas element of HTML-5. This chapter provides an overview of the HTML-5 2D canvas element.</p>
<h2>HTML5 Canvas</h2>
<p>HTML-5 <b>&lt;canvas&gt;</b> provides an easy and powerful option to draw graphics using JavaScript. It can be used to draw graphs, make photo compositions, or do simple (and not so simple) animations.</p>
<p>Here is a simple <b>&lt;canvas&gt;</b> element having only two specific attributes <b>width</b> and <b>height</b> plus all the core HTML-5 attributes like id, name, and class.</p>
<h3>Syntax</h3>
<p>The syntax of HTML canvas tag is given below. You have to mention the name of the canvas inside double quotations (“ ”).</p>
<pre class="result notranslate">
&lt;canvas id = "mycanvas" width = "100" height = "100"&gt;&lt;/canvas&gt;
</pre>
<h3>Canvas Attributes</h3>
<p>The canvas tag has three attributes namely, id, width, and height.</p>
<ul class="list">
<li><p><b>Id</b> &minus; Id represents the identifier of the canvas element in the <i>Document Object Model (DOM)</i>.</p></li>
<li><p><b>Width</b> &minus; Width represents the width of the canvas.</p></li>
<li><p><b>Height</b> &minus; Height represents the height of the canvas.</p></li>
</ul>
<p>These attributes determine the size of the canvas. If a programmer is not specifying them under the canvas tag, then browsers such as Firefox, Chrome, and Web Kit, by default, provide a canvas element of size 300 &times; 150.</p>
<h3>Example - Create a Canvas</h3>
<p>The following code shows how to create a canvas. We have used CSS to give a colored border to the canvas.</p>
<pre class="prettyprint notranslate tryit">
&lt;html&gt;
   &lt;head&gt;
	
      &lt;style&gt;
         #mycanvas{border:1px solid red;}
      &lt;/style&gt;
		
   &lt;/head&gt;
	
   &lt;body&gt;
      &lt;canvas id = "mycanvas" width = "100" height = "100"&gt;&lt;/canvas&gt;
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/html5_canvas.htm" height="120px" width="600px"></iframe>
<h2>HTML Context (Rendering)</h2>
<p>The &lt;canvas&gt; is initially blank. To display something on the canvas element, we have to use a scripting language. This scripting language should access the rendering context and draw on it.</p>
<p>The canvas element has a DOM method called <b>getContext()</b>, which is used to obtain the rendering context and its drawing functions. This method takes one parameter, the type of context <b>2d</b>.</p>
<p>The following code is to be written to get the required context. You can write this script inside the body tag as shown below.</p>
<pre class="prettyprint notranslate tryit">
&lt;!DOCTYPE HTML&gt;

&lt;html&gt;
   &lt;body&gt;
      &lt;canvas id = "mycanvas" width = "600" height = "200"&gt;&lt;/canvas&gt;
      
      &lt;script&gt;
         var canvas = document.getElementById('mycanvas');
         var context = canvas.getContext('2d');
			
         context.font = '20pt Calibri';
         context.fillStyle = 'green';
         context.fillText('Welcome to Tutorialspoint', 70, 70);
      &lt;/script&gt;
      
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/rendering_context.htm" height="120px" width="600px"></iframe>
<p>For more example on HTML-5 2D Canvas, check out the following link <a href="https://www.tutorialspoint.com/html5/html5_canvas.htm">HTML-5 Canvas</a>.</p>
<h2>WebGL Context</h2>
<p>HTML5 Canvas is also used to write WebGL applications. To create a WebGL rendering context on the canvas element, you should pass the string <b>experimental-webgl</b>, instead of <b>2d</b> to the <b>canvas.getContext()</b> method. Some browsers support only '<b>webgl</b>'.</p>
<pre class="prettyprint notranslate tryit">
&lt;!DOCTYPE html&gt;

&lt;html&gt;
   &lt;canvas id = 'my_canvas'&gt;&lt;/canvas&gt;
	
   &lt;script&gt;
      var canvas = document.getElementById('my_canvas');
      var gl = canvas.getContext('experimental-webgl');
      gl.clearColor(0.9,0.9,0.8,1);
      gl.clear(gl.COLOR_BUFFER_BIT);
   &lt;/script&gt;
	
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/webgl_context.htm" height="120px" width="600px"></iframe>
<h1>WebGL - Basics</h1>
<p>WebGL is mostly a low-level rasterization API rather than a 3D API. To draw an image using WebGL, you have to pass a vector representing the image. It then converts the given vector into pixel format using OpenGL SL and displays the image on the screen. Writing a WebGL application involves a set of steps which
we would be explaining in this chapter.</p>
<h2>WebGL – Coordinate System</h2>
<p>Just like any other 3D system, you will have x, y and z axes in WebGL, where the <b>z</b> axis signifies <b>depth</b>. The coordinates in WebGL are restricted to (1, 1, 1) and (-1, -1, - 1). It means &minus; if you consider the screen projecting WebGL graphics as a cube, then one corner of the cube will be (1, 1, 1) and the opposite corner will be (-1, -1, -1). WebGL won’t display anything that is drawn beyond these boundaries.</p>
<p>The following diagram depicts the WebGL coordinate system. The z-axis signifies depth. A positive value of z indicates that the object is near the screen/viewer, whereas a negative value of z indicates that the object is away from the screen. Likewise, a positive value of x indicates that the object is to the right side of the screen and a negative value indicates the object is to the left side. Similarly, positive and negative values of y indicate whether the object is at the top or at the bottom portion of the screen.</p>
<img src="https://www.tutorialspoint.com/webgl/images/webgl_coordinate_system.jpg" alt="WebGL Coordinate System" />
<h2>WebGL Fundamentals</h2>
<p>After getting the WebGL context of the canvas object, you can start drawing graphical elements using WebGL API in JavaScript.</p>
<p>Here are some fundamental terms you need to know before starting with WebGL.</p>
<h3>Vertices</h3>
<p>Generally, to draw objects such as a polygon, we mark the points on the plane and join them to form a desired polygon. A <b>vertex</b> is a point which defines the conjunction of the edges of a 3D object. It is represented by three floating point values each representing x, y, z axes respectively.</p>
<h3>Example</h3>
<p>In the following example, we are drawing a triangle with the following vertices &minus; (0.5, 0.5), (-0.5, 0.5), (-0.5, -0.5).</p>
<img src="https://www.tutorialspoint.com/webgl/images/vertices_example.jpg" alt="Vertices Example" />
<p><b>Note</b> &minus; We have to store these vertices manually using JavaScript arrays and pass them to the WebGL rendering pipeline using vertex buffer.</p>
<h3>Indices</h3>
<p>In WebGL, numerical values are used to identify the vertices. These numerical values are known as indices. These indices are used to draw meshes in WebGL.</p>
<img src="https://www.tutorialspoint.com/webgl/images/indices.jpg" alt="Indices" />
<p><b>Note</b> &minus; Just like vertices, we store the indices using JavaScript arrays and pass them to WebGL rendering pipeline using index buffer.</p>
<h3>Arrays</h3>
<p>Unlike OpenGL and JoGL, there are no predefined methods in WebGL to render the vertices directly. We have to store them manually using JavaScript arrays.</p>
<h3>Example</h3>
<pre class="result notranslate">
var vertices = [ 0.5, 0.5, 0.1,-0.5, 0.5,-0.5] 
</pre>
<h3>Buffers</h3>
<p>Buffers are the memory areas of WebGL that hold the data. There are various buffers namely, drawing buffer, frame buffer, vetex buffer, and index buffer. The <b>vertex buffer</b> and <b>index buffer</b> are used to describe and process the geometry of the model.</p>
<ul class="list">
<li><p><b>Vertex buffer objects</b> &minus; This stores data corresponding to each vertex (per-vertex data)</p></li>
<li><p><b>Index buffer objects</b> This stores data about the indices.</p></li>
<li><p><b>Frame buffer</b> is a portion of graphics memory that hold the scene data. This buffer contains details such as width and height of the surface (in pixels), color of each pixel and their depth.</p></li>
</ul>
<p>After storing the vertices into arrays, we pass them to WegGL graphics pipeline using these Buffer objects.</p>
<h3>Mesh</h3>
<p>To draw 2D or 3D objects, the WebGL API provides two methods namely, <b>drawArrays()</b> and <b>drawElements()</b>. These two methods accept a parameter called <b>mode</b> using which you can select the object you want to draw. The options provided by this field are restricted to points, lines, and triangles.</p>
<p>To draw a 3D object using these two methods, we have to construct one or more primitive polygons using points, lines, or triangles. Thereafter, using those primitive polygons, we can form a mesh.</p>
<p>A 3D object drawn using primitive polygons is called a <b>mesh</b>. WebGL offers several ways to draw 3D graphical objects, however users normally prefer to draw a mesh.</p>
<h3>Example</h3>
<p>In the following example, you can observe that we have drawn a square using two triangles&rarr; {1, 2, 3} and {4, 1, 3}.</p>
<img src="https://www.tutorialspoint.com/webgl/images/mesh_example.jpg" alt="Mesh Example" />
<h1>WebGL - Shader Program</h1>
<p>We normally use triangles to construct meshes. Since WebGL uses GPU accelerated computing, the information about these triangles should be transferred from CPU to GPU which takes a lot of communication overhead.</p>
<p>WebGL provides a solution to reduce the communication overhead. Since it uses ES SL (Embedded System Shader Language) that runs on GPU, we write all the required programs to draw graphical elements on the client system using <b>shader programs</b> (the programs which we write using OpenGL ES Shading Language / <b>GLSL</b>).</p>
<p>These shaders are the programs for GPU and the language used to write shader programs is GLSL. In these shaders, we define exactly how vertices, transformations, materials, lights, and camera interact with one another to create a particular image.</p>
<p>In short, it is a snippet that implements algorithms to get pixels for a mesh. We will discuss more about shaders in later chapters. There are two types of shaders &minus; Vertex Shader and Fragment Shader.</p>
<h2>Vertex Shader</h2>
<p>Vertext shader is the program code called on every vertex. It is used to transform (move) the geometry (ex: triangle) from one place to another. It handles the data of each vertex (per-vertex data) such as vertex coordinates, normals, colors, and texture coordinates.</p>
<p>In the <b>ES GL</b> code of vertex shader, programmers have to define attributes to handle the data. These attributes point to a <b>Vertex Buffer Object</b> written in JavaScript.</p>
<p>The following tasks can be performed using vertex shaders &minus;</p>
<ul class="list">
<li>Vertex transformation</li>
<li>Normal transformation and normalization</li>
<li>Texture coordinate generation</li>
<li>Texture coordinate transformation</li>
<li>Lighting</li>
<li>Color material application</li>
</ul>
<h2>Fragment Shader(Pixel Shader)</h2>
<p>A mesh is formed by multiple triangles, and the surface of each of the triangles is known as a <b>fragment</b>. Fragment shader is the code that runs on all pixels of every fragment. It is written to calculate and fill the color on <i>individual pixels</i>.</p>
<p>The following tasks can be performed using Fragment shaders &minus;</p>
<ul class="list">
<li>Operations on interpolated values</li>
<li>Texture access</li>
<li>Texture application</li>
<li>Fog</li>
<li>Color sum</li>
</ul>
<img src="https://www.tutorialspoint.com/webgl/images/fragment_shader.jpg" alt="Fragment Shader" />
<h2>OpenGL ES SL Variables</h2>
<p>The full form of <b>OpenGL ES SL</b> is OpenGL Embedded System Shading Language. To handle the data in the shader programs, ES SL provides three types of variables. They are as follows &minus;</p>
<ul class="list">
<li><p><b>Attributes</b> &minus; These variables hold the input values of the vertex shader program. Attributes point to the vertex buffer objects that contains per-vertex data. Each time the vertex shader is invoked, the attributes point to VBO of different vertices.</p></li>
<li><p><b>Uniforms</b> &minus; These variables hold the input data that is common for both vertex and fragment shaders, such as light position, texture coordinates, and color.</p></li>
<li><p><b>Varyings</b> &minus; These variables are used to pass the data from the vertex shader to the fragment shader.</p></li>
</ul>
<p>With this much basics, we will now move on to discuss the Graphics Pipeline.</p>
<h1>WebGL - Graphics Pipeline</h1>
<p>To render 3D graphics, we have to follow a sequence of steps. These steps are known as <b>graphics pipeline</b> or <b>rendering pipeline</b>. The following diagram depicts WebGL graphics pipeline.</p>
<img src="https://www.tutorialspoint.com/webgl/images/webgl_graphics_pipeline.jpg" alt="Graphics Pipeline" />
<p>In the following sections, we will discuss one by one the role of each step in the pipeline.</p>
<h2>JavaScript</h2>
<p>While developing WebGL applications, we write Shader language code to communicate with the GPU. JavaScript is used to write the control code of the program, which includes the following actions &minus;</p>
<ul class="list">
<li><p><b>Initialize WebGL</b> &minus; JavaScript is used to initialize the WebGL context.</p></li>
<li><p><b>Create arrays</b> &minus; We create JavaScript arrays to hold the data of the geometry.</p></li>
<li><p><b>Buffer objects</b> &minus; We create buffer objects (vertex and index) by passing the arrays as parameters.</p></li>
<li><p><b>Shaders</b> &minus; We create, compile, and link the shaders using JavaScript.</p></li>
<li><p><b>Attributes</b> &minus; We can create attributes, enable them, and associate them with buffer objects using JavaScript.</p></li>
<li><p><b>Uniforms</b> &minus; We can also associate the uniforms using JavaScript.</p></li>
<li><p><b>Transformation matrix</b> &minus; Using JavaScript, we can create transformation matrix.</p></li>
</ul>
<p>Initially we create the data for the required geometry and pass them to the shaders in the form of buffers. The attribute variable of the shader language points to the buffer objects, which are passed as inputs to the vertex shader.</p>
<h2>Vertex Shader</h2>
<p>When we start the rendering process by invoking the methods <b>drawElements()</b> and <b>drawArray()</b>, the vertex shader is executed for each vertex provided in the vertex buffer object. It calculates the position of each vertex of a primitive polygon and stores it in the varying <b>gl_position</b>. It also calculates the other attributes such as <b>color, texture coordinates</b>, and <b>vertices</b> that are normally associated with a vertex.</p>
<h2>Primitive Assembly</h2>
<p>After calculating the position and other details of each vertex, the next phase is the <b>primitive assembly stage</b>. Here the triangles are assembled and passed to the rasterizer.</p>
<h2>Rasterization</h2>
<p>In the rasterization step, the pixels in the final image of the primitive are determined. It has two steps &minus;</p>
<ul class="list">
<li><p><b>Culling</b> &minus; Initially the orientation (is it front or back facing?) of the polygon is determined. All those triangles with improper orientation that are not visible in view area are discarded. This process is called culling.</p></li>
<li><p><b>Clipping</b> &minus; If a triangle is partly outside the view area, then the part outside the view area is removed. This process is known as clipping.</p></li>
</ul>
<h2>Fragment Shader</h2>
<p>The fragment shader gets</p>
<ul class="list">
<li>data from the vertex shader in varying variables,</li>
<li>primitives from the rasterization stage, and then</li>
<li>calculates the color values for each pixel between the vertices.</li>
</ul>
<p>The fragment shader stores the color values of every pixel in each fragment. These color values can be accessed during fragment operations, which we are going to discuss next.</p>
<p>Some fragment operations are carried out after determining the color of each pixel in the primitive. These fragment operations may include the following &minus;</p>
<ul class="list">
<li>Depth</li>
<li>Color buffer blend</li>
<li>Dithering</li>
</ul>
<p>Once all the fragments are processed, a 2D image is formed and displayed on the screen. The <b>frame buffer</b> is the final destination of the rendering pipeline.</p>
<img src="https://www.tutorialspoint.com/webgl/images/fragment_operations.jpg" alt="Fragment Operations" />
<h2>Frame Buffer</h2>
<p>Frame buffer is a portion of graphics memory that hold the scene data. This buffer contains details such as width and height of the surface (in pixels), color of each pixel, and depth and stencil buffers.</p>
<h1>WebGL - Sample Application</h1>
<p>We have discussed the basics of WebGL and the WebGL pipeline (a procedure followed to render Graphics applications). In this chapter, we are going to take a sample application to create a triangle using WebGL and observe the steps followed in the application.</p>
<h2>Structure of WebGL Application</h2>
<p>WebGL application code is a combination of JavaScript and OpenGL Shader Language.</p>
<ul class="list">
<li>JavaScript is required to communicate with the CPU</li>
<li>OpenGL Shader Language is required to communicate with the GPU.</li>
</ul>
<img src="https://www.tutorialspoint.com/webgl/images/webgl_application_structure.jpg" alt="WebGL Application Structure" />
<h2>Sample Application</h2>
<p>Let us now take a simple example to learn how to use WebGL to draw a simple triangle with 2D coordinates.</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "300" height = "300" id = "my_Canvas"&gt;&lt;/canvas&gt;
		
      &lt;script&gt;


         <b>/* Step1: Prepare the canvas and get WebGL context */</b>

         var canvas = document.getElementById('my_Canvas');
         var gl = canvas.getContext('experimental-webgl');


         <b>/* Step2: Define the geometry and store it in buffer objects */</b>

         var vertices = [-0.5, 0.5, -0.5, -0.5, 0.0, -0.5,];

         // Create a new buffer object
         var vertex_buffer = gl.createBuffer();

         // Bind an empty array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         
         // Pass the vertices data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);


         <b>/* Step3: Create and compile Shader programs */</b>

         // Vertex shader source code
         var vertCode =
            'attribute vec2 coordinates;' + 
            'void main(void) {' + ' gl_Position = vec4(coordinates,0.0, 1.0);' + '}';

         //Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         //Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         //Compile the vertex shader
         gl.compileShader(vertShader);

         //Fragment shader source code
         var fragCode = 'void main(void) {' + 'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' + '}';

         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);

         // Compile the fragment shader
         gl.compileShader(fragShader);

         // Create a shader program object to store combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader); 
         
         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);


         <b>/* Step 4: Associate the shader programs to buffer objects */</b>

         //Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         //Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         //point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 2, gl.FLOAT, false, 0, 0);

         //Enable the attribute
         gl.enableVertexAttribArray(coord);


         <b>/* Step5: Drawing the required object (triangle) */</b>

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST); 
         
         // Clear the color buffer bit
         gl.clear(gl.COLOR_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         // Draw the triangle
         gl.drawArrays(gl.TRIANGLES, 0, 3);
         
      &lt;/script&gt;
      
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/sample_application.htm" height="320px" width="600px"></iframe>
<p>We follow five sequential steps to draw a simple triangle using WebGL. These steps are exaplained as follows &minus;</p>
<p><b>Step 1 &minus; Prepare the canvas and get WebGL rendering context</b></p> 
<p>We get the current HTML canvas object and obtain its WebGL rendering context.</p>
<p><b>Step 2 &minus; Define the geometry and store it in buffer objects</b></p>
<p>We define the attributes of the geometry such as vertices, indices, color, etc., and store them in the JavaScript arrays. Then, we create one or more buffer objects and pass the arrays containing the data to the respective buffer object. In the example, we store the vertices of the triangle in a JavaScript array and pass this array to a vertex buffer object.</p>
<p><b>Step 3 &minus; Create and compile Shader programs</b></p>
<p>We write vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<p><b>Step 4 &minus; Associate the shader programs with buffer objects</b></p>
<p>We associate the buffer objects and the combined shader program.</p>
<p><b>Step 5 &minus; Drawing the required object (triangle)</b></p>
<p>This step includes operations such as clearing the color, clearing the buffer bit, enabling the depth test, setting the view port, etc. Finally, you need to draw the required primitives using one of the methods &minus; <b>drawArrays()</b> or <b>drawElements()</b>.</p>
<p>All these steps are explained further in this tutorial.</p>
<h1>WebGL - Context</h1>
<p>To write a WebGL application, first step is to get the WebGL rendering context object. This object interacts with the WebGL drawing buffer and can call all the WebGL methods. The following operations are performed to obtain the WebGL context &minus;</p>
<ul class="list">
<li>Create an HTML-5 canvas</li>
<li>Get the canvas ID</li>
<li>Obtain WebGL</li>
</ul>
<h2>Creating HTML-5 Canvas Element</h2>
<p>We know to create an HTML-5 canvas element &minus;</p>
<ul class="list">
<li>Write canvas statement in HTML5 Body</li>   
<li>Give canvas an ID</li>  
<li>Change canvas dimensions using height &amp; width attributes (optional)</li>  
</ul>
<p>An example should bring more clarity here.</p>
<h3>Example</h3>
<p>The following example shows how to create a canvas element with the dimensions 500 × 500. We have created a border to the canvas using CSS for visibility. Copy and paste the following code in a file with the name <b>my_canvas.html</b>.</p>
<pre class="prettyprint notranslate tryit">
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
   &lt;head&gt;
   
      &lt;style&gt;
         #mycanvas{border:1px solid blue;}
      &lt;/style&gt;
   &lt;/head&gt;
	
   &lt;body&gt;
      &lt;canvas id = "mycanvas" width = "300" height = "300"&gt;&lt;/canvas&gt;
   &lt;/body&gt;
	
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/html5_canvas_element.htm" height="320px" width="600px"></iframe>
<h2>Get the Canvas ID</h2>
<p>Canvas ID is acquired by calling the DOM (Document Object Model) method <b>getElementById()</b>. This method accepts a string value as parameter, so we pass the name of the current canvas to it.</p>
<p>For example, if the canvas name is <b>my_canvas</b>, then canvas ID is obtained as shown below&minus;</p>
<pre class="result notranslate">
var canvas = document.getElementById('my_Canvas');
</pre>
<h2>Get the WebGL Drawing Context</h2>
<p>To get the WebGLRenderingContext object (or WebGL Drawing context object or simply WebGL context), call the <b>getContext()</b> method of the current <b>HTMLCanvasElement</b>. The syntax of getContext() is as follows &minus;</p>
<pre class="result notranslate">
canvas.getContext(contextType, contextAttributes);
</pre>
<p>Pass the strings <b>webgl</b> or <b>experimental-webgl</b> as the <b>contentType</b>. The <b>contextAttributes</b> parameter is optional. (While proceeding with this step, make sure your browser implements <u>WebGL</u> version 1 (OpenGL ES 2.0)).</p>
<p>The following code snippet shows how to obtain the WebGL rendering context. Here <b>gl</b> is the reference variable to the obtained context object.</p>
<pre class="result notranslate">
var canvas = document.getElementById('my_Canvas');
var gl = canvas.getContext('experimental-webgl');
</pre>
<h2>WebGLContextAttributes</h2>
<p>The parameter <b>WebGLContextAttributes</b> is not mandatory. This parameter provides various options that accept Boolean values as listed below &minus;</p>
<table class="table table-bordered">
<tr>
<td><b>Alpha</b></td>
<td><p>If its value is true, it provides an alpha buffer to the canvas.</p> 
<p>By default, its value is true.</p></td>
</tr>
<tr>
<td><b>depth</b></td>
<td><p>If its value is true, you will get a drawing buffer which contains a depth buffer of at least 16 bits.</p> 
<p>By default, its value is true.</p></td>
</tr>
<tr>
<td><b>stencil</b></td>
<td><p>If its value is true, you will get a drawing buffer which contains a stencil buffer of at least 8 bits.</p> 
<p>By default, its value is false.</p></td>
</tr>
<tr>
<td><b>antialias</b></td>
<td><p>If its value is true, you will get a drawing buffer which performs anti-aliasing.</p> 
<p>By default, its value is true.</p></td>
</tr>
<tr>
<td><b>premultipliedAlpha</b></td>
<td><p>If its value is true, you will get a drawing buffer which contains colors with pre-multiplied alpha.</p> 
<p>By default, its value is true.</p></td>
</tr>
<tr>
<td><b>preserveDrawingBuffer</b></td>
<td><p>If its value is true, the buffers will not be cleared and will preserve their values until cleared or overwritten by the author.</p> 
<p>By default, its value is false.</p></td>
</tr>
</table>
<p>The following code snippet shows how to create a WebGL context with a stencil buffer, which will not perform <b>anti-aliasing</b>.</p>
<pre class="result notranslate">
var canvas = document.getElementById('canvas1');
var context = canvas.getContext('webgl', { antialias: false, stencil: true });
</pre>
<p>At the time of creating the WebGLRenderingContext, a drawing buffer is created. The Context object manages OpenGL state and renders to the drawing buffer.</p>
<h2>WebGLRenderingContext</h2>
<p>It is the principal interface in WebGL. It represents the WebGL drawing context. This interface contains all the methods used to perform various tasks on the Drawing buffer. The attributes of this interface are given in the following table.</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>Attributes and Description</th>
</tr>
<tr>
<td>1</td>
<td><p><b>Canvas</b></p>
<p>This is a reference to the canvas element that created this context.</p>
</td>
</tr>
<tr>
<td>2</td>
<td><p><b>drawingBufferWidth</b></p>
<p>This attribute represents the actual width of the drawing buffer. It may differ from the width attribute of the HTMLCanvasElement.</p>
</td>
</tr>
<tr>
<td>3</td>
<td><p><b>drawingBufferHeight</b></p>
<p>This attribute represents the actual height of the drawing buffer. It may differ from the height attribute of the HTMLCanvasElement.</p>
</td>
</tr>
</table>
<h1>WebGL - Geometry</h1>
<p>All primitives (or object models) should have well-defined geometric details. These details may include vertices, indices, color, textures etc. In WebGL, geometric details are stored in JavaScript arrays.</p>
<p>Graphic objects are created by shader programs which run on the GPU. Geometric details are passed to shader programs using buffer objects.</p>
<h2>Defining the Required Geometry</h2>
<p>A 2D or 3D model drawn using vertices is called a <b>mesh</b>. Each facet in a mesh is called a <b>polygon</b> and a polygon is made of 3 or more vertices.</p>
<p>To draw models in the WebGL rendering context, you have to define the vertices and indices using JavaScript arrays. For example, if we want to create a triangle which lies on the coordinates {(5,5), (-5,5), (-5,-5)} as shown in the diagram, then you can create an array for the vertices as &minus;</p>
<pre class="result notranslate">
var vertices = [
   0.5,0.5,  //Vertex 1
   0.5,-0.5, //Vertex 2
  -0.5,-0.5, //Vertex 3
]; 
</pre>
<p></p>
<img src="https://www.tutorialspoint.com/webgl/images/geometry.jpg" alt="Geometry" />
<p>Similarly, you can create an array for the indices. Indices for the above triangle indices will be [0, 1, 2] and can be defined as &minus;</p>
<pre class="result notranslate">
var indices = [ 0,1,2 ]
</pre>
<p>For a better understanding of indices, consider more complex models like square. We can represent a square as a set of two triangles. If (0,3,1) and (3,1,2) are the two triangles using which we intend to draw a square, then the indices will be defined as &minus;</p>
<pre class="result notranslate">
var indices = [0,3,1,3,1,2];
</pre>
<p></p>
<img src="https://www.tutorialspoint.com/webgl/images/geometry_example.jpg" alt="Geometry Example" />
<p><b>Note</b> &minus;</p>
<p>For drawing primitives, WebGL provides the following two methods &minus;</p>
<ul class="list">
<li><p><b>drawArrays()</b> &minus; While using this method, we pass the vertices of the primitive using JavaScript arrays.</p></li>
<li><p><b>drawElements()</b> &minus; While using this method, we pass both vertices and indices of the primitive using JavaScript array.</p></li>
</ul>
<h2>Buffer Objects</h2>
<p>A buffer object is a mechanism provided by WebGL that indicates a memory area allocated in the system. In these buffer objects, you can store data of the model you want to draw, corresponding to vertices, indices, color, etc.</p>
<p>Using these buffer objects, you can pass multiple data to the shader program (vertex shader) through one of its attribute variables. Since these buffer objects reside in the GPU memory, they can be rendered directly, which in turn improves the performance.</p>
<p>To process geometry, there are two types of buffer objects. They are &minus;</p>
<ul class="list">
<li><p><b>Vertex buffer object (VBO)</b> &minus; It holds the per-vertex data of the graphical model that is going to be rendered. We use vertex buffer objects in WebGL to store and process the data regarding vertices such as vertex coordinates, normals, colors, and texture coordinates.</p></li>
<li><p><b>Index buffer objects (IBO)</b> &minus; It holds the indices (index data) of the graphical model that is going to be rendered.</p></li>
</ul>
<p>After defining the required geometry and storing them in JavaScript arrays, you need to pass these arrays to the buffer objects, from where the data will be passed to the shader programs. The following steps are to be followed to store data in the buffers.</p>
<ul class="list">
<li><p>Create an empty buffer.</p></li>
<li><p>Bind an appropriate array object to the empty buffer.</p></li>
<li><p>Pass the data (vertices/indices) to the buffer using one of the <b>typed arrays</b>.</p></li>
<li><p>Unbind the buffer (Optional).</p></li>
</ul>
<p><b>Note &minus;</b></p>
<p>WebGL provides a special type of array called <b>typed arrays</b> to transfer the data elements such as index vertex and texture. These typed arrays store large quantities of data and process them in native binary format which results in better performance. The typed arrays used by WebGL are Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, UInt32Array, Float32Array, and Float64Array.</p>
<ul class="list">
<li><p>Generally, for storing vertex data, we use <b>Float32Array</b>; and to store index data, we use <b>Uint16Array</b>.</p></li>
<li><p>You can create typed arrays just like JavaScript arrays using <b>new</b> keyword.</p></li>
</ul>
<p>Now, let's learn about the steps to store data in buffers &minus;</p>
<h2>Creating a Buffer</h2>
<p>To create an empty buffer object, WebGL provides a method called <b>createBuffer()</b>. This method returns a newly created buffer object, if the creation was successful; else it returns a null value in case of failure.</p>
<p>WebGL operates as a state machine. Once a buffer is created, any subsequent buffer operation will be executed on the current buffer until we unbound it. Use the following code to create a buffer &minus;</p>
<pre class="result notranslate">
var vertex_buffer = <b>gl</b>.createBuffer();
</pre>
<p><b>Note</b> &minus; <b>gl</b> is the reference variable to the current WebGL context.</p>
<h2>Bind the Buffer</h2>
<p>After creating an empty buffer object, you need to bind an appropriate array buffer (target) to it. WebGL provides a method called <b>bindBuffer()</b> for this purpose.</p>
<h3>Syntax</h3>
<p>The syntax of <b>bindBuffer()</b> method is as follows &minus;</p>
<pre class="result notranslate">
void <b>bindBuffer</b> (enum target, Object buffer)
</pre>
<p>This method accepts two parameters and they are discussed below.</p>
<p><b>target</b> &minus; The first variable is an enum value representing the type of the buffer we want to bind to the empty buffer. You have two predefined enum values as options for this parameter. They are &minus;</p>
<ul class="list">
<li><p><b>ARRAY_BUFFER</b> which represents vertex data.</p></li>
<li><p><b>ELEMENT_ARRAY_BUFFER</b> which represents index data.</p></li>
</ul>
<p><b>Object buffer</b> &minus; The second one is the reference variable to the buffer object created in the previous step. The reference variable can be of a vertex buffer object or of an index buffer object.</p>
<h3>Example</h3>
<p>The following code snippet shows how to use the bindBuffer() method.</p>
<pre class="result notranslate">
//vertex buffer
var vertex_buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

//Index buffer
var Index_Buffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
</pre>
<h2>Passing Data into the Buffer</h2>
<p>The next step is to pass the data (vertices/indices) to the buffer.  Till now data is in the form of an array and before passing it to the buffer, we need to wrap it in one of the WebGL typed arrays. WebGL provides a method named <b>bufferData()</b> for this purpose.</p>
<h3>Syntax</h3>
<p>The syntax of bufferData() method is as follows &minus;</p>
<pre class="result notranslate">
void <b>bufferData</b> (enum target, Object data, enum usage)
</pre>
<p>This method accepts three parameters and they are discussed below &minus;</p>
<p><b>target</b> &minus; The first parameter is an enum value representing the type of the array buffer we used. This can be ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.</p>
<p><b>Object data</b> &minus; The second parameter is the object value that contains the data to be written to the buffer object. Here we have to pass the data using <b>typed arrays</b>.</p>
<p><b>Usage</b> &minus; The third parameter of this method is an enum variable that specifies how to use the buffer object data (stored data) to draw shapes. There are three options for this parameter as listed below.</p>
<ul class="list">
<li><p><b>gl.STATIC_DRAW</b> &minus; Data will be specified once and used many times.</p></li>
<li><p><b>gl.STREAM_DRAW</b> &minus; Data will be specified once and used a few times.</p></li>
<li><p><b>gl.DYNAMIC_DRAW</b> &minus; Data will be specified repeatedly and used many times.</p></li>
</ul>
<h3>Example</h3>
<p>The following code snippet shows how to use the <b>bufferData()</b> method. Assume vertices and indices are the arrays holding the vertex and index data respectively.</p>
<pre class="result notranslate">
//vertex buffer
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

//Index buffer
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
</pre>
<h2>Unbind the Buffers</h2>
<p>It is recommended that you unbind the buffers after using them. It can be done by passing a null value in place of the buffer object, as shown below.</p>
<pre class="result notranslate">
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
</pre>
<p>WebGL provides the following methods to perform buffer operations &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>Methods and Description</th>
</tr>
<tr>
<td>1</td>
<td><p>void <b>bindBuffer</b> (enum <i>target</i>, Object <i>buffer</i>)</p>
<p><i>target</i> &minus; ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER</p></td>
</tr>
<tr>
<td>2</td>
<td><p>void <b>bufferData</b>(enum <i>target</i>, long <i>size</i>, enum <i>usage</i>)</p>
<p><i>target</i> &minus; ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER</p>
<p><i>usage</i> &minus; STATIC_DRAW, STREAM_DRAW, DYNAMIC_DRAW</p></td>
</tr>
<tr>
<td>3</td>
<td><p>void <b>bufferData</b> (enum <i>target</i>, Object <i>data</i>, enum <i>usage</i>)</p>
<p><i>target</i> and <i>usage</i> &minus; Same as for <b>bufferData</b> above</p></td>
</tr>
<tr>
<td>4</td>
<td><p>void <b>bufferSubData</b>(enum <i>target</i>, long <i>offset</i>, Object <i>data</i>)</p> 
<p><i>target</i> &minus; ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER</p></td>
</tr>
<tr>
<td>5</td>
<td>Object <b>createBuffer()</b></td>
</tr>
<tr>
<td>6</td>
<td>void <b>deleteBuffer</b>(Object <i>buffer</i>)</td>
</tr>
<tr>
<td>7</td>
<td><p>any <b>getBufferParameter</b>(enum <i>target</i>, enum <i>pname</i>)</p> <p><i>target</i> &minus; ARRAY_BUFFER, ELEMENT_ ARRAY_BUFFER</p>
<p><i>pname</i> &minus; BUFFER_SIZE, BUFFER_USAGE</p></td>
</tr>
<tr>
<td>8</td>
<td>bool <b>isBuffer</b>(Object <i>buffer</i>)</td>
</tr>
</table>
<h1>WebGL - Shaders</h1>
<p>Shaders are the programs that run on GPU. Shaders are written in OpenGL ES Shader Language (known as ES SL). ES SL has variables of its own, data types, qualifiers, built-in inputs and outputs.</p>
<h2>Data Types</h2>
<p>The following table lists the basic data types provided by OpenGL ES SL.</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>Type</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>void</td>
<td>Represents an empty value.</td>
</tr>
<tr>
<td>2</td>
<td>bool</td>
<td>Accepts true or false.</td>
</tr>
<tr>
<td>3</td>
<td>int</td>
<td>This is a signed integer data type.</td>
</tr>
<tr>
<td>4</td>
<td>float</td>
<td>This is a floating scalar data type.</td>
</tr>
<tr>
<td>5</td>
<td>vec2, vec3, vec4</td>
<td>n-component floating point vector</td>
</tr>
<tr>
<td>6</td>
<td>bvec2, bvec3, bvec4</td>
<td>Boolean vector</td>
</tr>
<tr>
<td>7</td>
<td>ivec2, ivec3, ivec4</td>
<td>signed integer vector</td>
</tr>
<tr>
<td>8</td>
<td>mat2, mat3, mat4</td>
<td>2x2, 3x3, 4x4 float matrix</td>
</tr>
<tr>
<td>9</td>
<td>sampler2D</td>
<td>Access a 2D texture</td>
</tr>
<tr>
<td>10</td>
<td>samplerCube</td>
<td>Access cube mapped texture</td>
</tr>
</table>
<h2>Qualifiers</h2>
<p>There are three main qualifiers in OpenGL ES SL &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>Qualifier</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td><b>attribute</b></td>
<td>This qualifier acts as a link between a vertex shader and OpenGL ES for per-vertex data. The value of this attribute changes for every execution of the vertex shader.</td>
</tr>
<tr>
<td>2</td>
<td><b>uniform</b></td>
<td><p>This qualifier links shader programs and the WebGL application. Unlike attribute qualifier, the values of uniforms do not change. Uniforms are read-only; you can use them with any basic data types, to declare a variable.</p>
<p><b>Example</b> &minus; uniform <b>vec4</b> lightPosition;</p>
</td>
</tr>
<tr>
<td>3</td>
<td><b>varying</b></td>
<td><p>This qualifier forms a link between a vertex shader and fragment shader for interpolated data. It can be used with the following data types &minus; float, vec2, vec3, vec4, mat2, mat3, mat4, or arrays.</p>
<p><b>Example</b> &minus; varying <b>vec3</b> normal;</p>
</td>
</tr>
</table>
<h2>Vertex Shader</h2>
<p>Vertex shader is a program code, which is called on every vertex. It transforms (move) the geometry (ex: triangle) from one place to other. It handles the data of each vertex (per-vertex data) such as vertex coordinates, normals, colors, and texture coordinates.</p>
<p>In the ES GL code of vertex shader, programmers have to define attributes to handle data. These attributes point to a Vertex Buffer Object written In JavaScript. The following tasks can be performed using vertex shaders along with vertex transformation &minus;</p>
<ul class="list">
<li>Vertex transformation</li>
<li>Normal transformation and normalization</li>
<li>Texture coordinate generation</li>
<li>Texture coordinate transformation</li>
<li>Lighting</li>
<li>Color material application</li>
</ul>
<h3>Predefined Variables</h3>
<p>OpenGL ES SL provides the following predefined variables for vertex shader &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="width:35%;">Variables</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td><b>highp vec4 gl_Position;</b></td>
<td>Holds the position of the vertex.</td>
</tr>
<tr>
<td>2</td>
<td><b>mediump float gl_PointSize;</b></td>
<td>Holds the transformed point size. The units for this variable are pixels.</td>
</tr>
</table>
<h3>Sample Code</h3>
<p>Take a look at the following sample code of a vertex shader. It processes the vertices of a triangle.</p>
<pre class="prettyprint notranslate">
attribute vec2 coordinates;

void main(void) {
   gl_Position = vec4(coordinates, 0.0, 1.0);
};
</pre>
<p>If you observe the above code carefully, we have declared an attribute variable with the name <b>coordinates</b>. (This variable will be associated with the Vertex Buffer Object using the method <b>getAttribLocation()</b>. The attribute <b>coordinates</b> is passed as a parameter to this method along with the shader program object.)</p>
<p>In the second step of the given vertex shader program, the <b>gl_position</b> variable is defined.</p>
<h3>gl_Position</h3>
<p>gl_Position is the predefined variable which is available only in the vertex shader program. It contains the vertex position. In the above code, the <b>coordinates</b> attribute is passed in the form of a vector. As vertex shader is a per-vertex operation, the gl_position value is calculated for each vertex.</p>
<p>Later, the gl_position value is used by primitive assembly, clipping, culling, and other fixed functionality operations that operate on the primitives after the vertex processing is over.</p>
<p>We can write vertex shader programs for all possible operations of vertex shader, which we will discuss individually in this tutorial.</p>
<h2>Fragment Shader</h2>
<p>A <b>mesh</b> is formed by multiple triangles, and the surface of the each triangle is known as a <b>fragment</b>. A fragment shader is the code that runs on every pixel on each fragment. This is written to calculate and fill the color on individual pixels. The following tasks can be performed using fragment shaders &minus;</p>
<ul class="list">
<li>Operations on interpolated values</li>
<li>Texture access</li>
<li>Texture application</li>
<li>Fog</li>
<li>Color sum</li>
</ul>
<h3>Predefined Variables</h3>
<p>OpenGL ES SL provides the following predefined variables for fragment shader &minus;</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th style="width:38%;">Variables</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>mediump vec4 <b>gl_FragCoord</b>;</td>
<td>Holds the fragment position within the frame buffer.</td>
</tr>
<tr>
<td>2</td>
<td>bool gl_FrontFacing;</td>
<td>Holds the fragment that belongs to a front-facing primitive.</td>
</tr>
<tr>
<td>3</td>
<td>mediump vec2 gl_PointCoord;</td>
<td>Holds the fragment position within a point (point rasterization only).</td>
</tr>
<tr>
<td>4</td>
<td>mediump vec4 gl_FragColor;</td>
<td>Holds the output fragment color value of the shader</td>
</tr>
<tr>
<td>5</td>
<td>mediump vec4 gl_FragData[n]</td>
<td>Holds the fragment color for color attachment <b>n</b>.</td>
</tr>
</table>
<h3>Sample Code</h3>
<p>The following sample code of a fragment shader shows how to apply color to every pixel in a triangle.</p>
<pre class="prettyprint notranslate">
void main(void) {
   gl_FragColor = vec4(0, 0.8, 0, 1);
}
</pre>
<p>In the above code, the <b>color</b> value is stored in the variable <code>gl.FragColor</code>. The fragment shader program passes the output to the pipeline using fixed function variables; FragColor is one of them. This variable holds the color value of the pixels of the model.</p>
<h2>Storing and Compiling the Shader Programs</h2>
<p>Since shaders are independent programs, we can write them as a separate script and use in the application. Or, you can store them directly in <b>string</b> format, as shown below.</p>
<pre class="prettyprint notranslate">
var vertCode =
   'attribute vec2 coordinates;' +
	
   'void main(void) {' +
      ' gl_Position = vec4(coordinates, 0.0, 1.0);' +
   '}';
</pre>
<h3>Compiling the Shader</h3>
<p>Compilation involves following three steps &minus;</p>
<ul class="list">
<li>Creating the shader object</li>
<li>Attaching the source code to the created shader object</li>
<li>Compiling the program</li>
</ul>
<h3>Creating the Vertex Shader</h3>
<p>To create an empty shader, WebGL provides a method called <b>createShader()</b>. It creates and returns the shader object. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
Object <b>createShader</b> (enum type)
</pre>
<p>As observed in the syntax, this method accepts a predefined enum value as parameter. We have two options for this &minus;</p>
<ul class="list">
<li><p><b>gl.VERTEX_SHADER</b> for creating vertex shader</p></li>
<li><p><b>gl.FRAGMENT_SHADER</b> for creating fragment shader.</p></li>
</ul>
<h3>Attaching the Source to the Shader</h3>
<p>You can attach the source code to the created shader object using the method <b>shaderSource()</b>. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
void <b>shaderSource</b>(Object shader, string source)
</pre>
<p>This method accepts two parameters &minus;</p>
<ul class="list">
<li><p><b>shader</b> &minus; You have to pass the created shader object as one parameter.</p></li>
<li><p><b>Source</b> &minus; You have to pass the shader program code in string format.</p></li>
</ul>
<h3>Compiling the Program</h3>
<p>To compile the program, you have to use the method <b>compileShader()</b>. Its syntax is as follow &minus;</p>
<pre class="result notranslate">
compileShader(Object shader)
</pre>
<p>This method accepts the shader program object as a parameter. After creating a shader program object, attach the source code to it and pass that object to this method.</p>
<p>The following code snippet shows how to create and compile a vertex shader as well as a fragment shader to create a triangle.</p>
<pre class="prettyprint notranslate">
// Vertex Shader
var vertCode =
   'attribute vec3 coordinates;' +
	
   'void main(void) {' +
      ' gl_Position = vec4(coordinates, 1.0);' +
   '}';
      
var vertShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertShader, vertCode);
gl.compileShader(vertShader);
 
// Fragment Shader
var fragCode =
   'void main(void) {' +
      ' gl_FragColor = vec4(0, 0.8, 0, 1);' +
   '}';
      
var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragShader, fragCode);
gl.compileShader(fragShader);
</pre>
<h2>Combined Program</h2>
<p>After creating and compiling both the shader programs, you need to create a combined program containing both the shaders (vertex &amp; fragment). The following steps need to be followed &minus;</p>
<ul class="list">
<li>Create a program object</li>
<li>Attach both the shaders</li>
<li>Link both the shaders</li>
<li>Use the program</li>
</ul>
<h3>Create a Program Object</h3>
<p>Create a program object by using the method <b>createProgram()</b>. It will return an empty program object. Here is its syntax &minus;</p>
<pre class="result notranslate">
createProgram();
</pre>
<h3>Attach the Shaders</h3>
<p>Attach the shaders to the created program object using the method <b>attachShader()</b>. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
<b>attachShader</b>(Object <i>program</i>, Object <i>shader</i>);
</pre>
<p>This method accepts two parameters &minus;</p>
<ul class="list">
<li><p><b>Program</b> &minus; Pass the created empty program object as one parameter.</p></li>
<li><p><b>Shader</b> &minus; Pass one of the compiled shaders programs (vertex shader, fragment shader)</p></li>
</ul>
<p><b>Note</b> &minus; You need to attach both the shaders using this method.</p>
<h3>Link the Shaders</h3>
<p>Link the shaders using the method <b>linkProgram()</b>, by passing the program object to which you have attached the shaders. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
linkProgram(shaderProgram);
</pre>
<h3>Use the Program</h3>
<p>WebGL provides a method called <b>useProgram()</b>. You need to pass the linked program to it. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
useProgram(shaderProgram);
</pre>
<p>The following code snippet shows how to create, link, and use a combined shader program.</p>
<pre class="result notranslate">
var shaderProgram = gl.createProgram();
gl.attachShader(shaderProgram, vertShader);
gl.attachShader(shaderProgram, fragShader);
gl.linkProgram(shaderProgram);
gl.useProgram(shaderProgram); 
</pre>
<h1>Associating Attributes &amp; Buffer Objects</h1>
<p>Each attribute in the vertex shader program points to a vertex buffer object. After creating the vertex buffer objects, programmers have to associate them with the attributes of the vertex shader program. Each attribute points to only one vertex buffer object from which they extract the data values, and then these attributes are passed to the shader program.</p>
<p>To associate the Vertex Buffer Objects with the attributes of the vertex shader program, you have to follow the steps given below &minus;</p>
<ul class="list">
<li>Get the attribute location</li>
<li>Point the attribute to a vertex buffer object</li>
<li>Enable the attribute</li>
</ul>
<h2>Get the Attribute Location</h2>
<p>WebGL provides a method called <b>getAttribLocation()</b> which returns the attribute location. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
ulong <b>getAttribLocation</b>(Object <i>program</i>, string <i>name</i>)
</pre>
<p>This method accepts the vertex shader program object and the attribute values of the vertex shader program.</p>
<p>The following code snippet shows how to use this method.</p>
<pre class="result notranslate">
<b>var</b> coordinatesVar = gl.getAttribLocation(shader_program, "coordinates"); 
</pre>
<p>Here, <b>shader_program</b> is the object of the shader program and <b>coordinates</b> is the attribute of the vertex shader program.</p>
<h2>Point the Attribute to a VBO</h2>
<p>To assign the buffer object to the attribute variable, WebGL provides a method called <b>vertexAttribPointer()</b>. Here is the syntax of this method &minus;</p>
<pre class="result notranslate">
void <b>vertexAttribPointer</b>(<i>location</i>, int <i>size</i>, enum <i>type</i>, bool <i>normalized</i>, long <i>stride</i>, long <i>offset</i>)
</pre>
<p>This method accepts six parameters and they are discussed below.</p>
<ul class="list">
<li><p><b>Location</b> &minus; It specifies the storage location of an attribute variable. Under this option, you have to pass the value returned by the <b>getAttribLocation()</b> method.</p></li>
<li><p><b>Size</b> &minus; It specifies the number of components per vertex in the buffer object.</p></li>
<li><p><b>Type</b> &minus; It specifies the type of data.</p></li>
<li><p><b>Normalized</b> &minus; This is a Boolean value. If true, non-floating data is normalized to [0, 1]; else, it is normalized to [-1, 1].</p></li>
<li><p><b>Stride</b> &minus; It specifies the number of bytes between different vertex data elements, or zero for default stride.</p></li>
<li><p><b>Offset</b> &minus; It specifies the offset (in bytes) in a buffer object to indicate which byte the vertex data is stored from. If the data is stored from the beginning, <i>offset</i> is 0.</p></li>
</ul>
<p>The following snippet shows how to use <b>vertexAttribPointer()</b> in a program &minus;</p>
<pre class="result notranslate">
gl.vertexAttribPointer(coordinatesVar, 3, gl.FLOAT, <b>false</b>, 0, 0);
</pre>
<h2>Enabling the Attribute</h2>
<p>Activate the vertex shader attribute to access the buffer object in a vertex shader. For this operation, WebGL provides <b>enableVertexAttribArray()</b> method. This method accepts the location of the attribute as a parameter. Here is how to use this method in a program &minus;</p>
<pre class="result notranslate">
gl.enableVertexAttribArray(coordinatesVar); 
</pre>
<h1>WebGL - Drawing a Model</h1>
<p>After associating the buffers with the shaders, the final step is to draw the required primitives. WebGL provides two methods namely, <b>drawArrays()</b> and <b>drawElements()</b> to draw models.</p>
<h2>drawArrays()</h2>
<p><b>drawArrays()</b> is the method which is used to draw models using vertices. Here is its syntax &minus;</p>
<pre class="result notranslate">
void drawArrays(enum mode, int first, long count)
</pre>
<p>This method takes the following three parameters &minus;</p>
<ul class="list">
<li><p><b>mode</b> &minus; In WebGL, models are drawn using primitive types. Using mode, programmers have to choose one of the primitive types provided by WebGL. The possible values for this option are &minus; gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, and gl.TRIANGLES.</p></li>
<li><p><b>first</b> &minus; This option specifies the starting element in the enabled arrays. It cannot be a negative value.</p></li>
<li><p><b>count</b> &minus; This option specifies the number of elements to be rendered.</p></li>
</ul>
<p>If you draw a model using <b>drawArrays()</b> method, then WebGL, while rendering the shapes, creates the geometry in the order in which the vertex coordinates are defined.</p>
<h3>Example</h3>
<p>If you want to draw a single triangle using <b>drawArray()</b> method, then you have to pass three vertices and call the <b>drawArrays()</b> method, as shown below.</p>
<pre class="result notranslate">
var vertices = [-0.5,-0.5, -0.25,0.5, 0.0,-0.5,];
gl.drawArrays(gl.TRIANGLES, 0, 3);
</pre>
<p>It will produce a triangle as shown below.</p>
<img src="https://www.tutorialspoint.com/webgl/images/triangle.jpg" alt="Triangle" />
<p>Suppose you want to draw contiguous triangles, then you have to pass the next three vertices in order in the vertex buffer and mention the number of elements to be rendered as 6.</p>
<pre class="result notranslate">
var vertices = [-0.5,-0.5, -0.25,0.5, 0.0,-0.5, 0.0,-0.5, 0.25,0.5, 0.5,-0.5,];
gl.drawArrays(gl.TRIANGLES, 0, 6);
</pre>
<p>It will produce a contiguous triangle as shown below.</p>
<img src="https://www.tutorialspoint.com/webgl/images/triangles_1.jpg" alt="Triangle 1" />
<h2>drawElements()</h2>
<p><b>drawElements()</b> is the method that is used to draw models using vertices and indices. Its syntax is as follows &minus;</p>
<pre class="result notranslate">
void <b>drawElements</b>(enum mode, long count, enum type, long offset)
</pre>
<p>This method takes the following four parameters &minus;</p>
<ul class="list">
<li><p><b>mode</b> &minus; WebGL models are drawn using primitive types. Using mode, programmers have to choose one of the primitive types provided by WebGL. The list of possible values for this option are &minus; gl.POINTS, gl.LINE_STRIP, gl.LINE_LOOP, gl.LINES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN, and gl.TRIANGLES.</p></li>
<li><p><b>count</b> &minus; This option specifies the number of elements to be rendered.</p></li>
<li><p><b>type</b> &minus; This option specifies the data type of the indices which must be UNSIGNED_BYTE or UNSIGNED_SHORT.</p></li>
<li><p><b>offset</b> &minus; This option specifies the starting point for rendering. It is usually the first element (0).</p></li>
</ul>
<p>If you draw a model using <b>drawElements()</b> method, then index buffer object should also be created along with the vertex buffer object. If you use this method, the vertex data will be processed once and used as many times as mentioned in the indices.</p>
<h3>Example</h3>
<p>If you want to draw a single triangle using indices, you need to pass the indices along with vertices and call the <b>drawElements()</b> method as shown below.</p>
<pre class="prettyprint notranslate">
var vertices = [ -0.5,-0.5,0.0, -0.25,0.5,0.0, 0.0,-0.5,0.0 ];
var indices = [0,1,2];

gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
</pre>
<p>It will produce the following output &minus;</p>
<img src="https://www.tutorialspoint.com/webgl/images/triangle.jpg" alt="Triangle" />
<p>If you want to draw contagious triangles using <b>drawElements()</b> method, simply add the other vertices and mention the indices for the remaining vertices.</p>
<pre class="prettyprint notranslate">
var vertices = [
   -0.5,-0.5,0.0,
   -0.25,0.5,0.0,
   0.0,-0.5,0.0,
   0.25,0.5,0.0,
   0.5,-0.5,0.0 
];

var indices = [0,1,2,2,3,4];
    
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
</pre>
<p>It will produce the following output &minus;</p>
<img src="https://www.tutorialspoint.com/webgl/images/triangles_1.jpg" alt="Triangle 1" />
<h2>Required Operations</h2>
<p>Before drawing a primitive, you need to perform a few operations, which are explained below.</p>
<h3>Clear the Canvas</h3>
<p>First of all, you should clear the canvas, using <b>clearColor()</b> method. You can pass the RGBA values of a desired color as parameter to this method. Then WebGL clears the canvas and fills it with the specified color. Therefore, you can use this method for setting the background color.</p>
<p>Take a look at the following example. Here we are passing the RGBA value of gray color.</p>
<pre class="result notranslate">
gl.clearColor(0.5, 0.5, .5, 1);
</pre>
<h3>Enable Depth Test</h3>
<p>Enable the depth test using the <b>enable()</b> method, as shown below.</p>
<pre class="result notranslate">
gl.enable(gl.DEPTH_TEST); 
</pre>
<h3>Clear the Color Buffer Bit</h3>
<p>Clear the color as well as the depth buffer by using the <b>clear()</b> method, as shown below.</p>
<pre class="result notranslate">
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
</pre>
<h3>Set the View Port</h3>
<p>The view port represents a rectangular viewable area that contains the rendering results of the drawing buffer. You can set the dimensions of the view port using <b>viewport()</b> method. In the following code, the view port dimensions are set to the canvas dimensions.</p>
<pre class="result notranslate">
gl.viewport(0,0,canvas.width,canvas.height);
</pre>
<h1>WebGL - Drawing Points</h1>
<p>We discussed earlier (in Chapter 5) how to follow a step-by-step process to draw a primitive. We have explained the process in five steps. You need to repeat these steps every time you draw a new shape. This chapter explains how to draw points with 3D coordinates in WebGL. Before moving further, let us take a relook at the five steps.</p>
<h2>Required Steps</h2>
<p>The following steps are required to create a WebGL application to draw points.</p>
<p><b>Step 1 &minus; Prepare the Canvas and Get the WebGL Rendering Context</b></p>
<p>In this step, we obtain the WebGL Rendering context object using the method <b>getContext().</b></p>
<p><b>Step 2 &minus; Define the Geometry and Store it in the Buffer Objects</b></p>
<p>Since we are drawing three points, we define three vertices with 3D coordinates and store them in buffers.</p>
<pre class="result notranslate">
var vertices = [
   -0.5,0.5,0.0,
   0.0,0.5,0.0,
   -0.25,0.25,0.0, 
];
</pre>
<p><b>Step 3 &minus; Create and Compile the Shader Programs</b></p>
<p>In this step, you need to write vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<ul class="list">
<li><p><b>Vertex Shader</b> &minus; In the vertex shader of the given example, we define a vector attribute to store 3D coordinates, and assign it to the <b>gl_position</b> variable.</p></li>
<li><p><b>gl_pointsize</b> is the variable used to assign a size to the point. We assign the point size as 10.</p></li>
</ul>
<pre class="result notranslate">
var vertCode = 'attribute vec3 coordinates;' +

   'void main(void) {' +
      ' gl_Position = vec4(coordinates, 1.0);' +
      'gl_PointSize = 10.0;'+
   '}';
</pre>
<ul class="list">
<li><p><b>Fragment Shader</b> &minus; In the fragment shader, we simply assign the fragment color to the <b>gl_FragColor</b> variable</p></li>
</ul>
<pre class="result notranslate">
var fragCode = 'void main(void) {' +' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +'}';
</pre>
<p><b>Step 4 &minus; Associate the Shader Programs to Buffer Objects</b></p>
<p>In this step, we associate the buffer objects with the shader program.</p>
<p><b>Step 5 &minus; Drawing the Required Object</b></p>
<p>We use the method <b>drawArrays()</b> to draw points. Since the number of points we want to draw are is three, the count value is 3.</p>
<pre class="result notranslate">
gl.drawArrays(gl.POINTS, 0, 3)
</pre>
<h2>Example – Draw Three Points using WebGL</h2>
<p>Here is the complete WebGL program to draw three points &minus;</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "570" height = "570" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*================Creating a canvas=================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl'); 
      
         /*==========Defining and storing the geometry=======*/

         var vertices = [
            -0.5,0.5,0.0,
            0.0,0.5,0.0,
            -0.25,0.25,0.0, 
         ];
         
         // Create an empty buffer object to store the vertex buffer
         var vertex_buffer = gl.createBuffer();

         //Bind appropriate array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
      
         // Pass the vertex data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);


         /*=========================Shaders========================*/
      
         // vertex shader source code
         var vertCode =
            'attribute vec3 coordinates;' +
				
            'void main(void) {' +
               ' gl_Position = vec4(coordinates, 1.0);' +
               'gl_PointSize = 10.0;'+
            '}';
         
         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);

         // fragment shader source code
         var fragCode =
            'void main(void) {' +
               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';
         
         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);
      
         // Compile the fragmentt shader
         gl.compileShader(fragShader);

         // Create a shader program object to store
         // the combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader); 
 
         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);

         /*======== Associating shaders to buffer objects ========*/

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         // Point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

         // Enable the attribute
         gl.enableVertexAttribArray(coord);

         /*============= Drawing the primitive ===============*/

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST);
 
         // Clear the color buffer bit
         gl.clear(gl.COLOR_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         // Draw the triangle
         gl.drawArrays(gl.POINTS, 0, 3);

      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/draw_three_points.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Drawing a Triangle</h1>
<p>In the previous chapter (Chapter 11), we discussed how to draw three points using WebGL. In Chapter 5, we took sample application to demonstrate how to draw a triangle. In both the examples, we have drawn the primitives using only vertices.</p>
<p>To draw more complex shapes/meshes, we pass the indices of a geometry too, along with the vertices, to the shaders. In this chapter, we will see how to draw a triangle using indices.</p>
<h2>Steps Required to Draw a Triangle</h2>
<p>The following steps are required to create a WebGL application to draw a triangle.</p>
<p><b>Step 1 &minus; Prepare the Canvas and Get WebGL Rendering Context</b></p>
<p>In this step, we obtain the WebGL Rendering context object using <b>getContext()</b>.</p>
<p><b>Step 2 &minus; Define the Geometry and Store it in Buffer Objects</b></p>
<p>Since we are drawing a triangle using indices, we have to pass the three vertices of the triangle, including the indices, and store them in the buffers.</p>
<pre class="result notranslate">
var vertices = [
   -0.5,0.5,0.0,
   -0.5,-0.5,0.0,
   0.5,-0.5,0.0, 
];
	
indices = [0,1,2]; 
</pre>
<p><b>Step 3 &minus; Create and Compile the Shader Programs</b></p>
<p>In this step, you need to write vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<ul class="list">
<li><p><b>Vertex Shader</b> &minus; In the vertex shader of the program, we define the vector attribute to store 3D coordinates and assign it to <b>gl_position</b>.</p></li>
</ul>
<pre class="result notranslate">
var vertCode =
   'attribute vec3 coordinates;' +
	
   'void main(void) {' +
      ' gl_Position = vec4(coordinates, 1.0);' +
   '}';
</pre>
<ul class="list">
<li><p><b>Fragment Shader</b> &minus; In the fragment shader, we simply assign the fragment color to the <b>gl_FragColor</b> variable.</p></li>
</ul>
<pre class="result notranslate">
var fragCode = 'void main(void) {' +
   ' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +
'}';
</pre>
<p><b>Step 4 &minus; Associate the Shader Programs to the Buffer Objects</b></p>
<p>In this step, we associate the buffer objects and the shader program.</p>
<p><b>Step 5 &minus; Drawing the Required Object</b></p>
<p>Since we are drawing a triangle using indices, we will use <code>drawElements()</code>. To this method, we have to pass the number of indices. The value of the <b>indices.length</b> signifies the number of indices.</p>
<pre class="result notranslate">
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
</pre>
<h2>Example – Drawing a Triangle</h2>
<p>The following program code shows how to draw a triangle in WebGL using indices &minus;</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "570" height = "570" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*============== Creating a canvas ====================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
      
         /*======== Defining and storing the geometry ===========*/

         var vertices = [
            -0.5,0.5,0.0,
            -0.5,-0.5,0.0,
            0.5,-0.5,0.0, 
         ];
         
         indices = [0,1,2];
         
         // Create an empty buffer object to store vertex buffer
         var vertex_buffer = gl.createBuffer();

         // Bind appropriate array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         
         // Pass the vertex data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);

         // Create an empty buffer object to store Index buffer
         var Index_Buffer = gl.createBuffer();

         // Bind appropriate array buffer to it
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

         // Pass the vertex data to the buffer
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
         
         // Unbind the buffer
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

         /*================ Shaders ====================*/
         
         // Vertex shader source code
         var vertCode =
            'attribute vec3 coordinates;' +
				
            'void main(void) {' +
               ' gl_Position = vec4(coordinates, 1.0);' +
            '}';
            
         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);

         //fragment shader source code
         var fragCode =
            'void main(void) {' +
               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';
            
         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode); 
         
         // Compile the fragmentt shader
         gl.compileShader(fragShader);

         // Create a shader program object to store
         // the combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader);

         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both the programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);

         /*======= Associating shaders to buffer objects =======*/

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Bind index buffer object
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
         
         // Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         // Point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0); 
         
         // Enable the attribute
         gl.enableVertexAttribArray(coord);

         /*=========Drawing the triangle===========*/

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST);

         // Clear the color buffer bit
         gl.clear(gl.COLOR_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         // Draw the triangle
         gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);

      &lt;/script&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/drawing_a_triangle.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Modes of Drawing</h1>
<p>In the previous chapter (Chapter 12), we discussed how to draw a triangle using WebGL. In addition to triangles, WebGL supports various other drawing modes. This chapter explains the drawing modes supported by WebGL.</p>
<h2>The mode Parameter</h2>
<p>Let’s take a look at the syntax of the methods &minus; <b>drawElements()</b> and draw <b>Arrays()</b>.</p>
<pre class="result notranslate">
void drawElements(enum mode, long count, enum type, long offset);

void drawArrays(enum mode, int first, long count);
</pre>
<p>If you clearly observe, both the methods accept a parameter <b>mode</b>. Using this parameter, the programmers can select the drawing mode in WebGL.</p>
<p>The drawing modes provided by WebGL are listed in the following table.</p>
<table class="table table-bordered">
<tr>
<th>S.No.</th>
<th>mode</th>
<th>Description</th>
</tr>
<tr>
<td>1</td>
<td>gl.POINTS</td>
<td>To draw a series of points.</td>
</tr>
<tr>
<td>2</td>
<td>gl.LINES</td>
<td>To draw a series of unconnected line segments (individual lines).</td>
</tr>
<tr>
<td>3</td>
<td>gl.LINE_STRIP</td>
<td>To draw a series of connected line segments.</td>
</tr>
<tr>
<td>4</td>
<td>gl.LINE_LOOP</td>
<td>To draw a series of connected line segments. It also joins the first and last vertices to form a loop.</td>
</tr>
<tr>
<td>5</td>
<td>gl.TRIANGLES</td>
<td>To draw a series of separate triangles.</td>
</tr>
<tr>
<td>6</td>
<td>gl.TRIANGLE_STRIP</td>
<td>To draw a series of connected triangles in strip fashion.</td>
</tr>
<tr>
<td>7</td>
<td>gl.TRIANGLE_FAN</td>
<td>To draw a series of connected triangles sharing the first vertex in a fan-like fashion.</td>
</tr>
</table>
<h2>Example – Draw Three Parallel Lines</h2>
<p>The following example shows how to draw three parallel lines using <b>gl.LINES</b>.</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "300" height = "300" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*======= Creating a canvas =========*/

         var canvas = document.getElementById('my_Canvas');
         var gl = canvas.getContext('experimental-webgl');


         /*======= Defining and storing the geometry ======*/

         var vertices = [
            -0.7,-0.1,0,
            -0.3,0.6,0,
            -0.3,-0.3,0,
            0.2,0.6,0,
            0.3,-0.3,0,
            0.7,0.6,0 
         ]
          
         // Create an empty buffer object
         var vertex_buffer = gl.createBuffer();

         // Bind appropriate array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
      
         // Pass the vertex data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);

         /*=================== Shaders ====================*/

         // Vertex shader source code
         var vertCode =
            'attribute vec3 coordinates;' +
            'void main(void) {' +
               ' gl_Position = vec4(coordinates, 1.0);' +
            '}';

         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);

         // Fragment shader source code
         var fragCode =
            'void main(void) {' +
               'gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';

         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);

         // Compile the fragmentt shader
         gl.compileShader(fragShader);

         // Create a shader program object to store
         // the combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader);

         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both the programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);

         /*======= Associating shaders to buffer objects ======*/

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         // Point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

         // Enable the attribute
         gl.enableVertexAttribArray(coord);

         /*============ Drawing the triangle =============*/

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST);

         // Clear the color and depth buffer
         gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         // Draw the triangle
         gl.drawArrays(gl.LINES, 0, 6);

         // POINTS, LINE_STRIP, LINE_LOOP, LINES,
         // TRIANGLE_STRIP,TRIANGLE_FAN, TRIANGLES
      
      &lt;/script&gt;
		
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/three_parallel_lines.htm" height="320px" width="600px"></iframe>
<h2>Drawing Modes</h2>
<p>In the above program, if you replace the mode of <b>drawArrays()</b> with one of the following drawing modes, it will produce different outputs each time.</p>
<table class="table table-bordered">
<tr>
<th>Drawing Modes</th>
<th>Outputs</th>
</tr>
<tr>
<td style="vertical-align:middle;">LINE_STRIP</td>
<td><img src="https://www.tutorialspoint.com/webgl/images/line_strip.jpg" alt="Line Strip" /></td>
</tr>
<tr>
<td style="vertical-align:middle;">LINE_LOOP</td>
<td><img src="https://www.tutorialspoint.com/webgl/images/line_loop.jpg" alt="Line Loop" /></td>
</tr>
<tr>
<td style="vertical-align:middle;">TRIANGLE_STRIP</td>
<td><img src="https://www.tutorialspoint.com/webgl/images/triangle_strip.jpg" alt="Triangle Strip" /></td>
</tr>
<tr>
<td style="vertical-align:middle;">TRIANGLE_FAN</td>
<td><img src="https://www.tutorialspoint.com/webgl/images/triangle_fan.jpg" alt="Triangle Fan" /></td>
</tr>
<tr>
<td style="vertical-align:middle;">TRIANGLES</td>
<td><img src="https://www.tutorialspoint.com/webgl/images/triangles.jpg" alt="Triangles" /></td>
</tr>
</table>
<h1>WebGL - Drawing a Quad</h1>
<p>In the previous chapter, we discussed the different drawing modes provided by WebGL. We can also use indices to draw primitives using one of these modes. To draw models in WebGL, we have to choose one of these primitives and draw the required mesh (i.e., a model formed using one or more primitives).</p>  
<p>In this chapter, we will take an example to demonstrate how to draw a quadrilateral using WebGL.</p>
<h2>Steps to Draw a Quadrilateral</h2>
<p>The following steps are required to create a WebGL application to draw a quadrilateral.</p>
<p><b>Step 1 &minus; Prepare the Canvas and Get the WebGL Rendering Context</b></p>
<p>In this step, we obtain the WebGL Rendering context object using <b>getContext()</b>.</p>
<p><b>Step 2 &minus; Define the Geometry and Store it in the Buffer Objects</b></p>
<p>A square can be drawn using two triangles. In this example, we provide the vertices for two triangles (with one common edge) and indices.</p>
<pre class="result notranslate">
var vertices = [
   -0.5,0.5,0.0,
   -0.5,-0.5,0.0,
   0.5,-0.5,0.0,
   0.5,0.5,0.0 
];

indices = [3,2,1,3,1,0]; 
</pre>
<p><b>Step 3 &minus; Create and Compile the Shader Programs</b></p>
<p>In this step, you need to write the vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<ul class="list">
<li><p><b>Vertex Shader</b> &minus; In the vertex shader of the program, we define the vector attribute to store 3D coordinates and assign it to <b>gl_position</b>.</p></li>
</ul>
<pre class="result notranslate">
var vertCode =
   'attribute vec3 coordinates;' +
   'void main(void) {' +
      ' gl_Position = vec4(coordinates, 1.0);' +
   '}';
</pre>
<ul class="list">
<li><p><b>Fragment Shader</b> &minus; In the fragment shader, we simply assign the fragment color to the <b>gl_FragColor</b> variable.</p></li>
</ul>
<pre class="result notranslate">
var fragCode = 'void main(void) {' +' gl_FragColor = vec4(0.5, 0.3, 0.0, 7.5);' +'}';
</pre>
<p><b>Step 4 &minus; Associate the Shader Programs to Buffer Objects</b></p>
<p>In this step, we associate the buffer objects with the shader program.</p>
<p><b>Step 5 &minus; Drawing the Required Object</b></p>
<p>Since we are drawing two triangles to form a quad, using indices, we will use the method <b>drawElements()</b>. To this method, we have to pass the number of indices. The value of <b>indices.length</b> gives the number of indices.</p>
<pre class="result notranslate">
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
</pre>
<h2>Example – Draw a Quadrilateral</h2>
<p>The following program shows how to create a WebGL application to draw a quadrilateral.</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "570" height = "570" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*============ Creating a canvas =================*/
      
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
      
         /*========== Defining and storing the geometry =========*/

         var vertices = [
            -0.5,0.5,0.0,
            -0.5,-0.5,0.0,
            0.5,-0.5,0.0,
            0.5,0.5,0.0 
         ];
          
         indices = [3,2,1,3,1,0];
      
         // Create an empty buffer object to store vertex buffer
         var vertex_buffer = gl.createBuffer();

         // Bind appropriate array buffer to it
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
 
         // Pass the vertex data to the buffer
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, null);

         // Create an empty buffer object to store Index buffer
         var Index_Buffer = gl.createBuffer();

         // Bind appropriate array buffer to it
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

         // Pass the vertex data to the buffer
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

         // Unbind the buffer
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

         /*====================== Shaders =======================*/
 
         // Vertex shader source code
         var vertCode =
            'attribute vec3 coordinates;' +
            'void main(void) {' +
               ' gl_Position = vec4(coordinates, 1.0);' +
            '}';
         
         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);

         // Fragment shader source code
         var fragCode =
            'void main(void) {' +
               ' gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';
         
         // Create fragment shader object 
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);

         // Compile the fragmentt shader
         gl.compileShader(fragShader);

         // Create a shader program object to
         // store the combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader);

         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both the programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);

         /* ======= Associating shaders to buffer objects =======*/

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Bind index buffer object
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer); 
 
         // Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         // Point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);
 
         // Enable the attribute
         gl.enableVertexAttribArray(coord);

         /*============= Drawing the Quad ================*/

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST);

         // Clear the color buffer bit
         gl.clear(gl.COLOR_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         // Draw the triangle
         gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);

      &lt;/script&gt;
   
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/draw_a_quadrilateral.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Colors</h1>
<p>In all our previous examples, we applied color to the object by assigning a desired color value to the <b>gl_FragColor</b> variable. In addition to that, we can define colors for each vertex &minus; just like vertex coordinates and indices. This chapter takes an example to demonstrate how to apply colors to a quadrilateral using WebGL.</p>
<h2>Applying Colors</h2>
<p>To apply colors, you have to define the colors for each vertex using the RGB values, in JavaScript array. You can assign the same values to all the vertices to have a unique color to the object. After defining the colors, you have to create a color buffer and store these values in it, and associate it to the vertex shader attributes.</p>
<p>In the vertex shader, along with the coordinates attribute (that holds the position of the vertices), we define an <b>attribute</b> and a <b>varying</b> to handle colors.</p>
<p>The <b>color</b> attribute holds the color value per vertex, and <b>varying</b> is the variable that is passed as an input to the fragment shader. Therefore, we have to assign the <b>color</b> value to <b>varying</b>.</p>
<p>In the fragment shader, the <b>varying</b> that holds the color value is assigned to <b>gl_FragColor</b>, which holds the final color of the object.</p>
<h2>Steps to Apply Colors</h2>
<p>The following steps are required to create a WebGL application to draw a Quad and apply colors to it.</p>
<p><b>Step 1 &minus; Prepare the Canvas and Get the WebGL Rendering Context</b></p>
<p>In this step, we obtain the WebGL Rendering context object using <b>getContext()</b>.</p>
<p><b>Step 2 &minus; Define the Geometry and Store it in the Buffer Objects</b></p>
<p>A square can be drawn using two triangles. Therefore, in this example, we provide the vertices for two triangles (with one common edge) and indices. Since we want to apply colors to it, a variable holding the color values is also defined and the color values for each (Red, Blue, Green, and Pink) are assigned to it.</p>
<pre class="result notranslate">
var vertices = [
   -0.5,0.5,0.0,
   -0.5,-0.5,0.0, 
   0.5,-0.5,0.0,
   0.5,0.5,0.0 
];

var colors = [ 0,0,1, 1,0,0, 0,1,0, 1,0,1,];

indices = [3,2,1,3,1,0]; 
</pre>
<p><b>Step 3 &minus; Create and Compile the Shader Programs</b></p>
<p>In this step, you need to write the vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<ul class="list">
<li><p><b>Vertex Shader</b> &minus; In the vertex shader of the program, we define vector attributes to store 3D coordinates (position), and the color of each vertex. A <b>varing</b> variable is declared to pass the color values from the vertex shader to the fragment shader. And finally, the value stored in the color attribute is assigned to <b>varying</b>.</p></li>
</ul>
<pre class="result notranslate">
var vertCode = 'attribute vec3 coordinates;'+
   'attribute vec3 color;'+
   'varying vec3 vColor;'+
	
   'void main(void) {' +
      ' gl_Position = vec4(coordinates, 1.0);' +
      'vColor = color;'+
   '}';
</pre>
<ul class="list">
<li><p><b>Fragment Shader</b> &minus; In the fragment shader, we assign the <b>varying</b> to the <b>gl_FragColor</b> variable.</p></li>
</ul>
<pre class="result notranslate">
var fragCode = 'precision mediump float;'+
   'varying vec3 vColor;'+
   'void main(void) {'+
      'gl_FragColor = vec4(vColor, 1.);'+
   '}';
</pre>
<p><b>Step 4 &minus; Associate the Shader Programs with the Buffer Objects</b></p>
<p>In this step, we associate the buffer objects and the shader program.</p>
<p><b>Step 5 &minus; Drawing the Required Object</b></p>
<p>Since we are drawing two triangles that will form a quad, using indices, we will use the method <b>drawElements()</b>. To this method, we have to pass the number of indices. The value of <b>indices.length</b> indicates the number of indices.</p>
<pre class="result notranslate">
gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
</pre>
<h2>Example – Applying Color</h2>
<p>The following program demonstrates how to draw a quad using WebGL application and apply colors to it.</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
    &lt;canvas width = "300" height = "300" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*============= Creating a canvas ==================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
         
         /*========== Defining and storing the geometry ==========*/

         var vertices = [
            -0.5,0.5,0.0,
            -0.5,-0.5,0.0,
            0.5,-0.5,0.0,
            0.5,0.5,0.0
         ];

         var colors = [0,0,1, 1,0,0, 0,1,0, 1,0,1,];
         
         indices = [3,2,1,3,1,0];
         
         // Create an empty buffer object and store vertex data
         var vertex_buffer = gl.createBuffer();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
         gl.bindBuffer(gl.ARRAY_BUFFER, null);

         // Create an empty buffer object and store Index data
         var Index_Buffer = gl.createBuffer();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

         // Create an empty buffer object and store color data
         var color_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

         /*======================= Shaders =======================*/
         
         // vertex shader source code
         var vertCode = 'attribute vec3 coordinates;'+
            'attribute vec3 color;'+
            'varying vec3 vColor;'+
            'void main(void) {' +
               ' gl_Position = vec4(coordinates, 1.0);' +
               'vColor = color;'+
            '}';
            
         // Create a vertex shader object
         var vertShader = gl.createShader(gl.VERTEX_SHADER);

         // Attach vertex shader source code
         gl.shaderSource(vertShader, vertCode);

         // Compile the vertex shader
         gl.compileShader(vertShader);


         // fragment shader source code
         var fragCode = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';
            
         // Create fragment shader object
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);

         // Attach fragment shader source code
         gl.shaderSource(fragShader, fragCode);

         // Compile the fragmentt shader
         gl.compileShader(fragShader);

         // Create a shader program object to
         // store the combined shader program
         var shaderProgram = gl.createProgram();

         // Attach a vertex shader
         gl.attachShader(shaderProgram, vertShader);

         // Attach a fragment shader
         gl.attachShader(shaderProgram, fragShader);

         // Link both the programs
         gl.linkProgram(shaderProgram);

         // Use the combined shader program object
         gl.useProgram(shaderProgram);

         /* ======== Associating shaders to buffer objects =======*/

         // Bind vertex buffer object
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

         // Bind index buffer object
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, Index_Buffer);

         // Get the attribute location
         var coord = gl.getAttribLocation(shaderProgram, "coordinates");

         // point an attribute to the currently bound VBO
         gl.vertexAttribPointer(coord, 3, gl.FLOAT, false, 0, 0);

         // Enable the attribute
         gl.enableVertexAttribArray(coord);

         // bind the color buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         
         // get the attribute location
         var color = gl.getAttribLocation(shaderProgram, "color");
 
         // point attribute to the volor buffer object
         gl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0) ;
 
         // enable the color attribute
         gl.enableVertexAttribArray(color);

         /*============Drawing the Quad====================*/

         // Clear the canvas
         gl.clearColor(0.5, 0.5, 0.5, 0.9);

         // Enable the depth test
         gl.enable(gl.DEPTH_TEST);

         // Clear the color buffer bit
         gl.clear(gl.COLOR_BUFFER_BIT);

         // Set the view port
         gl.viewport(0,0,canvas.width,canvas.height);

         //Draw the triangle
         gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);

      &lt;/script&gt;
      
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/applying_color.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Translation</h1>
<p>So far, we discussed how to draw various shapes and apply colors in them using WebGL. Here, in this chapter, we will take an example to show how to translate a triangle.</p>
<h2>Translation</h2>
<p>Translation is one of the <b>affine transformations</b> provided by WebGL. Using translation, we can move a triangle (any object) on the xyz plane. Suppose we have a triangle [a, b, c] and we want to move the triangle to a position which is 5 units towards the positive X-axis and 3 units towards the positive Y-axis. Then the new vertices would be [a+5, b+3, c+0]. That means, to translate the triangle, we need to add the translation distances, say, tx, ty, tz to each vertex.</p>
<p>Since it is a <b>per-vertex operation,</b> we can carry it in the vertex shader program.</p>
<p>In the vertex shader, along with the attribute, <b>coordinates</b> (that hold the vertex positions), we define a uniform variable that holds the translation distances (x,y,z). Later, we add this uniform variable to the coordinates variable and assign the result to the <b>gl_Position</b> variable.</p>
<p><b>Note</b> &minus; Since vertex shader will be run on each vertex, all the vertices of the triangle will be translated.</p>
<h2>Steps to Translate a Triangle</h2>
<p>The following steps are required to create a WebGL application to draw a triangle and then translate it to a new position.</p>
<p><b>Step 1 &minus; Prepare the Canvas and Get the WebGL Rendering Context</b></p>
<p>In this step, we obtain the WebGL Rendering context object using <b>getContext()</b>.</p>
<p><b>Step 2 &minus; Define the Geometry and Store it in the Buffer Objects</b></p>
<p>Since we are drawing a triangle, we have to pass three vertices of the triangle, and store them in buffers.</p>
<pre class="result notranslate">
var vertices = [ -0.5,0.5,0.0, -0.5,-0.5,0.0, 0.5,-0.5,0.0, ];
</pre>
<p><b>Step 3 &minus; Create and Compile the Shader Programs</b></p>
<p>In this step, you need to write the vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<ul class="list">
<li><p><b>Vertex Shader</b> &minus; In the vertex shader of the program, we define a vector attribute to store 3D coordinates. Along with it, we define a uniform variable to store the translation distances, and finally, we add these two values and assign it to <b>gl_position</b> which holds the final position of the vertices.</p></li>
</ul>
<pre class="result notranslate">
var vertCode =
   'attribute vec4 coordinates;' +
   'uniform vec4 translation;'+
   'void main(void) {' +
      ' gl_Position = coordinates + translation;' +
   '}';
</pre>
<ul class="list">
<li><p><b>Fragment Shader</b> &minus; In the fragment shader, we simply assign the fragment color to the variable gl_FragColor.</p></li>
</ul>
<pre class="result notranslate">
var fragCode = 'void main(void) {' +' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +'}';
</pre>
<p><b>Step 4 &minus; Associate the Shader Programs to the Buffer Objects</b></p>
<p>In this step, we associate the buffer objects with the shader program.</p>
<p><b>Step 5 &minus; Drawing the Required Object</b></p>
<p>Since we are drawing the triangle using indices, we will use the method <b>drawArrays()</b>. To this method, we have to pass the number of vertices /elements to be considered. Since we are drawing a triangle, we will pass 3 as a parameter.</p>
<pre class="result notranslate">
gl.drawArrays(gl.TRIANGLES, 0, 3);
</pre>
<h2>Example – Translate a Triangle</h2>
<p>The following example show how to translate a triangle on xyz plane.</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "300" height = "300" id = "my_Canvas"&gt;&lt;/canvas&gt;
         
      &lt;script&gt;
         
         /*=================Creating a canvas=========================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl'); 
 
         /*===========Defining and storing the geometry==============*/
         var vertices =  [
            -0.5,0.5,0.0, 	
            -0.5,-0.5,0.0, 	
            0.5,-0.5,0.0,   
         ];
            
         //Create an empty buffer object and store vertex data            
         var vertex_buffer = gl.createBuffer(); 
			
         //Create a new buffer
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);   
			
         //bind it to the current buffer			
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);           
         // Pass the buffer data
         gl.bindBuffer(gl.ARRAY_BUFFER, null);  
            
         /*========================Shaders============================*/
            
         //vertex shader source code 
         var vertCode =
            'attribute vec4 coordinates;' + 
            'uniform vec4 translation;'+
            'void main(void) {' +
               '  gl_Position = coordinates + translation;' +
            '}';
            
         //Create a vertex shader program object and compile it              
         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);
            
   
         //fragment shader source code
         var fragCode =
            'void main(void) {' +
               '   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';
               
         //Create a fragment shader program object and compile it            
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);
            
         //Create and use combiened shader program
         var shaderProgram = gl.createProgram();
         gl.attachShader(shaderProgram, vertShader);
         gl.attachShader(shaderProgram, fragShader);
         gl.linkProgram(shaderProgram);
   
         gl.useProgram(shaderProgram); 
   
   
         /* ===========Associating shaders to buffer objects============*/
      
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);    
         var coordinatesVar = gl.getAttribLocation(shaderProgram, "coordinates");
         gl.vertexAttribPointer(coordinatesVar, 3, gl.FLOAT, false, 0, 0);   
         gl.enableVertexAttribArray(coordinatesVar); 
   
         /* ==========translation======================================*/
         var Tx = 0.5, Ty = 0.5, Tz = 0.0;
         var translation = gl.getUniformLocation(shaderProgram, 'translation');
         gl.uniform4f(translation, Tx, Ty, Tz, 0.0);
 
         /*=================Drawing the riangle and transforming it========================*/ 
            
         gl.clearColor(0.5, 0.5, 0.5, 0.9);
         gl.enable(gl.DEPTH_TEST);
   
         gl.clear(gl.COLOR_BUFFER_BIT);
         gl.viewport(0,0,canvas.width,canvas.height);
         gl.drawArrays(gl.TRIANGLES, 0, 3);
               
      &lt;/script&gt;
 
    &lt;/body&gt;
 &lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/translate_a_triangle.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Scaling</h1>
<p>In this chapter, we will take an example to demonstrate how to modify the scale of a triangle using WebGL.</p>
<h2>Scaling</h2>
<p>Scaling is nothing but increasing or decreasing the size of an object. For example, if a triangle has vertices of the size [a,b,c], then the triangle with the vertices [2a, 2b, 2c] will be double its size. Therefore, to scale a triangle, you have to multiply each vertices with the scaling factor. You can also scale a particular vertex.</p>
<p>To scale a triangle, in the vertex shader of the program, we create a uniform matrix and multiply the coordinate values with this matrix. Later, we pass a 4×4 diagonal matrix having the scaling factors of x,y,z coordinates in the diagonal positions (last diagonal position 1).</p>
<h2>Required Steps</h2>
<p>The following steps are required to create a WebGL application to scale a triangle.</p>
<p><b>Step 1 &minus; Prepare the Canvas and Get the WebGL Rendering Context</b></p>
<p>In this step, we obtain the WebGL Rendering context object using <b>getContext()</b>.</p>
<p><b>Step 2 &minus; Define the Geometry and Store it in the Buffer Objects</b></p>
<p>Since we are drawing a triangle, we have to pass three vertices of the triangle, and store them in buffers.</p>
<pre class="result notranslate">
var vertices = [ -0.5,0.5,0.0, -0.5,-0.5,0.0, 0.5,-0.5,0.0, ];
</pre>
<p><b>Step 3 &minus; Create and Compile the Shader Programs</b></p>
<p>In this step, you need to write the vertex shader and fragment shader programs, compile them, and create a combined program by linking these two programs.</p>
<ul class="list">
<li><p><b>Vertex Shader</b> &minus; In the vertex shader of the program, we define a vector attribute to store 3D coordinates. Along with it, we define a uniform matrix to store the scaling factors, and finally, we multiply these two values and assign it to <b>gl_position</b> which holds the final position of the vertices.</p></li>
</ul>
<pre class="result notranslate">
var vertCode =
   'attribute vec4 coordinates;' +
   'uniform mat4 u_xformMatrix;' +
   'void main(void) {' +
      ' gl_Position = u_xformMatrix * coordinates;' +
   '}';
</pre>
<ul class="list">
<li><p><b>Fragment Shader</b> &minus; In the fragment shader, we simply assign the fragment color to the <b>gl_FragColor</b> variable.</p></li>
</ul>
<pre class="result notranslate">
var fragCode = 'void main(void) {' +' gl_FragColor = vec4(1, 0.5, 0.0, 1);' +'}';
</pre>
<p><b>Step 4 &minus; Associate the Shader Programs with the Buffer Objects</b></p>
<p>In this step, we associate the buffer objects with the shader program.</p>
<p><b>Step 5 &minus; Drawing the Required Object</b></p>
<p>Since we are drawing the triangle using indices, we use the <b>drawArrays()</b> method. To this method, we have to pass the number of vertices/elements to be considered. Since we are drawing a triangle, we will pass 3 as a parameter.</p>
<pre class="result notranslate">
gl.drawArrays(gl.TRIANGLES, 0, 3);
</pre>
<h2>Example – Scale a Triangle</h2>
<p>The following example shows how to scale a triangle &minus;</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "300" height = "300" id = "my_Canvas"&gt;&lt;/canvas&gt;
         
      &lt;script&gt;
         
         /*=================Creating a canvas=========================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl'); 
 
         /*===========Defining and storing the geometry==============*/
         var vertices =  [
            -0.5,0.5,0.0, 	
            -0.5,-0.5,0.0, 	
            0.5,-0.5,0.0,   
         ];
            
         //Create an empty buffer object and store vertex data
            
         var vertex_buffer = gl.createBuffer();                                                     
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);                                                
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);           
         gl.bindBuffer(gl.ARRAY_BUFFER, null);  
            
         /*========================Shaders============================*/
           
         //Vertex shader source code
         var vertCode =
            'attribute vec4 coordinates;' + 
            'uniform mat4 u_xformMatrix;' +
            'void main(void) {' +
               '  gl_Position = u_xformMatrix * coordinates;' +
            '}';
               
         //Create a vertex shader program object and compile it                
         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);
            
         //fragment shader source code
         var fragCode =
            'void main(void) {' +
               '   gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);' +
            '}';
            
         //Create a fragment shader program object and compile it 
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);
  
         //Create and use combiened shader program
         var shaderProgram = gl.createProgram();
         gl.attachShader(shaderProgram, vertShader);
         gl.attachShader(shaderProgram, fragShader);
         gl.linkProgram(shaderProgram);
   
         gl.useProgram(shaderProgram); 
          
         /*===================scaling==========================*/
          
         var Sx = 1.0, Sy = 1.5, Sz = 1.0;
         var xformMatrix = new Float32Array([
            Sx,   0.0,  0.0,  0.0,
            0.0,  Sy,   0.0,  0.0,
            0.0,  0.0,  Sz,   0.0,
            0.0,  0.0,  0.0,  1.0  
         ]);
   
         var u_xformMatrix = gl.getUniformLocation(shaderProgram, 'u_xformMatrix');
         gl.uniformMatrix4fv(u_xformMatrix, false, xformMatrix);
      
         /* ===========Associating shaders to buffer objects============*/
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);   
   
         var coordinatesVar = gl.getAttribLocation(shaderProgram, "coordinates"); 
         gl.vertexAttribPointer(coordinatesVar, 3, gl.FLOAT, false, 0, 0);  
         gl.enableVertexAttribArray(coordinatesVar);
   
         /*=================Drawing the Quad========================*/ 
         gl.clearColor(0.5, 0.5, 0.5, 0.9);
         gl.enable(gl.DEPTH_TEST);
   
         gl.clear(gl.COLOR_BUFFER_BIT);
         gl.viewport(0,0,canvas.width,canvas.height);
         gl.drawArrays(gl.TRIANGLES, 0, 3);
			
      &lt;/script&gt;      
      
   &lt;/body&gt;
&lt;/html&gt;      
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/scale_a_triangle.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Rotation</h1>
<p>In this chapter, we will take an example to demonstrate how to rotate a triangle using WebGL.</p>
<h2>Example – Rotate a Triangle</h2>
<p>The following program shows how to rotate a triangle using WebGL.</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
      &lt;canvas width = "400" height = "400" id = "my_Canvas"&gt;&lt;/canvas&gt;
         
      &lt;script&gt;
		
         /*=================Creating a canvas=========================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
            
         /*===========Defining and storing the geometry==============*/
            
         var vertices = [ -1,-1,-1, 1,-1,-1, 1, 1,-1 ];
         var colors = [ 1,1,1, 1,1,1, 1,1,1 ];
         var indices = [ 0,1,2 ];

         //Create and store data into vertex buffer
         var vertex_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         //Create and store data into color buffer
         var color_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

         //Create and store data into index buffer
         var index_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

         /*==========================Shaders=========================*/

         var vertCode = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute vec3 color;'+//the color of the point
            'varying vec3 vColor;'+
				
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vColor = color;'+
            '}';

         var fragCode = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';

         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);
				
         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);

         var shaderProgram = gl.createProgram();
         gl.attachShader(shaderProgram, vertShader);
         gl.attachShader(shaderProgram, fragShader);
         gl.linkProgram(shaderProgram);

         /*===========associating attributes to vertex shader ============*/
    
         var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
         var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
         var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
				
         var position = gl.getAttribLocation(shaderProgram, "position");
         gl.vertexAttribPointer(position, 3, gl.FLOAT, false,0,0) ; //position
         gl.enableVertexAttribArray(position);
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
				
         var color = gl.getAttribLocation(shaderProgram, "color");
         gl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0) ; //color
         gl.enableVertexAttribArray(color);
         gl.useProgram(shaderProgram);

         /*========================= MATRIX ========================= */
            
         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0
            ];
         }
			
         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);
         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         
         //translating z
         view_matrix[14] = view_matrix[14]-6;//zoom

         /*=======================rotation========================*/
         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8]; 
				
            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];
            m[1] = c*m[1]+s*mv0;
            m[5] = c*m[5]+s*mv4;
            m[9] = c*m[9]+s*mv8;
         }

         /*=================Drawing===========================*/

         var time_old = 0;
         var animate = function(time) {
            var dt = time-time_old;
            rotateZ(mov_matrix, dt*0.002);
            time_old = time;
				
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				
            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);
				
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            window.requestAnimationFrame(animate);
         }
			
         animate(0);
			
      &lt;/script&gt;
   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/rotate_a_triangle.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Cube Rotation</h1>
<p>In this chapter, we will take an example to demonstrate how to draw a rotating 3D cube using WebGL.</p>
<h2>Example – Draw a Rotating 3D Cube</h2>
<p>The following program shows how to draw a rotating 3D cube &minus;</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
     &lt;canvas width = "570" height = "570" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*============= Creating a canvas =================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');
         
         /*============ Defining and storing the geometry =========*/

         var vertices = [
            -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1,
            -1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1,
            -1,-1,-1, -1, 1,-1, -1, 1, 1, -1,-1, 1,
            1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1,
            -1,-1,-1, -1,-1, 1, 1,-1, 1, 1,-1,-1,
            -1, 1,-1, -1, 1, 1, 1, 1, 1, 1, 1,-1, 
         ];

         var colors = [
            5,3,7, 5,3,7, 5,3,7, 5,3,7,
            1,1,3, 1,1,3, 1,1,3, 1,1,3,
            0,0,1, 0,0,1, 0,0,1, 0,0,1,
            1,0,0, 1,0,0, 1,0,0, 1,0,0,
            1,1,0, 1,1,0, 1,1,0, 1,1,0,
            0,1,0, 0,1,0, 0,1,0, 0,1,0
         ];

         var indices = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
            8,9,10, 8,10,11, 12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

         // Create and store data into vertex buffer
         var vertex_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Create and store data into color buffer
         var color_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

         // Create and store data into index buffer
         var index_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                                              
         /*=================== Shaders =========================*/
         
         var vertCode = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute vec3 color;'+//the color of the point
            'varying vec3 vColor;'+
			
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vColor = color;'+
            '}';

         var fragCode = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';
         
         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);

         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);

         var shaderProgram = gl.createProgram();
         gl.attachShader(shaderProgram, vertShader);
         gl.attachShader(shaderProgram, fragShader);
         gl.linkProgram(shaderProgram);

         /* ====== Associating attributes to vertex shader =====*/
         var Pmatrix = gl.getUniformLocation(shaderProgram, "Pmatrix");
         var Vmatrix = gl.getUniformLocation(shaderProgram, "Vmatrix");
         var Mmatrix = gl.getUniformLocation(shaderProgram, "Mmatrix");

         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         var position = gl.getAttribLocation(shaderProgram, "position");
         gl.vertexAttribPointer(position, 3, gl.FLOAT, false,0,0) ;
         
         // Position
         gl.enableVertexAttribArray(position);
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         var color = gl.getAttribLocation(shaderProgram, "color");
         gl.vertexAttribPointer(color, 3, gl.FLOAT, false,0,0) ;
         
         // Color
         gl.enableVertexAttribArray(color);
         gl.useProgram(shaderProgram);

         /*==================== MATRIX =====================*/

         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 
            ];
         }
			
         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);

         var mov_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
         var view_matrix = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];

         // translating z
         view_matrix[14] = view_matrix[14]-6;//zoom

         /*==================== Rotation ====================*/

         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];
				
            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];

            m[1]=c*m[1]+s*mv0;
            m[5]=c*m[5]+s*mv4;
            m[9]=c*m[9]+s*mv8;
         }

         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];
				
            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
         }

         function rotateY(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];
				
            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
         }

         /*================= Drawing ===========================*/
         var time_old = 0;
			
         var animate = function(time) {

            var dt = time-time_old;
            rotateZ(mov_matrix, dt*0.005);//time
            rotateY(mov_matrix, dt*0.002);
            rotateX(mov_matrix, dt*0.003);
            time_old = time;

            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);

            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.uniformMatrix4fv(Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(Mmatrix, false, mov_matrix);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
				
            window.requestAnimationFrame(animate);
         }
         animate(0);
			
      &lt;/script&gt;

   &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/rotating_3d_cube.htm" height="320px" width="600px"></iframe>
<h1>WebGL - Interactive Cube</h1>
<p>In this chapter, we will take an example to demonstrate how to draw a 3D cube that can be rotated using mouse controls.</p>
<h2>Example – Draw an Interactive Cube</h2>
<p>The following program shows how to rotate a cube using mouse controls &minus;</p>
<pre class="prettyprint notranslate tryit">
&lt;!doctype html&gt;
&lt;html&gt;
   &lt;body&gt;
     &lt;canvas width = "570" height = "570" id = "my_Canvas"&gt;&lt;/canvas&gt;

      &lt;script&gt;

         /*============= Creating a canvas ======================*/
         var canvas = document.getElementById('my_Canvas');
         gl = canvas.getContext('experimental-webgl');

         /*========== Defining and storing the geometry ==========*/

         var vertices = [
            -1,-1,-1, 1,-1,-1, 1, 1,-1, -1, 1,-1,
            -1,-1, 1, 1,-1, 1, 1, 1, 1, -1, 1, 1,
            -1,-1,-1, -1, 1,-1, -1, 1, 1, -1,-1, 1,
            1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1,
            -1,-1,-1, -1,-1, 1, 1,-1, 1, 1,-1,-1,
            -1, 1,-1, -1, 1, 1, 1, 1, 1, 1, 1,-1, 
         ];

         var colors = [
            5,3,7, 5,3,7, 5,3,7, 5,3,7,
            1,1,3, 1,1,3, 1,1,3, 1,1,3,
            0,0,1, 0,0,1, 0,0,1, 0,0,1,
            1,0,0, 1,0,0, 1,0,0, 1,0,0,
            1,1,0, 1,1,0, 1,1,0, 1,1,0,
            0,1,0, 0,1,0, 0,1,0, 0,1,0 
         ];

         var indices = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7,
            8,9,10, 8,10,11, 12,13,14, 12,14,15,
            16,17,18, 16,18,19, 20,21,22, 20,22,23 
         ];

         // Create and store data into vertex buffer
         var vertex_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

         // Create and store data into color buffer
         var color_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

         // Create and store data into index buffer
         var index_buffer = gl.createBuffer ();
         gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
         gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                                              
         /*=================== SHADERS =================== */

         var vertCode = 'attribute vec3 position;'+
            'uniform mat4 Pmatrix;'+
            'uniform mat4 Vmatrix;'+
            'uniform mat4 Mmatrix;'+
            'attribute vec3 color;'+//the color of the point
            'varying vec3 vColor;'+
            'void main(void) { '+//pre-built function
               'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
               'vColor = color;'+
            '}';

         var fragCode = 'precision mediump float;'+
            'varying vec3 vColor;'+
            'void main(void) {'+
               'gl_FragColor = vec4(vColor, 1.);'+
            '}';

         var vertShader = gl.createShader(gl.VERTEX_SHADER);
         gl.shaderSource(vertShader, vertCode);
         gl.compileShader(vertShader);

         var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
         gl.shaderSource(fragShader, fragCode);
         gl.compileShader(fragShader);
			
         var shaderprogram = gl.createProgram();
         gl.attachShader(shaderprogram, vertShader);
         gl.attachShader(shaderprogram, fragShader);
         gl.linkProgram(shaderprogram);
         
         /*======== Associating attributes to vertex shader =====*/
         var _Pmatrix = gl.getUniformLocation(shaderprogram, "Pmatrix");
         var _Vmatrix = gl.getUniformLocation(shaderprogram, "Vmatrix");
         var _Mmatrix = gl.getUniformLocation(shaderprogram, "Mmatrix");

         gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
         var _position = gl.getAttribLocation(shaderprogram, "position");
         gl.vertexAttribPointer(_position, 3, gl.FLOAT, false,0,0);
         gl.enableVertexAttribArray(_position);

         gl.bindBuffer(gl.ARRAY_BUFFER, color_buffer);
         var _color = gl.getAttribLocation(shaderprogram, "color");
         gl.vertexAttribPointer(_color, 3, gl.FLOAT, false,0,0) ;
         gl.enableVertexAttribArray(_color);
         gl.useProgram(shaderprogram);

         /*==================== MATRIX ====================== */
         
         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 
			   ];
         }
         
         var proj_matrix = get_projection(40, canvas.width/canvas.height, 1, 100);
         var mo_matrix = [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];
         var view_matrix = [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1 ];

         view_matrix[14] = view_matrix[14]-6;

         /*================= Mouse events ======================*/

         var AMORTIZATION = 0.95;
         var drag = false;
         var old_x, old_y;
         var dX = 0, dY = 0;
			
         var mouseDown = function(e) {
            drag = true;
            old_x = e.pageX, old_y = e.pageY;
            e.preventDefault();
            return false;
         };
         
         var mouseUp = function(e){
            drag = false;
         };
         
         var mouseMove = function(e) {
            if (!drag) return false;
            dX = (e.pageX-old_x)*2*Math.PI/canvas.width,
            dY = (e.pageY-old_y)*2*Math.PI/canvas.height;
            THETA+= dX;
            PHI+=dY;
            old_x = e.pageX, old_y = e.pageY;
            e.preventDefault();
         };
         
         canvas.addEventListener("mousedown", mouseDown, false);
         canvas.addEventListener("mouseup", mouseUp, false);
         canvas.addEventListener("mouseout", mouseUp, false);
         canvas.addEventListener("mousemove", mouseMove, false);

         /*=========================rotation================*/

         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];
				
            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
         }

         function rotateY(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];
				
            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
         }

         /*=================== Drawing =================== */

         var THETA = 0,
         PHI = 0;
         var time_old = 0;
				
         var animate = function(time) {
            var dt = time-time_old;
					
            if (!drag) {
               dX *= AMORTIZATION, dY*=AMORTIZATION;
               THETA+=dX, PHI+=dY;
            }
               
            //set model matrix to I4
					
            mo_matrix[0] = 1, mo_matrix[1] = 0, mo_matrix[2] = 0,
            mo_matrix[3] = 0,
					
            mo_matrix[4] = 0, mo_matrix[5] = 1, mo_matrix[6] = 0,
            mo_matrix[7] = 0,
					
            mo_matrix[8] = 0, mo_matrix[9] = 0, mo_matrix[10] = 1,
            mo_matrix[11] = 0,
					
            mo_matrix[12] = 0, mo_matrix[13] = 0, mo_matrix[14] = 0,
            mo_matrix[15] = 1;

            rotateY(mo_matrix, THETA);
            rotateX(mo_matrix, PHI);
					
            time_old = time; 
            gl.enable(gl.DEPTH_TEST);
					
            // gl.depthFunc(gl.LEQUAL);
					
            gl.clearColor(0.5, 0.5, 0.5, 0.9);
            gl.clearDepth(1.0);
            gl.viewport(0.0, 0.0, canvas.width, canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.uniformMatrix4fv(_Pmatrix, false, proj_matrix);
            gl.uniformMatrix4fv(_Vmatrix, false, view_matrix);
            gl.uniformMatrix4fv(_Mmatrix, false, mo_matrix);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
					
            window.requestAnimationFrame(animate);
         }
			
         animate(0);
				
      &lt;/script&gt;
		
   &lt;/body&gt;
&lt;/html&gt; 
</pre>
<p>It will produce the following result &minus;</p>
<iframe onload="resizeFrame(this)" class="result" src="https://www.tutorialspoint.com/webgl/src/interactive_cube.htm" height="320px" width="600px"></iframe>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/webgl/webgl_interactive_cube.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="https://www.tutorialspoint.com/cgi-bin/printpage.cgi" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/webgl/webgl_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/webgl/webgl_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/webgl/webgl_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/webgl/webgl_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/webgl/webgl_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/webgl/webgl_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/webgl/webgl_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="https://www.tutorialspoint.com/index.htm" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="https://www.tutorialspoint.com/scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="https://www.tutorialspoint.com/about/tutorials_writing.htm">Write for us</a></li>
         <li><a href="https://www.tutorialspoint.com/about/faq.htm">FAQ's</a></li>
         <li><a href="https://www.tutorialspoint.com/about/about_helping.htm">Helping</a></li>
         <li><a href="https://www.tutorialspoint.com/about/contact_us.htm">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/custom-min.js?v=5"></script>
<script src="https://www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/jquery.colorbox-min.js"></script>
<script type="text/javascript">
   var tryit = new $.TryIt('https://www.tutorialspoint.com/webgl/try_webgl.php');
   tryit.compile();
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "WebGL Quick Guide",
    "name": "WebGL Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/webgl/webgl_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/webgl/images/cpu_and_gpu.jpg",
        "width": 600,
        "height": 323
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "July 23 2017 03:34:51.",
    "dateModified": "July 23 2017 03:34:51.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": "A few years back, Java applications \u2212 as a combination of applets and JOGL \u2212 were used to process 3D graphics on the Web by addressing the GPU (Graphical Processing Unit). As applets require a JVM to run, it became difficult to rely on Java applets. A..."
}
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Webgl",
                "@id": "https://www.tutorialspoint.com/webgl"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": "WebGL - Quick Guide"
            }
        }
    ]
}
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/webgl/webgl_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:14:56 GMT -->
</html>
