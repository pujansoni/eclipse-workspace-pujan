<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:20:11 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>Digital Circuits Quick Guide</title>
<meta name="description" content="Digital Circuits Quick Guide - Learn Digital Circuits in simple and easy steps starting from basic to advanced concepts with examples including Number Systems, Base Conversions, Binary Numbers Representation, Signed Binary Arithmetic, Codes, Error Detection and Correction Codes, Boolean Algebra, Canonical and Standard Forms, K Map Method, Quine-McCluskey Tabular Method, Logic Gates, Two-Level Logic Realization, Combinational Circuits, Arithmetic Circuits, Decoders, Encoders, Multiplexers, De-Multiplexers, Programmable Logic Devices, Threshold Logic, Sequential Circuits, Latches, Flip-Flops, Conversion of Flip-Flops, Shift Registers, Application of Shift Registers, Counters, Finite State Machines, Algorithmic State Machine Charts." />
<meta name="keywords" content="Digital Circuits, Tutorial, Number Systems, Base Conversions, Binary Numbers Representation, Signed Binary Arithmetic, Codes, Error Detection and Correction Codes, Boolean Algebra, Canonical and Standard Forms, K Map Method, Quine-McCluskey Tabular Method, Logic Gates, Two-Level Logic Realization, Combinational Circuits, Arithmetic Circuits, Decoders, Encoders, Multiplexers, De-Multiplexers, Programmable Logic Devices, Threshold Logic, Sequential Circuits, Latches, Flip-Flops, Conversion of Flip-Flops, Shift Registers, Application of Shift Registers, Counters, Finite State Machines, Algorithmic State Machine Charts." />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: { inlineMath: [["$","$"],["\\(","\\)"]] },
"HTML-CSS": {
linebreaks: { automatic: true, width: "container" } 
} 
});
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
<base  />
<link rel="shortcut icon" href="https://www.tutorialspoint.com/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="https://www.tutorialspoint.com/theme/css/style-min.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #01395a url(https://www.tutorialspoint.com/images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #01395a !important;}
.submenu-item{ border-bottom: 2px solid #01395a !important; border-top: 2px solid #01395a !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="https://www.tutorialspoint.com/images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="https://www.tutorialspoint.com/index.htm" title="tutorialspoint">
      <img alt="tutorialspoint" src="https://www.tutorialspoint.com/digital_circuits/images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="https://www.tutorialspoint.com/about/about_careers.htm" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="https://www.tutorialspoint.com/whiteboard.htm"><img src="https://www.tutorialspoint.com/theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="https://www.tutorialspoint.com/netmeeting.php"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="https://www.tutorialspoint.com/online_dev_tools.htm"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="https://www.tutorialspoint.com/articles/index.php"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="https://www.tutorialspoint.com/index.htm"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/codingground.htm"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/tutor_connect/index.php"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<div class="mini-logo">
<img src="https://www.tutorialspoint.com/digital_circuits/images/digital-circuits-mini-logo.jpg" alt="Digital Circuits Tutorial" />
</div>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Digital Circuits Tutorial</li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/index.htm">Home</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_number_systems.htm">Number Systems</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_base_conversions.htm">Base Conversions</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_binary_numbers_representation.htm">Binary Numbers Representation</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_signed_binary_arithmetic.htm">Signed Binary Arithmetic</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_codes.htm">Codes</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_error_detection_correction_codes.htm">Error Detection &amp; Correction Codes</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_boolean_algebra.htm">Boolean Algebra</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_canonical_standard_forms.htm">Canonical and Standard Forms</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_k_map_method.htm">K-Map Method</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_quine_mccluskey_tabular_method.htm">Quine-McCluskey Tabular Method</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_logic_gates.htm">Logic Gates</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_two_level_logic_realization.htm">Two-Level Logic Realization</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_combinational_circuits.htm">Combinational Circuits</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_arithmetic_circuits.htm">Arithmetic Circuits</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_decoders.htm">Decoders</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_encoders.htm">Encoders</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_multiplexers.htm">Multiplexers</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_demultiplexers.htm">De-Multiplexers</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_programmable_logic_devices.htm">Programmable Logic Devices</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_threshold_logic.htm">Threshold Logic</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_sequential_circuits.htm">Sequential Circuits</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_latches.htm">Latches</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_flip_flops.htm">Flip-Flops</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_conversion_of_flip_flops.htm">Conversion of Flip-Flops</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_shift_registers.htm">Shift Registers</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_application_of_shift_registers.htm">Application of Shift Registers</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_counters.htm">Counters</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_finite_state_machines.htm">Finite State Machines</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_algorithmic_state_machine_charts.htm">Algorithmic State Machine Charts</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Digital Circuits Resources</li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm">Digital Circuits - Quick Guide</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_useful_resources.htm">Digital Circuits - Useful Resources</a></li>
<li><a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_discussion.htm">Digital Circuits - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="https://www.tutorialspoint.com/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>Digital Circuits - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_algorithmic_state_machine_charts.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>Digital Circuits - Number Systems</h1>
<p>If base or radix of a number system is ‘r’, then the numbers present in that number system are ranging from zero to r-1. The total numbers present in that number system is ‘r’. So, we will get various number systems, by choosing the values of radix as greater than or equal to two.</p>
<p>In this chapter, let us discuss about the <b>popular number systems</b> and how to represent a number in the respective number system. The following number systems are the most commonly used.</p>
<ul class="list">
<li>Decimal Number system</li>
<li>Binary Number system</li>
<li>Octal Number system</li>
<li>Hexadecimal Number system</li>
</ul>
<h2>Decimal Number System</h2>
<p>The <b>base</b> or radix of Decimal number system is <b>10</b>. So, the numbers ranging from 0 to 9 are used in this number system. The part of the number that lies to the left of the <b>decimal point</b> is known as integer part. Similarly, the part of the number that lies to the right of the decimal point is known as fractional part.</p>
<p>In this number system, the successive positions to the left of the decimal point having weights of 10<sup>0</sup>, 10<sup>1</sup>, 10<sup>2</sup>, 10<sup>3</sup> and so on. Similarly, the successive positions to the right of the decimal point having weights of 10<sup>-1</sup>, 10<sup>-2</sup>, 10<sup>-3</sup> and so on. That means, each position has specific weight, which is <b>power of base 10</b></p>
<h3>Example</h3>
<p>Consider the <b>decimal number 1358.246</b>. Integer part of this number is 1358 and fractional part of this number is 0.246. The digits 8, 5, 3 and 1 have weights of 100, 101, 10<sup>2</sup> and 10<sup>3</sup> respectively. Similarly, the digits 2, 4 and 6 have weights of 10<sup>-1</sup>, 10<sup>-2</sup> and 10<sup>-3</sup> respectively.</p>
<p><b>Mathematically</b>, we can write it as</p>
<p>1358.246 = (1 × 10<sup>3</sup>) + (3 × 10<sup>2</sup>) + (5 × 10<sup>1</sup>) + (8 × 10<sup>0</sup>) + (2 × 10<sup>-1</sup>) +</p> 
<p style="padding-left:16.5%">(4 × 10<sup>-2</sup>) + (6 × 10<sup>-3</sup>)</p>
<p>After simplifying the right hand side terms, we will get the decimal number, which is on left hand side.</p>
<h2>Binary Number System</h2>
<p>All digital circuits and systems use this binary number system. The <b>base</b> or radix of this number system is <b>2</b>. So, the numbers 0 and 1 are used in this number system.</p>
<p>The part of the number, which lies to the left of the <b>binary point</b> is known as integer part. Similarly, the part of the number, which lies to the right of the binary point is known as fractional part.</p>
<p>In this number system, the successive positions to the left of the binary point having weights of 2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, 2<sup>3</sup> and so on. Similarly, the successive positions to the right of the binary point having weights of 2<sup>-1</sup>, 2<sup>-2</sup>, 2<sup>-3</sup> and so on. That means, each position has specific weight, which is <b>power of base 2</b>.</p>
<h3>Example</h3>
<p>Consider the <b>binary number 1101.011</b>. Integer part of this number is 1101 and fractional part of this number is 0.011. The digits 1, 0, 1 and 1 of integer part have weights of 2<sup>0</sup>, 2<sup>1</sup>, 2<sup>2</sup>, 2<sup>3</sup> respectively. Similarly, the digits 0, 1 and 1 of fractional part have weights of 2<sup>-1</sup>, 2<sup>-2</sup>, 2<sup>-3</sup> respectively.</p>
<p><b>Mathematically</b>, we can write it as</p>
<p>1101.011 = (1 × 2<sup>3</sup>) + (1 × 2<sup>2</sup>) + (0 × 2<sup>1</sup>) + (1 × 2<sup>0</sup>) + (0 × 2<sup>-1</sup>) + </p>
<p style="padding-left:16.5%">(1 × 2<sup>-2</sup>) + (1 × 2<sup>-3</sup>)</p>
<p>After simplifying the right hand side terms, we will get a decimal number, which is an equivalent of binary number on left hand side.</p>
<h2>Octal Number System</h2>
<p>The <b>base</b> or radix of octal number system is <b>8</b>. So, the numbers ranging from 0 to 7 are used in this number system. The part of the number that lies to the left of the <b>octal point</b> is known as integer part. Similarly, the part of the number that lies to the right of the octal point is known as fractional part.</p>
<p>In this number system, the successive positions to the left of the octal point having weights of 8<sup>0</sup>, 8<sup>1</sup>, 8<sup>2</sup>, 8<sup>3</sup> and so on. Similarly, the successive positions to the right of the octal point having weights of 8<sup>-1</sup>, 8<sup>-2</sup>, 8<sup>-3</sup> and so on. That means, each position has specific weight, which is <b>power of base 8</b>.</p>
<h3>Example</h3>
<p>Consider the <b>octal number 1457.236</b>. Integer part of this number is 1457 and fractional part of this number is 0.236. The digits 7, 5, 4 and 1 have weights of 8<sup>0</sup>, 8<sup>1</sup>, 8<sup>2</sup> and 8<sup>3</sup> respectively. Similarly, the digits 2, 3 and 6 have weights of 8<sup>-1</sup>, 8<sup>-2</sup>, 8<sup>-3</sup> respectively.</p>
<p><b>Mathematically</b>, we can write it as</p>
<p>1457.236 = (1 × 8<sup>3</sup>) + (4 × 8<sup>2</sup>) + (5 × 8<sup>1</sup>) + (7 × 8<sup>0</sup>) + (2 × 8<sup>-1</sup>) +</p>
<p style="padding-left:16%">(3 × 8<sup>-2</sup>) + (6 × 8<sup>-3</sup>)</p>
<p>After simplifying the right hand side terms, we will get a decimal number, which is an equivalent of octal number on left hand side.</p>
<h2>Hexadecimal Number System</h2>
<p>The <b>base</b> or radix of Hexa-decimal number system is <b>16</b>. So, the numbers ranging from 0 to 9 and the letters from A to F are used in this number system. The decimal equivalent of Hexa-decimal digits from A to F are 10 to 15.</p>
<p>The part of the number, which lies to the left of the <b>hexadecimal point</b> is known as integer part. Similarly, the part of the number, which lies to the right of the Hexa-decimal point is known as fractional part.</p>
<p>In this number system, the successive positions to the left of the Hexa-decimal point having weights of 16<sup>0</sup>, 16<sup>1</sup>, 16<sup>2</sup>, 16<sup>3</sup> and so on. Similarly, the successive positions to the right of the Hexa-decimal point having weights of 16<sup>-1</sup>, 16<sup>-2</sup>, 16<sup>-3</sup> and so on. That means, each position has specific weight, which is <b>power of base 16</b>.</p>
<h3>Example</h3>
<p>Consider the <b>Hexa-decimal number 1A05.2C4</b>. Integer part of this number is 1A05 and fractional part of this number is 0.2C4. The digits 5, 0, A and 1 have weights of 16<sup>0</sup>, 16<sup>1</sup>, 16<sup>2</sup> and 16<sup>3</sup> respectively. Similarly, the digits 2, C and 4 have weights of 16<sup>-1</sup>, 16<sup>-2</sup> and 16<sup>-3</sup> respectively.</p>
<p><b>Mathematically</b>, we can write it as</p>
<p>1A05.2C4 = (1 × 16<sup>3</sup>) + (10 × 16<sup>2</sup>) + (0 × 16<sup>1</sup>) + (5 × 16<sup>0</sup>) + (2 × 16<sup>-1</sup>) + (12 × 16<sup>-2</sup>) + (4 × 16<sup>-3</sup>)</p>
<p>After simplifying the right hand side terms, we will get a decimal number, which is an equivalent of Hexa-decimal number on left hand side.</p>
<h1>Digital Circuits - Base Conversions</h1>
<p>In previous chapter, we have seen the four prominent number systems. In this chapter, let us convert the numbers from one number system to the other in order to find the equivalent value.</p>
<h2>Decimal Number to other Bases Conversion</h2>
<p>If the decimal number contains both integer part and fractional part, then convert both the parts of decimal number into other base individually. Follow these steps for converting the decimal number into its equivalent number of any base ‘r’.</p>
<ul class="list">
<li><p>Do <b>division</b> of integer part of decimal number and <b>successive quotients</b> with base ‘r’ and note down the remainders till the quotient is zero. Consider the remainders in reverse order to get the integer part of equivalent number of base ‘r’. That means, first and last remainders denote the least significant digit and most significant digit respectively.</p></li>
<li><p>Do <b>multiplication</b> of fractional part of decimal number and <b>successive fractions</b> with base ‘r’ and note down the carry till the result is zero or the desired number of equivalent digits is obtained. Consider the normal sequence of carry in order to get the fractional part of equivalent number of base ‘r’.</p></li>
</ul>
<h3>Decimal to Binary Conversion</h3>
<p>The following two types of operations take place, while converting decimal number into its equivalent binary number.</p>
<ul class="list">
<li>Division of integer part and successive quotients with base 2.</li>
<li>Multiplication of fractional part and successive fractions with base 2.</li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>decimal number 58.25</b>. Here, the integer part is 58 and fractional part is 0.25.</p>
<p><b>Step 1</b> &minus; Division of 58 and successive quotients with base 2.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Quotient</th>
<th style="text-align:center">Remainder</th>
</tr>
<tr>
<td>58/2</td>
<td>29</td>
<td><b>0 (LSB)</b></td>
</tr>
<tr>
<td>29/2</td>
<td>14</td>
<td><b>1</b></td>
</tr>
<tr>
<td>14/2</td>
<td>7</td>
<td><b>0</b></td>
</tr>
<tr>
<td>7/2</td>
<td>3</td>
<td><b>1</b></td>
</tr>
<tr>
<td>3/2</td>
<td>1</td>
<td><b>1</b></td>
</tr>
<tr>
<td>1/2</td>
<td>0</td>
<td><b>1(MSB)</b></td>
</tr>
</table>
<p style="text-align:center">&rArr;(58)<sub>10</sub> = (111010)<sub>2</sub>.</p>
<p>Therefore, the <b>integer part</b> of equivalent binary number is <b>111010</b>.</p>
<p><b>Step 2</b> &minus; Multiplication of 0.25 and successive fractions with base 2.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Result</th>
<th style="text-align:center">Carry</th>
</tr>
<tr>
<td>0.25 x 2</td>
<td>0.5</td>
<td>0</td>
</tr>
<tr>
<td>0.5 x 2</td>
<td>1.0</td>
<td>1</td>
</tr>
<tr>
<td>-</td>
<td>0.0</td>
<td>-</td>
</tr>
</table>
<p style="text-align:center"> &rArr;(.25)<sub>10</sub> = (.01)<sub>2</sub></p>
<p>Therefore, the <b>fractional part</b> of equivalent binary number is <b>.01</b></p>
<p style="text-align:center"> &rArr;(58.25)<sub>10</sub> = (111010.01)<sub>2</sub></p>
<p>Therefore, the <b>binary equivalent</b> of decimal number 58.25 is 111010.01.</p>
<h3>Decimal to Octal Conversion</h3>
<p>The following two types of operations take place, while converting decimal number into its equivalent octal number.</p>
<ul class="list">
<li><p>Division of integer part and successive quotients with base 8.</p></li>
<li><p>Multiplication of fractional part and successive fractions with base 8.</p></li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>decimal number 58.25</b>. Here, the integer part is 58 and fractional part is 0.25.</p>
<p><b>Step 1</b> &minus; Division of 58 and successive quotients with base 8.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Quotient</th>
<th style="text-align:center">Remainder</th>
</tr>
<tr>
<td>58/8</td>
<td>7</td>
<td><b>2</b></td>
</tr>
<tr>
<td>7/8</td>
<td>0</td>
<td><b>7</b></td>
</tr>
</table>
<p style="text-align:center"> &rArr;(58)<sub>10</sub> = (72)<sub>8</sub></p>
<p>Therefore, the <b>integer part</b> of equivalent octal number is <b>72</b>.</p>
<p><b>Step 2</b> &minus; Multiplication of 0.25 and successive fractions with base 8.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Result</th>
<th style="text-align:center">Carry</th>
</tr>
<tr>
<td>0.25 x 8</td>
<td>2.00</td>
<td>2</td>
</tr>
<tr>
<td>-</td>
<td>0.00</td>
<td>-</td>
</tr>
</table>
<p style="text-align:center">&rArr; (.25)<sub>10</sub> = (.2)<sub>8</sub></p>
<p>Therefore, the <b>fractional part</b> of equivalent octal number is .2</p>
<p style="text-align:center">&rArr; (58.25)<sub>10</sub> = (72.2)<sub>8</sub></p>
<p>Therefore, the <b>octal equivalent</b> of decimal number 58.25 is 72.2.</p>
<h3>Decimal to Hexa-Decimal Conversion</h3>
<p>The following two types of operations take place, while converting decimal number into its equivalent hexa-decimal number.</p>
<ul class="list">
<li>Division of integer part and successive quotients with base 16.</li>
<li>Multiplication of fractional part and successive fractions with base 16.</li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>decimal number 58.25</b>. Here, the integer part is 58 and decimal part is 0.25.</p>
<p><b>Step 1</b> &minus; Division of 58 and successive quotients with base 16.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Quotient</th>
<th style="text-align:center">Remainder</th>
</tr>
<tr>
<td>58/16</td>
<td>3</td>
<td>10=A</td>
</tr>
<tr>
<td>3/16</td>
<td>0</td>
<td>3</td>
</tr>
</table>
<p style="text-align:center">&rArr; (58)<sub>10</sub> = (3A)<sub>16</sub></p>
<p>Therefore, the <b>integer part</b> of equivalent Hexa-decimal number is 3A.</p>
<p><b>Step 2</b> &minus; Multiplication of 0.25 and successive fractions with base 16.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Operation</th>
<th style="text-align:center">Result</th>
<th style="text-align:center">Carry</th>
</tr>
<tr>
<td>0.25 x 16</td>
<td>4.00</td>
<td>4</td>
</tr>
<tr>
<td>-</td>
<td>0.00</td>
<td>-</td>
</tr>
</table>
<p style="text-align:center"> &rArr;(.25)<sub>10</sub> = (.4)<sub>6</sub> </p>
<p>Therefore, the <b>fractional part</b> of equivalent Hexa-decimal number is .4.</p>
<p style="text-align:center"> <b>&rArr;(58.25)<sub>10</sub> = (3A.4)<sub>16</sub></b></p>
<p>Therefore, the <b>Hexa-decimal equivalent</b> of decimal number 58.25 is 3A.4.</p>
<h2>Binary Number to other Bases Conversion</h2>
<p>The process of converting a number from binary to decimal is different to the process of converting a binary number to other bases. Now, let us discuss about the conversion of a binary number to decimal, octal and Hexa-decimal number systems one by one.</p>
<h3>Binary to Decimal Conversion</h3>
<p>For converting a binary number into its equivalent decimal number, first multiply the bits of binary number with the respective positional weights and then add all those products.</p>
<p><b>Example</b></p>
<p>Consider the <b>binary number 1101.11</b>.</p>
<p><b>Mathematically</b>, we can write it as</p>
<p style="padding-left:2%">(1101.11)<sub>2</sub> = (1 × 2<sup>3</sup>) + (1 × 2<sup>2</sup>) + (0 × 2<sup>1</sup>) + (1 × 2<sup>0</sup>) + (1 × 2<sup>-1</sup>) + </p> 
<p style="padding-left:19.5%">(1 × 2<sup>-2</sup>)</p>
<p>&rArr; (1101.11)<sub>2</sub> = 8 + 4 + 0 + 1 + 0.5 + 0.25 = 13.75</p>
<p>&rArr; (1101.11)<sub>2</sub> = (13.75)<sub>10</sub></p>
<p>Therefore, the <b>decimal equivalent</b> of binary number 1101.11 is 13.75.</p>
<h3>Binary to Octal Conversion</h3>
<p>We know that the bases of binary and octal number systems are 2 and 8 respectively. Three bits of binary number is equivalent to one octal digit, since 2<sup>3</sup> = 8.</p>
<p>Follow these two steps for converting a binary number into its equivalent octal number.</p>
<ul class="list">
<li><p>Start from the binary point and make the groups of 3 bits on both sides of binary point. If one or two bits are less while making the group of 3 bits, then include required number of zeros on extreme sides.</p></li>
<li><p>Write the octal digits corresponding to each group of 3 bits.</p></li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>binary number 101110.01101</b>.</p>
<p><b>Step 1</b> &minus; Make the groups of 3 bits on both sides of binary point.</p>
<p style="text-align:center">101 110.011 01</p>
<p>Here, on right side of binary point, the last group is having only 2 bits. So, include one zero on extreme side in order to make it as group of 3 bits.</p>
<p style="text-align:center">&rArr; 101 110.011 010 </p>
<p><b>Step 2</b> &minus; Write the octal digits corresponding to each group of 3 bits.</p>
<p style="text-align:center">&rArr; (101 110.011 010)<sub>2</sub> = (56.32)<sub>8</sub></p>
<p>Therefore, the <b>octal equivalent</b> of binary number 101110.01101 is 56.32.</p>
<h3>Binary to Hexa-Decimal Conversion</h3>
<p>We know that the bases of binary and Hexa-decimal number systems are 2 and 16 respectively. Four bits of binary number is equivalent to one Hexa-decimal digit, since 2<sup>4</sup> = 16.</p>
<p>Follow these two steps for converting a binary number into its equivalent Hexa-decimal number.</p>
<ul class="list">
<li><p>Start from the binary point and make the groups of 4 bits on both sides of binary point. If some bits are less while making the group of 4 bits, then include required number of zeros on extreme sides.</p></li>
<li><p>Write the Hexa-decimal digits corresponding to each group of 4 bits.</p></li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>binary number 101110.01101</b></p>
<p><b>Step 1</b> &minus; Make the groups of 4 bits on both sides of binary point.</p>
<p style="text-align:center">10 1110.0110 1</p>
<p>Here, the first group is having only 2 bits. So, include two zeros on extreme side in order to make it as group of 4 bits. Similarly, include three zeros on extreme side in order to make the last group also as group of 4 bits.</p>
<p style="text-align:center"> &rArr; 0010 1110.0110 1000</p>
<p><b>Step 2</b> &minus; Write the Hexa-decimal digits corresponding to each group of 4 bits.</p>
<p style="text-align:center"> &rArr; (0010 1110.0110 1000)<sub>2</sub> = (2E.68)<sub>16</sub></p>
<p>Therefore, the <b>Hexa-decimal equivalent</b> of binary number 101110.01101 is (2E.68).</p>
<h2>Octal Number to other Bases Conversion</h2>
<p>The process of converting a number from octal to decimal is different to the process of converting an octal number to other bases. Now, let us discuss about the conversion of an octal number to decimal, binary and Hexa-decimal number systems one by one. </p>
<h3>Octal to Decimal Conversion</h3>
<p>For converting an octal number into its equivalent decimal number, first multiply the digits of octal number with the respective positional weights and then add all those products.</p>
<p><b>Example</b></p>
<p>Consider the <b>octal number 145.23</b>.</p>
<p><b>Mathematically</b>, we can write it as</p>
<p style="padding-left:7.5%">(145.23)<sub>8</sub> = (1 × 8<sup>2</sup>) + (4 × 8<sup>1</sup>) + (5 × 8<sup>0</sup>) + (2 × 8<sup>-1</sup>) + (3 × 8<sup>-2</sup>)</p>
<p style="padding-left:5%">&rArr; (145.23)<sub>8</sub> = 64 + 32 + 5 + 0.25 + 0.05 = 101.3</p>
<p style="padding-left:5%">&rArr; (145.23)<sub>8</sub> = (101.3)<sub>10</sub></p>
<p>Therefore, the <b>decimal equivalent</b> of octal number 145.23 is 101.3.</p>
<h3>Octal to Binary Conversion</h3>
<p>The process of converting an octal number to an equivalent binary number is just opposite to that of binary to octal conversion. By representing each octal digit with 3 bits, we will get the equivalent binary number.</p>
<p><b>Example</b></p>
<p>Consider the <b>octal number 145.23</b>.</p>
<p>Represent each octal digit with 3 bits.</p>
<p style="text-align:center">(145.23)<sub>8</sub> = (001 100 101.010 011)<sub>2</sub></p>
<p>The value doesn’t change by removing the zeros, which are on the extreme side.</p>
<p style="text-align:center">&rArr; (145.23)<sub>8</sub> = (1100101.010011)<sub>2</sub></p>
<p>Therefore, the <b>binary equivalent</b> of octal number 145.23 is 1100101.010011.</p>
<h3>Octal to Hexa-Decimal Conversion</h3>
<p>Follow these two steps for converting an octal number into its equivalent Hexa-decimal number.</p>
<ul class="list">
<li>Convert octal number into its equivalent binary number.</li>
<li>Convert the above binary number into its equivalent Hexa-decimal number.</li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>octal number 145.23</b></p>
<p>In previous example, we got the binary equivalent of octal number 145.23 as 1100101.010011.</p>
<p>By following the procedure of binary to Hexa-decimal conversion, we will get</p>
<p style="text-align:center">(1100101.010011)<sub>2</sub> = (65.4C)16</p>
<p style="text-align:center"> &rArr;(145.23)<sub>8</sub> = (65.4C)<sub>16</sub></p>
<p>Therefore, the <b>Hexa-decimal equivalent</b> of octal number 145.23 is 65.4<i>C</i>.</p>
<h2>Hexa-Decimal Number to other Bases Conversion</h2>
<p>The process of converting a number from Hexa-decimal to decimal is different to the process of converting Hexa-decimal number into other bases. Now, let us discuss about the conversion of Hexa-decimal number to decimal, binary and octal number systems one by one.</p>
<h3>Hexa-Decimal to Decimal Conversion</h3>
<p>For converting Hexa-decimal number into its equivalent decimal number, first multiply the digits of Hexa-decimal number with the respective positional weights and then add all those products.</p>
<p><b>Example</b></p>
<p>Consider the <b>Hexa-decimal number 1A5.2</b></p>
<p><b>Mathematically</b>, we can write it as</p>
<p style="text-align:center">(1A5.2)<sub>16</sub> = (1 × 16<sup>2</sup>) + (10 × 16<sup>1</sup>) + (5 × 16<sup>0</sup>) + (2 × 16<sup>-1</sup>)</p>
<p style="padding-left:7%">&rArr; (1A5.2)<sub>16</sub> = 256 + 160 + 5 + 0.125 = 421.125 </p>
<p style="padding-left:7%">&rArr; (1A5.2)<sub>16</sub> = (421.125)<sub>10</sub></p>
<p>Therefore, the <b>decimal equivalent</b> of Hexa-decimal number 1A5.2 is 421.125.</p>
<h3>Hexa-Decimal to Binary Conversion</h3>
<p>The process of converting Hexa-decimal number into its equivalent binary number is just opposite to that of binary to Hexa-decimal conversion. By representing each Hexa-decimal digit with 4 bits, we will get the equivalent binary number.</p>
<p><b>Example</b></p>
<p>Consider the <b>Hexa-decimal number 65.4C</b></p>
<p>Represent each Hexa-decimal digit with 4 bits.</p>
<p style="text-align:center">(65.4C)<sub>6</sub> = (0110 0101.0100 1100)<sub>2</sub></p>
<p>The value doesn’t change by removing the zeros, which are at two extreme sides.</p>
<p style="padding-left:25%"> &rArr; (65.4C)<sub>16</sub> = (1100101.010011)<sub>2</sub></p>
<p>Therefore, the <b>binary equivalent</b> of Hexa-decimal number 65.4C is 1100101.010011.</p>
<h3>Hexa-Decimal to Octal Conversion</h3>
<p>Follow these two steps for converting Hexa-decimal number into its equivalent octal number.</p>
<ul class="list">
<li>Convert Hexa-decimal number into its equivalent binary number.</li>
<li>Convert the above binary number into its equivalent octal number.</li>
</ul>
<p><b>Example</b></p>
<p>Consider the <b>Hexa-decimal number 65.4C</b></p>
<p>In previous example, we got the binary equivalent of Hexa-decimal number 65.4C as 1100101.010011.</p>
<p>By following the procedure of binary to octal conversion, we will get</p>
<p style="text-align:center">(1100101.010011)<sub>2</sub> = (145.23)<sub>8</sub></p>
<p style="text-align:center">&rArr;(65.4C)<sup>16</sup> = (145.23)<sub>𝟖</sub></p>
<p>Therefore, the <b>octal equivalent</b> of Hexa-decimal number 65.4<b><i>C</i></b> is 145.23.</p>
<h1>Binary Numbers Representation</h1>
<p>We can make the binary numbers into the following two groups &minus; <b>Unsigned numbers</b> and <b>Signed numbers</b>.</p>
<h3>Unsigned Numbers</h3>
<p>Unsigned numbers contain only magnitude of the number. They don’t have any sign. That means all unsigned binary numbers are positive. As in decimal number system, the placing of positive sign in front of the number is optional for representing positive numbers. Therefore, all positive numbers including zero can be treated as unsigned numbers if positive sign is not assigned in front of the number.</p>
<h3>Signed Numbers</h3>
<p>Signed numbers contain both sign and magnitude of the number. Generally, the sign is placed in front of number. So, we have to consider the positive sign for positive numbers and negative sign for negative numbers. Therefore, all numbers can be treated as signed numbers if the corresponding sign is assigned in front of the number.</p>
<p>If sign bit is zero, which indicates the binary number is positive. Similarly, if sign bit is one, which indicates the binary number is negative.</p>
<h2>Representation of Un-Signed Binary Numbers</h2>
<p>The bits present in the un-signed binary number holds the <b>magnitude</b> of a number. That means, if the un-signed binary number contains <b>‘N’</b> bits, then all <b>N</b> bits represent the magnitude of the number, since it doesn’t have any sign bit.</p>
<p><b>Example</b></p>
<p>Consider the <b>decimal number 108</b>. The binary equivalent of this number is <b>1101100</b>. This is the representation of unsigned binary number.</p>
<p style="text-align:center">(108)<sub>10</sub> = (1101100)<sub>2</sub></p>
<p>It is having 7 bits. These 7 bits represent the magnitude of the number 108.</p>
<h2>Representation of Signed Binary Numbers</h2>
<p>The Most Significant Bit (MSB) of signed binary numbers is used to indicate the sign of the numbers. Hence, it is also called as <b>sign bit</b>. The positive sign is represented by placing ‘0’ in the sign bit. Similarly, the negative sign is represented by placing ‘1’ in the sign bit.</p>
<p>If the signed binary number contains ‘N’ bits, then (N-1) bits only represent the magnitude of the number since one bit (MSB) is reserved for representing sign of the number.</p>
<p>There are three <b>types of representations</b> for signed binary numbers</p>
<ul class="list">
<li>Sign-Magnitude form</li>
<li>1’s complement form</li>
<li>2’s complement form</li>
</ul>
<p>Representation of a positive number in all these 3 forms is same. But, only the representation of negative number will differ in each form.</p>
<p><b>Example</b></p>
<p>Consider the <b>positive decimal number +108</b>. The binary equivalent of magnitude of this number is 1101100. These 7 bits represent the magnitude of the number 108. Since it is positive number, consider the sign bit as zero, which is placed on left most side of magnitude.</p>
<p style="text-align:center">(+108)<sub>10</sub> = (01101100)<sub>2</sub></p>
<p>Therefore, the <b>signed binary representation</b> of positive decimal number +108 is 𝟎𝟏𝟏𝟎𝟏𝟏𝟎𝟎. So, the same representation is valid in sign-magnitude form, 1’s complement form and 2’s complement form for positive decimal number +108.</p>
<h3>Sign-Magnitude form</h3>
<p>In sign-magnitude form, the MSB is used for representing <b>sign</b> of the number and the remaining bits represent the <b>magnitude</b> of the number. So, just include sign bit at the left most side of unsigned binary number. This representation is similar to the signed decimal numbers representation.</p>
<p><b>Example</b></p>
<p>Consider the <b>negative decimal number -108</b>. The magnitude of this number is 108. We know the unsigned binary representation of 108 is 1101100. It is having 7 bits. All these bits represent the magnitude.</p>
<p>Since the given number is negative, consider the sign bit as one, which is placed on left most side of magnitude.</p>
<p style="text-align:center">(−108)<sub>10</sub> = (11101100)<sub>2</sub></p>
<p>Therefore, the sign-magnitude representation of -108 is <b>11101100</b>.</p>
<h3>1’s complement form</h3>
<p>The 1’s complement of a number is obtained by <b>complementing all the bits</b> of signed binary number. So, 1’s complement of positive number gives a negative number. Similarly, 1’s complement of negative number gives a positive number.</p>
<p>That means, if you perform two times 1’s complement of a binary number including sign bit, then you will get the original signed binary number.</p>
<p><b>Example</b></p>
<p>Consider the <b>negative decimal number -108</b>. The magnitude of this number is 108. We know the signed binary representation of 108 is 01101100.</p>
<p>It is having 8 bits. The MSB of this number is zero, which indicates positive number. Complement of zero is one and vice-versa. So, replace zeros by ones and ones by zeros in order to get the negative number.</p>
<p style="text-align:center">(−108)<sub>10</sub> = (10010011)<sub>2</sub></p>
<p>Therefore, the <b>1’s complement of (108)<sub>10</sub></b> is <b>(10010011)<sub>2</sub></b>.</p>
<h3>2’s complement form</h3>
<p>The 2’s complement of a binary number is obtained by <b>adding one to the 1’s complement</b> of signed binary number. So, 2’s complement of positive number gives a negative number. Similarly, 2’s complement of negative number gives a positive number.</p>
<p>That means, if you perform two times 2’s complement of a binary number including sign bit, then you will get the original signed binary number.</p>
<p><b>Example</b></p>
<p>Consider the <b>negative decimal number -108</b>.</p>
<p>We know the 1’s complement of (108)<sub>10</sub> is (10010011)<sub>2</sub></p>
<p style="padding-left:10%"><i>2’s compliment of (108)<sub>10</sub> = 1’s compliment of (108)<sub>10</sub> + 1.</i></p>
<p style="padding-left:40.5%">= 10010011 + 1</p>
<p style="padding-left:40.5%">= 10010100</p>
<p>Therefore, the <b>2’s complement of (108)<sub>10</sub></b> is <b>(10010100)<sub>2</sub></b>.</p>
<h1>Digital Circuits - Signed Binary Arithmetic</h1>
<p>In this chapter, let us discuss about the basic arithmetic operations, which can be performed on any two signed binary numbers using 2’s complement method. The <b>basic arithmetic operations</b> are addition and subtraction.</p>
<h2>Addition of two Signed Binary Numbers</h2>
<p>Consider the two signed binary numbers A & B, which are represented in 2’s complement form. We can perform the <b>addition</b> of these two numbers, which is similar to the addition of two unsigned binary numbers. But, if the resultant sum contains carry out from sign bit, then discard (ignore) it in order to get the correct value.</p>
<p>If resultant sum is positive, you can find the magnitude of it directly. But, if the resultant sum is negative, then take 2’s complement of it in order to get the magnitude.</p>
<h3>Example 1</h3>
<p>Let us perform the <b>addition</b> of two decimal numbers <b>+7 and +4</b> using 2’s complement method.</p>
<p>The <b>2’s complement</b> representations of +7 and +4 with 5 bits each are shown below.</p>
<p style="text-align:center">(+7)<sub>10</sub> = (00111)<sub>2</sub></p>
<p style="text-align:center">(+4)<sub>10</sub> = (00100)<sub>2</sub></p>
<p>The addition of these two numbers is</p>
<p style="text-align:center">(+7)<sub>10</sub> +(+4)<sub>10</sub>= (00111)<sub>2</sub>+(00100)<sub>2</sub></p>
<p style="text-align:center">(+7)<sub>10</sub> +(+4)<sub>10</sub>= <b>(01011)<sub>2</sub></b>.</p>
<p>The resultant sum contains 5 bits. So, there is no carry out from sign bit. The sign bit ‘0’ indicates that the resultant sum is <b>positive</b>. So, the magnitude of sum is 11 in decimal number system. Therefore, addition of two positive numbers will give another positive number.</p>
<h3>Example 2</h3>
<p>Let us perform the <b>addition</b> of two decimal numbers <b>-7</b> and <b>-4</b> using 2’s complement method.</p>
<p>The <b>2’s complement</b> representation of -7 and -4 with 5 bits each are shown below.</p>
<p style="text-align:center">(−7)<sub>10</sub> = (11001)<sub>2</sub></p>
<p style="text-align:center">(−4)<sub>10</sub> = (11100)<sub>2</sub></p>
<p>The addition of these two numbers is</p>
<p style="text-align:center">(−7)<sub>10</sub> + (−4)<sub>10</sub> = (11001)<sub>2</sub> + (11100)<sub>2</sub></p>
<p style="text-align:center">&rArr;(−7)<sub>10</sub> + (−4)<sub>10</sub> = (110101)<sub>2</sub>.</p>
<p>The resultant sum contains 6 bits. In this case, carry is obtained from sign bit. So, we can remove it</p>
<p>Resultant sum after removing carry is (−7)<sub>10</sub> + (−4)<sub>10</sub> = <b>(10101)<sub>2</sub></b>.</p>
<p>The sign bit ‘1’ indicates that the resultant sum is <b>negative</b>. So, by taking 2’s complement of it we will get the magnitude of resultant sum as 11 in decimal number system. Therefore, addition of two negative numbers will give another negative number.</p>
<h2>Subtraction of two Signed Binary Numbers</h2>
<p>Consider the two signed binary numbers A & B, which are represented in 2’s complement form. We know that 2’s complement of positive number gives a negative number. So, whenever we have to subtract a number B from number A, then take 2’s complement of B and add it to A. So, <b>mathematically</b> we can write it as</p>
<p style="text-align:center"><b>A - B = A + <i>(2's complement of B)</i></b></p>
<p>Similarly, if we have to subtract the number A from number B, then take 2’s complement of A and add it to B. So, <b>mathematically</b> we can write it as </p>
<p style="text-align:center"><b>B - A = B + <i>(2's complement of A)</i></b></p>
<p>So, the subtraction of two signed binary numbers is similar to the addition of two signed binary numbers. But, we have to take 2’s complement of the number, which is supposed to be subtracted. This is the <b>advantage</b> of 2’s complement technique. Follow, the same rules of addition of two signed binary numbers.</p>
<h3>Example 3</h3>
<p>Let us perform the <b>subtraction</b> of two decimal numbers <b>+7 and +4</b> using 2’s complement method.</p>
<p>The subtraction of these two numbers is</p>
<p style="text-align:center">(+7)<sub>10</sub> − (+4)<sub>10</sub> = (+7)<sub>10</sub> + (−4)<sub>10</sub>.</p>
<p>The <b>2’s complement</b> representation of +7 and -4 with 5 bits each are shown below.</p>
<p style="text-align:center">(+7)<sub>10</sub> = (00111)<sub>2</sub></p>
<p style="text-align:center">(+4)<sub>10</sub> = (11100)<sub>2</sub></p>
<p style="padding-left:23%">&rArr;(+7)<sub>10</sub> + (+4)<sub>10</sub> = (00111)<sub>2</sub> + (11100)<sub>2</sub> = (00011)<sub>2</sub></p>
<p>Here, the carry obtained from sign bit. So, we can remove it. The resultant sum after removing carry is</p>
<p style="padding-left:25%">(+7)<sub>10</sub> + (+4)<sub>10</sub> = <b>(00011)<sub>2</sub></b></p>
<p>The sign bit ‘0’ indicates that the resultant sum is <b>positive</b>. So, the magnitude of it is 3 in decimal number system. Therefore, subtraction of two decimal numbers +7 and +4 is +3.</p>
<h3>Example 4</h3>
<p>Let us perform the <b>subtraction of</b> two decimal numbers <b>+4</b> and <b>+7</b> using 2’s complement method.</p>
<p>The subtraction of these two numbers is</p>
<p style="text-align:center">(+4)<sub>10</sub> − (+7)<sub>10</sub> = (+4)<sub>10</sub> + (−7)<sub>10</sub>.</p>
<p>The <b>2’s complement</b> representation of +4 and -7 with 5 bits each are shown below.</p>
<p style="text-align:center">(+4)<sub>10</sub> = (00100)<sub>2</sub></p>
<p style="text-align:center">(-7)<sub>10</sub> = (11001)<sub>2</sub></p>
<p style="padding-left:24%">&rArr;(+4)<sub>10</sub> + (-7)<sub>10</sub> = (00100)<sub>2</sub> + (11001)<sub>2</sub> = (11101)<sub>2</sub></p>
<p>Here, carry is not obtained from sign bit. The sign bit ‘1’ indicates that the resultant sum is <b>negative</b>. So, by taking 2’s complement of it we will get the magnitude of resultant sum as 3 in decimal number system. Therefore, subtraction of two decimal numbers +4 and +7 is -3.</p>
<h1>Digital Circuits - Codes</h1>
<p>In the coding, when numbers or letters are represented by a specific group of symbols, it is said to be that number or letter is being encoded. The group of symbols is called as <b>code</b>. The digital data is represented, stored and transmitted as group of bits. This group of bits is also called as <b>binary code</b>.</p>
<p>Binary codes can be classified into two types.</p>
<ul class="list">
<li>Weighted codes</li>
<li>Unweighted codes</li>
</ul>
<p>If the code has positional weights, then it is said to be <b>weighted code</b>. Otherwise, it is an unweighted code. Weighted codes can be further classified as positively weighted codes and negatively weighted codes.</p>
<h2>Binary Codes for Decimal digits</h2>
<p>The following table shows the various binary codes for decimal digits 0 to 9.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Decimal Digit</th>
<th style="text-align:center">8421 Code</th>
<th style="text-align:center">2421 Code</th>
<th style="text-align:center">84-2-1 Code</th>
<th style="text-align:center">Excess 3 Code</th>
</tr>
<tr>
<td>0</td>
<td>0000</td>
<td>0000</td>
<td>0000</td>
<td>0011</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>0001</td>
<td>0111</td>
<td>0100</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>0010</td>
<td>0110</td>
<td>0101</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td>0011</td>
<td>0101</td>
<td>0110</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td>0100</td>
<td>0100</td>
<td>0111</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td>1011</td>
<td>1011</td>
<td>1000</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td>1100</td>
<td>1010</td>
<td>1001</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td>1101</td>
<td>1001</td>
<td>1010</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>1110</td>
<td>1000</td>
<td>1011</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>1111</td>
<td>1111</td>
<td>1100</td>
</tr>
</table>
<p>We have 10 digits in decimal number system. To represent these 10 digits in binary, we require minimum of 4 bits. But, with 4 bits there will be 16 unique combinations of zeros and ones. Since, we have only 10 decimal digits, the other 6 combinations of zeros and ones are not required.</p>
<h3>8 4 2 1 code</h3>
<ul class="list">
<li><p>The weights of this code are 8, 4, 2 and 1. </p></li>
<li><p>This code has all positive weights. So, it is a <b>positively weighted code</b>.</p></li>
<li><p>This code is also called as <b>natural BCD</b> (Binary Coded Decimal) <b>code</b>.</p></li>
</ul>
<p><b>Example</b></p>
<p>Let us find the BCD equivalent of the decimal number 786. This number has 3 decimal digits 7, 8 and 6. From the table, we can write the BCD (8421) codes of 7, 8 and 6 are 0111, 1000 and 0110 respectively.</p>
<p style="text-align:center">&there4; (786)<sub>10</sub> = (011110000110)<sub>BCD</sub></p>
<p>There are 12 bits in BCD representation, since each BCD code of decimal digit has 4 bits.</p>
<h3>2 4 2 1 code</h3>
<ul class="list">
<li><p>The weights of this code are 2, 4, 2 and 1.</p></li>
<li><p>This code has all positive weights. So, it is a <b>positively weighted code</b>.</p></li>
<li><p>It is an <b>unnatural BCD</b> code. Sum of weights of unnatural BCD codes is equal to 9.</p></li>
<li><p>It is a <b>self-complementing</b> code. Self-complementing codes provide the 9’s complement of a decimal number, just by interchanging 1’s and 0’s in its equivalent 2421 representation.</p></li>
</ul>
<p><b>Example</b></p>
<p>Let us find the 2421 equivalent of the decimal number 786. This number has 3 decimal digits 7, 8 and 6. From the table, we can write the 2421 codes of 7, 8 and 6 are 1101, 1110 and 1100 respectively.</p>
<p>Therefore, the 2421 equivalent of the decimal number 786 is <b>110111101100</b>.</p>
<h3>8 4 -2 -1 code</h3>
<ul class="list">
<li><p>The weights of this code are 8, 4, -2 and -1.</p></li>
<li><p>This code has negative weights along with positive weights. So, it is a <b>negatively weighted code</b>.</p></li>
<li><p>It is an <b>unnatural BCD</b> code.</p></li>
<li><p>It is a <b>self-complementing</b> code.</p></li>
</ul>
<p><b>Example</b></p>
<p>Let us find the 8 4-2-1 equivalent of the decimal number 786. This number has 3 decimal digits 7, 8 and 6. From the table, we can write the 8 4 -2 -1 codes of 7, 8 and 6 are 1001, 1000 and 1010 respectively.</p>
<p>Therefore, the 8 4 -2 -1 equivalent of the decimal number 786 is <b>100110001010</b>.</p>
<h3>Excess 3 code</h3>
<ul class="list">
<li><p>This code doesn’t have any weights. So, it is an <b>un-weighted code</b>.</p></li>
<li><p>We will get the Excess 3 code of a decimal number by adding three (0011) to the binary equivalent of that decimal number. Hence, it is called as Excess 3 code.</p></li>
<li><p>It is a <b>self-complementing</b> code.</p></li>
</ul>
<p><b>Example</b></p>
<p>Let us find the Excess 3 equivalent of the decimal number 786. This number has 3 decimal digits 7, 8 and 6. From the table, we can write the Excess 3 codes of 7, 8 and 6 are 1010, 1011 and 1001 respectively.</p>
<p>Therefore, the Excess 3 equivalent of the decimal number 786 is <b>101010111001</b></p>
<h2>Gray Code</h2>
<p>The following table shows the 4-bit Gray codes corresponding to each 4-bit binary code. </p>
<table style="text-align:center" class ="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Decimal Number</th>
<th style="text-align:center">Binary Code</th>
<th style="text-align:center">Gray Code</th>
</tr>
<tr>
<td>0</td>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
<td>0110</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
<td>0111</td>
</tr>
<tr>
<td>6</td>
<td>0110</td>
<td>0101</td>
</tr>
<tr>
<td>7</td>
<td>0111</td>
<td>0100</td>
</tr>
<tr>
<td>8</td>
<td>1000</td>
<td>1100</td>
</tr>
<tr>
<td>9</td>
<td>1001</td>
<td>1101</td>
</tr>
<tr>
<td>10</td>
<td>1010</td>
<td>1111</td>
</tr>
<tr>
<td>11</td>
<td>1011</td>
<td>1110</td>
</tr>
<tr>
<td>12</td>
<td>1100</td>
<td>1010</td>
</tr>
<tr>
<td>13</td>
<td>1101</td>
<td>1011</td>
</tr>
<tr>
<td>14</td>
<td>1110</td>
<td>1001</td>
</tr>
<tr>
<td>15</td>
<td>1111</td>
<td>1000</td>
</tr>
</table>
<ul class="list">
<li><p>This code doesn’t have any weights. So, it is an <b>un-weighted code</b>.</p></li>
<li><p>In the above table, the successive Gray codes are differed in one bit position only. Hence, this code is called as <b>unit distance</b> code.</p></li>
</ul>
<h3>Binary code to Gray Code Conversion</h3>
<p>Follow these steps for converting a binary code into its equivalent Gray code.</p>
<ul class="list">
<li><p>Consider the given binary code and place a zero to the left of MSB.</p></li>
<li><p>Compare the successive two bits starting from zero. If the 2 bits are same, then the output is zero. Otherwise, output is one.</p></li>
<li><p>Repeat the above step till the LSB of Gray code is obtained.</p></li>
</ul>
<p><b>Example</b></p>
<p>From the table, we know that the Gray code corresponding to binary code 1000 is 1100. Now, let us verify it by using the above procedure.</p>
<p>Given, binary code is 1000.</p>
<p><b>Step 1</b> &minus; By placing zero to the left of MSB, the binary code will be 01000.</p>
<p><b>Step 2</b> &minus; By comparing successive two bits of new binary code, we will get the gray code as <b>1100</b>.</p>
<h1>Error Detection &amp; Correction Codes</h1>
<p>We know that the bits 0 and 1 corresponding to two different range of analog voltages. So, during transmission of binary data from one system to the other, the noise may also be added. Due to this, there may be errors in the received data at other system.</p>
<p>That means a bit 0 may change to 1 or a bit 1 may change to 0. We can’t avoid the interference of noise. But, we can get back the original data first by detecting whether any error(s) present and then correcting those errors. For this purpose, we can use the following codes.</p>
<ul class="list">
<li>Error detection codes</li>
<li>Error correction codes</li>
</ul>
<p><b>Error detection codes</b> are used to detect the error(s) present in the received data (bit stream). These codes contain some bit(s), which are included (appended) to the original bit stream. These codes detect the error, if it is occurred during transmission of the original data (bit stream).<b>Example</b> &minus; Parity code, Hamming code.</p>
<p><b>Error correction codes</b> are used to correct the error(s) present in the received data (bit stream) so that, we will get the original data. Error correction codes also use the similar strategy of error detection codes.<b>Example</b> &minus; Hamming code.</p>
<p>Therefore, to detect and correct the errors, additional bit(s) are appended to the data bits at the time of transmission.</p>
<h2>Parity Code</h2>
<p>It is easy to include (append) one parity bit either to the left of MSB or to the right of LSB of original bit stream. There are two types of parity codes, namely even parity code and odd parity code based on the type of parity being chosen.</p>
<h3>Even Parity Code</h3>
<p>The value of even parity bit should be zero, if even number of ones present in the binary code. Otherwise, it should be one. So that, even number of ones present in <b>even parity code</b>. Even parity code contains the data bits and even parity bit.</p>
<p>The following table shows the <b>even parity codes</b> corresponding to each 3-bit binary code. Here, the even parity bit is included to the right of LSB of binary code.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Binary Code </th>
<th style="text-align:center">Even Parity bit</th>
<th style="text-align:center">Even Parity Code</th>
</tr>
<tr>
<td>000</td>
<td>0</td>
<td>0000</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
<td>0011</td>
</tr>
<tr>
<td>010</td>
<td>1</td>
<td>0101</td>
</tr>
<tr>
<td>011</td>
<td>0</td>
<td>0110</td>
</tr>
<tr>
<td>100</td>
<td>1</td>
<td>1001</td>
</tr>
<tr>
<td>101</td>
<td>0</td>
<td>1010</td>
</tr>
<tr>
<td>110</td>
<td>0</td>
<td>1100</td>
</tr>
<tr>
<td>111</td>
<td>1</td>
<td>1111</td>
</tr>
</table>
<p>Here, the number of bits present in the even parity codes is 4. So, the possible even number of ones in these even parity codes are 0, 2 &amp; 4.</p>
<ul class="list">
<li><p>If the other system receives one of these even parity codes, then there is no error in the received data. The bits other than even parity bit are same as that of binary code.</p></li>
<li><p>If the other system receives other than even parity codes, then there will be an error(s) in the received data. In this case, we can’t predict the original binary code because we don’t know the bit position(s) of error.</p></li>
</ul>
<p>Therefore, even parity bit is useful only for detection of error in the received parity code. But, it is not sufficient to correct the error.</p>
<h3>Odd Parity Code</h3>
<p>The value of odd parity bit should be zero, if odd number of ones present in the binary code. Otherwise, it should be one. So that, odd number of ones present in <b>odd parity code</b>. Odd parity code contains the data bits and odd parity bit.</p>
<p>The following table shows the <b>odd parity codes</b> corresponding to each 3-bit binary code. Here, the odd parity bit is included to the right of LSB of binary code.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Binary Code</th>
<th style="text-align:center">Odd Parity bit</th>
<th style="text-align:center">Odd Parity Code</th>
</tr>
<tr>
<td>000</td>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>001</td>
<td>0</td>
<td>0010</td>
</tr>
<tr>
<td>010</td>
<td>0</td>
<td>0100</td>
</tr>
<tr>
<td>011</td>
<td>1</td>
<td>0111</td>
</tr>
<tr>
<td>100</td>
<td>0</td>
<td>1000</td>
</tr>
<tr>
<td>101</td>
<td>1</td>
<td>1011</td>
</tr>
<tr>
<td>110</td>
<td>1</td>
<td>1101</td>
</tr>
<tr>
<td>111</td>
<td>0</td>
<td>1110</td>
</tr>
</table>
<p>Here, the number of bits present in the odd parity codes is 4. So, the possible odd number of ones in these odd parity codes are 1 &amp; 3.</p>
<ul class="list">
<li><p>If the other system receives one of these odd parity codes, then there is no error in the received data. The bits other than odd parity bit are same as that of binary code.</p></li>
<li><p>If the other system receives other than odd parity codes, then there is an error(s) in the received data. In this case, we can’t predict the original binary code because we don’t know the bit position(s) of error.</p></li>
</ul>
<p>Therefore, odd parity bit is useful only for detection of error in the received parity code. But, it is not sufficient to correct the error.</p>
<h2>Hamming Code</h2>
<p>Hamming code is useful for both detection and correction of error present in the received data. This code uses multiple parity bits and we have to place these parity bits in the positions of powers of 2.</p>
<p>The <b>minimum value of 'k'</b> for which the following relation is correct (valid) is nothing but the required number of parity bits.</p>
<p>$$2^k\geq n+k+1$$</p>
<p>Where,</p>
<p>‘n’ is the number of bits in the binary code (information)</p>
<p>‘k’ is the number of parity bits</p>
<p>Therefore, the number of bits in the Hamming code is equal to n + k.</p>
<p>Let the <b>Hamming code</b> is $b_{n+k}b_{n+k-1}.....b_{3}b_{2}b_{1}$ &amp; parity bits $p_{k}, p_{k-1}, ....p_{1}$. We can place the ‘k’ parity bits in powers of 2 positions only. In remaining bit positions, we can place the ‘n’ bits of binary code.</p>
<p>Based on requirement, we can use either even parity or odd parity while forming a Hamming code. But, the same parity technique should be used in order to find whether any error present in the received data.</p>
<p>Follow this procedure for finding <b>parity bits</b>.</p>
<ul class="list">
<li><p>Find the value of p<sub>1</sub>, based on the number of ones present in bit positions b<sub>3</sub>, b<sub>5</sub>, b<sub>7</sub> and so on. All these bit positions (suffixes) in their equivalent binary have ‘1’ in the place value of 2<sup>0</sup>.</p></li>
<li><p>Find the value of p<sub>2</sub>, based on the number of ones present in bit positions b<sub>3</sub>, b<sub>6</sub>, b<sub>7</sub> and so on. All these bit positions (suffixes) in their equivalent binary have ‘1’ in the place value of 2<sup>1</sup>.</p></li>
<li><p>Find the value of p<sub>3</sub>, based on the number of ones present in bit positions b<sub>5</sub>, b<sub>6</sub>, b<sub>7</sub> and so on. All these bit positions (suffixes) in their equivalent binary have ‘1’ in the place value of 2<sup>2</sup>.</p></li>
<li><p>Similarly, find other values of parity bits.</p></li>
</ul>
<p>Follow this procedure for finding <b>check bits</b>.</p>
<ul class="list">
<li><p>Find the value of c<sub>1</sub>, based on the number of ones present in bit positions b<sub>1</sub>, b<sub>3</sub>, b<sub>5</sub>, b<sub>7</sub> and so on. All these bit positions (suffixes) in their equivalent binary have ‘1’ in the place value of 2<sup>0</sup>.</p></li>
<li><p>Find the value of c<sub>2</sub>, based on the number of ones present in bit positions b<sub>2</sub>, b<sub>3</sub>, b<sub>6</sub>, b<sub>7</sub> and so on. All these bit positions (suffixes) in their equivalent binary have ‘1’ in the place value of 2<sup>1</sup>.</p></li>
<li><p>Find the value of c<sub>2</sub>, based on the number of ones present in bit positions b<sub>4</sub>, b<sub>5</sub>, b<sub>6</sub>, b<sub>7</sub> and so on. All these bit positions (suffixes) in their equivalent binary have ‘1’ in the place value of 2<sup>2</sup>.</p></li>
<li><p>Similarly, find other values of check bits.</p></li>
</ul>
<p>The decimal equivalent of the check bits in the received data gives the value of bit position, where the error is present. Just complement the value present in that bit position. Therefore, we will get the original binary code after removing parity bits.</p>
<h3>Example 1</h3>
<p>Let us find the Hamming code for binary code, d<sub>4</sub>, d<sub>3</sub>,d<sub>2</sub>, d<sub>1</sub> = 1000. Consider even parity bits.</p>
<p>The number of bits in the given binary code is n=4.</p>
<p>We can find the required number of parity bits by using the following mathematical relation.</p>
<p>$$2^k\geq n+k+1$$</p>
<p>Substitute, n=4 in the above mathematical relation.</p>
<p>$$\Rightarrow 2^k\geq 4+k+1$$</p>
<p>$$\Rightarrow 2^k\geq 5+k$$</p>
<p>The minimum value of k that satisfied the above relation is 3. Hence, we require 3 parity bits p<sub>1</sub>, p<sub>2</sub>, and p<sub>3</sub>. Therefore, the number of bits in Hamming code will be 7, since there are 4 bits in binary code and 3 parity bits. We have to place the parity bits and bits of binary code in the Hamming code as shown below.</p>
<p>The <b>7-bit Hamming code</b> is $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}=d_{4}d_{3}d_{2}p_{3}d_{1}p_{2}bp_{1}$</p>
<p>By substituting the bits of binary code, the Hamming code will be $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1} = 100p_{3}Op_{2}p_{1}$. Now, let us find the parity bits.</p>
<p>$$p_{1}=b_{7}\oplus b_{5}\oplus b_{3}=1 \oplus 0 \oplus 0=1$$</p>
<p>$$p_{2}=b_{7}\oplus b_{6}\oplus b_{3}=1 \oplus 0 \oplus 0=1$$</p>
<p>$$p_{3}=b_{7}\oplus b_{6}\oplus b_{5}=1 \oplus 0 \oplus 0=1$$</p>
<p>By substituting these parity bits, the <b>Hamming code</b> will be $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}= 1001011$.</p>
<h3>Example 2</h3>
<p>In the above example, we got the Hamming code as $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}= 1001011$. Now, let us find the error position when the code received is $b_{7}b_{6}b_{5}b_{4}b_{3}b_{2}b_{1}= 1001111$.</p>
<p>Now, let us find the check bits.</p>
<p>$$c_{1}=b_{7}\oplus b_{5}\oplus b_{3}\oplus b_{1}=1 \oplus 0 \oplus 1 \oplus1 =1$$</p>
<p>$$c_{2}=b_{7}\oplus b_{6}\oplus b_{3}\oplus b_{2}=1 \oplus 0 \oplus 1 \oplus1 =1$$</p>
<p>$$c_{3}=b_{7}\oplus b_{6}\oplus b_{5}\oplus b_{4}=1 \oplus 0 \oplus 0 \oplus1 =1$$</p>
<p>The decimal value of check bits gives the position of error in received Hamming code.</p>
<p>$$c_{3}c_{2}c_{1} = \left ( 011 \right )_{2}=\left ( 3 \right )_{10}$$</p>
<p>Therefore, the error present in third bit (b<sub>3</sub>) of Hamming code. Just complement the value present in that bit and remove parity bits in order to get the original binary code.</p>
<h1>Digital Circuits - Boolean Algebra</h1>
<p><b>Boolean Algebra</b> is an algebra, which deals with binary numbers &amp; binary variables. Hence, it is also called as Binary Algebra or logical Algebra. A mathematician, named George Boole had developed this algebra in 1854. The variables used in this algebra are also called as Boolean variables.</p>
<p>The range of voltages corresponding to Logic ‘High’ is represented with ‘1’ and the range of voltages corresponding to logic ‘Low’ is represented with ‘0’.</p>
<h2>Postulates and Basic Laws of Boolean Algebra</h2>
<p>In this section, let us discuss about the Boolean postulates and basic laws that are used in Boolean algebra. These are useful in minimizing Boolean functions.</p>
<h3>Boolean Postulates</h3>
<p>Consider the binary numbers 0 and 1, Boolean variable (x) and its complement (x’). Either the Boolean variable or complement of it is known as <b>literal</b>. The four possible <b>logical OR</b> operations among these literals and binary numbers are shown below.</p>
<p style="text-align:center">x + 0 = x</p>
<p style="text-align:center">x + 1 = 1</p>
<p style="text-align:center">x + x = x</p>
<p style="text-align:center">x + x’ = 1</p>
<p>Similarly, the four possible <b>logical AND</b> operations among those literals and binary numbers are shown below.</p>
<p style="text-align:center">x.1 = x</p>
<p style="text-align:center">x.0 = 0</p>
<p style="text-align:center">x.x = x</p>
<p style="text-align:center">x.x’ = 0</p>
<p>These are the simple Boolean postulates. We can verify these postulates easily, by substituting the Boolean variable with ‘0’ or ‘1’.</p>
<p><b>Note</b>&minus; The complement of complement of any Boolean variable is equal to the variable itself. i.e., (x’)’=x.</p>
<h3>Basic Laws of Boolean Algebra</h3>
<p>Following are the three basic laws of Boolean Algebra.</p>
<ul class="list">
<li>Commutative law</li>
<li>Associative law</li>
<li>Distributive law</li>
</ul>
<h3>Commutative Law</h3>
<p>If any logical operation of two Boolean variables give the same result irrespective of the order of those two variables, then that logical operation is said to be <b>Commutative</b>. The logical OR &amp; logical AND operations of two Boolean variables x &amp; y are shown below</p>
<p style="text-align:center">x + y = y + x </p>
<p style="text-align:center">x.y = y.x</p>
<p>The symbol ‘+’ indicates logical OR operation. Similarly, the symbol ‘.’ indicates logical AND operation and it is optional to represent. Commutative law obeys for logical OR &amp; logical AND operations.</p>
<h3>Associative Law</h3>
<p>If a logical operation of any two Boolean variables is performed first and then the same operation is performed with the remaining variable gives the same result, then that logical operation is said to be <b>Associative</b>. The logical OR &amp; logical AND operations of three Boolean variables x, y &amp; z are shown below.</p>
<p style="text-align:center">x + (y + z) = (x + y) + z</p>
<p style="text-align:center">x.(y.z) = (x.y).z</p>
<p>Associative law obeys for logical OR &amp; logical AND operations.</p>
<h3>Distributive Law</h3>
<p>If any logical operation can be distributed to all the terms present in the Boolean function, then that logical operation is said to be <b>Distributive</b>. The distribution of logical OR &amp; logical AND operations of three Boolean variables x, y &amp; z are shown below.</p>
<p style="text-align:center">x.(y + z) = x.y + x.z</p>
<p style="text-align:center">x + (y.z) = (x+y).(x+z)</p>
<p>Distributive law obeys for logical OR and logical AND operations.</p>
<p>These are the Basic laws of Boolean algebra. We can verify these laws easily, by substituting the Boolean variables with ‘0’ or ‘1’.</p>
<h2>Theorems of Boolean Algebra</h2>
<p>The following two theorems are used in Boolean algebra.</p>
<ul class="list">
<li>Duality theorem</li>
<li>DeMorgan’s theorem</li>
</ul>
<h3>Duality Theorem</h3>
<p>This theorem states that the <b>dual</b> of the Boolean function is obtained by interchanging the logical AND operator with logical OR operator and zeros with ones. For every Boolean function, there will be a corresponding Dual function.</p>
<p>Let us make the Boolean equations (relations) that we discussed in the section of Boolean postulates and basic laws into two groups. The following table shows these two groups.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Group1</th>
<th style="text-align:center">Group2</th>
</tr>
<tr>
<td>x + 0 = x</td>
<td>x.1 = x</td>
</tr>
<tr>
<td>x + 1 = 1</td>
<td>x.0 = 0</td>
</tr>
<tr>
<td>x + x = x</td>
<td>x.x = x</td>
</tr>
<tr>
<td>x + x’ = 1</td>
<td>x.x’ = 0</td>
</tr>
<tr>
<td>x + y = y + x</td>
<td>x.y = y.x</td>
</tr>
<tr>
<td>x + (y + z) = (x + y) + z</td>
<td>x.(y.z) = (x.y).z</td>
</tr>
<tr>
<td>x.(y + z) = x.y + x.z</td>
<td>x + (y.z) = (x+y).(x+z)</td>
</tr>
</table>
<p>In each row, there are two Boolean equations and they are dual to each other. We can verify all these Boolean equations of Group1 and Group2 by using duality theorem.</p>
<h3>DeMorgan’s Theorem</h3>
<p>This theorem is useful in finding the <b>complement of Boolean function</b>. It states that the complement of logical OR of at least two Boolean variables is equal to the logical AND of each complemented variable.</p>
<p>DeMorgan’s theorem with 2 Boolean variables x and y can be represented as</p>
<p style="text-align:center">(x + y)’ = x’.y’</p>
<p>The dual of the above Boolean function is</p>
<p style="text-align:center">(x.y)’ = x’ + y’</p>
<p>Therefore, the complement of logical AND of two Boolean variables is equal to the logical OR of each complemented variable. Similarly, we can apply DeMorgan’s theorem for more than 2 Boolean variables also.</p>
<h2>Simplification of Boolean Functions</h2>
<p>Till now, we discussed the postulates, basic laws and theorems of Boolean algebra. Now, let us simplify some Boolean functions.</p>
<h3>Example 1</h3>
<p>Let us <b>simplify</b> the Boolean function, f=p’qr + pq’r + pqr’ + pqr</p>
<p>We can simplify this function in two methods.</p>
<p><b>Method 1</b></p>
<p>Given Boolean function, f=p’qr + pq’r + pqr’ +pqr.</p>
<p><b>Step 1</b> &minus; In first and second terms r is common and in third and fourth terms pq is common. So, take the common terms by using <b>Distributive law</b>.</p>
<p style="text-align:center">&rArr; f= (p’q + pq’)r + pq(r’+r)</p>
<p><b>Step 2</b> &minus; The terms present in first parenthesis can be simplified to Ex-OR operation. The terms present in second parenthesis can be simplified to ‘1’ using <b>Boolean postulate</b></p>
<p style="text-align:center">&rArr; f=(p &oplus;q)r+pq(1)</p>
<p><b>Step 3</b> &minus; The first term can’t be simplified further. But, the second term can be simplified
to pq using <b>Boolean postulate</b>.</p>
<p style="text-align:center">&rArr; f=(p &oplus;q)r+pq</p>
<p>Therefore, the simplified Boolean function is <b>f= (p&oplus;q)r + pq</b></p>
<p><b>Method 2</b></p>
<p>Given Boolean function, f=p’qr + pq’r + pqr’ +pqr.</p>
<p><b>Step 1</b> &minus; Use the <b>Boolean postulate</b>, x + x = x. That means, the Logical OR operation with any Boolean variable ‘n’ times will be equal to the same variable. So, we can write the last term pqr two more times.</p>
<p style="text-align:center">&rArr; f= p’qr + pq’r + pqr’ + pqr + pqr + pqr</p>
<p><b>Step 2</b> &minus; Use <b>Distributive law</b> for 1<sup>st</sup> and 4<sup>th</sup> terms, 2<sup>nd</sup> and 5<sup>th</sup> terms, 3<sup>rd</sup> and 6<sup>th</sup> terms.</p>
<p style="text-align:center">&rArr; f= qr(p’ + p) + pr(q’+q) + pq(r’+r)</p>
<p><b>Step 3</b> &minus; Use <b>Boolean postulate</b>, x + x’ = 1 for simplifying the terms present in each parenthesis.</p>
</p>
<p style="text-align:center">&rArr; f= qr(1) + pr(1) + pq(1)</p>
<p><b>Step 4</b> &minus; Use <b>Boolean postulate</b>, x.1 = x for simplifying the above three terms.</p>
<p style="text-align:center">&rArr; f = qr + pr + pq</p>
<p style="text-align:center">&rArr;  f = pq + qr + pr </p>
<p>Therefore, the simplified Boolean function is <b>f= pq + qr + pr</b>.</p>
<p>So, we got two different Boolean functions after simplifying the given Boolean function in each method. Functionally, those two Boolean functions are same. So, based on the requirement, we can choose one of those two Boolean functions.</p>
<h3>Example 2</h3>
<p>Let us find the <b>complement</b> of the Boolean function, f=p’q + pq’.</p>
<p>The complement of Boolean function is f’=(p’q + pq’)’.</p>
<p><b>Step 1</b> &minus; Use DeMorgan’s theorem, (x + y)’ = x’.y’.</p>
<p style="text-align:center">&rArr; f’= (p’q)’.(pq’)’</p>
<p><b>Step 2</b> &minus; Use DeMorgan’s theorem, (x.y)’ = x’+y’</p>
<p style="text-align:center">&rArr; f’=  {(p’)’+q’}.{p’+(q’)’}</p>
<p><b>Step3</b> &minus; Use the Boolean postulate, (x’)’=x.</p>
<p style="text-align:center">&rArr; f’=  {p+q’}.{p’+q}</p>
<p style="text-align:center">&rArr; f’=  pp’+pq+p’q’+qq’</p>
<p><b>Step 4</b> &minus; Use the Boolean postulate, xx’=0.</p>
<p style="text-align:center">&rArr; f= 0 + pq +p’q’ + 0</p>
<p style="text-align:center">&rArr; f= pq +p’q’</p>
<p>Therefore, the <b>complement</b> of Boolean function, p’q+pq’ is <b>pq+p’q’</b>.</p>
<h1>Digital Circuits - Canonical &amp; Standard Forms</h1>
<p>We will get four Boolean product terms by combining two variables x and y with logical AND operation. These Boolean product terms are called as <b>min terms</b> or <b>standard product terms</b>. The min terms are x’y’, x’y, xy’ and xy.</p>
<p>Similarly, we will get four Boolean sum terms by combining two variables x and y with logical OR operation. These Boolean sum terms are called as <b>Max terms</b> or <b>standard sum terms</b>. The Max terms are x+y, x+y’, x’+y and x’+y’.</p>
<p>The following table shows the representation of min terms and MAX terms for 2 variables.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
<th style="text-align:center">Min terms</th>
<th style="text-align:center">Max terms</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>m<sub>0</sub>=x’y’</td>
<td>M<sub>0</sub>=x+y</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>m<sub>1</sub>=x’y</td>
<td>M<sub>1</sub>=x+y’</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>m<sub>2</sub>=xy’</td>
<td>M<sub>2</sub>=x’+y</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>m<sub>3</sub>=xy</td>
<td>M<sub>3</sub>=x’+y’</td>
</tr>
</table>
<p>If the binary variable is ‘0’, then it is represented as complement of variable in min term and as the variable itself in Max term. Similarly, if the binary variable is ‘1’, then it is represented as complement of variable in Max term and as the variable itself in min term.</p>
<p>From the above table, we can easily notice that min terms and Max terms are complement of each other. If there are ‘n’ Boolean variables, then there will be 2<sup>n</sup> min terms and 2<sup>n</sup> Max terms.</p>
<h2>Canonical SoP and PoS forms</h2>
<p>A truth table consists of a set of inputs and output(s). If there are ‘n’ input variables, then there will be 2<sup>n</sup> possible combinations with zeros and ones. So the value of each output variable depends on the combination of input variables. So, each output variable will have ‘1’ for some combination of input variables and ‘0’ for some other combination of input variables.</p>
<p>Therefore, we can express each output variable in following two ways.</p>
<ul class="list">
<li>Canonical SoP form</li>
<li>Canonical PoS form</li>
</ul>
<h3>Canonical SoP form</h3>
<p>Canonical SoP form means Canonical Sum of Products form. In this form, each product term contains all literals. So, these product terms are nothing but the min terms. Hence, canonical SoP form is also called as <b>sum of min terms</b> form.</p>
<p>First, identify the min terms for which, the output variable is one and then do the logical OR of those min terms in order to get the Boolean expression (function) corresponding to that output variable. This Boolean function will be in the form of sum of min terms.</p>
<p>Follow the same procedure for other output variables also, if there is more than one output variable.</p>
<h3>Example</h3>
<p>Consider the following <b>truth table</b>.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="2">Inputs</th>
<th style="text-align:center" colspan="2">Output</th>
</tr>
<tr>
<td><b>p</b></td>
<td><b>q</b></td>
<td><b>r</b></td>
<td><b>f</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Here, the output (f) is ‘1’ for four combinations of inputs. The corresponding min terms are p’qr, pq’r, pqr’, pqr. By doing logical OR of these four min terms, we will get the Boolean function of output (f). </p>
<p>Therefore, the Boolean function of output is, f=p’qr + pq’r + pqr’ + pqr. This is the <b>canonical SoP form</b> of output, f. We can also represent this function in following two notations.</p>
<p>$$f=m_{3}+m_{5}+m_{6}+m_{7}$$</p>
<p>$$f=\sum m\left ( 3,5,6,7 \right )$$</p>
<p>In one equation, we represented the function as sum of respective min terms. In other equation, we used the symbol for summation of those min terms.</p>
<h3>Canonical PoS form</h3>
<p>Canonical PoS form means Canonical Product of Sums form. In this form, each sum term contains all literals. So, these sum terms are nothing but the Max terms. Hence, canonical PoS form is also called as <b>product of Max terms</b> form.</p>
<p>First, identify the Max terms for which, the output variable is zero and then do the logical AND of those Max terms in order to get the Boolean expression (function) corresponding to that output variable. This Boolean function will be in the form of product of Max terms.</p>
<p>Follow the same procedure for other output variables also, if there is more than one output variable.</p>
<p><b>Example</b></p>
<p>Consider the same truth table of previous example. Here, the output (f) is ‘0’ for four combinations of inputs. The corresponding Max terms are p+q+r, p+q+r’, p+q’+r, p’+q+r. By doing logical AND of these four Max terms, we will get the Boolean function of output (f).</p>
<p>Therefore, the Boolean function of output is, f=(p+q+r).(p+q+r’).(p+q’+r).(p’+q+r). This is the <b>canonical PoS form</b> of output, f. We can also represent this function in following two notations.</p>
<p>$$f=M_{0}.M_{1}.M_{2}.M_{4}$$</p>
<p>$$f=\prod M\left ( 0,1,2,4 \right )$$</p>
<p>In one equation, we represented the function as product of respective Max terms. In other equation, we used the symbol for multiplication of those Max terms.</p>
<p>The Boolean function, f=(p+q+r).(p+q+r’).(p+q’+r).(p’+q+r) is the dual of the Boolean function, f=p’qr + pq’r + pqr’ + pqr.</p>
<p>Therefore, both canonical SoP and canonical PoS forms are <b>Dual</b> to each other. Functionally, these two forms are same. Based on the requirement, we can use one of these two forms.</p>
<h2>Standard SoP and PoS forms</h2>
<p>We discussed two canonical forms of representing the Boolean output(s). Similarly, there are two standard forms of representing the Boolean output(s). These are the simplified version of canonical forms.</p>
<ul class="list">
<li>Standard SoP form</li>
<li>Standard PoS form</li>
</ul>
<p>We will discuss about Logic gates in later chapters. The main <b>advantage</b> of standard forms is that the number of inputs applied to logic gates can be minimized. Sometimes, there will be reduction in the total number of logic gates required.</p>
<h3>Standard SoP form</h3>
<p>Standard SoP form means <b>Standard Sum of Products</b> form. In this form, each product term need not contain all literals. So, the product terms may or may not be the min terms. Therefore, the Standard SoP form is the simplified form of canonical SoP form.</p>
<p>We will get Standard SoP form of output variable in two steps.</p>
<ul class="list">
<li>Get the canonical SoP form of output variable</li>
<li>Simplify the above Boolean function, which is in canonical SoP form.</li>
</ul>
<p>Follow the same procedure for other output variables also, if there is more than one output variable. Sometimes, it may not possible to simplify the canonical SoP form. In that case, both canonical and standard SoP forms are same.</p>
<p><b>Example</b></p>
<p>Convert the following Boolean function into Standard SoP form.</p>
<p style="text-align:center">f=p’qr + pq’r + pqr’ + pqr</p>
<p>The given Boolean function is in canonical SoP form. Now, we have to simplify this Boolean function in order to get standard SoP form.</p>
<p><b>Step 1</b> &minus; Use the <b>Boolean postulate</b>, x + x = x. That means, the Logical OR operation with any Boolean variable ‘n’ times will be equal to the same variable. So, we can write the last term pqr two more times.</p>
<p style="text-align:center">&rArr; f= p’qr + pq’r + pqr’ + pqr + pqr + pqr</p>
<p><b>Step 2</b> &minus; Use <b>Distributive law</b> for 1<sup>st</sup> and 4<sup>th</sup> terms, 2<sup>nd</sup> and 5<sup>th</sup> terms, 3<sup>rd</sup> and 6<sup>th</sup> terms.</p>
<p style="text-align:center">&rArr; f= qr(p’ + p) + pr(q’+q) + pq(r’+r)</p>
<p><b>Step 3</b> &minus; Use <b>Boolean postulate</b>, x + x’ = 1 for simplifying the terms present in each parenthesis.</p>
<p style="text-align:center">&rArr; f= qr(1) + pr(1) + pq(1)</p>
<p><b>Step 4</b> &minus; Use <b>Boolean postulate</b>, x.1 = x for simplifying above three terms.</p>
<p style="text-align:center">&rArr; f= qr + pr + pq</p>
<p style="text-align:center">&rArr; f= pq + qr + pr</p>
<p>This is the simplified Boolean function. Therefore, the <b>standard SoP form</b> corresponding to given canonical SoP form is <b>f= pq + qr + pr</b></p>
<h3>Standard PoS form</h3>
<p>Standard PoS form means <b>Standard Product of Sums</b> form. In this form, each sum term need not contain all literals. So, the sum terms may or may not be the Max terms. Therefore, the Standard PoS form is the simplified form of canonical PoS form.</p>
<p>We will get Standard PoS form of output variable in two steps.</p>
<ul class="list">
<li>Get the canonical PoS form of output variable</li>
<li>Simplify the above Boolean function, which is in canonical PoS form.</li>
</ul>
<p>Follow the same procedure for other output variables also, if there is more than one output variable. Sometimes, it may not possible to simplify the canonical PoS form. In that case, both canonical and standard PoS forms are same.</p>
<p><b>Example</b></p>
<p>Convert the following Boolean function into Standard PoS form.</p>
<p style="text-align:center">f=(p+q+r).(p+q+r’).(p+q’+r).(p’+q+r)</p>
<p>The given Boolean function is in canonical PoS form. Now, we have to simplify this Boolean function in order to get standard PoS form.</p>
<p><b>Step 1</b> &minus; Use the <b>Boolean postulate</b>, x.x=x. That means, the Logical AND operation with any Boolean variable ‘n’ times will be equal to the same variable. So, we can write the first term p+q+r two more times.</p>
<p style="text-align:center">&rArr; f=(p+q+r).(p+q+r).(p+q+r).(p+q+r’).(p+q’+r).(p’+q+r)</p>
<p><b>Step 2</b> &minus; Use <b>Distributive law,</b> x + (y.z) = (x+y).(x+z) for 1<sup>st</sup> and 4<sup>th</sup> parenthesis, 2<sup>nd</sup> and 5<sup>th</sup> parenthesis, 3<sup>rd</sup> and 6<sup>th</sup> parenthesis.</p>
<p style="text-align:center">&rArr; f=(p+q+rr’).(p+r+qq’).(q+r+pp’)</p>
<p><b>Step 3</b> &minus; Use <b>Boolean postulate</b>, x.x’=0 for simplifying the terms present in each parenthesis.</p>
<p style="text-align:center">&rArr; f=(p+q+0).(p+r+0).(q+r+0)</p>
<p><b>Step 4</b> &minus; Use <b>Boolean postulate</b>, x+0=x for simplifying the terms present in each parenthesis</p>
<p style="text-align:center">&rArr; f=(p+q).(p+r).(q+r)</p>
<p style="text-align:center">&rArr; f=(p+q).(q+r).(p+r)</p>
<p>This is the simplified Boolean function. Therefore, the <b>standard PoS form</b> corresponding to given canonical PoS form is <b>f=(p+q).(q+r).(p+r)</b>. This is the <b>dual</b> of the Boolean function, f=pq+qr+pr.</p>
<p>Therefore, both Standard SoP and Standard PoS forms are Dual to each other.</p>
<h1>Digital Circuits - K-Map Method</h1>
<p>In previous chapters, we have simplified the Boolean functions using Boolean postulates and theorems. It is a time consuming process and we have to re-write the simplified expressions after each step.</p>
<p>To overcome this difficulty, <b>Karnaugh</b> introduced a method for simplification of Boolean functions in an easy way. This method is known as Karnaugh map method or K-map method. It is a graphical method, which consists of 2<sup>n</sup> cells for ‘n’ variables. The adjacent cells are differed only in single bit position.</p>
<h2>K-Maps for 2 to 5 Variables</h2>
<p>K-Map method is most suitable for minimizing Boolean functions of 2 variables to 5 variables. Now, let us discuss about the K-Maps for 2 to 5 variables one by one.</p>
<h3>2 Variable K-Map</h3>
<p>The number of cells in 2 variable K-map is four, since the number of variables is two. The following figure shows <b>2 variable K-Map</b>.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/2_variable_k_map.jpg" alt="2 Variable K-Map" />
<ul class="list">
<li><p>There is only one possibility of grouping 4 adjacent min terms.</p></li>
<li><p>The possible combinations of grouping 2 adjacent min terms are {(m<sub>0</sub>, m<sub>1</sub>), (m<sub>2</sub>, m<sub>3</sub>), (m<sub>0</sub>, m<sub>2</sub>) and (m<sub>1</sub>, m<sub>3</sub>)}.</p></li>
</ul>
<h3>3 Variable K-Map</h3>
<p>The number of cells in 3 variable K-map is eight, since the number of variables is three. The following figure shows <b>3 variable K-Map</b>.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/3_variable_k_map.jpg" alt="3 Variable K-Map" />
<ul class="list">
<li><p>There is only one possibility of grouping 8 adjacent min terms.</p></li>
<li><p>The possible combinations of grouping 4 adjacent min terms are {(m<sub>0</sub>, m<sub>1</sub>, m<sub>3</sub>, m<sub>2</sub>), (m<sub>4</sub>, m<sub>5</sub>, m<sub>7</sub>, m<sub>6</sub>), (m<sub>0</sub>, m<sub>1</sub>, m<sub>4</sub>, m<sub>5</sub>), (m<sub>1</sub>, m<sub>3</sub>, m<sub>5</sub>, m<sub>7</sub>), (m<sub>3</sub>, m<sub>2</sub>, m<sub>7</sub>, m<sub>6</sub>) and (m<sub>2</sub>, m<sub>0</sub>, m<sub>6</sub>, m<sub>4</sub>)}.</p></li>
<li><p>The possible combinations of grouping 2 adjacent min terms are {(m<sub>0</sub>, m<sub>1</sub>), (m<sub>1</sub>, m<sub>3</sub>), (m<sub>3</sub>, m<sub>2</sub>), (m<sub>2</sub>, m<sub>0</sub>), (m<sub>4</sub>, m<sub>5</sub>), (m<sub>5</sub>, m<sub>7</sub>), (m<sub>7</sub>, m<sub>6</sub>), (m<sub>6</sub>, m<sub>4</sub>), (m<sub>0</sub>, m<sub>4</sub>), (m<sub>1</sub>, m<sub>5</sub>), (m<sub>3</sub>, m<sub>7</sub>) and (m<sub>2</sub>, m<sub>6</sub>)}.</p></li>
<li><p>If x=0, then 3 variable K-map becomes 2 variable K-map.</p></li>
</ul>
<h3>4 Variable K-Map</h3>
<p>The number of cells in 4 variable K-map is sixteen, since the number of variables is four. The following figure shows <b>4 variable K-Map</b>.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_variable_k_map.jpg" alt="" />
<ul class="list">
<li><p>There is only one possibility of grouping 16 adjacent min terms.</p></li>
<li><p>Let R<sub>1</sub>, R<sub>2</sub>, R<sub>3</sub> and R<sub>4</sub> represents the min terms of first row, second row, third row and fourth row respectively. Similarly, C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub> and C<sub>4</sub> represents the min terms of first column, second column, third column and fourth column respectively. The possible combinations of grouping 8 adjacent min terms are {(R<sub>1</sub>, R<sub>2</sub>), (R<sub>2</sub>, R<sub>3</sub>), (R<sub>3</sub>, R<sub>4</sub>), (R<sub>4</sub>, R<sub>1</sub>), (C<sub>1</sub>, C<sub>2</sub>), (C<sub>2</sub>, C<sub>3</sub>), (C<sub>3</sub>, C<sub>4</sub>), (C<sub>4</sub>, C<sub>1</sub>)}.</p></li>
<li><p>If w=0, then 4 variable K-map becomes 3 variable K-map.</p></li>
</ul>
<h3>5 Variable K-Map</h3>
<p>The number of cells in 5 variable K-map is thirty-two, since the number of variables is 5. The following figure shows <b>5 variable K-Map</b>.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/5_variable_k_map.jpg" alt="5 Variable K-Map" />
<ul class="list">
<li><p>There is only one possibility of grouping 32 adjacent min terms.</p></li>
<li><p>There are two possibilities of grouping 16 adjacent min terms. i.e., grouping of min terms from m<sub>0</sub> to m<sub>15</sub> and m<sub>16</sub> to m<sub>31</sub>.</p></li>
<li><p>If v=0, then 5 variable K-map becomes 4 variable K-map.</p></li>
</ul>
<p>In the above all K-maps, we used exclusively the min terms notation. Similarly, you can use exclusively the Max terms notation.</p>
<h2>Minimization of Boolean Functions using K-Maps</h2>
<p>If we consider the combination of inputs for which the Boolean function is ‘1’, then we will get the Boolean function, which is in <b>standard sum of products</b> form after simplifying the K-map.</p>
<p>Similarly, if we consider the combination of inputs for which the Boolean function is ‘0’, then we will get the Boolean function, which is in <b>standard product of sums</b> form after simplifying the K-map.</p>
<p>Follow these <b>rules for simplifying K-maps</b> in order to get standard sum of products form.</p>
<ul class="list">
<li><p>Select the respective K-map based on the number of variables present in the Boolean function.</p></li>
<li><p>If the Boolean function is given as sum of min terms form, then place the ones at respective min term cells in the K-map. If the Boolean function is given as sum of products form, then place the ones in all possible cells of K-map for which the given product terms are valid.</p></li>
<li><p>Check for the possibilities of grouping maximum number of adjacent ones. It should be powers of two. Start from highest power of two and upto least power of two. Highest power is equal to the number of variables considered in K-map and least power is zero.</p></li>
<li><p>Each grouping will give either a literal or one product term. It is known as <b>prime implicant</b>. The prime implicant is said to be <b>essential prime implicant</b>, if atleast single ‘1’ is not covered with any other groupings but only that grouping covers.</p></li>
<li><p>Note down all the prime implicants and essential prime implicants. The simplified Boolean function contains all essential prime implicants and only the required prime implicants.</p></li>
</ul>
<p><b>Note 1</b> &minus; If outputs are not defined for some combination of inputs, then those output values will be represented with <b>don’t care symbol ‘x’</b>. That means, we can consider them as either ‘0’ or ‘1’.</p>
<p><b>Note 2</b> &minus; If don’t care terms also present, then place don’t cares ‘x’ in the respective cells of K-map. Consider only the don’t cares ‘x’ that are helpful for grouping maximum number of adjacent ones. In those cases, treat the don’t care value as ‘1’.</p>
<h3>Example</h3>
<p>Let us <b>simplify</b> the following Boolean function, <b>f(W, X, Y, Z)= WX’Y’ + WY + W’YZ’</b> using K-map.</p>
<p>The given Boolean function is in sum of products form. It is having 4 variables W, X, Y &amp; Z. So, we require <b>4 variable K-map</b>. The <b>4 variable K-map</b> with ones corresponding to the given product terms is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/minimization_example.jpg" alt="Minimization Example" />
<p>Here, 1s are placed in the following cells of K-map.</p>
<ul class="list">
<li><p>The cells, which are common to the intersection of Row 4 and columns 1 &amp; 2 are corresponding to the product term, <b>WX’Y’</b>.</p></li>
<li><p>The cells, which are common to the intersection of Rows 3 &amp; 4 and columns 3 &amp; 4 are corresponding to the product term, <b>WY</b>.</p></li>
<li><p>The cells, which are common to the intersection of Rows 1 &amp; 2 and column 4 are corresponding to the product term, <b>W’YZ’</b>.</p></li>
</ul>
<p>There are no possibilities of grouping either 16 adjacent ones or 8 adjacent ones. There are three possibilities of grouping 4 adjacent ones. After these three groupings, there is no single one left as ungrouped. So, we no need to check for grouping of 2 adjacent ones. The <b>4 variable K-map</b> with these three <b>groupings</b> is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/three_groupings.jpg" alt="Three Groupings" />
<p>Here, we got three prime implicants WX’, WY &amp; YZ’. All these prime implicants are <b>essential</b> because of following reasons.</p>
<ul class="list">
<li><p>Two ones <b>(m<sub>8</sub> &amp; m<sub>9</sub>)</b> of fourth row grouping are not covered by any other groupings. Only fourth row grouping covers those two ones.</p></li>
<li><p>Single one <b>(m<sub>15</sub>)</b> of square shape grouping is not covered by any other groupings. Only the square shape grouping covers that one.</p></li>
<li><p>Two ones <b>(m<sub>2</sub> &amp; m<sub>6</sub>)</b> of fourth column grouping are not covered by any other groupings. Only fourth column grouping covers those two ones.</p></li>
</ul>
<p>Therefore, the <b>simplified Boolean function</b> is</p>
<p style="text-align:center"><b>f= WX’ + WY + YZ’</b></p>
<p>Follow these <b>rules for simplifying K-maps</b> in order to get standard product of sums form.</p>
<ul class="list">
<li><p>Select the respective K-map based on the number of variables present in the Boolean function.</p></li>
<li><p>If the Boolean function is given as product of Max terms form, then place the zeroes at respective Max term cells in the K-map. If the Boolean function is given as product of sums form, then place the zeroes in all possible cells of K-map for which the given sum terms are valid.</p></li>
<li><p>Check for the possibilities of grouping maximum number of adjacent zeroes. It should be powers of two. Start from highest power of two and upto least power of two. Highest power is equal to the number of variables considered in K-map and least power is zero.</p></li>
<li><p>Each grouping will give either a literal or one sum term. It is known as <b>prime implicant</b>. The prime implicant is said to be <b>essential prime implicant</b>, if atleast single ‘0’ is not covered with any other groupings but only that grouping covers.</p></li>
<li><p>Note down all the prime implicants and essential prime implicants. The simplified Boolean function contains all essential prime implicants and only the required prime implicants.</p></li>
</ul>
<p><b>Note</b> &minus; If don’t care terms also present, then place don’t cares ‘x’ in the respective cells of K-map. Consider only the don’t cares ‘x’ that are helpful for grouping maximum number of adjacent zeroes. In those cases, treat the don’t care value as ‘0’.</p>
<h3>Example</h3>
<p>Let us <b>simplify</b> the following Boolean function, $f\left ( X,Y,Z \right )=\prod M\left ( 0,1,2,4 \right )$ using K-map.</p>
<p>The given Boolean function is in product of Max terms form. It is having 3 variables X, Y &amp; Z. So, we require 3 variable K-map. The given Max terms are M<sub>0</sub>, M<sub>1</sub>, M<sub>2</sub> &amp; M<sub>4</sub>. The 3 <b>variable K-map</b> with zeroes corresponding to the given Max terms is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/prime_implicants.jpg" alt="Prime Implicants" />
<p>There are no possibilities of grouping either 8 adjacent zeroes or 4 adjacent zeroes. There are three possibilities of grouping 2 adjacent zeroes. After these three groupings, there is no single zero left as ungrouped. The <b>3 variable K-map</b> with these three <b>groupings</b> is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/ungrouped.jpg" alt="ungrouped" />
<p>Here, we got three prime implicants X+Y, Y+Z &amp; Z+X. All these prime implicants are <b>essential</b> because one zero in each grouping is not covered by any other groupings except with their individual groupings.</p>
<p>Therefore, the <b>simplified Boolean function</b> is </p>
<p style="text-align:center"><b>f=(X+Y).(Y+Z).(Z+X)</b></p>
<p>In this way, we can easily simplify the Boolean functions up to 5 variables using K-map method. For more than 5 variables, it is difficult to simplify the functions using K-Maps. Because, the number of <b>cells</b> in K-map gets <b>doubled</b> by including a new variable.</p>
<p>Due to this checking and grouping of adjacent ones (min terms) or adjacent zeros (Max terms) will be complicated. We will discuss <b>Tabular method</b> in next chapter to overcome the difficulties of K-map method.</p>
<h1>Quine-McCluskey Tabular Method</h1>
<p>In previous chapter, we discussed K-map method, which is a convenient method for minimizing Boolean functions up to 5 variables. But, it is difficult to simplify the Boolean functions having more than 5 variables by using this method.</p>
<p>Quine-McClukey tabular method is a tabular method based on the concept of prime implicants. We know that <b>prime implicant</b> is a product (or sum) term, which can’t be further reduced by combining with any other product (or sum) terms of the given Boolean function.</p>
<p>This tabular method is useful to get the prime implicants by repeatedly using the following Boolean identity.</p>
<p style="text-align:center">xy+xy’=x(y+y’)=x.1=x</p>
<h2>Procedure of Quine-McCluskey Tabular Method</h2>
<p>Follow these steps for simplifying Boolean functions using Quine-McClukey tabular method.</p>
<p><b>Step 1</b> &minus; Arrange the given min terms in an <b>ascending order</b> and make the groups based on the number of ones present in their binary representations. So, there will be <b>at most ‘n+1’ groups</b> if there are ‘n’ Boolean variables in a Boolean function or ‘n’ bits in the binary equivalent of min terms.</p>
<p><b>Step 2</b> &minus; Compare the min terms present in <b>successive groups</b>. If there is a change in only one-bit position, then take the pair of those two min terms. Place this symbol ‘_’ in the differed bit position and keep the remaining bits as it is.</p>
<p><b>Step 3</b> &minus; Repeat step2 with newly formed terms till we get all <b>prime implicants</b>.</p>
<p><b>Step 4</b> &minus; Formulate the <b>prime implicant table</b>. It consists of set of rows and columns. Prime implicants can be placed in row wise and min terms can be placed in column wise. Place ‘1’ in the cells corresponding to the min terms that are covered in each prime implicant.</p>
<p><b>Step 5</b> &minus; Find the essential prime implicants by observing each column. If the min term is covered only by one prime implicant, then it is <b>essential prime implicant</b>. Those essential prime implicants will be part of the simplified Boolean function.</p>
<p><b>Step 6</b> &minus; Reduce the prime implicant table by removing the row of each essential prime implicant and the columns corresponding to the min terms that are covered in that essential prime implicant. Repeat step 5 for Reduced prime implicant table. Stop this process when all min terms of given Boolean function are over.</p>
<h3>Example</h3>
<p>Let us <b>simplify</b> the following Boolean function, $f\left ( W,X,Y,Z \right )=\sum m\left ( 2,6,8,9,10,11,14,15 \right )$ using Quine-McClukey tabular method.</p>
<p>The given Boolean function is in <b>sum of min terms</b> form. It is having 4 variables W, X, Y &amp; Z. The given min terms are 2, 6, 8, 9, 10, 11, 14 and 15. The ascending order of these min terms based on the number of ones present in their binary equivalent is 2, 8, 6, 9, 10, 11, 14 and 15. The following table shows these <b>min terms and their equivalent binary</b> representations.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Group Name</th>
<th style="text-align:center;width:20%">Min terms</th>
<th style="text-align:center">W</th>
<th style="text-align:center">X</th>
<th style="text-align:center">Y</th>
<th style="text-align:center">Z</th>
</tr>
<tr>
<td style="vertical-align:middle" rowspan="2">GA1</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td style="vertical-align:middle" rowspan="3">GA2</td>
<td>6</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>9</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="vertical-align:middle"rowspan="2">GA3</td>
<td>11</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>14</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>GA4</td>
<td>15</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>The given min terms are arranged into 4 groups based on the number of ones present in their binary equivalents. The following table shows the possible <b>merging of min terms</b> from adjacent groups.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Group Name</th>
<th style="text-align:center;width:20%">Min terms</th>
<th style="text-align:center">W</th>
<th style="text-align:center">X</th>
<th style="text-align:center">Y</th>
<th style="text-align:center">Z</th>
</tr>
<tr>
<td style="vertical-align:middle" rowspan="4">GB1</td>
<td>2,6</td>
<td>0</td>
<td>-</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2,10</td>
<td>-</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>8,9</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>-</td>
</tr>
<tr>
<td>8,10</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>0</td>
</tr>
<tr>
<td style="vertical-align:middle" rowspan="4">GB2</td>
<td>6,14</td>
<td>-</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>9,11</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>1</td>
</tr>
<tr>
<td>10,11</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>10,14</td>
<td>1</td>
<td>-</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="vertical-align:middle"rowspan="2">GB3</td>
<td>11,15</td>
<td>1</td>
<td>-</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>14,15</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-</td>
</tr>
</table>
<p>The min terms, which are differed in only one-bit position from adjacent groups are merged. That differed bit is represented with this symbol, ‘-‘. In this case, there are three groups and each group contains combinations of two min terms. The following table shows the possible <b>merging of min term pairs</b> from adjacent groups.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Group Name</th>
<th style="text-align:center;width:20%">Min terms</th>
<th style="text-align:center">W</th>
<th style="text-align:center">X</th>
<th style="text-align:center">Y</th>
<th style="text-align:center">Z</th>
</tr>
<tr>
<td style="vertical-align:middle" rowspan="4">GB1</td>
<td>2,6,10,14</td>
<td>-</td>
<td>-</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2,10,6,14</td>
<td>-</td>
<td>-</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>8,9,10,11</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>8,10,9,11</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td style="vertical-align:middle" rowspan="2">GB2</td>
<td>10,11,14,15</td>
<td>1</td>
<td>-</td>
<td>1</td>
<td>-</td>
</tr>
<tr>
<td>10,14,11,15</td>
<td>1</td>
<td>-</td>
<td>1</td>
<td>-</td>
</tr>
</table>
<p>The successive groups of min term pairs, which are differed in only one-bit position are merged. That differed bit is represented with this symbol, ‘-‘. In this case, there are two groups and each group contains combinations of four min terms. Here, these combinations of 4 min terms are available in two rows. So, we can remove the repeated rows. The reduced table after removing the redundant rows is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">Group Name</th>
<th style="text-align:center;width:20%">Min terms</th>
<th style="text-align:center">W</th>
<th style="text-align:center">X</th>
<th style="text-align:center">Y</th>
<th style="text-align:center">Z</th>
</tr>
<tr>
<td>GC1</td>
<td>2,6,10,14</td>
<td>-</td>
<td>-</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>8,9,10,11</td>
<td>1</td>
<td>0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>GC2</td>
<td>10,11,14,15</td>
<td>1</td>
<td>-</td>
<td>1</td>
<td>-</td>
</tr>
</tr>
</table>
<p>Further merging of the combinations of min terms from adjacent groups is not possible, since they are differed in more than one-bit position. There are three rows in the above table. So, each row will give one prime implicant. Therefore, the <b>prime implicants</b> are YZ’, WX’ &amp; WY.</p>
<p>The <b>prime implicant table</b> is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="vertical-align:middle;width:30%">Min terms / Prime Implicants</th>
<th>2</th>
<th>6</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>14</th>
<th>15</th>
</tr>
<tr>
<td><b>YZ’</b></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><b>WX’</b></td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td><b>WY</b></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>The prime implicants are placed in row wise and min terms are placed in column wise. 1s are placed in the common cells of prime implicant rows and the corresponding min term columns.</p>
<p>The min terms 2 and 6 are covered only by one prime implicant <b>YZ’</b>. So, it is an <b>essential prime implicant</b>. This will be part of simplified Boolean function. Now, remove this prime implicant row and the corresponding min term columns. The reduced prime implicant table is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:30%">Min terms / Prime Implicants</th>
<th style="text-align:center">8</th>
<th style="text-align:center">9</th>
<th style="text-align:center">11</th>
<th style="text-align:center">15</th>
</tr>
<tr>
<td><b>WX’</b></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><b>WY</b></td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>The min terms 8 and 9 are covered only by one prime implicant <b>WX’</b>. So, it is an <b>essential prime implicant</b>. This will be part of simplified Boolean function. Now, remove this prime implicant row and the corresponding min term columns. The reduced prime implicant table is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:30%">Min terms / Prime Implicants</th>
<th style="text-align:center">15</th>
</tr>
<tr>
<td><b>WY</b></td>
<td>1</td>
</tr>
</table>
<p>The min term 15 is covered only by one prime implicant <b>WY</b>. So, it is an <b>essential prime implicant</b>. This will be part of simplified Boolean function.</p>
<p>In this example problem, we got three prime implicants and all the three are essential. Therefore, the <b>simplified Boolean function</b> is</p>
<p style="text-align:center"><b>f(W,X,Y,Z) = YZ’ + WX’ + WY.</b></p>
<h1>Digital Circuits - Logic Gates</h1>
<p>Digital electronic circuits operate with voltages of <b>two logic levels</b>namely Logic Low and Logic High. The range of voltages corresponding to Logic Low is represented with ‘0’. Similarly, the range of voltages corresponding to Logic High is represented with ‘1’.</p>
<p>The basic digital electronic circuit that has one or more inputs and single output is known as <b>Logic gate</b>. Hence, the Logic gates are the building blocks of any digital system. We can classify these Logic gates into the following three categories.</p>
<ul class="list">
<li>Basic gates</li>
<li>Universal gates</li>
<li>Special gates</li>
</ul>
<p>Now, let us discuss about the Logic gates come under each category one by one.</p>
<h2>Basic Gates</h2>
<p>In earlier chapters, we learnt that the Boolean functions can be represented either in sum of products form or in product of sums form based on the requirement. So, we can implement these Boolean functions by using basic gates. The basic gates are AND, OR &amp; NOT gates.</p>
<h3>AND gate</h3>
<p>An AND gate is a digital circuit that has two or more inputs and produces an output, which is the <b>logical AND</b> of all those inputs. It is optional to represent the <b>Logical AND</b> with the symbol ‘.’.</p>
<p>The following table shows the <b>truth table</b> of 2-input AND gate.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:30%">A</th>
<th style="text-align:center;width:30%">B</th>
<th style="text-align:center;width:40%">Y=A.B</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Here A, B are the inputs and Y is the output of two input AND gate. If both inputs are ‘1’, then only the output, Y is ‘1’. For remaining combinations of inputs, the output, Y is ‘0’.</p>
<p>The following figure shows the <b>symbol</b> of an AND gate, which is having two inputs A, B and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/and_gate.jpg" alt="And Gate" />
<p>This AND gate produces an output (Y), which is the 
<b>logical AND</b> of two inputs A, B. Similarly, if there are ‘n’ inputs, then the AND gate produces an output, which is the logical AND of all those inputs. That means, the output of AND gate will be ‘1’, when all the inputs are ‘1’.</p>
<h3>OR gate</h3>
<p>An OR gate is a digital circuit that has two or more inputs and produces an output, which is the logical OR of all those inputs. This <b>logical OR</b> is represented with the symbol ‘+’.</p>
<p>The following table shows the <b>truth table</b> of 2-input OR gate.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:30%">A</th>
<th style="text-align:center;width:30%">B</th>
<th style="text-align:center;width:40%">Y=A+B</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Here A, B are the inputs and Y is the output of two input OR gate. If both inputs are ‘0’, then only the output, Y is ‘0’. For remaining combinations of inputs, the output, Y is ‘1’.</p>
<p>The following figure shows the <b>symbol</b> of an OR gate, which is having two inputs A, B and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/or_gate.jpg" alt="Or Gate" />
<p>This OR gate produces an output (Y), which is the <b>logical OR</b> of two inputs A, B. Similarly, if there are ‘n’ inputs, then the OR gate produces an output, which is the logical OR of all those inputs. That means, the output of an OR gate will be ‘1’, when at least one of those inputs is ‘1’.</p>
<h3>NOT gate</h3>
<p>A NOT gate is a digital circuit that has single input and single output. The output of NOT gate is the <b>logical inversion</b> of input. Hence, the NOT gate is also called as inverter.</p>
<p>The following table shows the <b>truth table</b> of NOT gate.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">Y=A’</th>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>Here A and Y are the input and output of NOT gate respectively. If the input, A is ‘0’, then the output, Y is ‘1’. Similarly, if the input, A is ‘1’, then the output, Y is ‘0’.</p>
<p>The following figure shows the <b>symbol</b> of NOT gate, which is having one input, A and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/not_gate.jpg" alt="Not Gate" />
<p>This NOT gate produces an output (Y), which is the <b>complement</b> of input, A.</p>
<h2>Universal gates</h2>
<p>NAND &amp; NOR gates are called as <b>universal gates</b>. Because we can implement any Boolean function, which is in sum of products form by using NAND gates alone. Similarly, we can implement any Boolean function, which is in product of sums form by using NOR gates alone.</p>
<h3>NAND gate</h3>
<p>NAND gate is a digital circuit that has two or more inputs and produces an output, which is the <b>inversion of logical AND</b> of all those inputs.</p>
<p>The following table shows the <b>truth table</b> of 2-input NAND gate.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">A</th>
<th style="text-align:center;width:20%">B</th>
<th style="text-align:center;width:30%">Y=(A.B)’</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>Here A, B are the inputs and Y is the output of two input NAND gate. When both inputs are ‘1’, the output, Y is ‘0’. If at least one of the input is zero, then the output, Y is ‘1’. This is just opposite to that of two input AND gate operation.</p>
<p>The following image shows the <b>symbol</b> of NAND gate, which is having two inputs A, B and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/nand_gate.jpg" alt="NAND Gate" />
<p>NAND gate operation is same as that of AND gate followed by an inverter. That’s why the NAND gate symbol is represented like that.</p>
<h3>NOR gate</h3>
<p>NOR gate is a digital circuit that has two or more inputs and produces an output, which is the <b>inversion of logical OR</b> of all those inputs.</p>
<p>The following table shows the <b>truth table</b> of 2-input NOR gate</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:20%">A</th>
<th style="text-align:center;width:20%">B</th>
<th style="text-align:center;width:30%">Y=(A+B)’ </th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>Here A, B are the inputs and Y is the output. If both inputs are ‘0’, then the output, Y is ‘1’. If at least one of the input is ‘1’, then the output, Y is ‘0’. This is just opposite to that of two input OR gate operation.</p>
<p>The following figure shows the <b>symbol</b> of NOR gate, which is having two inputs A, B and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/nor_gate.jpg" alt="NOR Gate" />
<p>NOR gate operation is same as that of OR gate followed by an inverter. That’s why the NOR gate symbol is represented like that.</p>
<h2>Special Gates</h2>
<p>Ex-OR &amp; Ex-NOR gates are called as special gates. Because, these two gates are special cases of OR &amp; NOR gates.</p>
<h3>Ex-OR gate</h3>
<p>The full form of Ex-OR gate is <b>Exclusive-OR</b> gate. Its function is same as that of OR gate except for some cases, when the inputs having even number of ones.</p>
<p>The following table shows the <b>truth table</b> of 2-input Ex-OR gate.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:30%">A</th>
<th style="text-align:center;width:30%">B</th>
<th style="text-align:center;width:40%">Y=A&oplus;B</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>Here A, B are the inputs and Y is the output of two input Ex-OR gate. The truth table of Ex-OR gate is same as that of OR gate for first three rows. The only modification is in the fourth row. That means, the output (Y) is zero instead of one, when both the inputs are one, since the inputs having even number of ones.</p>
<p>Therefore, the output of Ex-OR gate is ‘1’, when only one of the two inputs is ‘1’. And it is zero, when both inputs are same.</p>
<p>Below figure shows the <b>symbol</b> of Ex-OR gate, which is having two inputs A, B and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/exor_gate.jpg" alt="Ex-OR Gate" />
<p>Ex-OR gate operation is similar to that of OR gate, except for few combination(s) of inputs. That’s why the Ex-OR gate symbol is represented like that. The output of Ex-OR gate is ‘1’, when odd number of ones present at the inputs. Hence, the output of Ex-OR gate is also called as an <b>odd function</b>.</p>
<h3>Ex-NOR gate</h3>
<p>The full form of Ex-NOR gate is <b>Exclusive-NOR</b> gate. Its function is same as that of NOR gate except for some cases, when the inputs having even number of ones.</p>
<p>The following table shows the <b>truth table</b> of 2-input Ex-NOR gate.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">A&odot;B</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Here A, B are the inputs and Y is the output. The truth table of Ex-NOR gate is same as that of NOR gate for first three rows. The only modification is in the fourth row. That means, the output is one instead of zero, when both the inputs are one.</p>
<p>Therefore, the output of Ex-NOR gate is ‘1’, when both inputs are same. And it is zero, when both the inputs are different.</p>
<p>The following figure shows the <b>symbol</b> of Ex-NOR gate, which is having two inputs A, B and one output, Y.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/exnor_gate.jpg" alt="Ex-NOR Gate" />
<p>Ex-NOR gate operation is similar to that of NOR gate, except for few combination(s) of inputs. That’s why the Ex-NOR gate symbol is represented like that. The output of Ex-NOR gate is ‘1’, when even number of ones present at the inputs. Hence, the output of Ex-NOR gate is also called as an <b>even function</b>.</p>
<p>From the above truth tables of Ex-OR &amp; Ex-NOR logic gates, we can easily notice that the Ex-NOR operation is just the logical inversion of Ex-OR operation.</p>
<h1>Digital Circuits - Two-Level Logic Realization</h1>
<p>The maximum number of levels that are present between inputs and output is two in <b>two level logic</b>. That means, irrespective of total number of logic gates, the maximum number of Logic gates that are present (cascaded) between any input and output is two in two level logic. Here, the outputs of first level Logic gates are connected as inputs of second level Logic gate(s).</p>
<p>Consider the four Logic gates AND, OR, NAND &amp; NOR. Since, there are 4 Logic gates, we will get 16 possible ways of realizing two level logic. Those are AND-AND, AND-OR, ANDNAND, AND-NOR, OR-AND, OR-OR, OR-NAND, OR-NOR, NAND-AND, NAND-OR, NANDNAND, NAND-NOR, NOR-AND, NOR-OR, NOR-NAND, NOR-NOR.</p>
<p>These two level logic realizations can be classified into the following two categories.</p>
<ul class="list">
<li>Degenerative form</li>
<li>Non-degenerative form</li>
</ul>
<h2>Degenerative Form</h2>
<p>If the output of two level logic realization can be obtained by using single Logic gate, then it is called as <b>degenerative form</b>. Obviously, the number of inputs of single Logic gate increases. Due to this, the fan-in of Logic gate increases. This is an advantage of degenerative form.</p>
<p>Only <b>6 combinations</b> of two level logic realizations out of 16 combinations come under degenerative form. Those are AND-AND, AND-NAND, OR-OR, OR-NOR, NAND-NOR, NORNAND.</p>
<p>In this section, let us discuss some realizations. Assume, A, B, C &amp; D are the inputs and Y is the output in each logic realization.</p>
<h3>AND-AND Logic</h3>
<p>In this logic realization, AND gates are present in both levels. Below figure shows an example for <b>AND-AND logic</b> realization.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/and_and_logic.jpg" alt="And-And Logic" />
<p>We will get the outputs of first level logic gates as $Y_{1}=AB$ and $Y_{2}=CD$</p>
<p>These outputs, $Y_{1}$ and $Y_{2}$ are applied as inputs of AND gate that is present in second level. So, the output of this AND gate is</p>
<p>$$Y=Y_{1}Y_{2}$$</p>
<p>Substitute $Y_{1}$ and $Y_{2}$ values in the above equation.</p>
<p>$$Y=\left ( AB \right )\left ( CD \right )$$</p>
<p  style="padding-left:35%">$\Rightarrow Y=ABCD$</p> 
<p>Therefore, the output of this AND-AND logic realization is <b>ABCD</b>. This Boolean function can be implemented by using a 4 input AND gate. Hence, it is <b>degenerative form</b>.</p>
<h3>AND-NAND Logic</h3>
<p>In this logic realization, AND gates are present in first level and NAND gate(s) are present in second level. The following figure shows an example for <b>AND-NAND logic</b> realization.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/and_nand_logic.jpg" alt="AND-NAND Logic" />
<p>Previously, we got the outputs of first level logic gates as $Y_{1} = AB$ and $Y_{2} = CD$</p>
<p>These outputs,$Y_{1}$ and $Y_{2}$ are applied as inputs of NAND gate that is present in second level. So, the output of this NAND gate is</p>
<p>$$Y={\left ( Y_{1}Y_{2} \right )}'$$</p>
<p>Substitute $Y_{1}$ and $Y_{2}$ values in the above equation.</p>
<p>$$Y={\left ( \left ( AB \right ) \left ( CD \right )\right )}'$$</p>
<p style="padding-left:33%">$\Rightarrow Y={\left ( ABCD \right )}'$</p>
<p>Therefore, the output of this AND-NAND logic realization is ${\left ( ABCD \right )}'$. This Boolean function can be implemented by using a 4 input NAND gate. Hence, it is <b>degenerative form</b>.</p>
<h3>OR-OR Logic</h3>
<p>In this logic realization, OR gates are present in both levels. The following figure shows an example for <b>OR-OR logic</b> realization.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/or_or_logic.jpg" alt="OR-OR Logic" />
<p>We will get the outputs of first level logic gates as $Y_{1}=A+B$ and $Y_{2}=C+D$.</p>
<p>These outputs, $Y_{1}$ and $Y_{2}$ are applied as inputs of OR gate that is present in second level. So, the output of this OR gate is </p>
<p>$$Y=Y_{1}+Y_{2}$$</p>
<p>Substitute $Y_{1}$ and $Y_{2}$ values in the above equation.</p>
<p>$$Y=\left ( A+B \right )+\left ( C+D \right )$$</p>
<p style="padding-left:29%">$\Rightarrow Y=A+B+C+D$</p>
<p>Therefore, the output of this OR-OR logic realization is <b>A+B+C+D</b>. This Boolean function can be implemented by using a 4 input OR gate. Hence, it is <b>degenerative form</b>.</p>
<p>Similarly, you can verify whether the remaining realizations belong to this category or not.</p>
<h2>Non-degenerative Form</h2>
<p>If the output of two level logic realization can’t be obtained by using single logic gate, then it is called as <b>non-degenerative form</b>.</p>
<p>The remaining <b>10 combinations</b> of two level logic realizations come under nondegenerative form. Those are AND-OR, AND-NOR, OR-AND, OR-NAND, NAND-AND, NANDOR, NAND-NAND, NOR-AND, NOR-OR, NOR-NOR.</p>
<p>Now, let us discuss some realizations. Assume, A, B, C &amp; D are the inputs and Y is the output in each logic realization.</p>
<h3>AND-OR Logic</h3>
<p>In this logic realization, AND gates are present in first level and OR gate(s) are present in second level. Below figure shows an example for <b>AND-OR logic</b> realization.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/and_or_logic.jpg" alt="AND-OR Logic" />
<p>Previously, we got the outputs of first level logic gates as $Y_{1} = AB$ and $Y_{2} = CD$.</p>
<p>These outputs, Y1 and Y2 are applied as inputs of OR gate that is present in second level. So, the output of this OR gate is</p>
<p>$$Y=Y_{1}+Y_{2}$$</p>
<p>Substitute $Y_{1}$ and $Y_{2}$ values in the above equation</p>
<p>$$Y=AB+CD$$</p>
<p>Therefore, the output of this AND-OR logic realization is <b>AB+CD</b>. This Boolean function is in <b>Sum of Products</b> form. Since, we can’t implement it by using single logic gate, this AND-OR logic realization is a <b>non-degenerative form</b>.</p>
<h3>AND-NOR Logic</h3>
<p>In this logic realization, AND gates are present in first level and NOR gate(s) are present in second level. The following figure shows an example for <b>AND-NOR logic</b> realization.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/and_nor_logic.jpg" alt="AND-NOR Logic" />
<p>We know the outputs of first level logic gates as $Y_{1} = AB$ and $Y_{2} = CD$</p>
<p>These outputs, Y1 and Y2 are applied as inputs of NOR gate that is present in second level. So, the output of this NOR gate is </p>
<p>$$Y={\left ( Y_{1}+Y_{2} \right )}'$$</p>
<p>Substitute $Y_{1}$ and $Y_{2}$ values in the above equation.</p>
<p>$$Y={\left ( AB+CD \right )}'$$</p>
<p>Therefore, the output of this AND-NOR logic realization is ${\left ( AB+CD \right )}'$. This Boolean function is in <b>AND-OR-Invert</b> form. Since, we can’t implement it by using single logic gate, this AND-NOR logic realization is a <b>non-degenerative form</b></p>
<h3>OR-AND Logic</h3>
<p>In this logic realization, OR gates are present in first level &amp; AND gate(s) are present in second level. The following figure shows an example for <b>OR-AND logic</b> realization.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/or_and_logic.jpg" alt="OR-AND Logic" />
<p>Previously, we got the outputs of first level logic gates as $Y_{1}=A+B$ and $Y_{2}=C+D$.</p>
<p>These outputs, $Y_{1}$ and $Y_{2}$ are applied as inputs of AND gate that is present in second level. So, the output of this AND gate is</p>
<p>$$Y=Y_{1}Y_{2}$$</p>
<p>Substitute $Y_{1}$ and $Y_{2}$ values in the above equation.</p>
<p>$$Y = \left ( A+B \right )\left ( C+D \right )$$</p>
<p>Therefore, the output of this OR-AND logic realization is <b>(A+B) (C+D)</b>. This Boolean function is in <b>Product of Sums</b> form. Since, we can’t implement it by using single logic gate, this OR-AND logic realization is a <b>non-degenerative form</b>.</p>
<p>Similarly, you can verify whether the remaining realizations belong to this category or not.</p>
<h1>Digital Combinational Circuits</h1>
<p><b>Combinational circuits</b> consist of Logic gates. These circuits operate with binary values. The output(s) of combinational circuit depends on the combination of present inputs. The following figure shows the <b>block diagram</b> of combinational circuit.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/combinational_circuit.jpg" alt="Combinational Circuit" />
<p>This combinational circuit has ‘n’ input variables and ‘m’ outputs. Each combination of input variables will affect the output(s).</p>
<h3>Design procedure of Combinational circuits</h3>
<ul class="list">
<li><p>Find the required number of input variables and outputs from given specifications.</p></li>
<li><p>Formulate the <b>Truth table</b>. If there are ‘n’ input variables, then there will be 2n possible combinations. For each combination of input, find the output values.</p></li>
<li><p>Find the <b>Boolean expressions</b> for each output. If necessary, simplify those expressions.</p></li>
<li><p>Implement the above Boolean expressions corresponding to each output by using <b>Logic gates</b>.</p></li>
</ul>
<h2>Code Converters</h2>
<p>We have discussed various codes in the chapter named codes. The converters, which convert one code to other code are called as <b>code converters</b>. These code converters basically consist of Logic gates.</p>
<h3>Example</h3>
<p>Binary code to Gray code converter</p>
<p>Let us implement a converter, which converts a 4-bit binary code WXYZ into its equivalent Gray code ABCD.</p>
<p>The following table shows the <b>Truth table</b> of a 4-bit binary code to Gray code converter.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Binary code WXYZ</th>
<th style="text-align:center">WXYZ Gray code ABCD</th>
</tr>
<tr>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>0001</td>
<td>0001</td>
</tr>
<tr>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>0011</td>
<td>0010</td>
</tr>
<tr>
<td>0100</td>
<td>0110</td>
</tr>
<tr>
<td>0101</td>
<td>0111</td>
</tr>
<tr>
<td>0110</td>
<td>0101</td>
</tr>
<tr>
<td>0111</td>
<td>0100</td>
</tr>
<tr>
<td>1000</td>
<td>1100</td>
</tr>
<tr>
<td>1001</td>
<td>1101</td>
</tr>
<tr>
<td>1010</td>
<td>1111</td>
</tr>
<tr>
<td>1011</td>
<td>1110</td>
</tr>
<tr>
<td>1100</td>
<td>1010</td>
</tr>
<tr>
<td>1101</td>
<td>1011</td>
</tr>
<tr>
<td>1110</td>
<td>1001</td>
</tr>
<tr>
<td>1111</td>
<td>1000</td>
</tr>
</table>
<p>From Truth table, we can write the <b>Boolean functions</b> for each output bit of Gray code as below.</p>
<p>$$A=\sum m\left (8,9,10,11,12,13,14,15  \right )$$</p>
<p>$$B=\sum m\left (4,5,6,7,8,9,10,11 \right )$$</p>
<p>$$C=\sum m\left (2,3,4,5,10,11,12,13 \right )$$</p>
<p>$$D=\sum m\left (1,2,5,6,9,10,13,14 \right )$$</p>
<p>Let us simplify the above functions using 4 variable K-Maps.</p>
<p>The following figure shows the <b>4 variable K-Map</b> for simplifying <b>Boolean function, A</b>.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/boolean_function.jpg" alt="Boolean function" />
<p>By grouping 8 adjacent ones, we got $A=W$.</p>
<p>The following figure shows the <b>4 variable K-Map</b> for simplifying <b>Boolean function, B</b>.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/boolean_function_b.jpg" alt="Boolean function B" />
<p>There are two groups of 4 adjacent ones. After grouping, we will get B as</p>
<p>$$B={W}'X+W{X}'=W\oplus X $$</p>
<p>Similarly, we will get the following Boolean functions for C &amp; D after simplifying.</p>
<p>$$C={X}'Y+X{Y}'=X \oplus Y$$</p>
<p>$$D={Y}'Z+Y{Z}'=Y \oplus Z$$</p>
<p>The following figure shows the <b>circuit diagram</b> of 4-bit binary code to Gray code converter.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/code_converters.jpg" alt="Code Converters" />
<p>Since the outputs depend only on the present inputs, this 4-bit Binary code to Gray code converter is a combinational circuit. Similarly, you can implement other code converters.</p>
<h2>Parity Bit Generator</h2>
<p>There are two types of parity bit generators based on the type of parity bit being generated. <b>Even parity generator</b> generates an even parity bit. Similarly, <b>odd parity generator</b> generates an odd parity bit.</p>
<h3>Even Parity Generator</h3>
<p>Now, let us implement an even parity generator for a 3-bit binary input, WXY. It generates an even parity bit, P. If odd number of ones present in the input, then even parity bit, P should be ‘1’ so that the resultant word contains even number of ones. For other combinations of input, even parity bit, P should be ‘0’. The following table shows the <b>Truth table</b> of even parity generator.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Binary Input WXY</th>
<th style="text-align:center">Even Parity bit P</th>
</tr>
<tr>
<td>000</td>
<td>0</td>
</tr>
<tr>
<td>001</td>
<td>1</td>
</tr>
<tr>
<td>010</td>
<td>1</td>
</tr>
<tr>
<td>011</td>
<td>0</td>
</tr>
<tr>
<td>100</td>
<td>1</td>
</tr>
<tr>
<td>101</td>
<td>0</td>
</tr>
<tr>
<td>110</td>
<td>0</td>
</tr>
<tr>
<td>111</td>
<td>1</td>
</tr>
</table>
<p>From the above Truth table, we can write the <b>Boolean function</b> for even parity bit as</p>
<p>$$P={W}'{X}'Y+{W}'X{Y}'+W{X}'{Y}'+WXY$$</p>
<p style="padding-left:17%">$\Rightarrow P={W}'\left ( {X}'Y+X{Y}' \right )+W\left ({X}'{Y}'+XY  \right )$</p>
<p style="padding-left:17%">$\Rightarrow P={W}'\left ( X \oplus Y \right )+W{\left (X \oplus Y \right )}'=W \oplus X \oplus Y$</p>
<p>The following figure shows the <b>circuit diagram</b> of even parity generator.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/even_parity_generator.jpg" alt="Even Parity Generator" />
<p>This circuit consists of two <b>Exclusive-OR gates</b> having two inputs each. First ExclusiveOR gate having two inputs W &amp; X and produces an output W &oplus; X. This output is given as one input of second Exclusive-OR gate. The other input of this second Exclusive-OR gate is Y and produces an output of W &oplus; X &oplus; Y.</p>
<h3>Odd Parity Generator</h3>
<p>If even number of ones present in the input, then odd parity bit, P should be ‘1’ so that the resultant word contains odd number of ones. For other combinations of input, odd parity bit, P should be ‘0’.</p>
<p>Follow the same procedure of even parity generator for implementing odd parity generator. The <b>circuit diagram</b> of odd parity generator is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/odd_parity_generator.jpg" alt="Odd Parity Generator" />
<p>The above circuit diagram consists of Ex-OR gate in first level and Ex-NOR gate in second level. Since the odd parity is just opposite to even parity, we can place an inverter at the output of even parity generator. In that case, the first and second levels contain an ExOR gate in each level and third level consist of an inverter.</p>
<h2>Parity Checker</h2>
<p>There are two types of parity checkers based on the type of parity has to be checked. <b>Even parity checker</b> checks error in the transmitted data, which contains message bits along with even parity. Similarly, <b>odd parity checker</b> checks error in the transmitted data, which contains message bits along with odd parity.</p>
<h3>Even parity checker</h3>
<p>Now, let us implement an even parity checker circuit. Assume a 3-bit binary input, WXY is transmitted along with an even parity bit, P. So, the resultant word (data) contains 4 bits, which will be received as the input of even parity checker.</p>
<p>It generates an <b>even parity check bit, E</b>. This bit will be zero, if the received data contains an even number of ones. That means, there is no error in the received data. This even parity check bit will be one, if the received data contains an odd number of ones. That means, there is an error in the received data.</p>
<p>The following table shows the <b>Truth table</b> of an even parity checker.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">4-bit Received Data WXYP</th>
<th style="text-align:center">Even Parity Check bit E</th>
</tr>
<tr>
<td>0000</td>
<td>0</td>
</tr>
<tr>
<td>0001</td>
<td>1</td>
</tr>
<tr>
<td>0010</td>
<td>1</td>
</tr>
<tr>
<td>0011</td>
<td>0</td>
</tr>
<tr>
<td>0100</td>
<td>1</td>
</tr>
<tr>
<td>0101</td>
<td>0</td>
</tr>
<tr>
<td>0110</td>
<td>0</td>
</tr>
<tr>
<td>0111</td>
<td>1</td>
</tr>
<tr>
<td>1000</td>
<td>1</td>
</tr>
<tr>
<td>1001</td>
<td>0</td>
</tr>
<tr>
<td>1010</td>
<td>0</td>
</tr>
<tr>
<td>1011</td>
<td>1</td>
</tr>
<tr>
<td>1100</td>
<td>0</td>
</tr>
<tr>
<td>1101</td>
<td>1</td>
</tr>
<tr>
<td>1110</td>
<td>1</td>
</tr>
<tr>
<td>1111</td>
<td>0</td>
</tr>
</table>
<p>From the above Truth table, we can observe that the even parity check bit value is ‘1’, when odd number of ones present in the received data. That means the Boolean function of even parity check bit is an <b>odd function</b>. Exclusive-OR function satisfies this condition. Hence, we can directly write the <b>Boolean function</b> of even parity check bit as</p>
<p>$$E=W \oplus X \oplus Y \oplus P$$</p>
<p>The following figure shows the <b>circuit diagram</b> of even parity checker.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/parity_checker.jpg" alt="Parity Checker" />
<p>This circuit consists of three <b>Exclusive-OR gates</b> having two inputs each. The first level gates produce outputs of $W \oplus X$ &amp; $Y \oplus P$. The Exclusive-OR gate, which is in second level produces an output of $W \oplus X \oplus  Y \oplus P$</p>
<h3>Odd Parity Checker</h3>
<p>Assume a 3-bit binary input, WXY is transmitted along with odd parity bit, P. So, the resultant word (data) contains 4 bits, which will be received as the input of odd parity checker.</p>
<p>It generates an <b>odd parity check bit, E</b>. This bit will be zero, if the received data contains an odd number of ones. That means, there is no error in the received data. This odd parity check bit will be one, if the received data contains even number of ones. That means, there is an error in the received data.</p>
<p>Follow the same procedure of an even parity checker for implementing an odd parity checker. The <b>circuit diagram</b> of odd parity checker is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/odd_parity_checker.jpg" alt="Odd Parity Checker" />
<p>The above circuit diagram consists of Ex-OR gates in first level and Ex-NOR gate in second level. Since the odd parity is just opposite to even parity, we can place an inverter at the output of even parity checker. In that case, the first, second and third levels contain two Ex-OR gates, one Ex-OR gate and one inverter respectively.</p>
<h1>Digital Arithmetic Circuits</h1>
<p>In this chapter, let us discuss about the basic arithmetic circuits like Binary adder and Binary subtractor. These circuits can be operated with binary values 0 and 1.</p>
<h2>Binary Adder</h2>
<p>The most basic arithmetic operation is addition. The circuit, which performs the addition of two binary numbers is known as <b>Binary adder</b>. First, let us implement an adder, which performs the addition of two bits.</p>
<h2>Half Adder</h2>
<p>Half adder is a combinational circuit, which performs the addition of two binary numbers A and B are of <b>single bit</b>. It produces two outputs sum, S &amp; carry, C.</p>
<p>The <b>Truth table</b> of Half adder is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="2">Inputs</th>
<th style="text-align:center" colspan="2">Outputs</th>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>S</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>When we do the addition of two bits, the resultant sum can have the values ranging from 0 to 2 in decimal. We can represent the decimal digits 0 and 1 with single bit in binary. But, we can’t represent decimal digit 2 with single bit in binary. So, we require two bits for representing it in binary.</p>
<p>Let, sum, S is the Least significant bit and carry, C is the Most significant bit of the resultant sum. For first three combinations of inputs, carry, C is zero and the value of S will be either zero or one based on the <b>number of ones</b> present at the inputs. But, for last combination of inputs, carry, C is one and sum, S is zero, since the resultant sum is two.</p>
<p>From Truth table, we can directly write the <b>Boolean functions</b> for each output as</p>
<p>$$S=A \oplus B$$</p>
<p style="padding-left:42%">$C=AB$</p>
<p>We can implement the above functions with 2-input Ex-OR gate &amp; 2-input AND gate. The <b>circuit diagram</b> of Half adder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/half_adder.jpg" alt="Half Adder" />
<p>In the above circuit, a two input Ex-OR gate &amp; two input AND gate produces sum, S &amp; carry, C respectively. Therefore, Half-adder performs the addition of two bits.</p>
<h3>Full Adder</h3>
<p>Full adder is a combinational circuit, which performs the <b>addition of three bits</b> A, B and C<sub>in</sub>. Where, A &amp; B are the two parallel significant bits and C<sub>in</sub> is the carry bit, which is generated from previous stage. This Full adder also produces two outputs sum, S &amp; carry, C<sub>out</sub>, which are similar to Half adder.</p>
<p>The <b>Truth table</b> of Full adder is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="3">Inputs</th>
<th style="text-align:center" colspan="2">Outputs</th>
</tr>
<tr>
<td><b>A</b></td>
<td><b>B</b></td>
<td><b>C<sub>in</sub></b></td>
<td><b>C<sub>out</sub></b></td>
<td><b>C<sub>out</sub></b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>When we do the addition of three bits, the resultant sum can have the values ranging from 0 to 3 in decimal. We can represent the decimal digits 0 and 1 with single bit in binary. But, we can’t represent the decimal digits 2 and 3 with single bit in binary. So, we require two bits for representing those two decimal digits in binary.</p>
<p>Let, sum, S is the Least significant bit and carry, C<sub>out</sub> is the Most significant bit of resultant sum. It is easy to fill the values of outputs for all combinations of inputs in the truth table. Just count the <b>number of ones</b> present at the inputs and write the equivalent binary number at outputs. If C<sub>in</sub> is equal to zero, then Full adder truth table is same as that of Half adder truth table.</p>
<p>We will get the following <b>Boolean functions</b> for each output after simplification.</p>
<p>$$S=A \oplus B \oplus C_{in}$$</p>
<p style="padding-left:35%">$c_{out} = AB + \left ( A \oplus B \right )c_{in}$</p>
<p>The sum, S is equal to one, when odd number of ones present at the inputs. We know that Ex-OR gate produces an output, which is an odd function. So, we can use either two 2input Ex-OR gates or one 3-input Ex-OR gate in order to produce sum, S. We can implement carry, C<sub>out</sub> using two 2-input AND gates &amp; one OR gate. The <b>circuit diagram</b> of Full adder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/full_adder.jpg" alt="Full Adder" />
<p>This adder is called as <b>Full adder</b> because for implementing one Full adder, we require two Half adders and one OR gate. If C<sub>in</sub> is zero, then Full adder becomes Half adder. We can verify it easily from the above circuit diagram or from the Boolean functions of outputs of Full adder.</p>
<h3>4-bit Binary Adder</h3>
<p>The 4-bit binary adder performs the <b>addition of two 4-bit numbers</b>. Let the 4-bit binary numbers, $A=A_{3}A_{2}A_{1}A_{0}$ and $B= B_{3}B_{2}B_{1}B_{0}$. We can implement 4-bit binary adder in one of the two following ways.</p>
<ul class="list">
<li><p>Use one Half adder for doing the addition of two Least significant bits and three Full adders for doing the addition of three higher significant bits.</p></li>
<li><p>Use four Full adders for uniformity. Since, initial carry C<sub>in</sub> is zero, the Full adder which is used for adding the least significant bits becomes Half adder.</p></li>
</ul>
<p>For the time being, we considered second approach. The <b>block diagram</b> of 4-bit binary adder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/four_bit_binary_adder.jpg" alt="Four Bit Binary Adder" />
<p>Here, the 4 Full adders are cascaded. Each Full adder is getting the respective bits of two parallel inputs A &amp; B. The carry output of one Full adder will be the carry input of subsequent higher order Full adder. This 4-bit binary adder produces the resultant sum having at most 5 bits. So, carry out of last stage Full adder will be the MSB.</p>
<p>In this way, we can implement any higher order binary adder just by cascading the required number of Full adders. This binary adder is also called as <b>ripple carry (binary) adder</b> because the carry propagates (ripples) from one stage to the next stage.</p>
<h2>Binary Subtractor</h2>
<p>The circuit, which performs the subtraction of two binary numbers is known as <b>Binary subtractor</b>. We can implement Binary subtractor in following two methods.</p>
<ul class="list">
<li>Cascade Full subtractors</li>
<li>2’s complement method</li>
</ul>
<p>In first method, we will get an n-bit binary subtractor by cascading ‘n’ Full subtractors. So, first you can implement Half subtractor and Full subtractor, similar to Half adder &amp; Full adder. Then, you can implement an n-bit binary subtractor, by cascading ‘n’ Full subtractors. So, we will be having two separate circuits for binary addition and subtraction of two binary numbers.</p>
<p>In second method, we can use same binary adder for subtracting two binary numbers just by doing some modifications in the second input. So, internally binary addition operation takes place but, the output is resultant subtraction.</p>
<p>We know that the subtraction of two binary numbers A &amp; B can be written as,</p>
<p>$$A-B = A+\left ( {2}'s \: compliment \: of \: B \right )$$</p>
<p style="padding-left:21%">$\Rightarrow A-B = A+\left ( {1}'s \: compliment \: of \: B \right )+1$</p>
<h3>4-bit Binary Subtractor</h3>
<p>The 4-bit binary subtractor produces the <b>subtraction of two 4-bit numbers</b>. Let the 4bit binary numbers, $A=A_{3}A_{2}A_{1}A_{0}$ and $B= B_{3}B_{2}B_{1}B_{0}$. Internally, the operation of 4-bit Binary subtractor is similar to that of 4-bit Binary adder. If the normal bits of binary number A, complemented bits of binary number B and initial carry (borrow), C<sub>in</sub> as one are applied to 4-bit Binary adder, then it becomes 4-bit Binary subtractor. The <b>block diagram</b> of 4-bit binary subtractor is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_bit_binary_subtractor.jpg" alt="4 Bit Binary Subtractor" />
<p>This 4-bit binary subtractor produces an output, which is having at most 5 bits. If Binary number A is greater than Binary number B, then MSB of the output is zero and the remaining bits hold the magnitude of A-B. If Binary number A is less than Binary number B, then MSB of the output is one. So, take the 2’s complement of output in order to get the magnitude of A-B.</p>
<p>In this way, we can implement any higher order binary subtractor just by cascading the required number of Full adders with necessary modifications.</p>
<h2>Binary Adder / Subtractor</h2>
<p>The circuit, which can be used to perform either addition or subtraction of two binary numbers at any time is known as <b>Binary Adder / subtractor</b>. Both, Binary adder and Binary subtractor contain a set of Full adders, which are cascaded. The input bits of binary number A are directly applied in both Binary adder and Binary subtractor.</p>
<p>There are two differences in the inputs of Full adders that are present in Binary adder and Binary subtractor.</p>
<ul class="list">
<li><p>The input bits of binary number B are directly applied to Full adders in Binary adder, whereas the complemented bits of binary number B are applied to Full adders in Binary subtractor.</p></li>
<li><p>The initial carry, C<sub>0</sub> = 0 is applied in 4-bit Binary adder, whereas the initial carry (borrow), C<sub>0</sub> = 1 is applied in 4-bit Binary subtractor.</p></li>
</ul>
<p>We know that a <b>2-input Ex-OR gate</b> produces an output, which is same as that of first input when other input is zero. Similarly, it produces an output, which is complement of first input when other input is one.</p>
<p>Therefore, we can apply the input bits of binary number B, to 2-input Ex-OR gates. The other input to all these Ex-OR gates is C<sub>0</sub>. So, based on the value of C<sub>0</sub>, the Ex-OR gates produce either the normal or complemented bits of binary number B.</p>
<h3>4-bit Binary Adder / Subtractor</h3>
<p>The 4-bit binary adder / subtractor produces either the addition or the subtraction of two 4-bit numbers based on the value of initial carry or borrow, C<sub>0</sub>. Let the 4-bit binary numbers, $A=A_{3}A_{2}A_{1}A_{0}$ and $B= B_{3}B_{2}B_{1}B_{0}$. The operation of 4-bit Binary adder / subtractor is similar to that of 4-bit Binary adder and 4-bit Binary subtractor.</p>
<p>Apply the normal bits of binary numbers A and B &amp; initial carry or borrow, C<sub>0</sub> from externally to a 4-bit binary adder. The <b>block diagram</b> of 4-bit binary adder / subtractor is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/adder_subtractor.jpg" alt="Adder and Subtractor" />
<p>If initial carry, C<sub>0</sub> is zero, then each full adder gets the normal bits of binary numbers A &amp; B. So, the 4-bit binary adder / subtractor produces an output, which is the <b>addition of two binary numbers</b> A &amp; B.</p>
<p>If initial borrow, 𝐶<sub>0</sub> is one, then each full adder gets the normal bits of binary number A &amp; complemented bits of binary number B. So, the 4-bit binary adder / subtractor produces an output, which is the <b>subtraction of two binary numbers</b> A &amp; B.</p>
<p>Therefore, with the help of additional Ex-OR gates, the same circuit can be used for both addition and subtraction of two binary numbers.</p>
<h1>Digital Circuits - Decoders</h1>
<p><b>Decoder</b> is a combinational circuit that has ‘n’ input lines and maximum of 2<sup>n</sup> output lines. One of these outputs will be active High based on the combination of inputs present, when the decoder is enabled. That means decoder detects a particular code. The outputs of the decoder are nothing but the <b>min terms</b> of ‘n’ input variables (lines), when it is enabled.</p>
<h2>2 to 4 Decoder</h2>
<p>Let 2 to 4 Decoder has two inputs A<sub>1</sub> &amp; A<sub>0</sub> and four outputs Y<sub>3</sub>, Y<sub>2</sub>, Y<sub>1</sub> &amp; Y<sub>0</sub>. The <b>block diagram</b> of 2 to 4 decoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/2_to_4_decoder.jpg" alt="2 to 4 Decoder" />
<p>One of these four outputs will be ‘1’ for each combination of inputs when enable, E is ‘1’. The <b>Truth table</b> of 2 to 4 decoder is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Enable</th>
<th style="text-align:center" colspan="2">Inputs </th>
<th style="text-align:center" colspan="4">Outputs</th>
</tr>
<tr>
<td><b>E</b></td>
<td><b>A<sub>1</sub></b></td>
<td><b>A<sub>0</sub></b></td>
<td><b>Y<sub>3</sub></b></td>
<td><b>Y<sub>2</sub></b></td>
<td><b>Y<sub>1</sub></b></td>
<td><b>Y<sub>0</sub></b></td>
</tr>
<tr>
<td>0</td>
<td>x</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>From Truth table, we can write the <b>Boolean functions</b> for each output as</p>
<p>$$Y_{3}=E.A_{1}.A_{0}$$</p>
<p>$$ Y_{2}=E.A_{1}.{A_{0}}'$$</p>
<p>$$ Y_{1}=E.{A_{1}}'.A_{0}$$</p>
<p>$$ Y_{0}=E.{A_{1}}'.{A_{0}}'$$</p>
<p>Each output is having one product term. So, there are four product terms in total. We can implement these four product terms by using four AND gates having three inputs each &amp; two inverters. The <b>circuit diagram</b> of 2 to 4 decoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/2_4_decoder_circuit_diagram.jpg" alt="2 to 4 Decoder Circuit Diagram" />
<p>Therefore, the outputs of 2 to 4 decoder are nothing but the <b>min terms</b> of two input variables A<sub>1</sub> &amp; A<sub>0</sub>, when enable, E is equal to one. If enable, E is zero, then all the outputs of decoder will be equal to zero.</p>
<p>Similarly, 3 to 8 decoder produces eight min terms of three input variables A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub> and 4 to 16 decoder produces sixteen min terms of four input variables A<sub>3</sub>, A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub>.</p>
<h2>Implementation of Higher-order Decoders</h2>
<p>Now, let us implement the following two higher-order decoders using lower-order decoders.</p>
<ul class="list">
<li>3 to 8 decoder</li>
<li>4 to 16 decoder</li>
</ul>
<h3>3 to 8 Decoder</h3>
<p>In this section, let us implement <b>3 to 8 decoder using 2 to 4 decoders</b>. We know that 2 to 4 Decoder has two inputs, A<sub>1</sub> &amp; A<sub>0</sub> and four outputs, Y<sub>3</sub> to Y<sub>0</sub>. Whereas, 3 to 8 Decoder has three inputs A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub> and eight outputs, Y<sub>7</sub> to Y<sub>0</sub>.</p>
<p>We can find the number of lower order decoders required for implementing higher order decoder using the following formula.</p>
<p>$$Required \: number \: of \: lower \: order \: decoders=\frac{m_{2}}{m_{1}}$$</p>
<p>Where,</p>
<p>$m_{1}$ is the number of outputs of lower order decoder.</p>
<p>$m_{2}$ is the number of outputs of higher order decoder.</p>
<p>Here, $m_{1}$ = 4 and $m_{2}$ = 8. Substitute, these two values in the above formula.</p>
<p>$$Required \: number \: of \: 2 \: to \: 4 \: decoders=\frac{8}{4}=2$$</p>
<p>Therefore, we require two 2 to 4 decoders for implementing one 3 to 8 decoder. The <b>block diagram</b> of 3 to 8 decoder using 2 to 4 decoders is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/3_8_decoder.jpg" alt="2 to 8 Decoder" />
<p>The parallel inputs A<sub>1</sub> &amp; A<sub>0</sub> are applied to each 2 to 4 decoder. The complement of input A<sub>2</sub> is connected to Enable, E of lower 2 to 4 decoder in order to get the outputs, Y<sub>3</sub> to Y<sub>0</sub>. These are the <b>lower four min terms</b>. The input, A<sub>2</sub> is directly connected to Enable, E of upper 2 to 4 decoder in order to get the outputs, Y<sub>7</sub> to Y<sub>4</sub>. These are the <b>higher four min terms</b>.</p>
<h3>4 to 16 Decoder</h3>
<p>In this section, let us implement <b>4 to 16 decoder using 3 to 8 decoders</b>. We know that 3 to 8 Decoder has three inputs A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub> and eight outputs, Y<sub>7</sub> to Y<sub>0</sub>. Whereas, 4 to 16 Decoder has four inputs A<sub>3</sub>, A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub> and sixteen outputs, Y<sub>15</sub> to Y<sub>0</sub></p>
<p>We know the following formula for finding the number of lower order decoders required.</p>
<p>$$Required \: number \: of \: lower \: order \: decoders=\frac{m_{2}}{m_{1}}$$</p>
<p>Substitute, $m_{1}$ = 8 and $m_{2}$ = 16 in the above formula.</p>
<p>$$Required \: number \: of \: 3 \: to \: 8 decoders=\frac{16}{8}=2$$</p>
<p>Therefore, we require two 3 to 8 decoders for implementing one 4 to 16 decoder. The <b>block diagram</b> of 4 to 16 decoder using 3 to 8 decoders is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_16 decoder.jpg" alt="4 to 16 Decoder" />
<p>The parallel inputs A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub> are applied to each 3 to 8 decoder. The complement of input, A3 is connected to Enable, E of lower 3 to 8 decoder in order to get the outputs, Y<sub>7</sub> to Y<sub>0</sub>. These are the <b>lower eight min terms</b>. The input, A<sub>3</sub> is directly connected to Enable, E of upper 3 to 8 decoder in order to get the outputs, Y<sub>15</sub> to Y<sub>8</sub>. These are the <b>higher eight min terms</b>.</p>
<h1>Digital Circuits - Encoders</h1>
<p>An <b>Encoder</b> is a combinational circuit that performs the reverse operation of Decoder. It has maximum of 2<sup>n</sup> input lines and ‘n’ output lines. It will produce a binary code equivalent to the input, which is active High. Therefore, the encoder encodes 2<sup>n</sup> input lines with ‘n’ bits. It is optional to represent the enable signal in encoders.</p>
<h2>4 to 2 Encoder</h2>
<p>Let 4 to 2 Encoder has four inputs Y<sub>3</sub>, Y<sub>2</sub>, Y<sub>1</sub> &amp; Y<sub>0</sub> and two outputs A<sub>1</sub> &amp; A<sub>0</sub>. The <b>block diagram</b> of 4 to 2 Encoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_2_encoder.jpg" alt="4 to 2 Encoder" />
<p>At any time, only one of these 4 inputs can be ‘1’ in order to get the respective binary code at the output. The <b>Truth table</b> of 4 to 2 encoder is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="4">Inputs</th>
<th style="text-align:center" colspan="2">Outputs</th>
<tr>
<td><b>Y<sub>3</sub></b></td>
<td><b>Y<sub>2</sub></b></td>
<td><b>Y<sub>1</sub></b></td>
<td><b>Y<sub>0</sub></b></td>
<td><b>A<sub>1</sub></b></td>
<td><b>A<sub>0</sub></b></td>
</tr>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>From Truth table, we can write the <b>Boolean functions</b> for each output as</p>
<p>$$A_{1}=Y_{3}+Y_{2}$$</p>
<p>$$A_{0}=Y_{3}+Y_{1}$$</p>
<p>We can implement the above two Boolean functions by using two input OR gates. The <b>circuit diagram</b> of 4 to 2 encoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_2_encoder_circuit_diagram.jpg" alt="4 to 2 Encoder Circuit Diagram" />
<p>The above circuit diagram contains two OR gates. These OR gates encode the four inputs with two bits</p>
<h2>Octal to Binary Encoder</h2>
<p>Octal to binary Encoder has eight inputs, Y<sub>7</sub> to Y<sub>0</sub> and three outputs A<sub>2</sub>, A<sub>1</sub> &amp; A<sub>0</sub>. Octal to binary encoder is nothing but 8 to 3 encoder. The <b>block diagram</b> of octal to binary Encoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/octal_to_binary_encoder.jpg" alt="Octal to Binary Encoder" />
<p>At any time, only one of these eight inputs can be ‘1’ in order to get the respective binary code. The <b>Truth table</b> of octal to binary encoder is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="8">Inputs </th>
<th style="text-align:center" colspan="3">Outputs</th>
</tr>
<tr>
<td><b>Y<sub>7</sub></b></td>
<td><b>Y<sub>6</sub></b></td>
<td><b>Y<sub>5</sub></td>
<td><b>Y<sub>4</sub></td>
<td><b>Y<sub>3</sub></td>
<td><b>Y<sub>2</sub></td>
<td><b>Y<sub>1</sub></td>
<td><b>Y<sub>0</sub></td>
<td><b>A<sub>2</sub></b></td>
<td><b>A<sub>1</sub></td>
<td><b>A<sub>0</sub></b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>From Truth table, we can write the <b>Boolean functions</b> for each output as</p>
<p>$$A_{2}=Y_{7}+Y_{6}+Y_{5}+Y_{4}$$</p>
<p>$$A_{1}=Y_{7}+Y_{6}+Y_{3}+Y_{2}$$</p>
<p>$$A_{0}=Y_{7}+Y_{5}+Y_{3}+Y_{1}$$</p>
<p>We can implement the above Boolean functions by using four input OR gates. The <b>circuit diagram</b> of octal to binary encoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/octal_to_binary_encoder_circuit_diagram.jpg" alt="Octal to Binary Encoder Circuit Diagram" />
<p>The above circuit diagram contains three 4-input OR gates. These OR gates encode the eight inputs with three bits.</p>
<h3>Drawbacks of Encoder</h3>
<p>Following are the drawbacks of normal encoder.</p>
<ul class="list">
<li><p>There is an ambiguity, when all outputs of encoder are equal to zero. Because, it could be the code corresponding to the inputs, when only least significant input is one or when all inputs are zero.</p></li>
<li><p>If more than one input is active High, then the encoder produces an output, which may not be the correct code. For <b>example</b>, if both Y<sub>3</sub> and Y<sub>6</sub> are ‘1’, then the encoder produces 111 at the output. This is neither equivalent code corresponding to Y<sub>3</sub>, when it is ‘1’ nor the equivalent code corresponding to Y<sub>6</sub>, when it is ‘1’.</p></li>
</ul>
<p>So, to overcome these difficulties, we should assign priorities to each input of encoder. Then, the output of encoder will be the (binary) code corresponding to the active High input(s), which has higher priority. This encoder is called as <b>priority encoder</b>.</p>
<h2>Priority Encoder</h2>
<p>A 4 to 2 priority encoder has four inputs Y<sub>3</sub>, Y<sub>2</sub>, Y<sub>1</sub> &amp; Y<sub>0</sub> and two outputs A<sub>1</sub> &amp; A<sub>0</sub>. Here, the input, Y<sub>3</sub> has the highest priority, whereas the input, Y<sub>0</sub> has the lowest priority. In this case, even if more than one input is ‘1’ at the same time, the output will be the (binary) code corresponding to the input, which is having <b>higher priority</b>.</p>
<p>We considered one more <b>output, V</b> in order to know, whether the code available at outputs is valid or not.</p>
<ul class="list">
<li><p>If at least one input of the encoder is ‘1’, then the code available at outputs is a valid one. In this case, the output, V will be equal to 1.</p></li>
<li><p>If all the inputs of encoder are ‘0’, then the code available at outputs is not a valid one. In this case, the output, V will be equal to 0.</p></li>
</ul>
<p>The <b>Truth table</b> of 4 to 2 priority encoder is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="4">Inputs</th>
<th style="text-align:center" colspan="3">Outputs</th>
</tr>
<tr>
<td><b>Y<sub>3</sub></b></td>
<td><b>Y<sub>2</sub></b></td>
<td><b>Y<sub>1</sub></b></td>
<td><b>Y<sub>0</sub></b></td>
<td><b>A<sub>1</sub></b></td>
<td><b>A<sub>0</sub></b></td>
<td><b>V</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>x</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>x</td>
<td>x</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Use <b>4 variable K-maps</b> for getting simplified expressions for each output.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/k_map.jpg" alt="K Map" />
<p>The simplified <b>Boolean functions</b> are</p>
<p>$$A_{1}=Y_{3}+Y_{2}$$</p>
<p style="padding-left:41%">$A_{0}=Y_{3}+{Y_{2}}'Y_{1}$</p>
<p>Similarly, we will get the Boolean function of output, V as</p>
<p>$$V=Y_{3}+Y_{2}+Y_{1}+Y_{0}$$</p>
<p>We can implement the above Boolean functions using logic gates. The <b>circuit diagram</b> of 4 to 2 priority encoder is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/priority_encoder.jpg" alt="Priority Encoder" />
<p>The above circuit diagram contains two 2-input OR gates, one 4-input OR gate, one 2input AND gate &amp; an inverter. Here AND gate &amp; inverter combination are used for producing a valid code at the outputs, even when multiple inputs are equal to ‘1’ at the same time. Hence, this circuit encodes the four inputs with two bits based on the <b>priority</b> assigned to each input.</p>
<h1>Digital Circuits - Multiplexers</h1>
<p><b>Multiplexer</b> is a combinational circuit that has maximum of 2<sup>n</sup> data inputs, ‘n’ selection lines and single output line. One of these data inputs will be connected to the output based on the values of selection lines.</p>
<p>Since there are ‘n’ selection lines, there will be 2<sup>n</sup> possible combinations of zeros and ones. So, each combination will select only one data input. Multiplexer is also called as <b>Mux</b>.</p>
<h2>4x1 Multiplexer</h2>
<p>4x1 Multiplexer has four data inputs I<sub>3</sub>, I<sub>2</sub>, I<sub>1</sub> &amp; I<sub>0</sub>, two selection lines s<sub>1</sub> &amp; s<sub>0</sub> and one output Y. The <b>block diagram</b> of 4x1 Multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_1_multiplexer.jpg" alt="4x1 Multiplexer" />
<p>One of these 4 inputs will be connected to the output based on the combination of inputs present at these two selection lines. <b>Truth table</b> of 4x1 Multiplexer is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="2">Selection Lines</th>
<th style="text-align:center">Output</th>
</tr>
<tr>
<td><b>S<sub>1</sub></b></td>
<td><b>S<sub>0</sub></b></td>
<td><b>Y</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>I<sub>0</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>I<sub>1</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>I<sub>2</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>I<sub>3</sub></td>
</tr>
</table>
<p>From Truth table, we can directly write the <b>Boolean function</b> for output, Y as</p>
<p>$$Y={S_{1}}'{S_{0}}'I_{0}+{S_{1}}'S_{0}I_{1}+S_{1}{S_{0}}'I_{2}+S_{1}S_{0}I_{2}$$</p>
<p>We can implement this Boolean function using Inverters, AND gates &amp; OR gate. The <b>circuit diagram</b> of 4x1 multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/4_1_multiplexer_circuit_diagram.jpg" alt="4 to 1 Multiplexer Circuit Diagram" />
<p>We can easily understand the operation of the above circuit. Similarly, you can implement 8x1 Multiplexer and 16x1 multiplexer by following the same procedure.</p>
<h2>Implementation of Higher-order Multiplexers.</h2>
<p>Now, let us implement the following two higher-order Multiplexers using lower-order Multiplexers.</p>
<ul class="list">
<li>8x1 Multiplexer</li>
<li>16x1 Multiplexer</li>
</ul>
<h3>8x1 Multiplexer</h3>
<p>In this section, let us implement 8x1 Multiplexer using 4x1 Multiplexers and 2x1 Multiplexer. We know that 4x1 Multiplexer has 4 data inputs, 2 selection lines and one output. Whereas, 8x1 Multiplexer has 8 data inputs, 3 selection lines and one output.</p>
<p>So, we require two <b>4x1 Multiplexers</b> in first stage in order to get the 8 data inputs. Since, each 4x1 Multiplexer produces one output, we require a <b>2x1 Multiplexer</b> in second stage by considering the outputs of first stage as inputs and to produce the final output.</p>
<p>Let the 8x1 Multiplexer has eight data inputs I<sub>7</sub> to I<sub>0</sub>, three selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s0 and one output Y. The <b>Truth table</b> of 8x1 Multiplexer is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="3">Selection Inputs</th>
<th style="text-align:center">Output</th>
</tr>
<tr>
<td><b>S<sub>2</sub></b></td>
<td><b>S<sub>1</sub></b></td>
<td><b>S<sub>0</sub></b></td>
<td><b>Y</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>I<sub>0</sub></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>I<sub>1</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>I<sub>2</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>I<sub>3</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>I<sub>4</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>I<sub>5</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>I<sub>6</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>I<sub>7</sub></td>
</tr>
</table>
<p>We can implement 8x1 Multiplexer using lower order Multiplexers easily by considering the above Truth table. The <b>block diagram</b> of 8x1 Multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/8_1_multiplexer.jpg" alt="8 to 1 Multiplexer" />
<p>The same <b>selection lines, s<sub>1</sub> &amp; s<sub>0</sub></b> are applied to both 4x1 Multiplexers. The data inputs of upper 4x1 Multiplexer are I<sub>7</sub> to I<sub>4</sub> and the data inputs of lower 4x1 Multiplexer are I<sub>3</sub> to I<sub>0</sub>. Therefore, each 4x1 Multiplexer produces an output based on the values of selection lines, s<sub>1</sub> &amp; s<sub>0</sub>.</p>
<p>The outputs of first stage 4x1 Multiplexers are applied as inputs of 2x1 Multiplexer that is present in second stage. The other <b>selection line, s<sub>2</sub></b> is applied to 2x1 Multiplexer.</p>
<ul class="list">
<li><p>If s<sub>2</sub> is zero, then the output of 2x1 Multiplexer will be one of the 4 inputs I<sub>3</sub> to I<sub>0</sub> based on the values of selection lines s<sub>1</sub> &amp; s<sub>0</sub>.</p></li>
<li><p>If s<sub>2</sub> is one, then the output of 2x1 Multiplexer will be one of the 4 inputs I<sub>7</sub> to I<sub>4</sub> based on the values of selection lines s<sub>1</sub> &amp; s<sub>0</sub>.</p></li>
</ul>
<p>Therefore, the overall combination of two 4x1 Multiplexers and one 2x1 Multiplexer performs as one 8x1 Multiplexer.</p>
<h3>16x1 Multiplexer</h3>
<p>In this section, let us implement 16x1 Multiplexer using 8x1 Multiplexers and 2x1 Multiplexer. We know that 8x1 Multiplexer has 8 data inputs, 3 selection lines and one output. Whereas, 16x1 Multiplexer has 16 data inputs, 4 selection lines and one output.</p>
<p>So, we require two <b>8x1 Multiplexers</b> in first stage in order to get the 16 data inputs. Since, each 8x1 Multiplexer produces one output, we require a 2x1 Multiplexer in second stage by considering the outputs of first stage as inputs and to produce the final output.</p>
<p>Let the 16x1 Multiplexer has sixteen data inputs I<sub>15</sub> to I<sub>0</sub>, four selection lines s<sub>3</sub> to s<sub>0</sub> and one output Y. The <b>Truth table</b> of 16x1 Multiplexer is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="4">Selection Inputs</th>
<th style="text-align:center">Output</th>
</tr>
<tr>
<td><b>S<sub>3</sub></b></td>
<td><b>S<sub>2</sub></b></td>
<td><b>S<sub>1</sub></b></td>
<td><b>S<sub>0</sub></b></td>
<td><b>Y</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>I<sub>0</sub></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>I<sub>1</sub></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>I<sub>2</sub></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>I<sub>3</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>I<sub>4</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>I<sub>5</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>I<sub>6</sub></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>I<sub>7</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>I<sub>8</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>I<sub>9</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>I<sub>10</sub></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>I<sub>11</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>I<sub>12</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>I<sub>13</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>I<sub>14</sub></td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>I<sub>15</sub></td>
</tr>
</table>
<p>We can implement 16x1 Multiplexer using lower order Multiplexers easily by considering the above Truth table. The <b>block diagram</b> of 16x1 Multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/16_1_multiplexer.jpg" alt="16 to 1 Multiplexer" />
<p>The <b>same selection lines, s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub></b> are applied to both 8x1 Multiplexers. The data inputs of upper 8x1 Multiplexer are I<sub>15</sub> to I<sub>8</sub> and the data inputs of lower 8x1 Multiplexer are I<sub>7</sub> to I<sub>0</sub>. Therefore, each 8x1 Multiplexer produces an output based on the values of selection lines, s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub>.</p>
<p>The outputs of first stage 8x1 Multiplexers are applied as inputs of 2x1 Multiplexer that is present in second stage. The other <b>selection line, s<sub>3</sub></b> is applied to 2x1 Multiplexer.</p>
<ul class="list">
<li><p>If s<sub>3</sub> is zero, then the output of 2x1 Multiplexer will be one of the 8 inputs Is<sub>7</sub> to I<sub>0</sub> based on the values of selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub>.</p></li>
<li><p>If s<sub>3</sub> is one, then the output of 2x1 Multiplexer will be one of the 8 inputs I<sub>15</sub> to I<sub>8</sub> based on the values of selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub>.</p></li>
</ul>
<p>Therefore, the overall combination of two 8x1 Multiplexers and one 2x1 Multiplexer performs as one 16x1 Multiplexer.</p>
<h1>Digital Circuits - De-Multiplexers</h1>
<p><b>De-Multiplexer</b> is a combinational circuit that performs the reverse operation of Multiplexer. It has single input, ‘n’ selection lines and maximum of 2<sup>n</sup> outputs. The input will be connected to one of these outputs based on the values of selection lines.</p>
<p>Since there are ‘n’ selection lines, there will be 2<sup>n</sup> possible combinations of zeros and ones. So, each combination can select only one output. De-Multiplexer is also called as <b>De-Mux</b>.</p>
<h2>1x4 De-Multiplexer</h2>
<p>1x4 De-Multiplexer has one input I, two selection lines, s<sub>1</sub> &amp; s<sub>0</sub> and four outputs Y<sub>3</sub>, Y<sub>2</sub>, Y<sub>1</sub> &amp;Y<sub>0</sub>. The <b>block diagram</b> of 1x4 De-Multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/1_4_demultiplexer.jpg" alt="1 to 4 De-Multiplexer" />
<p>The single input ‘I’ will be connected to one of the four outputs, Y<sub>3</sub> to Y<sub>0</sub> based on the values of selection lines s<sub>1</sub> &amp; s0. The <b>Truth table</b> of 1x4 De-Multiplexer is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="2">Selection Inputs</th>
<th style="text-align:center" colspan="4">Outputs</th>
</tr>
<tr>
<td style="text-align:center"><b>S<sub>1</sub></b></td>
<td style="text-align:center"><b>S<sub>0</sub></b></td>
<td style="text-align:center"><b>Y<sub>3</sub></b></td>
<td style="text-align:center"><b>Y<sub>2</sub></b></td>
<td style="text-align:center"><b>Y<sub>1</sub></b></td>
<td style="text-align:center"><b>Y<sub>0</sub></b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>From the above Truth table, we can directly write the <b>Boolean functions</b> for each output as</p>
<p>$$Y_{3}=s_{1}s_{0}I$$</p>
<p>$$Y_{2}=s_{1}{s_{0}}'I$$</p>
<p>$$Y_{1}={s_{1}}'s_{0}I$$</p>
<p>$$Y_{0}={s_1}'{s_{0}}'I$$</p>
<p>We can implement these Boolean functions using Inverters &amp; 3-input AND gates. The <b>circuit diagram</b> of 1x4 De-Multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/1_4_demultiplexer_circuit_diagram.jpg" alt="1x4 De-Multiplexer Circuit Diagram" />
<p>We can easily understand the operation of the above circuit. Similarly, you can implement 1x8 De-Multiplexer and 1x16 De-Multiplexer by following the same procedure.</p>
<h2>Implementation of Higher-order De-Multiplexers</h2>
<p>Now, let us implement the following two higher-order De-Multiplexers using lower-order De-Multiplexers.</p>
<ul class="list">
<li>1x8 De-Multiplexer</li>
<li>1x16 De-Multiplexer</li>
</ul>
<h3>1x8 De-Multiplexer</h3>
<p>In this section, let us implement 1x8 De-Multiplexer using 1x4 De-Multiplexers and 1x2 De-Multiplexer. We know that 1x4 De-Multiplexer has single input, two selection lines and four outputs. Whereas, 1x8 De-Multiplexer has single input, three selection lines and eight outputs.</p>
<p>So, we require two <b>1x4 De-Multiplexers</b> in second stage in order to get the final eight outputs. Since, the number of inputs in second stage is two, we require <b>1x2 DeMultiplexer</b> in first stage so that the outputs of first stage will be the inputs of second stage. Input of this 1x2 De-Multiplexer will be the overall input of 1x8 De-Multiplexer.</p>
<p>Let the 1x8 De-Multiplexer has one input I, three selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub> and outputs Y<sub>7</sub> to Y<sub>0</sub>. The <b>Truth table</b> of 1x8 De-Multiplexer is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="3">Selection Inputs</th>
<th style="text-align:center" colspan="8">Outputs</th>
</tr>
<tr>
<td><b>s<sub>2</sub></b></td>
<td><b>s<sub>1</sub></b></td>
<td><b>s<sub>0</sub></b></td>
<td><b>Y<sub>7</sub></b></td>
<td><b>Y<sub>6</sub></b></td>
<td><b>Y<sub>5</sub></b></td>
<td><b>Y<sub>4</sub></b></td>
<td><b>Y<sub>3</sub></b></td>
<td><b>Y<sub>2</sub></b></td>
<td><b>Y<sub>1</sub></b></td>
<td><b>Y<sub>0</sub></b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td><b>I</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>We can implement 1x8 De-Multiplexer using lower order Multiplexers easily by considering the above Truth table. The <b>block diagram</b> of 1x8 De-Multiplexer is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/1_8_demultiplexer.jpg" alt="1 to 8 De-Multiplexer" />
<p>The common <b>selection lines, s<sub>1</sub> &amp; s<sub>0</sub></b> are applied to both 1x4 De-Multiplexers. The outputs of upper 1x4 De-Multiplexer are Y<sub>7</sub> to Y<sub>4</sub> and the outputs of lower 1x4 De-Multiplexer are Y<sub>3</sub> to Y<sub>0</sub>.</p>
<p>The other <b>selection line, s<sub>2</sub></b> is applied to 1x2 De-Multiplexer. If s<sub>2</sub> is zero, then one of the four outputs of lower 1x4 De-Multiplexer will be equal to input, I based on the values of selection lines s<sub>1</sub> &amp; s<sub>0</sub>. Similarly, if s<sub>2</sub> is one, then one of the four outputs of upper 1x4 DeMultiplexer will be equal to input, I based on the values of selection lines s<sub>1</sub> &amp; s<sub>0</sub>.</p>
<h3>1x16 De-Multiplexer</h3>
<p>In this section, let us implement 1x16 De-Multiplexer using 1x8 De-Multiplexers and 1x2 De-Multiplexer. We know that 1x8 De-Multiplexer has single input, three selection lines and eight outputs. Whereas, 1x16 De-Multiplexer has single input, four selection lines and sixteen outputs.</p>
<p>So, we require two <b>1x8 De-Multiplexers</b> in second stage in order to get the final sixteen outputs. Since, the number of inputs in second stage is two, we require <b>1x2 DeMultiplexer</b> in first stage so that the outputs of first stage will be the inputs of second stage. Input of this 1x2 De-Multiplexer will be the overall input of 1x16 De-Multiplexer.</p>
<p>Let the 1x16 De-Multiplexer has one input I, four selection lines s<sub>3</sub>, s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub> and outputs Y<sub>15</sub> to Y<sub>0</sub>. The <b>block diagram</b> of 1x16 De-Multiplexer using lower order Multiplexers is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/1_16_demultiplexer.jpg" alt="1 to 16 Demultiplexer" />
<p>The common <b>selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub></b> are applied to both 1x8 De-Multiplexers. The outputs of upper 1x8 De-Multiplexer are Y<sub>15</sub> to Y<sub>8</sub> and the outputs of lower 1x8 DeMultiplexer are Y<sub>7</sub> to Y<sub>0</sub>. </p>
<p>The other <b>selection line, s<sub>3</sub></b> is applied to 1x2 De-Multiplexer. If s<sub>3</sub> is zero, then one of the eight outputs of lower 1x8 De-Multiplexer will be equal to input, I based on the values of selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub>. Similarly, if s3 is one, then one of the 8 outputs of upper 1x8 De-Multiplexer will be equal to input, I based on the values of selection lines s<sub>2</sub>, s<sub>1</sub> &amp; s<sub>0</sub>.</p>
<h1>Programmable Logic Devices</h1>
<p>Programmable Logic Devices <b>(PLDs)</b> are the integrated circuits. They contain an array of AND gates &amp; another array of OR gates. There are three kinds of PLDs based on the type of array(s), which has programmable feature.</p>
<ul class="list">
<li>Programmable Read Only Memory</li>
<li>Programmable Array Logic</li>
<li>Programmable Logic Array</li>
</ul>
<p>The process of entering the information into these devices is known as <b>programming</b>. Basically, users can program these devices or ICs electrically in order to implement the Boolean functions based on the requirement. Here, the term programming refers to hardware programming but not software programming.</p>
<h2>Programmable Read Only Memory (PROM)</h2>
<p>Read Only Memory (ROM) is a memory device, which stores the binary information permanently. That means, we can’t change that stored information by any means later. If the ROM has programmable feature, then it is called as <b>Programmable ROM (PROM)</b>. The user has the flexibility to program the binary information electrically once by using PROM programmer.</p>
<p>PROM is a programmable logic device that has fixed AND array &amp; Programmable OR array. The <b>block diagram</b> of PROM is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/prom.jpg" alt="PROM" />
<p>Here, the inputs of AND gates are not of programmable type. So, we have to generate 2<sup>n</sup> product terms by using 2<sup>n</sup> AND gates having n inputs each. We can implement these product terms by using nx2<sup>n</sup> decoder. So, this decoder generates ‘n’ <b>min terms</b>.</p>
<p>Here, the inputs of OR gates are programmable. That means, we can program any number of required product terms, since all the outputs of AND gates are applied as inputs to each OR gate. Therefore, the outputs of PROM will be in the form of <b>sum of min terms</b>.</p>
<h3>Example</h3>
<p>Let us implement the following <b>Boolean functions</b> using PROM.</p>
<p>$$A(X,Y,Z)=\sum m\left ( 5,6,7 \right )$$</p>
<p>$$B(X,Y,Z)=\sum m\left ( 3,5,6,7 \right )$$</p>
<p>The given two functions are in sum of min terms form and each function is having three variables X, Y &amp; Z. So, we require a 3 to 8 decoder and two programmable OR gates for producing these two functions. The corresponding <b>PROM</b> is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/prom_example.jpg" alt="Prom Example" />
<p>Here, 3 to 8 decoder generates eight min terms. The two programmable OR gates have the access of all these min terms. But, only the required min terms are programmed in order to produce the respective Boolean functions by each OR gate. The symbol ‘X’ is used for programmable connections.</p>
<h2>Programmable Array Logic (PAL)</h2>
<p>PAL is a programmable logic device that has Programmable AND array &amp; fixed OR array. The advantage of PAL is that we can generate only the required product terms of Boolean function instead of generating all the min terms by using programmable AND gates. The <b>block diagram</b> of PAL is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/pal.jpg" alt="PAL" />
<p>Here, the inputs of AND gates are programmable. That means each AND gate has both normal and complemented inputs of variables. So, based on the requirement, we can program any of those inputs. So, we can generate only the required <b>product terms</b> by using these AND gates.</p>
<p>Here, the inputs of OR gates are not of programmable type. So, the number of inputs to each OR gate will be of fixed type. Hence, apply those required product terms to each OR gate as inputs. Therefore, the outputs of PAL will be in the form of <b>sum of products form</b>.</p>
<h3>Example</h3>
<p>Let us implement the following <b>Boolean functions</b>  using PAL.</p>
<p>$$A=XY+X{Z}'$$</p>
<p>$$A=X{Y}'+Y{Z}'$$</p>
<p>The given two functions are in sum of products form. There are two product terms present in each Boolean function. So, we require four programmable AND gates &amp; two fixed OR gates for producing those two functions. The corresponding <b>PAL</b> is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/pal_example.jpg" alt="Pal Example" />
<p>The <b>programmable AND gates</b> have the access of both normal and complemented inputs of variables. In the above figure, the inputs X, ${X}'$, Y, ${Y}'$, Z &amp; ${Z}'$, are available at the inputs of each AND gate. So, program only the required literals in order to generate one product term by each AND gate. The symbol ‘X’ is used for programmable connections.</p>
<p>Here, the inputs of OR gates are of fixed type. So, the necessary product terms are connected to inputs of each <b>OR gate</b>. So that the OR gates produce the respective Boolean functions. The symbol ‘.’ is used for fixed connections.</p>
<h2>Programmable Logic Array (PLA)</h2>
<p>PLA is a programmable logic device that has both Programmable AND array &amp; Programmable OR array. Hence, it is the most flexible PLD. The <b>block diagram</b> of PLA is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/pla.jpg" alt="PLA" />
<p>Here, the inputs of AND gates are programmable. That means each AND gate has both normal and complemented inputs of variables. So, based on the requirement, we can program any of those inputs. So, we can generate only the required <b>product terms</b> by using these AND gates.</p>
<p>Here, the inputs of OR gates are also programmable. So, we can program any number of required product terms, since all the outputs of AND gates are applied as inputs to each OR gate. Therefore, the outputs of PAL will be in the form of <b>sum of products form</b>.</p>
<h3>Example</h3>
<p>Let us implement the following <b>Boolean functions</b> using PLA.</p>
<p>$$A=XY+X{Z}'$$</p>
<p>$$B=X{Y}'+YZ+X{Z}'$$</p>
<p>The given two functions are in sum of products form. The number of product terms present in the given Boolean functions A &amp; B are two and three respectively. One product term, ${Z}'X$ is common in each function.</p>
<p>So, we require four programmable AND gates &amp; two programmable OR gates for producing those two functions. The corresponding <b>PLA</b> is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/pla_circuit_diagram.jpg" alt="PLA Circuit Diagram" />
<p>The <b>programmable AND gates</b> have the access of both normal and complemented inputs of variables. In the above figure, the inputs X, ${X}'$, Y, ${Y}'$, Z &amp; ${Z}'$, are available at the inputs of each AND gate. So, program only the required literals in order to generate one product term by each AND gate.</p>
<p>All these product terms are available at the inputs of each <b>programmable OR gate</b>. But, only program the required product terms in order to produce the respective Boolean functions by each OR gate. The symbol ‘X’ is used for programmable connections.</p>
<h1>Digital Circuits - Threshold Logic</h1>
<p>In previous chapters, we have implemented various combinational circuits using logic gates. Except NOT gate, the remaining all logic gates have at least two inputs and single output. Similarly, the <b>threshold gate</b> also contains at least one input and only one output.</p>
<p>Additionally, it contains the respective weights to each input and a threshold value. The values of these weights and threshold could be of any finite real number.</p>
<h2>Basics of Threshold gate</h2>
<p>Let the inputs of threshold gate are X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub>,…, X<sub>n</sub>. The corresponding weights of these inputs are W<sub>1</sub>, W<sub>2</sub>, W<sub>3</sub>,…, W<sub>n</sub>. The <b>symbol</b> of Threshold gate is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/basics_threshold_gate.jpg" alt="Basics Threshold Gate" />
<p><b>Threshold gate</b> is represented with a circle and it is having ‘n’ inputs, X<sub>1</sub> to X<sub>n</sub> and single output, Y. This circle is made into two parts. One part represents the weights corresponding to the inputs and other part represents Threshold value, T.</p>
<p>The sum of products of inputs with corresponding weights is known as <b>weighted sum</b>. If this weighted sum is greater than or equal to Threshold value, T then only the output, Y will be equal to one. Otherwise, the output, Y will be equal to zero.</p>
<p><b>Mathematically</b>, we can write this relationship between inputs and output of Threshold gate as below.</p>
<p>$$Y=1, if \:   \: W_{1}X_{1}+W_{2}X_{2}+W_{3}X_{3}+...W_{n}X_{n}\geq T$$</p>
<p style="text-align:center">𝑌 = 0, otherwise.</p>
<p>Therefore, we can implement various logic gates and Boolean functions just by changing the values of weights and / or Threshold value, T.</p>
<h3>Example</h3>
<p>Let us find the <b>simplified Boolean function</b> for the following Threshold gate.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/threshold_gate_example.jpg" alt="Threshold Gate Example" />
<p>This Threshold gate is having three inputs X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub> and one output Y.</p>
<p>The weights corresponding to the inputs X<sub>1</sub>, X<sub>2</sub> &amp; X<sub>3</sub> are W<sub>1</sub>=2, W<sub>2</sub>=1 &amp; W<sub>3</sub>=-4 respectively.</p>
<p>The value of Threshold gate is T=-1.</p>
<p>The <b>weighted sum</b> of Threshold gate is</p>
<p>$$W=W_{1}X_{1}+W_{2}X_{2}+W_{3}X_{3}$$</p>
<p>Substitute the given weights in the above equation.</p>
<p>$$\Rightarrow W=2X_{1}+X_{2}-4X_{3}$$</p>
<p>Output of Threshold gate, Y will be ‘1’ if W &ge; −1, otherwise it will be ‘0’.</p>
<p>The following <b>table</b> shows the relationship between the input and output for all possible combination of inputs.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:25%" colspan="3">Inputs</th>
<th style="text-align:center">Weighted sum</th>
<th style="text-align:center">Output</th>
</tr>
<tr>
<td>$X_{1}$</td>
<td>$X_{2}$</td>
<td>$X_{3}$</td>
<td>$W=2X_{1}+X_{2}-4X_{3}$</td>
<td>$Y$</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>-4</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>-3</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>-2</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>-1</td>
<td>1</td>
</tr>
</table>
<p>From the above table, we can write the <b>Boolean function</b> for output, Y as</p>
<p>$$Y= \sum m\left ( 0,2,4,6,7 \right )$$</p>
<p>The simplification of this Boolean function using <b>3 variable K-Map</b> is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/simplified_boolean_function.jpg" alt="Simplified Boolean Function" />
<p>Therefore, the <b>simplified Boolean function</b> for given Threshold gate is $Y={X_{3}'}+X_{1}X_{2}$.</p>
<h2>Synthesis of Threshold Functions</h2>
<p>Threshold gate is also called as <b>universal gate</b> because we can implement any Boolean function using Threshold gate(s). Some-times, it may not possible to implement few logic gates and Boolean functions by using single Threshold gate. In that case, we may require multiple Threshold gates.</p>
<p>Follow these <b>steps</b> for implementing a Boolean function using single Threshold gate.</p>
<p><b>Step 1</b> &minus; Formulate a <b>Truth table</b> for given Boolean function.</p>
<p><b>Step 2</b> &minus; In the above Truth table, add (include) one more column, which gives the relation between <b>weighted sums</b> and <b>Threshold value</b>.</p>
<p><b>Step 3</b> &minus; Write the relation between weighted sums and threshold for each combination of inputs as mentioned below.</p>
<ul class="list">
<li><p>If the output of Boolean function is 1, then the weighted sum will be greater than or equal to Threshold value for those combination of inputs.</p></li>
<li><p>If the output of Boolean function is 0, then the weighted sum will be less than Threshold value for those combination of inputs.</p></li>
</ul>
<p><b>Step 4</b> &minus; Choose the values of weights & Threshold in such a way that they should satisfy all the relations present in last column of the above table.</p>
<p><b>step 5</b> &minus; Draw the <b>symbol</b> of Threshold gate with those weights and Threshold value.</p>
<h3>Example</h3>
<p>Let us implement the following <b>Boolean function</b> using single Threshold gate.</p>
<p>$$Y\left ( X_{1},X_{2},X_{3} \right )=\sum m\left ( 0,2,4,6,7 \right )$$</p>
<p>The given Boolean function is a three variable function, which is represented in sum of min terms form. The <b>Truth table</b> of this function is shown below.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="3">Inputs</th>
<th>Output</th>
</tr>
<tr>
<td><b>X<sub>1</sub></b></td>
<td><b>X<sub>2</sub></b></td>
<td><b>X<sub>3</sub></b></td>
<td><b>Y</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Now, let us add (include) one more column to the above Truth table. This last column contains the relations between <b>weighted sums (W) and Threshold</b> value (T) for each combination of inputs.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="3">Inputs</th>
<th style="text-align:center">Output</th>
<th style="text-align:center;vertical-align:middle" rowspan="2">Relations between W &amp; T</th>
</tr>
<tr>
<td><b>X<sub>1</sub></b></td>
<td><b>X<sub>2</sub></b></td>
<td><b>X<sub>3</sub></b></td>
<td><b>Y</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0 &ge;T</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>W<sub>3</sub> &lt; T</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>W<sub>2</sub> &ge; T</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>W<sub>2</sub> + W<sub>3</sub> &lt; T</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>W<sub>1</sub> &ge; T</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>W<sub>1</sub>+ W<sub>3</sub> &lt; T</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>W<sub>1</sub>+ W<sub>2</sub> &ge; T</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>W<sub>1</sub>+ W<sub>2</sub>+ W<sub>3</sub> &ge; T</td>
</tr>
</table>
<p>Following are the conclusions from the above table. </p>
<ul class="list">
<li><p>The value of Threshold should be either zero or negative based on first relation.</p></li>
<li><p>The value of W<sub>3</sub> should be negative based on first and second relations.</p></li>
<li><p>The values of W<sub>1</sub> and W<sub>2</sub> should be greater than or equal Threshold value based on fifth and third relations.</p></li>
<li><p>W<sub>2</sub> should be greater than W<sub>3</sub> based on fourth relation.</p></li>
</ul>
<p>We can choose the following values for weights and Threshold based on the above conclusions.</p>
<p style="text-align:center">W<sub>1</sub>=2, W<sub>2</sub>=1, W<sub>3</sub>= -4 &amp; T = -1</p>
<p>The <b>symbol</b> of Threshold gate with the above values is shown below.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/symbol_of_threshold_gate.jpg" alt="Symbol of Threshold Gate" />
<p>Therefore, this Threshold gate implements the given <b>Boolean function</b>, $Y\left ( X_{1}, X_{2},X_{3} \right )=\sum m\left ( 0,2,4,6,7 \right )$.</p>
<h1>Digital Sequential Circuits</h1>
<p>We discussed various combinational circuits in earlier chapters. All these circuits have a set of output(s), which depends only on the combination of present inputs. The following figure shows the <b>block diagram</b> of sequential circuit.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/sequential_circuit.jpg" alt="Sequential Circuit" />
<p>This sequential circuit contains a set of inputs and output(s). The output(s) of sequential circuit depends not only on the combination of present inputs but also on the previous output(s). Previous output is nothing but the <b>present state</b>. Therefore, sequential circuits contain combinational circuits along with memory (storage) elements. Some sequential circuits may not contain combinational circuits, but only memory elements.</p>
<p>Following table shows the <b>differences</b> between combinational circuits and sequential circuits.</p>
<table  style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Combinational Circuits</th>
<th style="text-align:center">Sequential Circuits</th>
</tr>
<tr>
<td>Outputs depend only on present inputs.</td>
<td>Outputs depend on both present inputs and present state.</td>
</tr>
<tr>
<td>Feedback path is not present.</td>
<td>Feedback path is present.</td>
</tr>
<tr>
<td>Memory elements are not required.</td>
<td>Memory elements are required.</td>
</tr>
<tr>
<td>Clock signal is not required.</td>
<td>Clock signal is required.</td>
</tr>
<tr>
<td>Easy to design.</td>
<td>Difficult to design.</td>
</tr>
</table>
<h2>Types of Sequential Circuits</h2>
<p>Following are the two types of sequential circuits &minus;</p>
<ul class="list">
<li>Asynchronous sequential circuits</li>
<li>Synchronous sequential circuits</li>
</ul>
<h3>Asynchronous sequential circuits</h3>
<p>If some or all the outputs of a sequential circuit do not change (affect) with respect to active transition of clock signal, then that sequential circuit is called as <b>Asynchronous sequential circuit</b>. That means, all the outputs of asynchronous sequential circuits do not change (affect) at the same time. Therefore, most of the outputs of asynchronous sequential circuits are <b>not in synchronous</b> with either only positive edges or only negative edges of clock signal.</p>
<h3>Synchronous sequential circuits</h3>
<p>If all the outputs of a sequential circuit change (affect) with respect to active transition of clock signal, then that sequential circuit is called as <b>Synchronous sequential circuit</b>. That means, all the outputs of synchronous sequential circuits change (affect) at the same time. Therefore, the outputs of synchronous sequential circuits are in synchronous with either only positive edges or only negative edges of clock signal.</p>
<h2>Clock Signal and Triggering</h2>
<p>In this section, let us discuss about the clock signal and types of triggering one by one.</p>
<h3>Clock signal</h3>
<p>Clock signal is a periodic signal and its ON time and OFF time need not be the same. We can represent the clock signal as a <b>square wave</b>, when both its ON time and OFF time are same. This clock signal is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/clock_signal.jpg" alt="Clock Signal" />
<p>n the above figure, square wave is considered as clock signal. This signal stays at logic High (5V) for some time and stays at logic Low (0V) for equal amount of time. This pattern repeats with some time period. In this case, the <b>time period</b> will be equal to either twice of ON time or twice of OFF time.</p>
<p>We can represent the clock signal as <b>train of pulses</b>, when ON time and OFF time are not same. This clock signal is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/train_of_pulses.jpg" alt="Train of Pulses" />
<p>In the above figure, train of pulses is considered as clock signal. This signal stays at logic High (5V) for some time and stays at logic Low (0V) for some other time. This pattern repeats with some time period. In this case, the <b>time period</b> will be equal to sum of ON time and OFF time.</p>
<p>The reciprocal of the time period of clock signal is known as the <b>frequency</b> of the clock signal. All sequential circuits are operated with clock signal. So, the frequency at which the sequential circuits can be operated accordingly the clock signal frequency has to be chosen.</p>
<h2>Types of Triggering</h2>
<p>Following are the two possible types of triggering that are used in sequential circuits.</p>
<ul class="list">
<li>Level triggering</li>
<li>Edge triggering</li>
</ul>
<h3>Level triggering</h3>
<p>There are two levels, namely logic High and logic Low in clock signal. Following are the two <b>types of level triggering</b>.</p>
<ul class="list">
<li>Positive level triggering</li>
<li>Negative level triggering</li>
</ul>
<p>If the sequential circuit is operated with the clock signal when it is in <b>Logic High</b>, then that type of triggering is known as <b>Positive level triggering</b>. It is highlighted in below figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/level_triggering.jpg" alt="level triggering" />
<p>If the sequential circuit is operated with the clock signal when it is in <b>Logic Low</b>, then that type of triggering is known as <b>Negative level triggering</b>. It is highlighted in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/negative_level_triggering.jpg" alt="Negative Level Triggering" />
<h3>Edge triggering</h3>
<p>There are two types of transitions that occur in clock signal. That means, the clock signal transitions either from Logic Low to Logic High or Logic High to Logic Low.</p>
<p>Following are the two <b>types of edge triggering</b> based on the transitions of clock signal.</p>
<ul class="list">
<li>Positive edge triggering</li>
<li>Negative edge triggering</li>
</ul>
<p>If the sequential circuit is operated with the clock signal that is transitioning from Logic Low to Logic High, then that type of triggering is known as <b>Positive edge triggering</b>. It is also called as rising edge triggering. It is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/positive_edge_triggering.jpg" alt="Positive Edge Triggering" />
<p>If the sequential circuit is operated with the clock signal that is transitioning from Logic High to Logic Low, then that type of triggering is known as <b>Negative edge triggering</b>. It is also called as falling edge triggering. It is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/negative_edge_triggering.jpg" alt="Negative Edge Triggering" />
<p>In coming chapters, we will discuss about various sequential circuits based on the type of triggering that can be used in it.</p>
<h1>Digital Circuits - Latches</h1>
<p>There are two types of memory elements based on the type of triggering that is suitable to operate it.</p>
<ul class="list">
<li>Latches</li>
<li>Flip-flops</li>
</ul>
<p>Latches operate with enable signal, which is <b>level sensitive</b>. Whereas, flip-flops are edge sensitive. We will discuss about flip-flops in next chapter. Now, let us discuss about SR Latch &amp; D Latch one by one.</p>
<h2>SR Latch</h2>
<p>SR Latch is also called as <b>Set Reset Latch</b>. This latch affects the outputs as long as the enable, E is maintained at ‘1’. The <b>circuit diagram</b> of SR Latch is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/sr_latch.jpg" alt="SR Latch" />
<p>This circuit has two inputs S &amp; R and two outputs Q(t) &amp; Q(t)’. The <b>upper NOR gate</b> has two inputs R &amp; complement of present state, Q(t)’ and produces next state, Q(t+1) when enable, E is ‘1’.</p>
<p>Similarly, the <b>lower NOR gate</b> has two inputs S &amp; present state, Q(t) and produces complement of next state, Q(t+1)’ when enable, E is ‘1’.</p>
<p>We know that a <b>2-input NOR gate</b> produces an output, which is the complement of another input when one of the input is ‘0’. Similarly, it produces ‘0’ output, when one of the input is ‘1’.</p>
<ul class="list">
<li><p>If S=1, then next state Q(t+1) will be equal to ‘1’ irrespective of present state, Q(t) values.</p></li>
<li><p>If R=1, then next state Q(t+1) will be equal to ‘0’ irrespective of present state, Q(t) values.</p></li>
</ul>
<p>At any time, only of those two inputs should be ‘1’. If both inputs are ‘1’, then the next state Q(t+1) value is undefined.</p>
<p>The following table shows the <b>state table</b> of SR latch.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">S</th>
<th style="text-align:center">R</th>
<th style="text-align:center">Q(t+1)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>Q(t)</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>-</td>
</tr>
</table>
<p>Therefore, SR Latch performs three types of functions such as Hold, Set &amp; Reset based on the input conditions.</p>
<h2>D Latch</h2>
<p>There is one drawback of SR Latch. That is the next state value can’t be predicted when both the inputs S &amp; R are one. So, we can overcome this difficulty by D Latch. It is also called as Data Latch. The <b>circuit diagram</b> of D Latch is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/d_latch.jpg" alt="D Latch" />
<p>This circuit has single input D and two outputs Q(t) &amp; Q(t)’. D Latch is obtained from SR Latch by placing an inverter between S amp;& R inputs and connect D input to S. That means we eliminated the combinations of S &amp; R are of same value.</p>
<ul class="list">
<li><p>If D=0 &rarr; S=0 &amp; R=1, then next state Q(t+1) will be equal to ‘0’ irrespective of present state, Q(t) values. This is corresponding to the second row of SR Latch state table.</p></li>
<li><p>If D=1 &rarr; S=1 &amp; R=0, then next state Q(t+1) will be equal to ‘1’ irrespective of present state, Q(t) values. This is corresponding to the third row of SR Latch state table.</p></li>
</ul>
<p>The following table shows the <b>state table</b> of D latch.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">D</th>
<th style="text-align:center">Q(t+1)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Therefore, D Latch Hold the information that is available on data input, D. That means the output of D Latch is sensitive to the changes in the input, D as long as the enable is High.</p> 
<p>In this chapter, we implemented various Latches by providing the cross coupling between NOR gates. Similarly, you can implement these Latches using NAND gates.</p>
<h1>Digital Circuits - Flip-Flops</h1>
<p>In previous chapter, we discussed about Latches. Those are the basic building blocks of flip-flops. We can implement flip-flops in two methods.</p>
<p>In first method, <b>cascade two latches</b> in such a way that the first latch is enabled for every positive clock pulse and second latch is enabled for every negative clock pulse. So that the combination of these two latches become a flip-flop.</p>
<p>In second method, we can directly implement the flip-flop, which is edge sensitive. In this chapter, let us discuss the following <b>flip-flops</b> using second method.</p>
<ul class="list">
<li>SR Flip-Flop</li>
<li>D Flip-Flop</li>
<li>JK Flip-Flop</li>
<li>T Flip-Flop</li>
</ul>
<h2>SR Flip-Flop</h2>
<p>SR flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, SR latch operates with enable signal. The <b>circuit diagram</b> of SR flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/sr_flipflop.jpg" alt="SR Flip-Flop" />
<p>This circuit has two inputs S & R and two outputs Q(t) &amp; Q(t)’. The operation of SR flipflop is similar to SR Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable.</p>
<p>The following table shows the <b>state table</b> of SR flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">S</th>
<th style="text-align:center">R</th>
<th style="text-align:center">Q(t+1)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>Q(t+1)</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>-</td>
</tr>
</table>
<p>Here, Q(t) &amp; Q(t+1) are present state &amp; next state respectively. So, SR flip-flop can be used for one of these three functions such as Hold, Reset &amp; Set based on the input conditions, when positive transition of clock signal is applied. The following table shows the <b>characteristic table</b> of SR flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="2">Present Inputs</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
</tr>
<tr>
<td><b>S</b></td>
<td><b>R</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>x</td>
</tr>
</table>
<p>By using three variable K-Map, we can get the simplified expression for next state, Q(t+1). The <b>three variable K-Map</b> for next state, Q(t+1) is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/3_variable_k_map_next_state.jpg" alt="3 variable K map Next State" />
<p>The maximum possible groupings of adjacent ones are already shown in the figure. Therefore, the <b>simplified expression</b> for next state Q(t+1) is</p>
<p style="text-align:center">$Q\left ( t+1 \right )=S+{R}'Q\left ( t \right )$</p>
<h2>D Flip-Flop</h2>
<p>D flip-flop operates with only positive clock transitions or negative clock transitions. Whereas, D latch operates with enable signal. That means, the output of D flip-flop is insensitive to the changes in the input, D except for active transition of the clock signal. The <b>circuit diagram</b> of D flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/d_flipflop.jpg" alt="D Flip-Flop" />
<p>This circuit has single input D and two outputs Q(t) & Q(t)’. The operation of D flip-flop is similar to D Latch. But, this flip-flop affects the outputs only when positive transition of the clock signal is applied instead of active enable.</p>
<p>The following table shows the <b>state table</b> of D flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:50%">D</th>
<th style="text-align:center;width:50%">Q(t+1)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
</table>
<p>Therefore, D flip-flop always Hold the information, which is available on data input, D of earlier positive transition of clock signal. From the above state table, we can directly write the next state equation as</p>
<p style="text-align:center">Q(t+1)=D</p>
<p>Next state of D flip-flop is always equal to data input, D for every positive transition of the clock signal. Hence, D flip-flops can be used in registers, <b>shift registers</b> and some of the counters.</p>
<h2>JK Flip-Flop</h2>
<p>JK flip-flop is the modified version of SR flip-flop. It operates with only positive clock transitions or negative clock transitions. The <b>circuit diagram</b> of JK flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/jk_flipflop.jpg" alt="JK Flip-Flop" />
<p>This circuit has two inputs J & K and two outputs Q(t) & Q(t)’. The operation of JK flip-flop is similar to SR flip-flop. Here, we considered the inputs of SR flip-flop as <b>S=J Q(t)’</b> and <b>R=KQ(t)</b> in order to utilize the modified SR flip-flop for 4 combinations of inputs.</p>
<p>The following table shows the <b>state table</b> of JK flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">J</th>
<th style="text-align:center">K</th>
<th style="text-align:center">Q(t+1)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>Q(t)</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Q(t)'</td>
</tr>
</table>
<p>Here, Q(t) &amp; Q(t+1) are present state &amp; next state respectively. So, JK flip-flop can be used for one of these four functions such as Hold, Reset, Set &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied. The following table shows the <b>characteristic table</b> of JK flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center" colspan="2">Present Inputs</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
</tr>
<tr>
<td><b>J</b></td>
<td><b>K</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>By using three variable K-Map, we can get the simplified expression for next state, Q(t+1). <b>Three variable K-Map</b> for next state, Q(t+1) is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/jk_3_variable_kmap.jpg" alt="JK 3 Variable K-Map" />
<p>The maximum possible groupings of adjacent ones are already shown in the figure. Therefore, the <b>simplified expression</b> for next state Q(t+1) is</p>
<p>$$Q\left ( t+1 \right )=J{Q\left ( t \right )}'+{K}'Q\left ( t \right )$$</p>
<h2>T Flip-Flop</h2>
<p>T flip-flop is the simplified version of JK flip-flop. It is obtained by connecting the same input ‘T’ to both inputs of JK flip-flop. It operates with only positive clock transitions or negative clock transitions. The <b>circuit diagram</b> of T flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/t_flipflop.jpg" alt="T Flip-Flop" />
<p>This circuit has single input T and two outputs Q(t) &amp; Q(t)’. The operation of T flip-flop is same as that of JK flip-flop. Here, we considered the inputs of JK flip-flop as <b>J=T</b> and <b>K=T</b> in order to utilize the modified JK flip-flop for 2 combinations of inputs. So, we eliminated the other two combinations of J &amp; K, for which those two values are complement to each other in T flip-flop.</p>
<p>The following table shows the <b>state table</b> of T flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:50%">D</th>
<th style="text-align:center;width:50%">Q(t+1)</th>
</tr>
<tr>
<td>0</td>
<td>Q(t)</td>
</tr>
<tr>
<td>1</td>
<td>Q(t)’</td>
</tr>
</table>
<p>Here, Q(t) &amp; Q(t+1) are present state &amp; next state respectively. So, T flip-flop can be used for one of these two functions such as Hold, &amp; Complement of present state based on the input conditions, when positive transition of clock signal is applied. The following table shows the <b>characteristic table</b> of T flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Inputs</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
</tr>
<tr>
<td><b>T</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>From the above characteristic table, we can directly write the <b>next state equation</b> as</p>
<p>$$Q\left ( t+1 \right )={T}'Q\left ( t \right )+TQ{\left ( t \right )}'$$</p>
<p>$$\Rightarrow Q\left ( t+1 \right )=T\oplus Q\left ( t \right )$$</p>
<p>The output of T flip-flop always toggles for every positive transition of the clock signal, when input T remains at logic High (1). Hence, T flip-flop can be used in <b>counters</b>.</p> 
<p>In this chapter, we implemented various flip-flops by providing the cross coupling between NOR gates. Similarly, you can implement these flip-flops by using NAND gates.</p>
<h1>Digital Circuits - Conversion of Flip-Flops</h1>
<p>In previous chapter, we discussed the four flip-flops, namely SR flip-flop, D flip-flop, JK flip-flop &amp; T flip-flop. We can convert one flip-flop into the remaining three flip-flops by including some additional logic. So, there will be total of twelve <b>flip-flop conversions</b>.</p>
<p>Follow these <b>steps</b> for converting one flip-flop to the other.</p>
<ul class="list">
<li><p>Consider the <b>characteristic table</b> of desired flip-flop.</p></li>
<li><p>Fill the excitation values (inputs) of given flip-flop for each combination of present state and next state. The <b>excitation table</b> for all flip-flops is shown below.</p></li>
</ul>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
<th style="text-align:center" colspan="2">SR flip-flop inputs</th>
<th style="text-align:center">D flip-flop input</th>
<th style="text-align:center" colspan="2">JK flip-flop inputs</th>
<th style="text-align:center">T flip-flop input</th>
</tr>
<tr>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
<td><b>S</b></td>
<td><b>R</b></td>
<td><b>D</b></td>
<td><b>J</b></td>
<td><b>K</b></td>
<td><b>T</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>0</td>
<td>0</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>x</td>
<td>0</td>
<td>1</td>
<td>x</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<ul class="list">
<li><p>Get the <b>simplified expressions</b> for each excitation input. If necessary, use Kmaps for simplifying.</p></li>
<li><p>Draw the <b>circuit diagram</b> of desired flip-flop according to the simplified expressions using given flip-flop and necessary logic gates.</p></li>
</ul>
<p>Now, let us convert few flip-flops into other. Follow the same process for remaining flipflop conversions.</p>
<h2>SR Flip-Flop to other Flip-Flop Conversions</h2>
<p>Following are the three possible conversions of SR flip-flop to other flip-flops.</p>
<ul class="list">
<li>SR flip-flop to D flip-flop</li>
<li>SR flip-flop to JK flip-flop</li>
<li>SR flip-flop to T flip-flop</li>
</ul>
<h3>SR flip-flop to D flip-flop conversion</h3>
<p>Here, the given flip-flop is SR flip-flop and the desired flip-flop is D flip-flop. Therefore, consider the following <b>characteristic table</b> of D flip-flop.</p>
<table style="text-align:center"class="table table-bordered">
<tr>
<th style="text-align:center">D flip-flop input</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
</tr>
<tr>
<td><b>D</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>We know that SR flip-flop has two inputs S &amp; R. So, write down the excitation values of SR flip-flop for each combination of present state and next state values. The following table shows the characteristic table of D flip-flop along with the <b>excitation inputs</b> of SR flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">D flip-flop input</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
<th style="text-align:center" colspan="2">SR flip-flop inputs</th>
</tr>
<tr>
<td><b>D</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
<td><b>S</b></td>
<td><b>R</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>0</td>
</tr>
</table>
<p>From the above table, we can write the <b>Boolean functions</b> for each input as below.</p>
<p>$$S=m_{2}+d_{3}$$</p>
<p>$$R=m_{1}+d_{0}$$</p>
<p>We can use 2 variable K-Maps for getting simplified expressions for these inputs. The <b>k-Maps</b> for S &amp; R are shown below.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/conversion_of_flipflop.jpg" alt="Conversion of Flip-Flop" />
<p>So, we got S = D &amp; R = D' after simplifying. The <b>circuit diagram</b> of D flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/circuit_diagram_of_d_flip_flop.jpg" alt="Circuit Diagram of D Flip-Flop" />
<p>This circuit consists of SR flip-flop and an inverter. This inverter produces an output, which is complement of input, D. So, the overall circuit has single input, D and two outputs Q(t) &amp; Q(t)'. Hence, it is a <b>D flip-flop</b>. Similarly, you can do other two conversions.</p>
<h2>D Flip-Flop to other Flip-Flop Conversions</h2>
<p>Following are the three possible conversions of D flip-flop to other flip-flops.</p>
<ul class="list">
<li>D flip-flop to T flip-flop</li>
<li>D flip-flop to SR flip-flop </li>
<li>D flip-flop to JK flip-flop</li>
</ul>
<h3>D flip-flop to T flip-flop conversion</h3>
<p>Here, the given flip-flop is D flip-flop and the desired flip-flop is T flip-flop. Therefore, consider the following <b>characteristic table</b> of T flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th>T flip-flop input</th>
<th>Present State</th>
<th>Next State</th>
</tr>
<tr>
<td><b>T</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>We know that D flip-flop has single input D. So, write down the excitation values of D flip-flop for each combination of present state and next state values. The following table shows the characteristic table of T flip-flop along with the <b>excitation input</b> of D flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">T flip-flop input</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
<th style="text-align:center">D flip-flop input</th>
</tr>
<tr>
<td><b>T</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
<td><b>D</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>From the above table, we can directly write the <b>Boolean function</b> of D as below.</p>
<p>$$D=T\oplus Q\left ( t \right )$$</p>
<p>So, we require a two input Exclusive-OR gate along with D flip-flop. The <b>circuit diagram</b> of T flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/circuit_diagram_of_t_flip_flop.jpg" alt="Circuit Diagram of T Flip-Flop" />
<p>This circuit consists of D flip-flop and an Exclusive-OR gate. This Exclusive-OR gate produces an output, which is Ex-OR of T and Q(t). So, the overall circuit has single input, T and two outputs Q(t) &amp; Q(t)’. Hence, it is a <b>T flip-flop</b>. Similarly, you can do other two conversions.</p>
<h2>JK Flip-Flop to other Flip-Flop Conversions</h2>
<p>Following are the three possible conversions of JK flip-flop to other flip-flops.</p>
<ul class="list">
<li>JK flip-flop to T flip-flop</li>
<li>JK flip-flop to D flip-flop</li>
<li>JK flip-flop to SR flip-flop</li>
</ul>
<h3>JK flip-flop to T flip-flop conversion</h3>
<p>Here, the given flip-flop is JK flip-flop and the desired flip-flop is T flip-flop. Therefore, consider the following <b>characteristic table</b> of T flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">T flip-flop input</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
</tr>
<tr>
<td><b>T</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>We know that JK flip-flop has two inputs J &amp; K. So, write down the excitation values of JK flip-flop for each combination of present state and next state values. The following table shows the characteristic table of T flip-flop along with the <b>excitation inputs</b> of JK flipflop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">T flip-flop input</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
<th style="text-align:center" colspan="2">JK flip-flop inputs</th>
</tr>
<tr>
<td><b>T</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
<td><b>J</b></td>
<td><b>K</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>x</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>x</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>x</td>
<td>1</td>
</tr>
</table>
<p>From the above table, we can write the <b>Boolean functions</b> for each input as below.</p>
<p>$$J=m_{2}+d_{1}+d_{3}$$</p>
<p>$$K=m_{3}+d_{0}+d_{2}$$</p>
<p>We can use 2 variable K-Maps for getting simplified expressions for these two inputs. The <b>k-Maps</b> for J &amp; K are shown below.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/k_map_for_j_k.jpg" alt="K Map for J and K" />
<p>So, we got, J = T &amp; K = T after simplifying. The <b>circuit diagram</b> of T flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/circuit_diagram_of_t_flip_flop_with_jk_flipflop.jpg" alt="Circuit Diagram of T Flip-Flop with JK Flip-Flop" />
<p>This circuit consists of JK flip-flop only. It doesn’t require any other gates. Just connect the same input T to both J &amp; K. So, the overall circuit has single input, T and two outputs Q(t) &amp; Q(t)’. Hence, it is a <b>T flip-flop</b>. Similarly, you can do other two conversions.</p>
<h2>T Flip-Flop to other Flip-Flop Conversions</h2>
<p>Following are the three possible conversions of T flip-flop to other flip-flops.</p>
<ul class="list">
<li>T flip-flop to D flip-flop</li>
<li>T flip-flop to SR flip-flop</li>
<li>T flip-flop to JK flip-flop</li>
</ul>
<h3>T flip-flop to D flip-flop conversion</h3>
<p>Here, the given flip-flop is T flip-flop and the desired flip-flop is D flip-flop. Therefore, consider the characteristic table of D flip-flop and write down the excitation values of T flip-flop for each combination of present state and next state values. The following table shows the <b>characteristic table</b> of D flip-flop along with the <b>excitation input</b> of T flip-flop.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center">D flip-flop input</th>
<th style="text-align:center">Present State</th>
<th style="text-align:center">Next State</th>
<th style="text-align:center" colspan="2">T flip-flop input</th>
</tr>
<tr>
<td><b>D</b></td>
<td><b>Q(t)</b></td>
<td><b>Q(t+1)</b></td>
<td><b>T</b></td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</table>
<p>From the above table, we can directly write the Boolean function of T as below.</p>
<p>$$T=D\oplus Q\left ( t \right )$$</p>
<p>So, we require a two input Exclusive-OR gate along with T flip-flop. The <b>circuit diagram</b> of D flip-flop is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/t_flipflop_circuit_diagram.jpg" alt="T Flip-Flop circuit Diagram" />
<p>This circuit consists of T flip-flop and an Exclusive-OR gate. This Exclusive-OR gate produces an output, which is Ex-OR of D and Q(t). So, the overall circuit has single input, D and two outputs Q(t) &amp; Q(t)’. Hence, it is a <b>D flip-flop</b>. Similarly, you can do other two conversions.</p>
<h1>Digital Circuits - Shift Registers</h1>
<p>We know that one flip-flop can store one-bit of information. In order to store multiple bits of information, we require multiple flip-flops. The group of flip-flops, which are used to hold (store) the binary data is known as <b>register</b>.</p>
<p>If the register is capable of shifting bits either towards right hand side or towards left hand side is known as <b>shift register</b>. An ‘N’ bit shift register contains ‘N’ flip-flops. Following are the four types of shift registers based on applying inputs and accessing of outputs.</p>
<ul class="list">
<li>Serial In - Serial Out shift register</li>
<li>Serial In - Parallel Out shift register</li>
<li>Parallel In - Serial Out shift register</li>
<li>Parallel In - Parallel Out shift register</li>
</ul>
<h2>Serial In - Serial Out (SISO) Shift Register</h2>
<p>The shift register, which allows serial input and produces serial output is known as Serial In – Serial Out <b>(SISO)</b> shift register. The <b>block diagram</b> of 3-bit SISO shift register is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/siso.jpg" alt="SISO" />
<p>This block diagram consists of three D flip-flops, which are <b>cascaded</b>. That means, output of one D flip-flop is connected as the input of next D flip-flop. All these flip-flops are synchronous with each other since, the same clock signal is applied to each one.</p>
<p>In this shift register, we can send the bits serially from the input of left most D flip-flop. Hence, this input is also called as <b>serial input</b>. For every positive edge triggering of clock signal, the data shifts from one stage to the next. So, we can receive the bits serially from the output of right most D flip-flop. Hence, this output is also called as <b>serial output</b>.</p>
<h3>Example</h3>
<p>Let us see the working of 3-bit SISO shift register by sending the binary information <b>“011”</b> from LSB to MSB serially at the input.</p>
<p>Assume, initial status of the D flip-flops from leftmost to rightmost is $Q_{2}Q_{1}Q_{0}=000$. We can understand the <b>working of 3-bit SISO shift register</b> from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:38%">No of positive edge of Clock</th>
<th style="text-align:center">Serial Input</th>
<th style="text-align:center">Q<sub>2</sub></th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>0</sub></th>
</tr>
<tr>
<td>0</td>
<td>-</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1(LSB)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0(MSB)</td>
<td>0</td>
<td>1</td>
<td>1(LSB)</td>
</tr>
<tr>
<td>4</td>
<td>-</td>
<td>-</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>0(MSB)</td>
</tr>
</table>
<p>The initial status of the D flip-flops in the absence of clock signal is $Q_{2}Q_{1}Q_{0}=000$. Here, the serial output is coming from $Q_{0}$. So, the LSB (1) is received at 3<sup>rd</sup> positive edge of clock and the MSB (0) is received at 5<sup>th</sup> positive edge of clock.</p>
<p>Therefore, the 3-bit SISO shift register requires five clock pulses in order to produce the valid output. Similarly, the <b>N-bit SISO shift register</b> requires <b>2N-1</b> clock pulses in order to shift ‘N’ bit information.</p>
<h2>Serial In - Parallel Out (SIPO) Shift Register</h2>
<p>The shift register, which allows serial input and produces parallel output is known as Serial In – Parallel Out <b>(SIPO)</b> shift register. The <b>block diagram</b> of 3-bit SIPO shift register is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/sipo.jpg" alt="SIPO" />
<p>This circuit consists of three D flip-flops, which are cascaded. That means, output of one D flip-flop is connected as the input of next D flip-flop. All these flip-flops are synchronous with each other since, the same clock signal is applied to each one.</p>
<p>In this shift register, we can send the bits serially from the input of left most D flip-flop. Hence, this input is also called as <b>serial input</b>. For every positive edge triggering of clock signal, the data shifts from one stage to the next. In this case, we can access the outputs of each D flip-flop in parallel. So, we will get <b>parallel outputs</b> from this shift register.</p>
<h3>Example</h3>
<p>Let us see the working of 3-bit SIPO shift register by sending the binary information <b>“011”</b> from LSB to MSB serially at the input.</p>
<p>Assume, initial status of the D flip-flops from leftmost to rightmost is $Q_{2}Q_{1}Q_{0}=000$. Here, $Q_{2}$ &amp; $Q_{0}$ are MSB &amp; LSB respectively. We can understand the <b>working of 3-bit SIPO shift register</b> from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:37%">No of positive edge of Clock</th>
<th style="text-align:center">Serial Input</th>
<th style="text-align:center">Q<sub>2</sub>(MSB)</th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>0</sub>(LSB)</th>
</tr>
<tr>
<td>0</td>
<td>-</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1(LSB)</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0(MSB)</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>The initial status of the D flip-flops in the absence of clock signal is $Q_{2}Q_{1}Q_{0}=000$. The binary information <b>“011”</b> is obtained in parallel at the outputs of D flip-flops for third positive edge of clock.</p>
<p>So, the 3-bit SIPO shift register requires three clock pulses in order to produce the valid output. Similarly, the <b>N-bit SIPO shift register</b> requires <b>N</b> clock pulses in order to shift ‘N’ bit information.</p>
<h2>Parallel In - Serial Out (PISO) Shift Register</h2>
<p>The shift register, which allows parallel input and produces serial output is known as Parallel In – Serial Out <b>(PISO)</b> shift register. The <b>block diagram</b> of 3-bit PISO shift register is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/piso.jpg" alt="PISO" />
<p>This circuit consists of three D flip-flops, which are cascaded. That means, output of one D flip-flop is connected as the input of next D flip-flop. All these flip-flops are synchronous with each other since, the same clock signal is applied to each one.</p>
<p>In this shift register, we can apply the <b>parallel inputs</b> to each D flip-flop by making Preset Enable to 1. For every positive edge triggering of clock signal, the data shifts from one stage to the next. So, we will get the <b>serial output</b> from the right most D flip-flop.</p>
<h3>Example</h3>
<p>Let us see the working of 3-bit PISO shift register by applying the binary information <b>“011”</b> in parallel through preset inputs.</p>
<p>Since the preset inputs are applied before positive edge of Clock, the initial status of the D flip-flops from leftmost to rightmost will be $Q_{2}Q_{1}Q_{0}=011$. We can understand the <b>working of 3-bit PISO shift register</b> from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:38%">No of positive edge of Clock</th>
<th style="text-align:center">Q<sub>2</sub></th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>0</sub></th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1(LSB)</td>
</tr>
<tr>
<td>1</td>
<td>-</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>-</td>
<td>-</td>
<td>0(LSB)</td>
</tr>
</table>
<p>Here, the serial output is coming from $Q_{0}$. So, the LSB (1) is received before applying positive edge of clock and the MSB (0) is received at 2<sup>nd</sup> positive edge of clock.</p>
<p>Therefore, the 3-bit PISO shift register requires two clock pulses in order to produce the valid output. Similarly, the <b>N-bit PISO shift register</b> requires <b>N-1</b> clock pulses in order to shift ‘N’ bit information.</p>
<h2>Parallel In - Parallel Out (PIPO) Shift Register</h2>
<p>The shift register, which allows parallel input and produces parallel output is known as Parallel In &minus; Parallel Out <b>(PIPO)</b> shift register. The <b>block diagram</b> of 3-bit PIPO shift register is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/pipo.jpg" alt="PIPO" />
<p>This circuit consists of three D flip-flops, which are cascaded. That means, output of one D flip-flop is connected as the input of next D flip-flop. All these flip-flops are synchronous with each other since, the same clock signal is applied to each one.</p>
<p>In this shift register, we can apply the <b>parallel inputs</b> to each D flip-flop by making Preset Enable to 1. We can apply the parallel inputs through preset or clear. These two are asynchronous inputs. That means, the flip-flops produce the corresponding outputs, based on the values of asynchronous inputs. In this case, the effect of outputs is independent of clock transition. So, we will get the <b>parallel outputs</b> from each D flip-flop.</p>
<h3>Example</h3>
<p>Let us see the working of 3-bit PIPO shift register by applying the binary information <b>“011”</b> in parallel through preset inputs.</p>  
<p>Since the preset inputs are applied before positive edge of Clock, the initial status of the D flip-flops from leftmost to rightmost will be $Q_{2}Q_{1}Q_{0}=011$. So, the binary information <b>“011”</b> is obtained in parallel at the outputs of D flip-flops before applying positive edge of clock.</p>  
<p>Therefore, the 3-bit PIPO shift register requires zero clock pulses in order to produce the valid output. Similarly, the <b>N-bit PIPO shift register</b> doesn’t require any clock pulse in order to shift ‘N’ bit information.</p>
<h1>Digital Circuits - Application of Shift Registers</h1>
<p>In previous chapter, we discussed four types of shift registers. Based on the requirement, we can use one of those shift registers. Following are the applications of shift registers.</p>
<ul class="list">
<li><p>Shift register is used as <b>Parallel to serial converter</b>, which converts the parallel data into serial data. It is utilized at the transmitter section after Analog to Digital Converter (ADC) block.</p></li>
<li><p>Shift register is used as  <b>Serial to parallel converter</b>, which converts the serial data into parallel data. It is utilized at the receiver section before Digital to Analog Converter (DAC) block.</p></li>
<li><p>Shift register along with some additional gate(s) generate the sequence of zeros and ones. Hence, it is used as <b>sequence generator</b>.</p></li>
<li><p>Shift registers are also used as <b>counters</b>. There are two types of counters based on the type of output from right most D flip-flop is connected to the serial input. Those are Ring counter and Johnson Ring counter.</p></li>
</ul>
<p>In this chapter, let us discuss about these two counters one by one.</p>
<h2>Ring Counter</h2>
<p>In previous chapter, we discussed the operation of Serial In - Parallel Out <b>(SIPO)</b> shift register. It accepts the data from outside in serial form and it requires ‘N’ clock pulses in order to shift ‘N’ bit data.</p>
<p>Similarly, <b>‘N’ bit Ring counter</b> performs the similar operation. But, the only difference is that the output of rightmost D flip-flop is given as input of leftmost D flip-flop instead of applying data from outside. Therefore, Ring counter produces a sequence of states (pattern of zeros and ones) and it repeats for every <b>‘N’ clock cycles</b>.</p>
<p>The <b>block diagram</b> of 3-bit Ring counter is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/ring_counter.jpg" alt="Ring Counter" />
<p>The 3-bit Ring counter contains only a 3-bit SIPO shift register. The output of rightmost D flip-flop is connected to serial input of left most D flip-flop.</p>
<p>Assume, initial status of the D flip-flops from leftmost to rightmost is $Q_{2}Q_{1}Q_{0}=001$. Here, $Q_{2}$ &amp; $Q_{0}$ are MSB &amp; LSB respectively. We can understand the <b>working of Ring counter</b> from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:38%">No of positive edge of Clock</th>
<th style="text-align:center">Serial Input = Q<sub>0</sub></th>
<th style="text-align:center">Q<sub>2</sub>(MSB)</th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>0</sub>(LSB)</th>
</tr>
<tr>
<td>0</td>
<td>-</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
</table>
<p>The initial status of the D flip-flops in the absence of clock signal is $Q_{2}Q_{1}Q_{0}=001$. This status repeats for every three positive edge transitions of clock signal.</p>
<p>Therefore, the following <b>operations</b> take place for every positive edge of clock signal.</p>
<ul class="list">
<li><p>Serial input of first D flip-flop gets the previous output of third flip-flop. So, the present output of first D flip-flop is equal to the previous output of third flip-flop.</p></li>
<li><p>The previous outputs of first and second D flip-flops are right shifted by one bit. That means, the present outputs of second and third D flip-flops are equal to the previous outputs of first and second D flip-flops.</p></li>
</ul>
<h2>Johnson Ring Counter</h2>
<p>The operation of <b>Johnson Ring counter</b> is similar to that of Ring counter. But, the only difference is that the complemented output of rightmost D flip-flop is given as input of leftmost D flip-flop instead of normal output. Therefore, ‘N’ bit Johnson Ring counter produces a sequence of states (pattern of zeros and ones) and it repeats for every <b>‘2N’ clock cycles</b>.</p>
<p>Johnson Ring counter is also called as <b>Twisted Ring counter</b> and switch tail Ring counter. The <b>block diagram</b> of 3-bit Johnson Ring counter is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/twisted_ring_counter.jpg" alt="Twisted Ring Counter" />
<p>The 3-bit Johnson Ring counter also contains only a 3-bit SIPO shift register. The complemented output of rightmost D flip-flop is connected to serial input of left most D flip-flop.</p>
<p>Assume, initially all the D flip-flops are cleared. So, $Q_{2}Q_{1}Q_{0}=000$. Here, $Q_{2}$ &amp; $Q_{0}$ are MSB &amp; LSB respectively. We can understand the <b>working</b> of Johnson Ring counter from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:38%">No of positive edge of Clock</th>
<th style="text-align:center">Serial Input = Q<sub>0</sub></th>
<th style="text-align:center">Q<sub>2</sub>(MSB)</th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>0</sub>(LSB)</th>
</tr>
<tr>
<td>0</td>
<td>-</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>The initial status of the D flip-flops in the absence of clock signal is $Q_{2}Q_{1}Q_{0}=000$. This status repeats for every six positive edge transitions of clock signal.</p>
<p>Therefore, the following <b>operations</b> take place for every positive edge of clock signal.</p>
<ul class="list">
<li><p>Serial input of first D flip-flop gets the previous complemented output of third flip-flop. So, the present output of first D flip-flop is equal to the previous complemented output of third flip-flop.</p></li>
<li><p>The previous outputs of first and second D flip-flops are right shifted by one bit. That means, the present outputs of second and third D flip-flops are equal to the previous outputs of first and second D flip-flops.</p></li>
</ul>
<h1>Digital Circuits - Counters</h1>
<p>In previous two chapters, we discussed various shift registers &amp; <b>counters using D flipflops</b>. Now, let us discuss various counters using T flip-flops. We know that T flip-flop toggles the output either for every positive edge of clock signal or for negative edge of clock signal.</p>
<p>An ‘N’ bit binary counter consists of ‘N’ T flip-flops. If the counter counts from 0 to 2<sup>𝑁</sup> − 1, then it is called as binary <b>up counter</b>. Similarly, if the counter counts down from 2<sup>𝑁</sup> − 1 to 0, then it is called as binary <b>down counter</b>.</p>
<p>There are two <b>types of counters</b> based on the flip-flops that are connected in synchronous or not.</p>
<ul class="list">
<li>Asynchronous counters</li>
<li>Synchronous counters</li>
</ul>
<h2>Asynchronous Counters</h2>
<p>If the flip-flops do not receive the same clock signal, then that counter is called as <b>Asynchronous counter</b>. The output of system clock is applied as clock signal only to first flip-flop. The remaining flip-flops receive the clock signal from output of its previous stage flip-flop. Hence, the outputs of all flip-flops do not change (affect) at the same time.</p>
<p>Now, let us discuss the following two counters one by one.</p>
<ul class="list">
<li>Asynchronous Binary up counter</li>
<li>Asynchronous Binary down counter</li>
</ul>
<h3>Asynchronous Binary Up Counter</h3>
<p>An ‘N’ bit Asynchronous binary up counter consists of ‘N’ T flip-flops. It counts from 0 to 2<sup>𝑁</sup> − 1. The <b>block diagram</b> of 3-bit Asynchronous binary up counter is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/asynchronous_binary_up_counter.jpg" alt="Asynchronous Binary Up Counter" />
<p>The 3-bit Asynchronous binary up counter contains three T flip-flops and the T-input of all the flip-flops are connected to ‘1’. All these flip-flops are negative edge triggered but the outputs change asynchronously. The clock signal is directly applied to the first T flip-flop. So, the output of first T flip-flop <b>toggles</b> for every negative edge of clock signal.</p>
<p>The output of first T flip-flop is applied as clock signal for second T flip-flop. So, the output of second T flip-flop toggles for every negative edge of output of first T flip-flop. Similarly, the output of third T flip-flop toggles for every negative edge of output of second T flip-flop, since the output of second T flip-flop acts as the clock signal for third T flip-flop.</p>
<p>Assume the initial status of T flip-flops from rightmost to leftmost is $Q_{2}Q_{1}Q_{0}=000$. Here, $Q_{2}$ &amp; $Q_{0}$ are MSB &amp; LSB respectively. We can understand the <b>working</b> of 3-bit asynchronous binary counter from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:38%">No of negative edge of Clock</th>
<th style="text-align:center">Q<sub>0</sub>(LSB)</th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>2</sub>(MSB)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</table>
<p>Here $Q_{0}$ toggled for every negative edge of clock signal. $Q_{1}$ toggled for every $Q_{0}$ that goes from 1 to 0, otherwise remained in the previous state. Similarly, $Q_{2}$ toggled for every $Q_{1}$ that goes from 1 to 0, otherwise remained in the previous state.</p>
<p>The initial status of the T flip-flops in the absence of clock signal is $Q_{2}Q_{1}Q_{0}=000$. This is incremented by one for every negative edge of clock signal and reached to maximum value at 7<sup>th</sup> negative edge of clock signal. This pattern repeats when further negative edges of clock signal are applied.</p>
<h3>Asynchronous Binary Down Counter</h3>
<p>An ‘N’ bit Asynchronous binary down counter consists of ‘N’ T flip-flops. It counts from 2<sup>𝑁</sup> − 1 to 0. The <b>block diagram</b> of 3-bit Asynchronous binary down counter is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/asynchronous_binary_down_counter.jpg" alt="Asynchronous Binary Down Counter" />
<p>The block diagram of 3-bit Asynchronous binary down counter is similar to the block diagram of 3-bit Asynchronous binary up counter. But, the only difference is that instead of connecting the normal outputs of one stage flip-flop as clock signal for next stage flip-flop, connect the <b>complemented outputs</b> of one stage flip-flop as clock signal for next stage flip-flop. Complemented output goes from 1 to 0 is same as the normal output goes from 0 to 1.</p>
<p>Assume the initial status of T flip-flops from rightmost to leftmost is $Q_{2}Q_{1}Q_{0}=000$. Here, $Q_{2}$ &amp; $Q_{0}$ are MSB &amp; LSB respectively. We can understand the <b>working</b> of 3-bit asynchronous binary down counter from the following table.</p>
<table style="text-align:center" class="table table-bordered">
<tr>
<th style="text-align:center;width:38%">No of negative edge of Clock</th>
<th style="text-align:center">Q<sub>0</sub>(LSB)</th>
<th style="text-align:center">Q<sub>1</sub></th>
<th style="text-align:center">Q<sub>2</sub>(MSB)</th>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
</table>
<p>Here $Q_{0}$ toggled for every negative edge of clock signal. $Q_{1}$ toggled for every $Q_{0}$ that goes from 0 to 1, otherwise remained in the previous state. Similarly, $Q_{2}$ toggled for every $Q_{1}$ that goes from 0 to 1, otherwise remained in the previous state.</p>
<p>The initial status of the T flip-flops in the absence of clock signal is $Q_{2}Q_{1}Q_{0}=000$. This is decremented by one for every negative edge of clock signal and reaches to the same value at 8<sup>th</sup> negative edge of clock signal. This pattern repeats when further negative edges of clock signal are applied.</p>
<h2>Synchronous Counters</h2>
<p>If all the flip-flops receive the same clock signal, then that counter is called as <b>Synchronous counter</b>. Hence, the outputs of all flip-flops change (affect) at the same time.</p>
<p>Now, let us discuss the following two counters one by one.</p>
<ul class="list">
<li>Synchronous Binary up counter</li>
<li>Synchronous Binary down counter</li>
</ul>
<h3>Synchronous Binary Up Counter</h3>
<p>An ‘N’ bit Synchronous binary up counter consists of ‘N’ T flip-flops. It counts from 0 to 2<sup>𝑁</sup> − 1. The <b>block diagram</b> of 3-bit Synchronous binary up counter is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/synchronous_binary_up_counter.jpg" alt="Synchronous Binary Up Counter" />
<p>The 3-bit Synchronous binary up counter contains three T flip-flops &amp; one 2-input AND gate. All these flip-flops are negative edge triggered and the outputs of flip-flops change (affect) synchronously. The T inputs of first, second and third flip-flops are 1, $Q_{0}$ &amp; $Q_{1}Q_{0}$ respectively.</p>
<p>The output of first T flip-flop <b>toggles</b> for every negative edge of clock signal. The output of second T flip-flop toggles for every negative edge of clock signal if $Q_{0}$ is 1. The output of third T flip-flop toggles for every negative edge of clock signal if both $Q_{0}$ &amp;  $Q_{1}$ are 1.</p>
<h3>Synchronous Binary Down Counter</h3>
<p>An ‘N’ bit Synchronous binary down counter consists of ‘N’ T flip-flops. It counts from 2<sup>𝑁</sup> − 1 to 0. The <b>block diagram</b> of 3-bit Synchronous binary down counter is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/synchronous_binary_down_counter.jpg" alt="Synchronous Binary Down Counter" />
<p>The 3-bit Synchronous binary down counter contains three T flip-flops &amp; one 2-input AND gate. All these flip-flops are negative edge triggered and the outputs of flip-flops change (affect) synchronously. The T inputs of first, second and third flip-flops are 1, ${Q_{0}}'$ &amp;' ${Q_{1}}'$${Q_{0}}'$ respectively.</p>
<p>The output of first T flip-flop <b>toggles</b> for every negative edge of clock signal. The output of second T flip-flop toggles for every negative edge of clock signal if ${Q_{0}}'$ is 1. The output of third T flip-flop toggles for every negative edge of clock signal if both ${Q_{1}}'$ &amp; ${Q_{0}}'$ are 1.</p>
<h1>Digital Circuits - Finite State Machines</h1>
<p>We know that synchronous sequential circuits change (affect) their states for every positive (or negative) transition of the clock signal based on the input. So, this behavior of synchronous sequential circuits can be represented in the graphical form and it is known as <b>state diagram</b>.</p>
<p>A synchronous sequential circuit is also called as <b>Finite State Machine</b> (FSM), if it has finite number of states. There are two types of FSMs.</p>
<ul class="list">
<li>Mealy State Machine</li>
<li>Moore State Machine</li>
</ul>
<p>Now, let us discuss about these two state machines one by one.</p>
<h2>Mealy State Machine</h2>
<p>A Finite State Machine is said to be Mealy state machine, if outputs depend on both present inputs &amp; present states. The <b>block diagram</b> of Mealy state machine is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/mealy_state_machine.jpg" alt="Mealy State Machine" />
<p>As shown in figure, there are two parts present in Mealy state machine. Those are combinational logic and memory. Memory is useful to provide some or part of previous outputs <b>(present states)</b> as inputs of combinational logic.</p>
<p>So, based on the present inputs and present states, the Mealy state machine produces outputs. Therefore, the outputs will be valid only at positive (or negative) transition of the clock signal.</p>
<p>The <b>state diagram</b> of Mealy state machine is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/state_diagram.jpg" alt="State Diagram" />
<p>In the above figure, there are three states, namely A, B &amp; C. These states are labelled inside the circles &amp; each circle corresponds to one state. Transitions between these states are represented with directed lines. Here, 0 / 0, 1 / 0 &amp; 1 / 1 denotes <b>input / output</b>. In the above figure, there are two transitions from each state based on the value of input, x.</p>
<p>In general, the number of states required in Mealy state machine is less than or equal to the number of states required in Moore state machine. There is an equivalent Moore state machine for each Mealy state machine.</p>
<h2>Moore State Machine</h2>
<p>A Finite State Machine is said to be Moore state machine, if outputs depend only on present states. The <b>block diagram</b> of Moore state machine is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/moore_state_machine.jpg" alt="Moore State Machine" />
<p>As shown in figure, there are two parts present in Moore state machine. Those are combinational logic and memory. In this case, the present inputs and present states determine the next states. So, based on next states, Moore state machine produces the outputs. Therefore, the outputs will be valid only after transition of the state.</p>
<p>The <b>state diagram</b> of Moore state machine is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/state_diagram_of_moore_state_machine.jpg" alt="State Diagram Moore State Machine" />
<p>In the above figure, there are four states, namely A, B, C &amp; D. These states and the respective outputs are labelled inside the circles. Here, only the input value is labeled on each transition. In the above figure, there are two transitions from each state based on the value of input, x.</p>  
<p>In general, the number of states required in Moore state machine is more than or equal to the number of states required in Mealy state machine. There is an equivalent Mealy state machine for each Moore state machine. So, based on the requirement we can use one of them.</p>
<h1>Digital Circuits - Algorithmic State Machines</h1>
<p>Every <b>digital system</b> can be partitioned into two parts. Those are data path (digital) circuits and control circuits. Data path circuits perform the functions such as storing of binary information (data) and transfer of data from one system to the other system. Whereas, control circuits determine the flow of operations of digital circuits.</p>
<p>It is difficult to describe the behavior of large state machines using state diagrams. To overcome this difficulty, Algorithmic State Machine (ASM) charts can be used. <b>ASM charts</b> are similar to flow charts. They are used to represent the flow of tasks to be performed by data path circuits and control circuits.</p>
<h2>Basic Components of ASM charts</h2>
<p>Following are the three basic components of ASM charts.</p>
<ul class="list">
<li>State box</li>
<li>Decision box</li>
<li>Conditional output box</li>
</ul>
<h3>State box</h3>
<p>State box is represented in rectangular shape. Each state box represents one state of the sequential circuit. The <b>symbol</b> of state box is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/state_box.jpg" alt="State Box" />
<p>It is having one entry point and one exit point. Name of the state is placed to the left of state box. The unconditional outputs corresponding to that state can be placed inside state box. <b>Moore</b> state machine outputs can also be placed inside state box.</p>
<h3>Decision box</h3>
<p>Decision box is represented in diamond shape. The <b>symbol</b> of decision box is shown in the following figure. </p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/decision_box.jpg" alt="Decision Box" />
<p>It is having one entry point and two exit paths. The inputs or Boolean expressions can be placed inside the decision box, which are to be checked whether they are true or false. If the condition is true, then it will prefer path1. Otherwise, it will prefer path2.</p>
<h3>Conditional output box</h3>
<p>Conditional output box is represented in oval shape. The <b>symbol</b> of conditional output box is shown in the following figure.</p>
<img src="https://www.tutorialspoint.com/digital_circuits/images/conditional_output_box.jpg" alt="Conditional output box" />
<p>It is also having one entry point and one exit point similar to state box. The conditional outputs can be placed inside state box. In general, <b>Mealy</b> state machine outputs are represented inside conditional output box. So, based on the requirement, we can use the above components properly for drawing ASM charts.</p>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_algorithmic_state_machine_charts.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="https://www.tutorialspoint.com/cgi-bin/printpage.cgi" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/digital_circuits/digital_circuits_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="https://www.tutorialspoint.com/index.htm" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="https://www.tutorialspoint.com/scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="https://www.tutorialspoint.com/about/tutorials_writing.htm">Write for us</a></li>
         <li><a href="https://www.tutorialspoint.com/about/faq.htm">FAQ's</a></li>
         <li><a href="https://www.tutorialspoint.com/about/about_helping.htm">Helping</a></li>
         <li><a href="https://www.tutorialspoint.com/about/contact_us.htm">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/custom-min.js?v=5"></script>
<script src="https://www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": "Digital Circuits Quick Guide",
    "name": "Digital Circuits Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/digital_circuits/images/2_variable_k_map.jpg",
        "width": 600,
        "height": 135
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "July 23 2017 03:34:50.",
    "dateModified": "July 23 2017 03:34:50.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": "If base or radix of a number system is \u2018r\u2019, then the numbers present in that number system are ranging from zero to r-1. The total numbers present in that number system is \u2018r\u2019. So, we will get various number systems, by choosing the values of radi..."
}
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Digital Circuits",
                "@id": "https://www.tutorialspoint.com/digital_circuits"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": "Digital Circuits - Quick Guide"
            }
        }
    ]
}
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/digital_circuits/digital_circuits_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:20:11 GMT -->
</html>
