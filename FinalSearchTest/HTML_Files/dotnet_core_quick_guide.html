<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 14:43:21 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>.NET Core Quick Guide</title>
<meta name="description" content=".NET Core Quick Guide - Learn .NET Core in simple and easy steps starting from basic to advanced concepts with examples including Overview, Prerequisites, Environment Setup, Getting Started, Numerics, Garbage Collection, Code Execution, Modularity, Project Files, Package References, Create UWP App, MSBuild, Metapackage, Windows Runtime and Extension SDKs, Create .NET Standard Library, Portable Class Library, Adding References to Library, Sharing .NET Core Libraries, Creating a Xamarin.Forms Project, PCL Troubleshooting, Create a Testing Project, Running Tests in Visual Studio, Testing Library, Managed Extensibility Framework, SDK, MSBuild and project.json, Restoring and Building with MSBuild, Migrations." />
<meta name="keywords" content=".NET Core, Tutorial, Learning, Overview, Prerequisites, Environment Setup, Getting Started, Numerics, Garbage Collection, Code Execution, Modularity, Project Files, Package References, Create UWP App, MSBuild, Metapackage, Windows Runtime and Extension SDKs, Create .NET Standard Library, Portable Class Library, Adding References to Library, Sharing .NET Core Libraries, Creating a Xamarin.Forms Project, PCL Troubleshooting, Create a Testing Project, Running Tests in Visual Studio, Testing Library, Managed Extensibility Framework, SDK, MSBuild and project.json, Restoring and Building with MSBuild, Migrations." />
<base  />
<link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="../theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="../theme/css/style-min5e1f.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #0058b2 url(../images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #0058b2 !important;}
.submenu-item{ border-bottom: 2px solid #0058b2 !important; border-top: 2px solid #0058b2 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="../images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="../index-2.html" title="tutorialspoint">
      <img alt="tutorialspoint" src="images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="../about/about_careers.html" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="../whiteboard.html"><img src="../theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="../netmeeting.html"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="../online_dev_tools.html"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="../articles/index.html"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="../index-2.html"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../codingground.html"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../tutor_connect/index.html"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="../videotutorials/index.html"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<style>
.content img.raligned{margin: 5px 3px 0px 26px; float: right; width: 275px;}
</style>
<div class="mini-logo">
<img src="images/dotnet-core-mini-logo.jpg" alt=".NET Core Tutorial" />
</div>
<ul class="nav nav-list primary left-menu" >
<li class="heading">.NET Core Tutorial</li>
<li><a href="index.html">.NET Core - Home</a></li>
<li><a href="dotnet_core_overview.html">.NET Core - Overview</a></li>
<li><a href="dotnet_core_prerequisites.html">.NET Core - Prerequisites</a></li>
<li><a href="dotnet_core_environment_setup.html">.NET Core - Environment Setup</a></li>
<li><a href="dotnet_core_getting_started.html">.NET Core - Getting Started</a></li>
<li><a href="dotnet_core_numerics.html">.NET Core - Numerics</a></li>
<li><a href="dotnet_core_garbage_collection.html">.NET Core - Garbage Collection</a></li>
<li><a href="dotnet_core_code_execution.html">.NET Core - Code Execution</a></li>
<li><a href="dotnet_core_modularity.html">.NET Core - Modularity</a></li>
<li><a href="dotnet_core_project_files.html">.NET Core - Project Files</a></li>
<li><a href="dotnet_core_package_references.html">.NET Core - Package References</a></li>
<li><a href="dotnet_core_create_uwp_app.html">Create UWP App with .NET Core</a></li>
<li><a href="dotnet_core_msbuild.html">.NET Core - MSBuild</a></li>
<li><a href="dotnet_core_metapackage.html">.NET Core - Metapackage</a></li>
<li><a href="dotnet_core_windows_runtime_and_extension_sdks.html">Windows Runtime &amp; Extension SDKs</a></li>
<li><a href="dotnet_core_create_standard_library.html">Create .NET Standard Library</a></li>
<li><a href="dotnet_core_portable_class_library.html">.NET Core - Portable Class Library</a></li>
<li><a href="dotnet_core_adding_references_to_library.html">Adding References to Library</a></li>
<li><a href="dotnet_core_sharing_libraries.html">Sharing .NET Core Libraries</a></li>
<li><a href="dotnet_core_creating_xamarin_forms_project.html">Creating a Xamarin.Forms Project</a></li>
<li><a href="dotnet_core_pcl_troubleshooting.html">.NET Core - PCL Troubleshooting</a></li>
<li><a href="dotnet_core_create_testing_project.html">.NET Core - Create a Testing Project</a></li>
<li><a href="dotnet_core_running_tests_in_visual_studio.html">Running Tests in Visual Studio</a></li>
<li><a href="dotnet_core_testing_library.html">.NET Core - Testing Library</a></li>
<li><a href="dotnet_core_managed_extensibility_framework.html">Managed Extensibility Framework</a></li>
<li><a href="dotnet_core_sdk.html">.NET Core -  SDK</a></li>
<li><a href="dotnet_core_msbuild_and_project_json.html">.NET Core - MSBuild &amp; project.json</a></li>
<li><a href="dotnet_core_restoring_building_with_msbuild.html">Restoring and Building &amp; MSBuild</a></li>
<li><a href="dotnet_core_migrations.html">.NET Core - Migrations</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">.NET Core Useful Resources</li>
<li><a href="dotnet_core_quick_guide.html">.NET Core - Quick Guide</a></li>
<li><a href="dotnet_core_useful_resources.html">.NET Core - Useful Resources</a></li>
<li><a href="dotnet_core_discussion.html">.NET Core - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="../developers_best_practices/index.html">Developer's Best Practices</a></li>
<li><a target="_top" href="../questions_and_answers.html">Questions and Answers</a></li>
<li><a target="_top" href="../effective_resume_writing.html">Effective Resume Writing</a></li>
<li><a target="_top" href="../hr_interview_questions/index.html">HR Interview Questions</a></li>
<li><a target="_top" href="../computer_glossary.html">Computer Glossary</a></li>
<li><a target="_top" href="../computer_whoiswho.html">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>.NET Core - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="dotnet_core_migrations.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="dotnet_core_useful_resources.html">Next Page <i class="icon 
icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>.NET Core - Overview</h1>
<p>.NET Core is the latest general purpose development platform maintained by Microsoft. It works across different platforms and has been redesigned in a way that makes .NET fast, flexible and modern. This happens to be one of the major contributions by Microsoft. Developers can now build Android, iOS, Linux, Mac, and Windows applications with .NET, all in Open Source.</p>
<p>In this tutorial, we will cover .NET Core and a few new innovations including the .NET Framework updates, .NET Standard, and Universal Windows Platform updates, etc.</p>
<h2>Characteristics of .NET Core</h2>
<p>The following are the major characteristics of .NET Core &minus;</p>
<h3>Open source</h3>
<ul class="list">
<li><p>.NET Core is an open source implementation, using MIT and Apache 2 licenses.</p></li>
<li><p>.NET Core is a .NET Foundation project and is available on GitHub.</p></li>
<li><p>As an open source project, it promotes a more transparent development process and promotes an active and engaged community.</p></li>
</ul>
<h3>Cross-platform</h3>
<ul class="list">
<li><p>Application implemented in .NET Core can be run and its code can be reused regardless of your platform target.</p></li>
<li><p>It currently supports three main operating systems (OS)</p>
<ul class="list">
<li><p>Windows</p></li>
<li><p>Linux</p></li>
<li><p>MacOS</p></li>
</ul>
</li>
<li><p>The supported Operating Systems (OS), CPUs and application scenarios will grow over time, provided by Microsoft, other companies, and individuals.</p></li>
</ul>
<h3>Flexible deployment</h3>
<ul class="list">
<li><p>There can be two types of deployments for .NET Core applications &minus;</p>
<ul class="list">
<li><p>Framework-dependent deployment</p></li>
<li><p>Self-contained deployment</p></li>
</ul>
</li>
<li><p>With framework-dependent deployment, your app depends on a system-wide version of .NET Core on which your app and third-party dependencies are installed.</p></li>
<li><p>With self-contained deployment, the .NET Core version used to build your application is also deployed along with your app and third-party dependencies and can run side-by-side with other versions.</p></li>
</ul>
<h3>Command-line tools</h3>
<ul class="list">
<li><p>All product scenarios can be exercised at the command-line.</p></li>
</ul>
<h3>Compatible</h3>
<ul class="list">
<li><p>.NET Core is compatible with .NET Framework, Xamarin and Mono, via the .NET Standard Library</p></li>
</ul>
<h3>Modular</h3>
<ul class="list">
<li><p>.NET Core is released through NuGet in smaller assembly packages.</p></li>
<li><p>.NET Framework is one large assembly that contains most of the core functionalities.</p></li>
<li><p>.NET Core is made available as smaller feature-centric packages.</p></li>
<li><p>This modular approach enables the developers to optimize their app by including just those NuGet packages which they need in their app.</p></li>
<li><p>The benefits of a smaller app surface area include tighter security, reduced servicing, improved performance, and decreased costs in a pay-for-what-you-use model.</p></li>
</ul>
<h2>The .NET Core Platform</h2>
<p>.NET Core Platform contains the following main parts &minus;</p>
<ul class="list">
<li><p><b>.NET Runtime</b> &minus; It provides a type system, assembly loading, a garbage collector, native interop and other basic services.</p></li>
<li><p><b>Fundamental Libraries</b> &minus; A set of framework libraries, which provide primitive data types, app composition types and fundamental utilities.</p></li>
<li><p><b>SDK &amp; Compiler</b> &minus; A set of SDK tools and language compilers that enable the base developer experience, available in the .NET Core SDK.</p></li>
<li><p><b>‘dotnet’ app host</b> &minus; It is used to launch .NET Core apps. It selects the runtime and hosts the runtime, provides an assembly loading policy and launches the app. The same host is also used to launch SDK tools in much the same way.</p></li>
</ul>
<h1>.NET Core - Prerequisites</h1>
<p>In this chapter, we will discuss the various dependencies that you need to deploy and run. These include the .NET Core applications on Windows machines that are developed using Visual Studio.</p>
<h2>Supported Windows Versions</h2>
<p>.NET Core is supported on the following versions of Windows &minus;</p>
<ul class="list">
<li>Windows 7 SP1</li>
<li>Windows 8.1</li>
<li>Windows 10</li>
<li>Windows Server 2008 R2 SP1 (Full Server or Server Core)</li>
<li>Windows Server 2012 SP1 (Full Server or Server Core)</li>
<li>Windows Server 2012 R2 SP1 (Full Server or Server Core)</li>
<li>Windows Server 2016 (Full Server, Server Core or Nano Server)</li>
</ul>
<h2>Dependencies</h2>
<ul class="list">
<li><p>If you are running your .NET Core application on Windows versions earlier than Windows 10 and Windows Server 2016, then it will also require the Visual C++ Redistributable.</p></li>
<li><p>This dependency is automatically installed for you if you use the .NET Core installer.</p></li>
<li><p>You need to manually install the Visual C++ Redistributable for Visual Studio 2015 if you are installing .NET Core via the installer script or deploying a self-contained .NET Core application.</p></li>
<li><p>For Windows 7 and Windows Server 2008 machines, you need to make sure that your Windows installation is up-to-date and also includes hotfix KB2533623 installed through Windows Update.</p></li>
</ul>
<h2>Prerequisites with Visual Studio</h2>
<ul class="list">
<li><p>To develop .NET Core applications using the .NET Core SDK, you can use any editor of your choice.</p></li>
<li><p>However, if you want to develop .NET Core applications on Windows using Visual Studio, you can use the following two versions &minus;</p>
<ul class="list">
<li><p>Visual Studio 2015</p></li>
<li><p>Visual Studio 2017 RC</p></li>
</ul>
</li>
<li><p>Projects created with Visual Studio 2015 will be project.json-based by default while projects created with Visual Studio 2017 RC will always be MSBuild-based.</p></li> 
</ul>
<h1>.NET Core - Environment Setup</h1>
<p>In this chapter, we will discuss the Environment Setup of .NET Core. It is a significant redesign of the .NET Framework. To use .NET Core in your application, there are two versions you can use &minus;</p>
<ul class="list">
<li>Visual Studio 2015</li>
<li>Visual Studio 2017 RC</li>
</ul>
<h2>Visual Studio 2015</h2>
<p>To use Visual Studio 2015, you must have installed the following &minus;</p>
<ul class="list">
<li>Microsoft Visual Studio 2015 Update 3</li>
<li>Microsoft .NET Core 1.0.1 - VS 2015 Tooling Preview 2</li>
</ul>
<p>Microsoft provides a free version of visual studio which also contains the SQL Server and can be downloaded from <a target="_blank" rel="nofollow" href="https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx">https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx</a> and Microsoft .NET Core 1.0.1 - VS 2015 Tooling Preview 2 can be downloaded from <a target="_blank" rel="nofollow" href="https://www.visualstudio.com/downloads/" >https://www.visualstudio.com/downloads/</a></p>
<p>You can also follow the installation guidelines on the following Url <a target="_blank" rel="nofollow" href="https://www.microsoft.com/net/core/#windowsvs2017" >https://www.microsoft.com/net/core/#windowsvs2017</a></p>
<h3>Installation of Visual Studio 2015</h3>
<p>Follow these steps to install Visual Studio 2015 &minus;</p>
<p><b>Step 1</b> &minus; Once the downloading completes, then run the installer. The following dialog box will be displayed.</p>
<img src="images/download.jpg" alt="Download" />
<p><b>Step 2</b> &minus; Click <b>Install</b> to start the installation process.</p>
<img src="images/install.jpg" alt="Install" />
<p><b>Step 3</b> &minus; Once the installation completes, you will see the following dialog box.</p>
<img src="images/complete.jpg" alt="Complete" />
<p><b>Step 4</b> &minus; Close this dialog and restart your computer if required.</p>
<p><b>Step 5</b> &minus; Open Visual Studio from the Start Menu; you will receive the following dialog box. It may take a few minutes to load and finally be used for the first time.</p>
<img src="images/open.jpg" alt="Open" />
<p><b>Step 6</b> &minus; Once it is loaded, you will see the following screen.</p>
<img src="images/loading.jpg" alt="Loading" />
<p><b>Step 7</b> &minus; Once Visual Studio installation is finished, then close Visual Studio and launch Microsoft .NET Core - VS 2015 Tooling Preview 2.</p>
<img src="images/launch.jpg" alt="Launch" />
<p><b>Step 8</b> &minus; Check the checkbox and click Install.</p>
<img src="images/checkbox.jpg" alt="Checkbox" />
<p><b>Step 9</b> &minus; Once the installation completes, you will see the following dialog box.</p>
<img src="images/application_ready.jpg" alt="Application Ready" />
<p>You are now ready to start your application using .NET Core.</p>
<h3>Visual Studio 2017</h3>
<p>In this tutorial, we will be using Visual Studio 2015, but if you want to use Visual Studio 2017, an experimental release of .NET Core tools for Visual Studio is included in Visual Studio 2017 RC and you can see the installation guidelines here <a target="_blank" rel="nofollow" href="https://www.microsoft.com/net/core/#windowsvs2017" >https://www.microsoft.com/net/core/#windowsvs2017</a></p>
<h1>.NET Core - Getting Started</h1>
<p>Visual Studio 2015 provides a full-featured development environment for developing .NET Core applications. In this chapter, we will be creating a new project inside Visual Studio. Once you have installed the Visual Studio 2015 tooling, you can start building a new .NET Core Application.</p>
<img src="images/core_application.jpg" alt="Core Application" />
<p>In the <b>New Project</b> dialog box, in the Templates list, expand the Visual C# node and select .NET Core and you should see the following three new project templates</p>
<ul class="list">
<li>Class Library (.NET Core)</li>
<li>Console Application (.NET Core)</li>
<li>ASP.NET Core Web Application (.NET Core)</li>
</ul>
<p>In the middle pane on the New Project dialog box, select Console Application (.NET Core) and name it "FirstApp", then click OK.</p>
<img src="images/first_app.jpg" alt="First App" />
<p>Visual Studio will open the newly created project, and you will see in the Solution Explorer window all of the files that are in this project.</p>
<p>To test that .NET core console application is working, let us add the following line.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 
  
namespace FirstApp { 
   public class Program { 
      public static void Main(string[] args) { 
         Console.WriteLine("Hello guys, welcome to .NET Core world!"); 
      } 
   } 
}
</pre>
<p>Now, run the application. You should see the following output.</p>
<img src="images/output.jpg" alt="Output" />
<h1>.NET Core - Numerics</h1>
<p>.NET Core supports the standard numeric integral and floating-point primitives. It also supports the following types &minus;</p>
<ul class="list">
<li><p>System.Numerics.BigInteger which is an integral type with no upper or lower bound.</p></li>
<li><p>System.Numerics.Complex is a type that represents complex numbers.</p></li>
<li><p>A set of Single Instruction Multiple Data (SIMD)-enabled vector types in the System.Numerics namespace.</p></li>
</ul>
<h2>Integral types</h2>
<p>.NET Core supports both signed and unsigned integers of different ranges from one byte to eight bytes in length. All integers are value types.</p>
<p>The following table represents the integral types and their size;</p>
<table class="table table-bordered" style="text-align:center;font-size:11.7px">
<tr>
<th style="text-align:center;vertical-align:middle;">Type</th>
<th style="text-align:center;">Signed/ Unsigned</th>
<th style="text-align:center;">Size (bytes)</th>
<th style="text-align:center;vertical-align:middle;">Minimum Value</th>
<th style="text-align:center;vertical-align:middle;">Maximum Value</th>
</tr>
<tr>
<td>Byte</td>
<td>Unsigned</td>
<td>1</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>Int16</td>
<td>Signed</td>
<td>2</td>
<td>−32,768</td>
<td>32,767</td>
</tr>
<tr>
<td>Int32</td>
<td>Signed</td>
<td>4</td>
<td>−2,147,483,648</td>
<td>2,147,483,647</td>
</tr>
<tr>
<td>Int64</td>
<td>Signed</td>
<td>8</td>
<td>−9,223,372,036,854,775,808</td>
<td>9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>SByte</td>
<td>Signed</td>
<td>1</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>UInt16</td>
<td>Unsigned</td>
<td>2</td>
<td>0</td>
<td>65,535</td>
</tr>
<tr>
<td>UInt32</td>
<td>Unsigned</td>
<td>4</td>
<td>0</td>
<td>4,294,967,295</td>
</tr>
<tr>
<td>UInt64</td>
<td>Unsigned</td>
<td>8</td>
<td>0</td>
<td>18,446,744,073,709,551,615</td>
</tr>
</table>
<p>Each integral type supports a standard set of arithmetic, comparison, equality, explicit conversion, and implicit conversion operators.</p>
<p>You can also work with the individual bits in an integer value by using the System.BitConverter class.</p>
<h2>Floating-point types</h2>
<p>.NET Core includes three primitive floating point types, which are shown in the following table.</p>
<table class="table table-bordered" style="text-align:center;font-size:11.7px">
<tr>
<th style="text-align:center;vertical-align:middle;">Type</th>
<th style="text-align:center;">Size (bytes)</th>
<th style="text-align:center;vertical-align:middle;">Minimum Value</th>
<th style="text-align:center;vertical-align:middle;">Maximum Value</th>
</tr>
<tr>
<td>Double</td>
<td>8</td>
<td>−1.79769313486232e308</td>
<td>1.79769313486232e308</td>
</tr>
<tr>
<td>Single</td>
<td>4</td>
<td>−3.402823e38</td>
<td>3.402823e38</td>
</tr>
<tr>
<td style="vertical-align:middle;">Decimal</td>
<td style="vertical-align:middle;">16</td>
<td>−79,228,162,514,264,337,593,5 43,950,335</td>
<td>79,228,162,514,264,337,593,543,9 50,335</td>
</tr>
</table>
<ul class="list">
<li><p>Each floating-point type supports a standard set of arithmetic, comparison, equality, explicit conversion, and implicit conversion operators.</p></li>
<li><p>You can also work with the individual bits in Double and Single values by using the BitConverter class.</p></li>
<li><p>The Decimal structure has its own methods, Decimal.GetBits and Decimal.Decimal(Int32()), for working with a decimal value's individual bits, as well as its own set of methods for performing some additional mathematical operations.</p></li>
</ul>
<h3>BigInteger</h3>
<ul class="list">
<li><p>System.Numerics.BigInteger is an immutable type that represents an arbitrarily large integer whose value in theory has no upper or lower bounds.</p></li>
<li><p>The methods of the BigInteger type is closely parallel to those of the other integral types.</p></li>
</ul>
<h3>Complex</h3>
<ul class="list">
<li><p>The System.Numerics.Complex type represents a complex number, i.e., a number with a real number part and an imaginary number part</p></li>
<li><p>It supports a standard set of arithmetic, comparison, equality, explicit conversion, and implicit conversion operators, as well as mathematical, algebraic, and trigonometric methods.</p></li>
</ul>
<h3>SIMD</h3>
<ul class="list">
<li><p>The Numerics namespace includes a set of SIMD-enabled vector types for .NET Core.</p></li>
<li><p>SIMD allows some operations to be parallelized at the hardware level, which results in huge performance improvements in mathematical, scientific, and graphics apps that perform computations over vectors.</p></li>
<li><p>The SIMD-enabled vector types in .NET Core include the following &minus;</p>
<ul class="list">
<li><p>System.Numerics.Vector2, System.Numerics.Vector3, and System.Numerics.Vector4 types, which are 2, 3, and 4-dimensional vectors of type Single.</p></li>
<li><p>The Vector &lt;T&gt; structure that allows you to create a vector of any primitive numeric type. The primitive numeric types include all numeric types in the System namespace except for Decimal.</p></li>
<li><p>Two matrix types, System.Numerics.Matrix3&times;2, which represents a 3&times;2 matrix; and System.Numerics.Matrix4&times;4, which represents a 4&times;4 matrix.</p></li>
<li><p>The System.Numerics.Plane type, which represents a three-dimensional plane, and the System.Numerics.Quaternion type, which represents a vector that is used to encode three-dimensional physical rotations.</p></li>
</ul>
</li>
</ul>
<h1>.NET Core - Garbage Collection</h1>
<p>In this chapter, we will cover the concept of Garbage collection which is one of most important features of the .NET managed code platform. The garbage collector (GC) manages the allocation and release of memory. The garbage collector serves as an automatic memory manager.</p>
<ul class="list">
<li><p>You do not need to know how to allocate and release memory or manage the lifetime of the objects that use that memory</p></li>
<li><p>An allocation is made any time you declare an object with a “new” keyword or a value type is boxed. Allocations are typically very fast</p></li>
<li><p>When there isn’t enough memory to allocate an object, the GC must collect and dispose of garbage memory to make memory available for new allocations.</p></li>
<li><p>This process is known as <b>garbage collection</b>.</p></li>
</ul>
<h2>Advantages of Garbage Collection</h2>
<p>Garbage Collection provides the following benefits &minus;</p>
<ul class="list">
<li><p>You don’t need to free memory manually while developing your application.</p></li>
<li><p>It also allocates objects on the managed heap efficiently.</p></li>
<li><p>When objects are no longer used then it will reclaim those objects by clearing their memory, and keeps the memory available for future allocations.</p></li>
<li><p>Managed objects automatically get clean content to start with, so their constructors do not have to initialize every data field.</p></li>
<li><p>It also provides memory safety by making sure that an object cannot use the content of another object.</p></li>
</ul>
<h2>Conditions for Garbage Collection</h2>
<p>Garbage collection occurs when one of the following conditions is true.</p>
<ul class="list">
<li><p>The system has low physical memory.</p></li>
<li><p>The memory that is used by allocated objects on the managed heap surpasses an acceptable threshold. This threshold is continuously adjusted as the process runs.</p></li>
<li><p>The <b>GC.Collect</b> method is called and in almost all cases, you do not have to call this method, because the garbage collector runs continuously. This method is primarily used for unique situations and testing.</p></li>
</ul>
<h2>Generations</h2>
<p>The .NET Garbage Collector has 3 generations and each generation has its own heap that that is used for the storage of allocated objects. There is a basic principle that most objects are either short-lived or long-lived.</p>
<h3>Generation First (0)</h3>
<ul class="list">
<li><p>In Generation 0, objects are first allocated.</p></li>
<li><p>In this generation, objects often don’t live past the first generation, since they are no longer in use (out of scope) by the time the next garbage collection occurs.</p></li>
<li><p>Generation 0 is quick to collect because its associated heap is small.</p></li>
</ul>
<h3>Generation Second (1)</h3>
<ul class="list">
<li><p>In Generation 1, objects have a second chance space.</p></li>
<li><p>Objects that are short-lived but survive the generation 0 collection (often based on coincidental timing) go to generation 1.</p></li>
<li><p>Generation 1 collections are also quick because its associated heap is also small.</p></li>
<li><p>The first two heaps remain small because objects are either collected or promoted to the next generation heap.</p></li>
</ul>
<h3>Generation Third (2)</h3>
<ul class="list">
<li><p>In Generation 2, all long objects are lived and its heap can grow to be very large.</p></li>
<li><p>The objects in this generation can survive a long time and there is no next generation heap to further promote objects.</p></li>
<li><p>The Garbage Collector has an additional heap for large objects known as Large Object Heap (LOH).</p></li>
<li><p>It is reserved for objects that are 85,000 bytes or greater.</p></li>
<li><p>Large objects are not allocated to the generational heaps but are allocated directly to the LOH</p></li>
<li><p>Generation 2 and LOH collections can take noticeable time for programs that have run for a long time or operate over large amounts of data.</p></li>
<li><p>Large server programs are known to have heaps in the 10s of GBs.</p></li>
<li><p>The GC employs a variety of techniques to reduce the amount of time that it blocks program execution.</p></li>
<li><p>The primary approach is to do as much garbage collection work as possible on a background thread in a way that does not interfere with program execution.</p></li>
<li><p>The GC also exposes a few ways for developers to influence its behavior, which can be quite useful to improve performance.</p></li>
</ul>
<h1>.NET Core - Code Execution</h1>
<p>In this chapter, we will understand the execution process of .NET Core and compare it with the .NET Framework. The managed execution process includes the following steps.</p>
<ul class="list">
<li>Choosing a compiler</li>
<li>Compiling your code to MSIL</li>
<li>Compiling MSIL to native code</li>
<li>Running code</li>
</ul>
<img src="images/code_execution.jpg" alt="Code Execution" />
<h3>Choosing a Compiler</h3>
<ul class="list">
<li><p>It is a multi-language execution environment, the runtime supports a wide variety of data types and language features.</p></li>
<li><p>To obtain the benefits provided by the common language runtime, you must use one or more language compilers that target the runtime.</p></li>
</ul>
<h3>Compiling your code to MSIL</h3>
<ul class="list">
<li><p>Compiling translates your source code into Microsoft Intermediate Language (MSIL) and generates the required metadata.</p></li>
<li><p>Metadata describes the types in your code, including the definition of each type, the signatures of each type's members, the members that your code references, and other data that the runtime uses at execution time.</p></li>
<li><p>The runtime locates and extracts the metadata from the file as well as from framework class libraries (FCL) as needed during execution.</p></li>
</ul>
<h3>Compiling MSIL to Native Code</h3>
<ul class="list">
<li><p>At execution time, a just-in-time (JIT) compiler translates the MSIL into native code.</p></li>
<li><p>During this compilation, code must pass a verification process that examines the MSIL and metadata to find out whether the code can be determined to be type safe.</p></li>
</ul>
<h3>Running Code</h3>
<ul class="list">
<li><p>The common language runtime provides the infrastructure that enables the execution to take place and services that can be used during execution.</p></li>
<li><p>During execution, managed code receives services such as garbage collection, security, interoperability with unmanaged code, cross-language debugging support, and enhanced deployment and versioning support.</p></li>
</ul>
<h2>.NET Core Code Execution Process</h2>
<p>Now let’s relate how code executes with .NET Core as compared to .NET Framework. In .NET Core there are many replacements of these components that are the part of the .NET Framework.</p>
<img src="images/dotnet_core_code_execution.jpg" alt=".NET Core Code Execution" />
<ul class="list">
<li><p>In .NET Core now we have a new series of compilers, like we have Roslyn for C# and VB.</p></li>
<li><p>You can also make use of the new F# 4.1 compiler if you want to use F# with .NET Core.</p></li>
<li><p>Actually these tools are different and we can use Roslyn with .NET Framework as well if we are using C# 6 or later, because C# compiler can only support up to C# 5.</p></li>
<li><p>In .NET Core, we don’t have a framework class libraries (FCL), so a different set of libraries are used and we now have CoreFx.</p></li>
<li><p>CoreFx is the reimplementation of the class libraries for .NET Core.</p></li>
<li><p>We also have a new run time with .NET Core known as CoreCLR and leverages a JIT Compiler.</p></li>
<li><p>Now the question is why do we have the reimplementation of all these components that we already have in .NET framework.</p></li>
<li><p>So the answer is the same as why Microsoft implemented .NET Core.</p></li>
</ul>
<h1>.NET Core - Modularity</h1>
<p>It is another consideration of .NET Core to build and implement application that is modular. Instead of installing the entire .NET Framework, your application can now just install what is required. Let us go to the visual studio and see the modularity.</p>
<p>Here is our simple .NET Core application, in Solution Explorer. Let us expand References and you will see reference to .NETCoreApp</p>
<img src="images/dotnet_core_app.jpg" alt=".Net Core App" />
<p>Inside .NETCoreApp, you will see package reference to NuGet; let us expand it.</p>
<img src="images/nuget.jpg" alt="NuGet" />
<p>You will see the whole series of NuGet Package references. If you have worked in .NET Framework, then many of these namespaces will look familiar, because you are used to it by using in .NET Framework.</p>
<p>.NET Framework is split into many different pieces and re-implemented with CoreFx; these pieces are further distributed as individual packages.</p>
<img src="images/framework.jpg" alt="Framework" />
<ul class="list">
<li><p>Now if you expand the NETStandard.Library, you will see addition references. You will even notice System.Console which we are using in this application.</p></li>
<li><p>Now you don’t have to bring in everything inside the .NET Framework, but just bring in what you need for your application.</p></li>
<li><p>There are some other benefits as well; for example, these modules can be updated individually if desired.</p></li>
</ul>
<p>Modularity leads to performance benefits and your application can run faster, especially ASP.NET Core application.</p>
<h1>.NET Core - Project Files</h1>
<p>In this chapter, we will discuss .NET Core project files and how you can add existing files in your project.</p>
<p>Let us understand a simple example in which we have some files which are already created; we have to add these files in our FirstApp project.</p>
<p>Here is the implementation of the <b>Student.cs</b> file</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 
  
namespace FirstApp { 
   public class Student { 
      public int ID { get; set; } 
      public string LastName { get; set; } 
      public string FirstMidName { get; set; } 
      public DateTime EnrollmentDate { get; set; } 
   } 
}
</pre>
<p>Here is the implementation of the <b>Course.cs</b> file.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 
  
namespace FirstApp { 
   public class Course { 
      public int CourseID { get; set; } 
      public string Title { get; set; } 
      public int Credits { get; set; } 
   } 
}
</pre>
<p>Let us now save these three files in your disk and the source folder of your project.</p>
<img src="images/source_folder.jpg" alt="Source Folder" />
<ul class="list">
<li><p>Now if you are familiar with .NET and this one was a traditional .NET framework console application, it is important to understand how to add these files in your project in Visual Studio.</p></li>
<li><p>You first need to drag the files to the solution explorer to copy them in your project folder, because your project needs reference to these files.</p></li>
<li><p>One of the benefits of .NET Core is the approach taken with the project file (project.json); we can just drop files into the root of our project and then these will be automatically included in our project.</p></li>
<li><p>We don’t have to manually reference files like we did in the past for traditional .NET Framework application in Visual Studio.</p></li>
</ul>
<p>Let us now open the root of your project.</p>
<img src="images/root.jpg" alt="Root" />
<p>Let us now copy all of the three files into the root of your project.</p>
<img src="images/project.jpg" alt="Project" />
<p>You can now see all the files copied to the root folder.</p>
<p>Let us now go to Visual Studio; you will receive the following dialog box.</p>
<img src="images/visual.jpg" alt="Visual" />
<p>Click <b>Yes to All</b> to reload your project.</p>
<img src="images/yes_to_all.jpg" alt="Yes to all" />
<p>You will now that files are automatically included in your project.</p>
<h1>.NET Core - Package References</h1>
<p>In this chapter, we will discuss how to add packages in your .NET Core application and how to find a specific package. We can directly go to NuGet and add package, but here we will see some other places.</p>
<p>Let us now go to the source code of .NET Core which is located here &minus; <a target="_blank" rel="nofollow" href="https://github.com/dotnet/corefx" >https://github.com/dotnet/corefx</a></p>
<img src="images/source_code.jpg" alt="Source Code" />
<p>In CoreFx repo, open the <b>src</b> folder &minus;</p>
<img src="images/corefx.jpg" alt="CoreFx" />
<p>And you will see the whole list of folders that correspond to different packages. Let us now search Json &minus;</p>
<img src="images/json.jpg" alt="Json" />
<p>There is another way to find your package, you probably know various types if you are familiar with .NET Framework, but the assembling of packages in .NET Core is totally different and you won’t know where that packages in.</p>
<p>If you know the type, you can search to reverse package search by using <a target="_blank" rel="nofollow" href="https://packagesearch.azurewebsites.net/" >https://packagesearch.azurewebsites.net/</a></p>
<img src="images/reverse_package.jpg" alt="Reverse Package" />
<p>Here you can enter any type of package you would like to find. Then, this site will scan NuGet and find the relevant packages for you.</p>
<p>Let us now search for <b>DataContractJson</b>.</p>
<img src="images/datacontractjson.jpg" alt="DataContractJson" />
<p>You will now see that we get the same package; let us click on the package.</p>
<img src="images/package.jpg" alt="package" />
<p>You will now see the NuGet page; you need to confirm that you need this package. You can add this in your application using a few methods.</p>
<p>Let us open the project.json file.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "emitEntryPoint": true 
   }, 
   "dependencies": { 
      "Microsoft.NETCore.App": { 
         "type": "platform", 
         "version": "1.0.1" 
      } 
   }, 
   "frameworks": { 
      "netcoreapp1.0": { 
         "imports": "dnxcore50" 
      } 
   } 
} 
</pre>
<p>This is the new project format and inside this file you will see the dependencies section. Let us add a new dependency as shown below.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "emitEntryPoint": true 
   }, 
   "dependencies": { 
      "Microsoft.NETCore.App": { 
         "type": "platform", 
         "version": "1.0.1" 
      }, 
      "System.Runtime.Serialization.Json": "4.0.2" 
   }, 
   "frameworks": { 
      "netcoreapp1.0": { 
         "imports": "dnxcore50" 
      } 
   } 
}
</pre>
<p>Now if you look at your references, then you will see that <b>System.Runtime.Serialization.Json</b> package is added to your project.</p>
<img src="images/run.jpg" alt="Run" />
<p>Another way is to go to the NuGet Manager and browse the package you want to add.</p>
<img src="images/browse_package.jpg" alt="Browse Package" />
<h1>.NET Core - Create UWP App</h1>
<p>In this chapter, we will discuss how to create a UWP application using .NET Core. UWP is also known as Windows 10 UWP application. This application does not run on previous versions of Windows but will only run on future version of Windows.</p>
<p>Following are a few exceptions where UWP will run smoothly.</p>
<ul class="list">
<li><p>If you want to run it locally you must have Windows 10, you can also develop on Windows 8 and then you will need to run it on Emulator, but it is encouraged to use Windows 10.</p></li>
<li><p>For UWP application you will also need Windows 10 SDK. Let us open Visual Studio 2015 setup and then modify Visual Studio.</p></li>
<li><p>On select features page, scroll down and you will see Universal Windows App Development Tools, check that option as shown below.</p></li>
</ul>
<p>Here you can see the different versions of SDK and the latest update on Tools as well, click Next.</p>
<img src="images/professional_2015.jpg" alt="Professional 2015" />
<p>Now, click the <b>Install</b> button.</p>
<img src="images/install_button.jpg" alt="Install Button" />
<p>Once the installation is finished, you will need to restart your system.</p>
<img src="images/setup_completed.jpg" alt="Setup Completed" />
<p>Let us now implement the UWP by following these steps.</p>
<ul class="list">
<li><p>First, launch Visual Studio 2015.</p></li>
<li><p>Click on the File menu and select New &rarr; Project; a New Project dialog will show up. You can see the different types of templates on the left pane of the dialog box.</p></li>
</ul>
<img src="images/file_menu.jpg" alt="File Menu" />
<ul class="list">
<li><p>In the left pane, you can see the tree view, now select Universal template from Templates &rarr; Visual C# &rarr; Windows.</p></li> 
<li><p>From the center pane, select the Blank App (Universal Windows) template.</p></li>
<li><p>Give a name to the project by typing <b>UWPFirstApp</b> in the Name field and click OK.</p></li>
</ul>
<img src="images/uwpfirstapp.jpg" alt="UWPFirstApp" />
<ul class="list">
<li><p>The target version/minimum version dialog appears. The default settings are fine for this tutorial, so select OK to create the project.</p></li>
</ul>
<img src="images/default_settings.jpg" alt="Default Settings" />
<ul class="list">
<li><p>Here, we have a single project which can target all Windows 10 Devices, and you will notice that both .NET Core and UWP are simplification of multi-targeting.</p></li>
<li><p>When a new project opens, its files are displayed on the right hand side of the Solution Explorer pane. You may need to choose the Solution Explorer tab instead of the Properties tab to see your files.</p></li>
<li><p>Although the Blank App (Universal Window) is a minimal template, it still contains a lot of files. These files are essential to all UWP apps using C#. Every project that you create in Visual Studio contains the files.</p></li>
<li><p>To see the running example, let us open MainPage.XAML and add the following code.</p></li>
</ul>
<pre class="prettyprint notranslate">
&lt;Page 
   x:Class = "UWPFirstApp.MainPage" 
   xmlns = "http://schemas.microsoft.com/winfx/2006/xaml/presentation" 
   xmlns:x = "http://schemas.microsoft.com/winfx/2006/xaml" 
   xmlns:local = "using:UWPFirstApp" 
   xmlns:d = "http://schemas.microsoft.com/expression/blend/2008" 
   xmlns:mc = "http://schemas.openxmlformats.org/markup-compatibility/2006" 
   mc:Ignorable = "d"&gt;  
   
   &lt;Grid Background = "{ThemeResource ApplicationPageBackgroundThemeBrush}"&gt; 
      &lt;StackPanel HorizontalAlignment = "Center"&gt; 
         &lt;TextBlock Text = "Hello, world!"  
            Margin = "20" 
            Width = "200" 
            HorizontalAlignment = "Left"/&gt; 
         &lt;TextBlock Text = "Write your name." 
            Margin = "20" 
            Width = "200" 
            HorizontalAlignment = "Left"/&gt; 
         &lt;TextBox x:Name = "txtbox"  
            Width = "280" 
            Margin = "20" 
            HorizontalAlignment = "Left"/&gt; 
         &lt;Button x:Name = "button" Content = "Click Me" 
            Margin = "20" 
            Click = "button_Click"/&gt; 
         &lt;TextBlock x:Name = "txtblock"  
            HorizontalAlignment = "Left" 
            Margin = "20"/&gt; 
      &lt;/StackPanel&gt; 
   &lt;/Grid&gt; 

&lt;/Page&gt; 
</pre>
<p>Below is the click event of button in C#.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.IO; 
using System.Linq; 
using System.Runtime.InteropServices.WindowsRuntime; 

using Windows.Foundation; 
using Windows.Foundation.Collections; 

using Windows.UI.Xaml; 
using Windows.UI.Xaml.Controls; 
using Windows.UI.Xaml.Controls.Primitives; 
using Windows.UI.Xaml.Data; 
using Windows.UI.Xaml.Input; 
using Windows.UI.Xaml.Media; 
using Windows.UI.Xaml.Navigation;  

// The Blank Page item template is documented at 
// http://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x409  

namespace UWPHellowWorld { 
   /// &lt;summary&gt; 
   /// An empty page that can be used on its own or navigated to within a Frame. 
   /// &lt;/summary&gt; 
   public sealed partial class MainPage : Page { 
      public MainPage() { 
         this.InitializeComponent(); 
      }  
      private void button_Click(object sender, RoutedEventArgs e) { 
         if (txtbox.Text != "") 
            txtblock.Text = "Hello: " + txtbox.Text; 
         else 
            txtblock.Text = "You have not write your name"; 
      } 
   } 
} 
</pre>
<p>Let us now run the above code on the local machine and you will see the following window. Now type any name in the text box and press the <b>Click Me</b> button.</p>
<img src="images/click_me.jpg" alt="Click Me" />
<h1>.NET Core - MSBuild</h1>
<p>In this chapter, we will discuss what is MSBuild and how it works with .NET Core. MSBuild is the build platform for Microsoft and Visual Studio. In UWP application if you open the project folder, then you will see both project.json and *.csproj files.</p>
<img src="images/project_json.jpg" alt="project.json" />
<p>But if you open our previous .NET Core Console app, then you will see project.json and *.xproj files.</p>
<img src="images/files.jpg" alt="Files" />
<ul class="list">
<li><p>The .NET Core build system or the project.json build system is not sufficient for UWP needs; this is why UWP is still using *.csproj (MSBuild) Build system.</p></li>
<li><p>But project.json will move out as far as the build system is concerned.</p></li>
<li><p>Now if you want to add a few existing files to your UWP application as we have added in the Console app, then you need to add those files in the project folder. Further, you will also need to include in your project in Solution Explorer as well.</p></li>
</ul>
<p>Let us now consider the following files; copy these files to your project folder.</p>
<img src="images/project_folder.jpg" alt="Project Folder" />
<p></p>
<img src="images/projects.jpg" alt="Projects" />
<p>Let us go back to Visual Studio and open the Solution Explorer.</p>
<img src="images/solution_explorer.jpg" alt="Solution Explorer" />
<ul class="list">
<li><p>You can now see that only copying files is not sufficient in case of UWP applications, because in Solution Explorer, we can’t see those files.</p></li>
<li><p>Now we must include those files as well by clicking on the <b>Show All Files</b> icon as highlighted in the above screenshot and you will see now all files in the project folder.</p></li>
</ul>
<img src="images/show_all_files.jpg" alt="Show All Files" />
<p>These two files are still not included in our project. To include these files, select these files and right-click on any file and then select <b>Include in Project</b>.</p>
<img src="images/include_in_project.jpg" alt="Include in Project" />
<p>Now these files are also included. One good thing that can be foreseen is the project.json approach of dropping files for *.csproj in the future version of the SKD tools and also to Visual Studio.</p>
<h1>.NET Core - Metapackage</h1>
<p>In this chapter, we will discuss the references between our Console app and our UWP app. If you look at the References in Solution Explorer of your Console application, you will see the .NETCoreApp as shown below.</p>
<img src="images/console_application.jpg" alt="Console Application" />
<p>.NETCoreApp is a new framework that targeted .NET Core application. Now if you look under the References of UWP application, it will look a bit different as shown below.</p>
<img src="images/uwp_application.jpg" alt="UWP Application" />
<ul class="list">
<li><p>The main reason for this is because here in UWP we have the *.csproj, so we are back to the old style of references and we can target only one framework with this project type.</p></li>
<li><p>The references are similar though. You can now see that in UWP application, the Miscrosoft.NETCore.UniversalWindowsPlatform NuGet Package reference is similar to the Microsoft.NETCore.App NuGet reference in Console application.</p></li>
<li><p>Both Miscrosoft.NETCore.UniversalWindowsPlatform and Microsoft.NETCore.App are meta-package which means that they are composed of other packages.</p></li>
<li><p>In Console application, we can drill in and see other packages inside Microsoft.NETCore.App, but we can’t do the same Miscrosoft.NETCore.UniversalWindowsPlatform in Solution Explorer.</p></li>
<li><p>However, we can use another tool, the NuGet Package Explorer to look at this. Let us now open this url in the browser &minus; <a target="_blank" rel="nofollow" href="https://npe.codeplex.com/downloads/get/clickOnce/NuGetPackageExplorer.application" >https://npe.codeplex.com/downloads/get/clickOnce/NuGetPackageExplorer.application</a> and you will see a small utility downloading.</p></li>
<li><p>Once downloading completes, then double-click on that file.</p></li>
</ul>
<img src="images/open_file.jpg" alt="Open File" />
<ul class="list">
<li><p>Click <b>Install</b> to start installation on the NuGet Package Explorer.</p></li>
</ul>
<img src="images/nuget_package_explorer.jpg" alt="NuGet Package Explorer" />
<ul class="list">
<li><p>When the installation is finished, you will see the following dialog box.</p></li>
</ul>
<img src="images/finished.jpg" alt="Finished" />
<ul class="list">
<li><p>Let us now click on the <b>Open a package from online feed</b> option.</p></li>
</ul>
<img src="images/online_feed.jpg" alt="Online Feed" />
<ul class="list">
<li><p>By default it will search for the nuget.org feed. Let us now search for Microsoft.NETCore.UniversalWindowsPlatform in the search box and you will see 1 result as shown below.</p></li>
</ul>
<img src="images/nuget_org_feed.jpg" alt="Nuget Org feed" />
<ul class="list">
<li><p>Click the <b>open</b> link and it will open the top-level dependencies of this metapackage.</p></li>
</ul>
<img src="images/open_link.jpg" alt="Open Link" />
<ul class="list">
<li><p>Let us now open the .NETCore meta package for the .NETCore application and meta-package for UWP application side by side.</p></li>
</ul>
<img src="images/meta_package.jpg" alt="Meta Package" />
<ul class="list">
<li><p>You can now see that each meta-package is composed of different set of packages.</p></li>
<li><p>.NET Core is a subset of the classes available in .NET Framework at least at this point of time, but is growing and will be as per the base classes of .NET Framework.</p></li>
<li><p>The UWP is based on .NET Core, it is a superset of the APIs available for Windows Store development.</p></li>
</ul>
<p>We now have more APIs available for development due to .NET Core.</p>
<h1>Windows Runtime and Extension SDKs</h1>
<p>Windows Runtime components are self-contained objects that you can instantiate and use from any language, including C#, Visual Basic, JavaScript, and C++. In addition to the .NET Core meta-package we saw in the previous chapter, UWP app also has a reference by default to a Universal Windows SDK.</p>
<img src="images/universal_windows_sdk.jpg" alt="Universal Windows SDK" />
<p>Universal Windows is the reference to Windows Runtime and it has been factored into a series of APIs contracts.</p>
<p>The set of APIs within a device family is broken down into subdivisions known as API contracts. You can find a list of different API contracts here <a target="_blank" rel="nofollow" href="https://msdn.microsoft.com/en-us/library/windows/apps/dn706135.aspx" >https://msdn.microsoft.com/en-us/library/windows/apps/dn706135.aspx</a></p>
<img src="images/api.jpg" alt="API" />
<p>Most of those APIs inside windows runtime are factored into a single contract. Let us now search for the Universal keyword on the API Contracts page.</p>
<img src="images/api_contracts_page.jpg" alt="API Contracts page" />
<p>You can see links to various APIs and you can also see the Universal family is so big that it has 12 pages of documentation.</p>
<p>You can also search for phone API contract on this page.</p>
<img src="images/phone_api.jpg" alt="phone API" />
<p>Let us now click on the <b>Windows.Phone.PhoneContract</b> and scroll down; you will now see the battery information of phone or the mobile device.</p>
<img src="images/battery_information.jpg" alt="battery information" />
<p>If you want to add this information on top of what you already have, then you should add the references manually. Let us now go to the Visual Studio and right-click on the References in Solution Explorer.</p>
<p>Select <b>Add References…</b></p>
<img src="images/add_references.jpg" alt="Add References" />
<p>You can now see the new reference category for Universal Windows; under this category there is Core which refers to the core Universal Windows API contracts</p>
<img src="images/api_contracts.jpg" alt="API contracts" />
<ul class="list">
<li><p>The Extensions allow us to extend the functionality and you will see different references Mobile, Desktop and other Extensions.</p></li>
<li><p>There are different SKD extensions and you can add on top to get more APIs.</p></li>
<li><p>You can also see different versions. So, make sure you get the latest version to get the updated APIs and then click OK.</p></li>
</ul>
<img src="images/updated_apis.jpg" alt="updated APIs" />
<p>You can now see that <b>Windows Mobile Extensions for the UWP</b> is added as reference.</p>
<h1>.NET Core - Create .NET Standard Library</h1>
<p>A class library defines the types and methods that can be called from any application.</p>
<ul class="list">
<li><p>A class library developed using .NET Core supports the .NET Standard Library, which allows your library to be called by any .NET platform that supports that version of the .NET Standard Library.</p></li>
<li><p>When you finish your class library, you can decide whether you want to distribute it as a third-party component, or whether you want to include it as a component that is bundled with one or more applications.</p></li>
</ul>
<p>Let us start by adding a class library project in our Console application; right-click on the <b>src</b> folder in Solution Explorer and select <b>Add &rarr; New Project…</b></p>
<img src="images/new_project.jpg" alt="New Project" />
<p>In the <b>Add New Project</b> dialog box, choose the .NET Core node, then choose the Class Library (.NET Core) project template.</p>
<p>In the Name text box, enter "UtilityLibrary" as the name of the project, as the following figure shows.</p>
<img src="images/utilitylibrary.jpg" alt="UtilityLibrary" />
<p>Click OK to create the class library project. Once the project is created, let us add a new class. Right-click on <b>project</b> in Solution Explorer and select <b>Add &rarr; Class...</b></p>
<img src="images/class.jpg" alt="Class" />
<p>Select class in the middle pane and enter StringLib.cs in the name and field and then click <b>Add</b>. Once the class is added, then replace the following code in StringLib.cs file.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 
  
namespace UtilityLibrary { 
   public static class StringLib { 
      public static bool StartsWithUpper(this String str) { 
         if (String.IsNullOrWhiteSpace(str)) 
         return false; 
         Char ch = str[0]; 
         return Char.IsUpper(ch); 
      } 
      public static bool StartsWithLower(this String str) { 
         if (String.IsNullOrWhiteSpace(str)) 
         return false; 
         Char ch = str[0]; 
         return Char.IsLower(ch); 
      } 
      public static bool StartsWithNumber(this String str) { 
         if (String.IsNullOrWhiteSpace(str)) 
         return false;  
         Char ch = str[0]; 
         return Char.IsNumber(ch); 
      } 
   } 
} 
</pre>
<ul class="list">
<li><p>The class library, <b>UtilityLibrary.StringLib</b>, contains some methods like, <b>StartsWithUpper</b>, <b>StartsWithLower</b>, and <b>StartsWithNumber</b> which returns a Boolean value that indicates whether the current string instance begins with an uppercase, lowercase and number respectively.</p></li>
<li><p>In .NET Core, the <b>Char.IsUpper</b> method returns true if a character is in uppercase, the Char.IsLower method returns true if a character is in lowercase, and similarly the Char.IsNumber method returns true if a character is a numeric.</p></li>
<li><p>On the menu bar, choose Build, Build Solution. The project should compile without error.</p></li>
<li><p>Our .NET Core console project doesn't have access to our class library.</p></li>
<li><p>Now to consume this class library we need to add reference of this class library in our console project.</p></li>
</ul>
<p>To do so, expand FirstApp and right-click on References and select <b>Add Reference…</b></p>
<img src="images/firstapp.jpg" alt="FirstApp" />
<p>In the Reference Manager dialog box, select UtilityLibrary, our class library project, and then click <b>OK</b>.</p>
<p>Let us now open the Program.cs file of the console project and replace all of the code with the following code.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Threading.Tasks; 
using UtilityLibrary; 

namespace FirstApp { 
   public class Program { 
      public static void Main(string[] args) { 
         int rows = Console.WindowHeight; 
         Console.Clear(); 
         do { 
            if (Console.CursorTop &gt;= rows || Console.CursorTop == 0) { 
               Console.Clear(); 
               Console.WriteLine("\nPress &lt;Enter&gt; only to exit; otherwise, enter a string and press &lt;Enter&gt;:\n"); 
            } 
            string input = Console.ReadLine(); 
            
            if (String.IsNullOrEmpty(input)) break; 
            Console.WriteLine("Input: {0} {1,30}: {2}\n", input, "Begins with uppercase? ", 
            input.StartsWithUpper() ? "Yes" : "No"); 
         } while (true); 
      } 
   } 
} 
</pre>
<p>Let us now run your application and you will see the following output.</p>
<img src="images/application.jpg" alt="Application" />
<p>For better understanding, let us make use of the other extension methods of your class library in your project.</p>
<h1>.NET Core - Portable Class Library</h1>
<p>In this chapter, we will discuss what is PCL (Portable Class Library), and also why we need PCL. To understand this concept, let us open the class library project folder which we have created in the previous chapter.</p>
<img src="images/pcl.jpg" alt="PCL" />
<p>In this folder, you can see that in addition to project.json and CS files we also have *.xproj file, and that is because Visual Studio setup .NET Core project type as *.xproj instead of *.csproj.</p>
<p>As mentioned by Microsoft, *.xproj will be going away, but it is still here in preview 2 tooling. As we have covered that UWP application uses the *.csproj.</p>
<img src="images/tooling.jpg" alt="Tooling" />
<p>Now it is actually not feasible to get *.csproj to reference and *.xproj and that functionality is not going to be implemented because *.xproj will move out.</p>
<p>So instead, we need a class library which can be shared between the console app and the UWP app and here comes PCL.</p>
<h2>What is PCL</h2>
<p>Let us now understand what PCL is &minus;</p>
<ul class="list">
<li><p>The Portable Class Library project enables you to write and build managed assemblies that work on more than one .NET Framework platform.</p></li>
<li><p>You can create classes that contain code you wish to share across many projects, such as shared business logic, and then reference those classes from different types of projects.</p></li>
<li><p>It can also help you build cross-platform apps and libraries for Microsoft platforms quickly and easily.</p></li>
<li><p>Portable class libraries can help you reduce the time and costs of developing and testing code.</p></li>
<li><p>Use this project type to write and build portable .NET Framework assemblies, and then reference those assemblies from apps that target multiple platforms such as Windows and Windows Phone, etc.</p></li>
</ul>
<p>Let us now remove the class library which we have created from the Solution Explorer. At the same time, delete it from the Solution folder and further add a new project item.</p>
<img src="images/remove.jpg" alt="Remove" />
<p>Select the <b>Visual C# &rarr; Windows</b> template in the left pane and select Class Library (Portable) in the middle pane.</p>
<p>Enter StringLibrary in the name field and click <b>OK</b> to create this project.</p>
<img src="images/stringlibrary.jpg" alt="StringLibrary" />
<p>Now we need to select the target frameworks to reference. Let us select Windows Universal and ASP.NET Core for a moment then we will retarget it. Click <b>OK</b>.</p>
<img src="images/retarget.jpg" alt="retarget" />
<p>You can see that it has created a new project in PCF format. Let us now right-click StringLibrary project in the Solution Explorer and select Properties.</p>
<img src="images/properties.jpg" alt="Properties" />
<p>Click on the Target .NET Platform Standard.</p>
<img src="images/target.jpg" alt="Target" />
<p>Click Yes; it is now the same class library with one minor difference. The difference is that it can be used by UWP as well, because it contains *.csproj file instead of *.xproj.</p>
<img src="images/class_library.jpg" alt="class library" />
<p>Let us now add a new class; for this, you need to right-click on project in Solution Explorer and select <b>Add &rarr; Class...</b></p>
<img src="images/add_new_class.jpg" alt="add new class" />
<p>Select class in the middle pane and enter <b>StringLib.cs</b> in the name field and then Click <b>Add</b>. Once the class is added, then replace the following code in StringLib.cs file.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Text; 
using System.Threading.Tasks; 
  
namespace StringLibrary { 
   public static class StringLib { 
      public static bool StartsWithUpper(this String str) { 
         if (String.IsNullOrWhiteSpace(str)) 
            return false; 
         Char ch = str[0]; 
         return Char.IsUpper(ch); 
      } 
      public static bool StartsWithLower(this String str) { 
         if (String.IsNullOrWhiteSpace(str)) 
            return false; 
         Char ch = str[0]; 
         return Char.IsLower(ch); 
      } 
      public static bool StartsWithNumber(this String str) { 
         if (String.IsNullOrWhiteSpace(str)) 
            return false; 
         Char ch = str[0]; 
         return Char.IsNumber(ch); 
      } 
   } 
} 
</pre>
<p>Let us build this portable class library project and it should compile without error. Now we need to add reference of this portable class library in our console project. So, expand FirstApp and right-click on References and select <b>Add Reference…</b></p>
<img src="images/references.jpg" alt="References" />
<p>In the Reference Manager dialog box, select StringLibrary which is our portable class library project, and then click <b>OK</b>.</p>
<img src="images/library_project.jpg" alt="Library project" />
<p>You can see that the StringLibrary reference is added to the console project and it can be seen in the project.json file as well.</p>
<p>You can now run the application again and you will see the same output.</p>
<img src="images/run_application.jpg" alt="Run Application" />
<p>Let us now use the other extension methods of your portable class library in your project.  The same portable library will be consumed in your UWP application as well.</p>
<h1>.NET Core - Adding References to Library</h1>
<p>In this chapter, we will discuss how to add references to your library. Adding references to library is like adding references to your other projects, like console project and UWP project.</p>
<img src="images/uwp_project.jpg" alt="UWP Project" />
<p>You can now see that the PCL project has some references by default. You can also add other references as per your application need.</p>
<p>In the PCL library, you can also see the project.json file.</p>
<pre class="prettyprint notranslate">
{ 
   "supports": {}, 
   "dependencies": { 
      "NETStandard.Library": "1.6.0", 
      "Microsoft.NETCore.Portable.Compatibility": "1.0.1" 
   }, 
   "frameworks": { 
      "netstandard1.3": {} 
   } 
}
</pre>
<p>One method of adding references to your library is by typing it directly in the project.json file. As you can see that we have added some references under the dependencies section as shown in the following code.</p>
<pre class="prettyprint notranslate">
{ 
   "supports": {}, 
   "dependencies": { 
      "NETStandard.Library": "1.6.0", 
      "Microsoft.NETCore.Portable.Compatibility": "1.0.1", 
      "System.Runtime.Serialization.Json": "4.0.3", 
      "Microsoft.EntityFrameworkCore": "1.1.0" 
   }, 
   "frameworks": { 
      "netstandard1.3": {} 
   } 
} 
</pre>
<p>Let us now save this file and you will see that references are added to your library now.</p>
<img src="images/references_added.jpg" alt="References Added" />
<p>The other method of adding references to your library is the NuGet Package Manager. Let us now right-click on the <b>StringLibrary (Portable)</b> project and select <b>Mange NuGet Packages…</b></p>
<img src="images/portable.jpg" alt="Portable" />
<p>On the Browse tab, you can search any NuGet package; let us say we want to add “System.Runtime.Serialization.Primitives” package.</p>
<img src="images/browse_tab.jpg" alt="Browse Tab" />
<p>Click the <b>Install</b> button, which will display the following screen.</p>
<img src="images/press_install.jpg" alt="Press Install" />
<p>Now, click the <b>OK</b> button.</p>
<img src="images/button.jpg" alt="Button" />
<p>Finally, click the <b>I Accept</b> button to start installation of this NuGet package. Once installation is finished, then you will see that the “System.Runtime.Serialization.Primitives” NuGet package is added to your library.</p>
<img src="images/installation.jpg" alt="Installation" />
<h1>.NET Core - Sharing Libraries</h1>
<p>In this chapter, we will discuss how to share your library as <b>NuGet Package</b> so that it can be consumed within another project. Creating a package starts with the code you want to package and share with others, either through the public nuget.org gallery or a private gallery within your organization. The package can also include additional files such as a <b>readme</b> that is displayed when the package is installed, and can include transformations to certain project files.</p>
<p>Let us now consider a simple example in which we will create a NuGet package from our library. To do so, open the command prompt and go to the folder where the project.json file of your library project is located.</p>
<img src="images/example.jpg" alt="Example" />
<p>Let us now run the following command.</p>
<pre class="result notranslate">
dotnet help 
</pre>
<p></p>
<img src="images/command.jpg" alt="Command" />
<p>At the end, you can see different commands like new, restore and build, etc.</p>
<p>The last command is <b>pack;</b> this will create a NuGet package. Let us now execute the following command.</p>
<pre class="result notranslate">
dotnet pack
</pre>
<p></p>
<img src="images/execute.jpg" alt="Execute" />
<p>You can now see that the NuGet packages are produced in the bin folder; let us open the bin\Debug folder.</p>
<img src="images/debug_folder.jpg" alt="Debug Folder" />
<p>Now the question is what is inside the NuGet packages, to see that we can use NuGet Package Explorer. Let us now open the NuGet Package Explorer.</p>
<img src="images/open_nuget.jpg" alt="Open NuGet" />
<p>Select the first option <b>Open a local package</b>.</p>
<img src="images/first_option.jpg" alt="First Option" />
<p>Select the <b>StringLibrary.1.0.0.nupkg</b> and click <b>Open</b>.</p>
<img src="images/click_ok.jpg" alt="Click Ok" />
<p>You can see that in the Package contents section we have StringLibrary.dll only. In the Package metadata section, you will see a bit of information about this library like Id, Versions and all the of the dependencies.</p>
<p>Let us now open the <b>StringLibrary.1.0.0.symbols.nupkg</b>.</p>
<img src="images/symbols.jpg" alt="Symbols" />
<p>In this NuGet package, you will see the source files and the <b>*.pdb</b> file as well. If you double-click on the <b>StringLib.cs</b> file, you see the source code as well.</p>
<img src="images/stinglib_cs.jpg" alt="StringLib.cs" />
<p>Here the question is, how can configure the metadata like version, authors and description, etc.</p>
<p>The project.json file is used on .NET Core projects to define project metadata, compilation information, and dependencies. Let us now open the project.json file and add the following additional information.</p>
<pre class="prettyprint notranslate">
{ 
   "authors": [ "Mark Junior" ], 
   "description": "String Library API", 
   "version" : "1.0.1-*", 
   "supports": {}, 
   
   "dependencies": { 
      "Microsoft.EntityFrameworkCore": "1.1.0", 
      "Microsoft.NETCore.Portable.Compatibility": "1.0.1", 
      "NETStandard.Library": "1.6.0", 
      "System.Runtime.Serialization.Json": "4.0.3", 
      "System.Runtime.Serialization.Primitives": "4.3.0" 
   }, 
   "frameworks": { 
      "netstandard1.3": {} 
   } 
}
</pre>
<p>You can now see additional information like author name, description and version added here. Let us save this file, build the library project, then execute the “dotnet pack” command again.</p>
<img src="images/dotnet_pack.jpg" alt=".Net Pack" />
<p>Inside the bin\Debug folder, you can see that the StringLibrary NuGet packages are produced with version 1.0.1; let us open it in NuGet Package Explorer.</p>
<img src="images/version.jpg" alt="Version" />
<p>You will see the updated metadata. The question now is, how can we use it in another package.</p>
<p>We need to start by publishing somewhere in the NuGet feed and then we can consume it in another project.</p>
<p>There are two options to publish the updated metadata &minus;</p>
<ul class="list">
<li>Publish it to nuget.org</li>
<li>Push the metadata to private NuGet feed</li>
</ul>
<p>Here we will be using the private NuGet feed because it is a lot easier than to setup an account on nuget.org. To learn how to publish your package to nuget.org, you can follow all the guidelines specified here <a target="_blank" rel="nofollow" href="https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package" >https://docs.microsoft.com/en-us/nuget/create-packages/publish-a-package</a>.</p>
<p>Follow these steps to push the updated metadata to private NuGet feed.</p>
<p><b>Step 1</b> &minus; To start with, we need the nuget commandline utility and we have to install it. Let us now open the NuGet Package Manager and search for nuget.commandline.</p>
<p><b>Step 2</b> &minus; Select Nuget.Commandline and click <b>Install</b>.</p>
<img src="images/commandline.jpg" alt="Commandline" />
<p><b>Step 3</b> &minus; Click <b>OK</b> to install Nuget.Commandline. You can also manually install it by downloading it from the following Url <a target="_blank" rel="nofollow" href="https://dist.nuget.org/index.html" >https://dist.nuget.org/index.html</a> and then set up the environment variable.</p>
<img src="images/manual_install.jpg" alt="Manual Install" />
<p><b>Step 4</b> &minus; Once the installation is finished, let us open the command prompt again and go to the <b>bin\Debug</b> folder where the NuGet packages are located and specify the following command &minus;</p>
<pre class="result notranslate">
nuget add StringLibrary.1.0.1.nupkg -Source D:\PrivateNugetPackages 
</pre>
<p><b>Step 5</b> &minus; In the above command, we add the StringLibrary.1.0.1.nupkg package to our private feed and the location is <b>D:\PrivateNugetPackages</b>, -Source specifies the package source.</p>
<p><b>Step 6</b> &minus; You can see that the <b>StringLibrary</b> is installed; the <b>StringLibrary</b> can further be added to the private feed.</p>
<img src="images/private_feed.jpg" alt="Private Feed" />
<p><b>Step 7</b> &minus; Let us go to that folder.</p>
<img src="images/folder.jpg" alt="Folder" />
<p><b>Step 8</b> &minus; Inside the <b>stringlibrary</b> folder, you will see another folder with the version name and here it is 1.0.1.</p>
<img src="images/version_name.jpg" alt="Version Name" />
<p>The NuGet package is located here.</p>
<h1>Creating a Xamarin.Forms Project</h1>
<p>In this chapter, we will discuss how to consume the NuGet package which we have created and published to a private NuGet feed. So, first we will create a Xamarin.Forms project. We need to first understand what is Xamarin.Forms.</p>
<ul class="list">
<li><p>Xamarin.Forms is a framework that allows developers to rapidly create crossplatform user interfaces.</p></li>
<li><p>Xamarin.Forms is a cross-platform natively backed UI toolkit abstraction that allows developers to easily create user interfaces that can be shared across Android, iOS, Windows, and Windows Phone.</p></li>
<li><p>The user interfaces are rendered using the native controls of the target platform, allowing Xamarin.Forms applications to retain the appropriate look and feel for each platform.</p></li>
</ul>
<p>To start Xamarin.Forms, we need some additional features in Visual Studio 2015. Let us modify your Visual Studio 2015 and make sure the following cross-platform mobile development option is selected.</p>
<img src="images/cross_platform.jpg" alt="Cross Platform" />
<p>Once the installation is finished, let us update the Xamarin by selecting <b>Tools &rarr; Options…</b></p>
<img src="images/tools.jpg" alt="Tools" />
<p>Scroll down and expand Xamarin in the left pane and then select <b>Other</b>. On top right hand corner of the dialog box, click on <b>Check Now</b> to see if updates are available.</p>
<img src="images/check_now.jpg" alt="Check Now" />
<p>You can see that updates are available, let us click on the <b>Download</b> button to start downloading. Once downloading is finished, you will be notified to install the updates.</p>
<p>Let us now open the Visual studio again and select the <b>File &rarr; New &rarr; Project…</b> menu option.</p>
<img src="images/updates.jpg" alt="Updates" />
<p>In the left pane, select the <b>Visual C# &rarr; Cross-Platform</b> template and in the middle pane, select <b>Blank Xaml App (Xamarin.Forms Portable)</b>. Enter the name in the Name field and click OK.</p>
<img src="images/blank_xaml_app.jpg" alt="Blank Xaml App" />
<p>Select the Target Version and the Minimum Version and click OK.</p>
<img src="images/target_version.jpg" alt="Target Version" />
<p>You will see a series of projects; at the top we have the PCL library which will be shared among all platforms like Android, iOS, UWP, Windows 8.1, and Windows Phone 8.1.</p>
<p>Here, we will focus on the PCL library and will bring some code here. Let us expand the code.</p>
<img src="images/expand_the_code.jpg" alt="Expand the Code" />
<p>In this Xamarin.Forms template, you can see the generic App.xaml and MainPage.xaml, uses Xamarin.Forms XAML framework which works across these platforms.</p>
<p>We need to import our codes and we also need the private NuGet feed we set up in the last chapter.</p>
<p>Let us now open the NuGet Package Manager. Click on the wheel next to the Package source dropdown list.</p>
<img src="images/source.jpg" alt="Source" />
<p>We need to add our private feed here, let us click on the <b>plus (+) button</b>.</p>
<img src="images/plus.jpg" alt="Plus" />
<p></p>
<img src="images/plus_button.jpg" alt="Plus Button" />
<p>You will see that another checkbox is added in the <b>Available package sources</b> section, let us specify a name and source path and click <b>OK</b>.</p>
<img src="images/source_path.jpg" alt="Source Path" />
<p>Let us now go to the Browse tab and select PrivateSource from the Package source dropdown list and you will see the StringLibrary NuGet package. Select StringLibrary and click <b>Install</b>.</p>
<img src="images/select_stringlibrary.jpg" alt="Select StringLibrary" />
<p>Click OK and you will see one error.</p>
<img src="images/error.jpg" alt="Error" />
<p>We can’t use library with .NETPortable profile version 259, we will be fixing this error in the next chapter.</p>
<img src="images/fixing.jpg" alt="Fixing" />
<h1>.NET Core - PCL Troubleshooting</h1>
<p>In this chapter, we will be fixing the error we got while installing the NuGet package from our private feed in Xamarin.Forms project.</p>
<img src="images/fixing_error.jpg" alt="Fixing error" />
<p>We will further understand the problem in brief. To start with, let us right-click on the PCL library and select Properties.</p>
<p>On this page, you will see the whole series of frameworks targeted. From the error, you can see that the .NETPortable profile 259 is not compatible with our StringLibrary 1.0.1. However, it is trying to take reference from the .NET Standard 1.1 library.</p>
<img src="images/compatible.jpg" alt="Compatible" />
<p>Let us now see the .NET Standard Library and identify which platform is not compatible with our library.</p>
<img src="images/platform.jpg" alt="Platform" />
<p>You can see that Windows Phone Silverlight 8 is compatible with .NET Standard 1.0. If you open the following webpage, then you will see that Profile259 can support only .NET Standard 1.0.</p>
<img src="images/profile259.jpg" alt="Profile259" />
<p>Let us now uncheck Windows Phone Silverlight 8.</p>
<img src="images/silverlight.jpg" alt="Silverlight" />
<p>Click the <b>OK</b> button.</p>
<img src="images/ok_button.jpg" alt="Ok Button" />
<p>Now to fix this issue click OK and cancel the Change Targets dialog and then open Package Manager Console and execute the following command.</p>
<pre class="result notranslate">
PM &gt; Uninstall-Package Xamarin.Forms
</pre>
<p></p>
<img src="images/execute_command.jpg" alt="Execute Command" />
<p>Let us now go to the Properties of PCL library. Click on the Change button.</p>
<img src="images/pcl_library.jpg" alt="PCL library" />
<p>Uncheck Windows Phone Silverlight 8 and Click OK.</p>
<img src="images/uncheck.jpg" alt="Uncheck" />
<p>You can now see that Windows Phone Silverlight 8 is no longer available in Targeted framework. You can also see the profile that is the target now. To see this, let us unload the PCL library and edit the XamarinApp.csproj file.</p>
<img src="images/unload.jpg" alt="Unload" />
<p>You can see now that TargetFrameworkProfile is now Profile111.</p>
<img src="images/targetframeworkprofile.jpg" alt="TargetFrameworkProfile" />
<p>If you open the documentation, then you will see that Profile111 is supporting .NET Standard 1.1.</p>
<img src="images/documentation.jpg" alt="Documentation" />
<p>Let us now reload the PCL again and open the NuGet Package Manager and try to install the StringLibrary package from private feed.</p>
<img src="images/package_private_feed.jpg" alt="Package private feed" />
<p>From the Dependency behavior dropdown list, select Ignore Dependencies and then click <b>Install</b>.</p>
<img src="images/dependencies.jpg" alt="Dependencies" />
<p>You can see that the StringLibrary package is now installed from the private feed. If you expand the References of PCL, then you will see that the StringLibrary reference is also added as shown below.</p>
<img src="images/pcl_reference.jpg" alt="PCL Reference" />
<p>We had uninstalled the Xamarin.Forms for the Windows Phone Silverlight 8 issue. The Xamarin.Forms needs to be installed again. It is recommended that the same version is installed.</p>
<img src="images/same_version.jpg" alt="Same Version" />
<p>Once the installation completes, let us use the StringLibrary functionality in your application.</p>
<h1>.NET Core - Create a Testing Project</h1>
<p>In this chapter, we will discuss how to create a Testing project using .NET Core. Unit testing is a development process for the software that has the smallest testable parts of an application, which are called units. They are individually and independently scrutinized for any proper operation. Unit testing is can either be automated or done manually as well.</p>
<p>Let us now open the New Project dialog box and select <b>Visual C# &rarr; .NET Core</b> template.</p>
<img src="images/visual_csharp.jpg" alt="Visual C#" />
<p>On this dialog box, you can see that there is no project template for unit testing. To create a unit test project, we should use the command line utility. Let us go to the Solution folder that we created; create a test folder and inside the test folder create another folder and call it <b>StringLibraryTests</b>.</p>
<img src="images/stringlibrarytests.jpg" alt="StringLibraryTests" />
<p>Let us now use the dotnet commandline utility to create a new test project by executing the following command &minus;</p>
<pre class="result notranslate">
dotnet new -t xunittest
</pre>
<p>You can now see that a new C# project is created; let us look into the folder by executing the <b>v</b> command and you will see <b>project.json</b> and <b>Tests.cs</b> files as shown below.</p>
<img src="images/dir_command.jpg" alt="DIR Command" />
<p>Here is the code in project.json file.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "debugType": "portable" 
   }, 
   "dependencies": { 
      "System.Runtime.Serialization.Primitives": "4.1.1", 
      "xunit": "2.1.0", 
      "dotnet-test-xunit": "1.0.0-rc2-192208-24" 
   }, 
   "testRunner": "xunit", 
   "frameworks": { 
      "netcoreapp1.0": { 
         "dependencies": { 
            "Microsoft.NETCore.App": { 
               "type": "platform", 
               "version": "1.0.1" 
            } 
         }, 
         "imports": [ 
            "dotnet5.4", 
            "portable-net451+win8" 
         ] 
      } 
   } 
} 
</pre>
<p>Following is the code in the Test.cs file.</p>
<pre class="prettyprint notranslate">
using System; 
using Xunit; 
namespace Tests { 
   public class Tests { 
      [Fact] 
      public void Test1() { 
         Assert.True(true); 
      } 
   } 
} 
</pre>
<p>To fetch the necessary dependencies from NuGet, let us execute the following command &minus;</p>
<pre class="result notranslate">
dotnet restore
</pre>
<p>We can run the test when the necessary dependencies are restored.</p>
<img src="images/restored.jpg" alt="Restored" />
<p>You can see that the compilation succeeded; as you go down you can see some information about the test executed.</p>
<img src="images/test_executed.jpg" alt="Test Executed" />
<p>Currently we have 1 test executed, 0 error, 0 failed, 0 skipped and the time taken by the execution process also mentioned as information.</p>
<h1>.NET Core - Running Tests in Visual Studio</h1>
<p>In this chapter, we will discuss how to run tests in Visual Studio. The .NET Core has been designed with testability in mind, so that creating unit tests for your applications is easier than ever before. In this chapter, we will run and execute our test project in Visual Studio.</p>
<p>Let us open the FirstApp solution in Visual Studio.</p>
<img src="images/firstapp_solution.jpg" alt="FirstApp solution" />
<p>You can see that it has only two projects and you will not be able to see the test project because we haven’t added that project in our solution.</p>
<p>Let us add a folder first and call it <b>test</b>.</p>
<img src="images/test.jpg" alt="Test" />
<p>Right-click on the <b>test</b> folder.</p>
<img src="images/test_folder.jpg" alt="Test Folder" />
<p>Select <b>project.json</b> file and click <b>Open</b>.</p>
<img src="images/project_json_file.jpg" alt="Project Json File" />
<p>The following screenshot shows the code in <b>Tests.cs</b> file as output.</p>
<img src="images/tests.jpg" alt="Tests" />
<p>It is the default implementation and it is just testing that True is equal to true. It is the xUnit testing framework and you will see the Fact attribute that annotates and denotes the test method.</p>
<pre class="prettyprint notranslate">
using System; 
using Xunit; 
  
namespace Tests { 
   public class Tests { 
      [Fact] 
      public void Test1() { 
         Assert.True(true); 
      } 
   } 
} 
</pre>
<p>Following is the implementation of <b>project.json</b> file.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "debugType": "portable" 
   }, 
   "dependencies": { 
      "System.Runtime.Serialization.Primitives": "4.1.1", 
      "xunit": "2.1.0", 
      "dotnet-test-xunit": "1.0.0-rc2-192208-24" 
   }, 
   "testRunner": "xunit", 
   "frameworks": { 
      "netcoreapp1.0": { 
         "dependencies": { 
            "Microsoft.NETCore.App": { 
               "type": "platform", 
               "version": "1.0.1" 
            }
         }, 
         "imports": [ 
            "dotnet5.4", 
            "portable-net451+win8" 
         ] 
      } 
   } 
}
</pre>
<p>In <b>project.json</b> file, the most important dependency to the testing framework is the xunit, which brings in the Fact attribute. It brings in the testing framework and APIs for testing with xunit.</p>
<p>We also have the <b>dotnet-test-xunit</b>, this is an adopter so that xunit can work with .NET Core, specifically with <b>dotnet test</b> command line utility. Then you will see the <b>testRunner</b> which will run xunit and you can also see the <b>netcoreapp1.0</b> framework.</p>
<p>You will see the .NETCore.App dependeny below.</p>
<p>To run test in Visual Studio, let us open Test Explorer from the <b>Test &rarr; Window &rarr; Test Explorer</b> menu option.</p>
<img src="images/test_explorer.jpg" alt="Test Explorer" />
<p>And you can see that Visual Studio automatically detects the test. The name of the test consists of <b>namespace.className.TestMethodName</b>. Let us now click on <b>Run All button in Test Explorer</b>.</p>
<img src="images/run_all_button.jpg" alt="Run All Button" />
<p>It will first build the code and the run the test and you will see the total time taken by the test. Let us change the test method so that we can see the output when the test fails.</p>
<pre class="prettyprint notranslate">
using System; 
using Xunit; 
  
namespace Tests { 
   public class Tests { 
      [Fact] 
      public void Test1() { 
         Assert.True(false); 
      } 
   } 
} 
</pre>
<p>Let us execute the test again by clicking on the <b>Run All</b> button link.</p>
<img src="images/run_all.jpg" alt="Run All" />
<p>You can now see the <b>test</b> failure.</p>
<h1>.NET Core - Testing Library</h1>
<p>In this chapter, we will test our StringLibrary and to do so, we need to rearrange our projects so that we can follow the default convention.</p>
<p>Let us open the <b>global.json</b> file.</p>
<pre class="prettyprint notranslate">
{ 
   "projects": [ "src", "test" ], 
   "sdk": { 
      "version": "1.0.0-preview2-003131" 
   } 
}
</pre>
<p>At the top of this file you will see the project settings and it sets up some folder such as <b>src</b> and <b>test</b> by default.</p>
<p>As by convention we must have projects in these folders, this is the new convention and that is going to be used as part of .NET Core.</p>
<p>In the Solution Explorer, you can see that both the console project and the library project are inside the <b>src</b> folder while the Testing project is inside <b>test</b> folder.</p>
<img src="images/src_folder.jpg" alt="SRC Folder" />
<p>And the projects structure in Solution Explorer doesn’t represent where the projects physically exist on the disk. Let us now open the Solution folder and you will see that <b>StringLibrary</b> project is not inside the <b>src</b> folder.</p>
<img src="images/stringlibrary_project.jpg" alt="StringLibrary Project" />
<p>You can see that both <b>src</b> and <b>test</b> folders map to the convention specified in the <b>global.json</b> file. However, we have one project StringLibrary which is out of convention. Let us now add the <b>StringLibrary</b> project inside the <b>src</b> folder.</p>
<p>In the src folder, we have two projects and we need to fix the problem so that we can use all the projects properly. Let us go back to the Visual Studio and right-click on the StringLibrary project and select the Remove option. It won’t delete it, but it will only remove the project.</p>
<img src="images/remove_project.jpg" alt="Remove Project" />
<p>Now right-click on the src folder and select <b>Add &rarr; Existing Project…</b></p>
<img src="images/src.jpg" alt="SRC" />
<p>Browse to the StringLibrary project which is now inside the <b>src</b> folder, select the <b>StringLibrary.csproj</b> file and click <b>Open</b>.</p>
<img src="images/stringlibrary_csproj.jpg" alt="StringLibrary.csproj" />
<p>We now have to remove the reference of <b>StringLibrary</b> from the <b>project.json</b> file of the console app.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "emitEntryPoint": true 
   }, 
   "dependencies": { 
      "Microsoft.NETCore.App": { 
         "type": "platform", 
         "version": "1.0.1" 
      }, 
      "NuGet.CommandLine": "3.5.0", 
      "System.Runtime.Serialization.Json": "4.0.3" 
   }, 
   "frameworks": { 
      "netcoreapp1.0": { 
         "dependencies": { }, 
         "imports": "dnxcore50" 
      } 
   } 
} 
</pre>
<p>Save the changes and then add a reference of <b>StringLibrary</b> again in your console project.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "emitEntryPoint": true 
   }, 
   "dependencies": { 
      "Microsoft.NETCore.App": { 
         "type": "platform", 
         "version": "1.0.1" 
      }, 
   "NuGet.CommandLine": "3.5.0", 
      "System.Runtime.Serialization.Json": "4.0.3" 
   }, 
   "frameworks": { 
      "netcoreapp1.0": { 
         "dependencies": { 
            "StringLibrary": { 
               "target": "project" 
            } 
         }, 
         "imports": "dnxcore50" 
      } 
   } 
}
</pre>
<p>Now everything should be working again and you can build <b>StringLibrary</b> and then <b>FirstApp</b> (console project) without any error. Let us now test the StringLibrary functionality using xunit. We need to add reference of StringLibrary into our testing project. Right-click on the References of StringLibraryTests project and select Add Reference…</p>
<img src="images/add.jpg" alt="Add" />
<p>Click <b>OK</b> which will add a reference of <b>StringLibrary</b> to our testing project. Let us now replace the following code in the <b>Tests.cs</b> file.</p>
<pre class="prettyprint notranslate">
using System; 
using Xunit; 
using StringLibrary; 
  
namespace Tests { 
   public class Tests { 
      [Fact] 
      public void StartsWithUpperCaseTest() { 
         string input = "Mark"; 
         Assert.True(input.StartsWithUpper()); 
      } 
      [Fact] 
      public void StartsWithLowerCaseTest() { 
         string input = "mark"; 
         Assert.True(input.StartsWithLower()); 
      } 
      [Fact] 
      public void StartsWithNumberCaseTest() { 
         string input = "123"; 
         Assert.True(input.StartsWithNumber()); 
      } 
   } 
} 
</pre>
<p>You can see that we have three test methods which will test the functionality of StringLibrary. Let us click the <b>Run All</b> link and you will see the following output in Test Explorer.</p>
<img src="images/run_all_link.jpg" alt="Run All Link" />
<p>You can also run the tests from the command line. Let us open the command prompt and execute the <b>dotnet test</b> command.</p>
<img src="images/dotnet_test.jpg" alt=".Net Test" />
<h1>Managed Extensibility Framework</h1>
<p>In this chapter, we will discuss the Managed Extensibility Framework (MEF). MEF can be used for third-party plugin extensibility, or it can bring the benefits of a loosely-coupled plugin-like architecture to regular applications.</p>
<ul class="list">
<li><p>MEF is a library for creating lightweight, extensible applications.</p></li>
<li><p>It allows application developers to discover and use extensions with no configuration required.</p></li>
<li><p>MEF is an integral part of the .NET Framework 4, and is available wherever the .NET Framework is used that improves the flexibility, maintainability and testability of large applications.</p></li>
<li><p>You can use MEF in your client applications, whether they use Windows Forms, WPF, or any other technology, or in server applications that use ASP.NET.</p></li>
<li><p>MEF has been ported as <b>Microsoft.Composition</b> to .NET Core as well but partially.</p></li>
<li><p>Only <b>System.Composition</b> is ported, and <b>System.ComponentModel.Composition</b> is not available yet. This means, we don’t have the catalogs which can load types from assemblies in a directory.</p></li>
</ul>
<p>In this chapter, we will only learn how we can use MEF in .NET Core application.</p>
<p>Let us understand a simple example in which we will use MEF in .NET Core console application. Let us now create a new .NET Core console project.</p>
<p>In the left pane, select <b>Templates &rarr; Visual C# &rarr; .NET</b> Core and then in the middle pane, select Console Application (.NET Core).</p>
<p>Enter the name of the project in the Name field and click OK.</p>
<img src="images/name_field.jpg" alt="Name field" />
<p>Once the project is created, we need to add reference of Microsoft.Composition so that we can use MEF. To do so, let us right-click on the project in Solution Explorer and <b>Manage NuGet Packages…</b></p>
<p>Search for <b>Microsoft.Composition</b> and click <b>Install</b>.</p>
<img src="images/manage.jpg" alt="Manage" />
<p>Click the <b>OK</b> button.</p>
<img src="images/click_the_button.jpg" alt="Click the Button" />
<p>Click the <b>I Accept</b> button.</p>
<img src="images/accept.jpg" alt="Accept" />
<p>When the installation completes, you will find an error in References.</p>
<img src="images/error_references.jpg" alt="Error References" />
<p>Let us open the <b>project.json</b> file.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "emitEntryPoint": true 
   }, 
  
   "dependencies": { 
      "Microsoft.Composition": "1.0.30", 
      "Microsoft.NETCore.App": { 
         "type": "platform", 
         "version": "1.0.1" 
      } 
   }, 
  
   "frameworks": { 
      "netcoreapp1.0": { 
         "imports": "dnxcore50" 
      } 
   } 
}
</pre>
<p>You can see that the <b>Microsoft.Composition</b> dependency is added, but the problem is that this package is not compatible with <b>dnxcore50</b>. So we need to import <b>portablenet45+win8+wp8+wpa81</b>. Let us now replace your <b>project.json</b> file with the following code.</p>
<pre class="prettyprint notranslate">
{ 
   "version": "1.0.0-*", 
   "buildOptions": { 
      "emitEntryPoint": true 
   }, 
   "dependencies": { 
      "Microsoft.Composition": "1.0.30", 
      "Microsoft.NETCore.App": { 
         "type": "platform", 
         "version": "1.0.1"
      } 
   }, 
   "frameworks": { 
      "netcoreapp1.0": { 
         "imports": "portable-net45+win8+wp8+wpa81" 
      } 
   } 
} 
</pre>
<p>Save this file and you will see that the error is rectified.</p>
<img src="images/rectified.jpg" alt="Rectified" />
<p>If you expand the References, then you will see a reference of <b>Microsoft.Composition</b>.</p>
<img src="images/microsoft_composition.jpg" alt="Microsoft.Composition" />
<p>First we need to create an interface that is to be exported and implement the interface and decorate the class with the export attribute. Let us now add a new class.</p>
<p>Enter the name for your class in the Name field and click <b>Add</b>.</p>
<img src="images/click_add.jpg" alt="Click Add" />
<p>Let us add the following code in the <b>PrintData.cs</b> file.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Composition; 
using System.Linq; 
using System.Threading.Tasks; 
  
namespace MEFDemo { 
   public interface IPrintData { 
      void Send(string message); 
   } 
   [Export(typeof(IPrintData))] 
   public class PrintData : IPrintData { 
      public void Send(string message) { 
         Console.WriteLine(message); 
      } 
   } 
} 
</pre>
<p>As mentioned above, Catalogs are not available in Microsoft.Composition namespace. So, it will load all the types from the Assembly with export attribute and attach to the import attribute as shown in the Compose method in the Program.cs file.</p>
<pre class="prettyprint notranslate">
using System; 
using System.Collections.Generic; 
using System.Composition; 
using System.Composition.Hosting; 
using System.Linq; 
using System.Reflection; 
using System.Threading.Tasks; 
  
namespace MEFDemo { 
   public class Program { 
      public static void Main(string[] args) { 
         Program p = new Program(); 
         p.Run(); 
      } 
      public void Run() { 
         Compose(); 
         PrintData.Send("Hello,this is MEF demo"); 
      } 
      [Import] 
      public IPrintData PrintData { get; set; } 
      
      private void Compose() { 
         var assemblies = new[] { typeof(Program).GetTypeInfo().Assembly }; 
         var configuration = new ContainerConfiguration() 
            .WithAssembly(typeof(Program).GetTypeInfo().Assembly); 
         
         using (var container = configuration.CreateContainer()) { 
            PrintData = container.GetExport&lt;IPrintData&gt;(); 
         } 
      } 
   } 
}
</pre>
<p>Let us now run your application and you will see that it is running by instantiating the <b>PrintData</b> class.</p>
<img src="images/printdata.jpg" alt="PrintData" />
<p>To learn more about MEF, let us visit the following Url <a target="_blank" rel="nofollow" href="https://msdn.microsoft.com/en-us/library/dd460648(v=vs.110).aspx" >https://msdn.microsoft.com/en-us/library/dd460648%28v=vs.110%29.aspx</a> for more details.</p>
<h1>.NET Core - SDK</h1>
<p>In this chapter, we will understand the upcoming features in .NET Core. We will start with the .NET command line tools by opening the following Url in browser <a target="_blank" rel="nofollow" href="https://github.com/dotnet/cli" >https://github.com/dotnet/cli</a></p>
<img src="images/url.jpg" alt="Url" />
<p>To know more about the progress, you can download the latest version of .NET Core SDK by scrolling down and you will see the Installer and Binaries section.</p>
<img src="images/binaries_section.jpg" alt="Binaries Section" />
<p>You can see the latest version of preview tools for different operating systems, let us select the Installer as per your operating system.</p>
<p>We are working on preview 1 of .NET Core 2.0.</p>
<p>Let us now look at our current tooling by opening the command prompt and execute the following command.</p>
<pre class="result notranslate">
dotnet --info 
</pre>
<p>You will see information about the currently installed version of .NET Command Line Tools on your system as shown below.</p>
<img src="images/command_line_tools.jpg" alt="Command Line Tools" />
<p>You can see that currently we have preview 2 tooling. Let us now run the following command to see about the <b>new</b> command.</p>
<pre class="result notranslate">
dotnet help new
</pre>
<p>For new command language of project, you can select like C# and F# and the type of project, etc.</p>
<img src="images/project_type.jpg" alt="Project Type" />
<p>Let us now see the changes in the latest version of .NET Core. Once the installer is downloaded, double-click on it to install it. Click on Install.</p>
<img src="images/installer.jpg" alt="Installer" />
<p>The following screenshot shows the installation process.</p>
<img src="images/process.jpg" alt="Process" />
<p>It will start the installation process. One the installation is finished, Close this dialog.</p>
<img src="images/installation_finished.jpg" alt="Installation Finished" />
<p>Open the command prompt and execute the following command.</p>
<pre class="result notranslate">
dotnet --info
</pre>
<p>You will see information of currently installed version of .NET Command Line Tools on your system as shown below.</p>
<img src="images/tools_on_system.jpg" alt="Tools on System" />
<p>You can now see that we have preview1 tooling of .NET Core 2. Let us now run the following code in the command prompt to see about the new command in .NET Core 2 preview1.</p>
<pre class="result notranslate">
dotnet help new
</pre>
<p>The command helps you download packages as well to the package cache.</p>
<img src="images/package_cache.jpg" alt="Package Cache" />
<p>The command opens the following webpage which contains information about the new command in .NET Core 2 preview1.</p>
<img src="images/preview1.jpg" alt="Preview1" />
<p>Let us scroll down, you can now see that we can create the .NET Core application with more templates.</p>
<img src="images/templates.jpg" alt="Templates" />
<p>We can now create <b>mstest, web, mvc</b> and <b>webapi</b> projects as well using the command line.</p>
<h1>.NET Core - MSBuild and project.json</h1>
<p>The .NET Core has decided to drop project.json and go back to MSBuild and *.csproj. This is something that’s already happened in the just released .Net Core 2.0 preview1 tooling. This is fairly disappointing, because the project.json was a breath of fresh air. However, it is understandable and have many advantages as well.</p>
<p>Let us now discuss the advantages that the change brings in &minus;</p>
<ul class="list">
<li><p>It would make the transition of the existing Visual Studio solutions to .NET Core straightforward.</p></li>
<li><p>It is a huge change and it will also enable leveraging existing investment in CI/RM based around MSBuild.</p></li>
<li><p>During build in MSBuild, we can think of incremental compilation, resolving buildtime dependencies, configuration management, etc.</p></li>
<li><p>A lot of work is required to ship dotnet cli on time, because it is no longer just about ASP.NET Core, but also console apps, UWP apps, etc.</p></li>
</ul>
<p>Following are the changes in MSBuild and *.csproj &minus;</p>
<ul class="list">
<li><p>Project.json file (*.xproj) will be replaced by MSBuild (*.csproj).</p></li>
<li><p>Features in project.json will start getting merged back into the the *.csproj.</p></li>
<li><p>It is not yet clear what they are going to do about the packages list, but it was mentioned they might keep it as json under <b>nuget.json</b> or merge it into the <b>*.csproj</b>.</p></li>
<li><p>Supposedly that transition should be smooth and potentially automatic if using Visual Studio.</p></li>
</ul>
<h3>Advantages of MSBuild</h3>
<ul class="list">
<li><p>MSBuild is open source and available on GitHub and is bound to become fully crossplatform.</p></li>
<li><p>MSBuild will dramatically simplify and trim the structure of the <b>*.csproj</b>.</p></li>
<li><p>Microsoft is also introducing a new project system which will enable a lot of scenarios without the need for Visual Studio and the details are given on the this Url <a target="_blank" rel="nofollow" href="https://github.com/dotnet/roslyn-project-system/" >https://github.com/dotnet/roslyn-project-system/</a>.</p></li>
<li><p>The goal is that even with the MSBuild setup, working with builds and project will be as seamless in Visual Studio IDE as outside of it.</p></li>
</ul>
<h2>MSBuild vs project.json</h2>
<p>Let us now create a new console project with .NET Core preview2 tooling by executing the following command.</p>
<pre class="result notranslate">
dotnet new -t console 
</pre>
<p>To see all the files created within this project, run the <b>dir</b> command.</p>
<img src="images/run_dir.jpg" alt="Run Dir" />
<p>You can see that two files are created, <b>Program.cs</b> and <b>project.json</b> file.</p>
<p>Let us now create a console app with .NET Core 2 preview1 tooling by executing the following command.</p>
<pre class="result notranslate">
dotnet new console 
</pre>
<p>To see all the files created within this project, run the <b>dir</b> command. You can see that three files are created, <b>Program.cs, NuGet.config</b> and <b>MSBuild.csproj</b> instead of the project.json file.</p>
<img src="images/console.jpg" alt="Console" />
<p>Let us now compare <b>project.json</b> and <b>MSBuild.csproj</b> files side by side.</p>
<img src="images/compare.jpg" alt="Compare" />
<p>To the left, we have the file in json format while on the right, the file is in XML format. You can see that in the project.json file, inside the dependencies section, there is <b>netcoreapp1.0</b>, while in MSBuild.csproj file, you will see the <b>netcoreapp2.0</b>.</p>
<h1>Restoring and Building with MSBuild</h1>
<p>In this chapter, we will discuss how to restore and build your MSBuild (*.csproj) file using the command line utility. To see what commands are available in .NET Core 2.0 preview 1, let us run the following command.</p>
<pre class="result notranslate">
dotnet help 
</pre>
<p>You will see all the commands like new, restore, build, etc.</p>
<img src="images/restore.jpg" alt="Restore" />
<p>Following is the default implementation in <b>Program.cs</b> file.</p>
<pre class="prettyprint notranslate">
using System;  
namespace MSBuild { 
   class Program { 
      static void Main(string[] args) { 
         Console.WriteLine("Hello World!"); 
      } 
   } 
} 
</pre>
<p>Let us now execute the following command to see the progress.</p>
<pre class="result notranslate">
dotnet build
</pre>
<p>You will see a lot of errors. These errors need to be rectified.</p>
<img src="images/lot_of_errors.jpg" alt="Lot of errors" />
<p>Let us now run the following command.</p>
<pre class="result notranslate">
dotnet restore
</pre>
<p>You can see that all the packages are restored. Some new folders and files have also been generated.</p>
<img src="images/generated.jpg" alt="Generated" />
<p>To see the directory structure, let us run the following command.</p>
<pre class="result notranslate">
tree /f 
</pre>
<p>Following is the directory structure &minus;</p>
<img src="images/directory_structure.jpg" alt="Directory structure" />
<p>Let us now rebuild the project running the following command again.</p>
<pre class="result notranslate">
dotnet build
</pre>
<p>Now you project will build successfully without any error(s) and MSBuild.dll is also created.</p>
<img src="images/msbuild_dll.jpg" alt="MSBuild.dll" />
<p>To see the output, let us run the following command &minus;</p>
<pre class="result notranslate">
dotnet run 
</pre>
<p>You can see the following output on your console.</p>
<img src="images/console_output.jpg" alt="Console Output" />
<h1>.NET Core - Migrations</h1>
<p>In this chapter, we will migrate the console application which contains the <b>project.json</b> file build system instead of <b>MSBuild (*.csproj)</b>. So, we have an old project which contains the following files.</p>
<img src="images/following_files.jpg" alt="Following Files" />
<p>Now the question is, why do we need migration? This project is created using .NET Core 1.0 preview 2 tooling and now we have installed .NET Core 2.0 preview 1 tooling. Now when you build this application using .NET Core 2.0 command line utility, then you will see the following error.</p>
<img src="images/following_error.jpg" alt="Following Error" />
<p>This is because the <b>project.json</b> build system is no longer available in .NET Core 2.0, so we need migration so that it can work properly. To see the available commands, let us run the following command.</p>
<pre class="result notranslate">
dotnet help 
</pre>
<p>In the commands section, you can see the different commands and you can also see the <b>migrate</b> command which will migrate a project.json based project to a MSBuild based project.</p>
<img src="images/migrate.jpg" alt="Migrate" />
<p>Let us now run the following command.</p>
<pre class="result notranslate">
dotnet migrate 
</pre>
<p>You will see a summary of the migration process and here you can also see that a project is migrated successfully.</p>
<img src="images/migrate_sucessfull.jpg" alt="Migrate Sucessfull" />
<p>Let us now see the directory structure by using the following command.</p>
<pre class="result notranslate">
tree /f 
</pre>
<p>You will now see the *.csproj file along with Program.cs file in the project root directory and project.json is moved to the backup folder.</p>
<img src="images/backup_folder.jpg" alt="Backup Folder" />
<p>Let us open the <b>console.csproj</b> file. Now you can restore and build this project using the MSBuild system by running the following command.</p>
<pre class="result notranslate">
dotnet restore 
</pre>
<p>You can now see that all the packages are restored.</p>
<img src="images/dotnet_restore.jpg" alt="Dotnet Restore" />
<p>You can now build your project with the following command.</p>
<pre class="result notranslate">
dotnet build 
</pre>
<p>You can now see that the project is built successfully using MSBuild and console.dll is also generated in <b>..\bin\Debug\netcoreapp1.0</b> folder.</p>
<img src="images/msbuild.jpg" alt="MSBuild" />
<p>The following screenshot shows the directory structure and files.</p>
<img src="images/screenshot.jpg" alt="screenshot" />
<hr />
<div class="pre-btn">
<a href="dotnet_core_migrations.html"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="../cgi-bin/printpage.html" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="dotnet_core_useful_resources.html">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="../images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="../images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="../../pagead2.googlesyndication.com/pagead/f.txt">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="../index-2.html" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="../scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="../about/tutorials_writing.html">Write for us</a></li>
         <li><a href="../about/faq.html">FAQ's</a></li>
         <li><a href="../about/about_helping.html">Helping</a></li>
         <li><a href="../about/contact_us.html">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="../theme/js/custom-minae52.js?v=5"></script>
<script src="../../www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>

<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "headline": ".NET Core Quick Guide",
    "name": ".NET Core Quick Guide",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm"
    },
    "image": {
        "@type": "ImageObject",
        "url": "https://www.tutorialspoint.com/dotnet_core/images/download.jpg",
        "width": 450,
        "height": 630
    },
    "author": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "datePublished": "July 23 2017 03:34:50.",
    "dateModified": "July 23 2017 03:34:50.",
    "publisher": {
        "@type": "Organization",
        "name": "Tutorials Point",
        "url": "https://www.tutorialspoint.com",
        "logo": {
            "@type": "ImageObject",
            "url": "https://www.tutorialspoint.com/images/logo60.png",
            "width": 210,
            "height": 60
        }
    },
    "description": ".NET Core is the latest general purpose development platform maintained by Microsoft. It works across different platforms and has been redesigned in a way that makes .NET fast, flexible and modern. This happens to be one of the major contributions by Micr..."
}
</script>
<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BreadcrumbList",
    "itemListElement": [
        {
            "@type": "ListItem",
            "position": 1,
            "item": {
                "name": "www.tutorialspoint.com",
                "@id": "https://www.tutorialspoint.com"
            }
        },
        {
            "@type": "ListItem",
            "position": 2,
            "item": {
                "name": "Dotnet Core",
                "@id": "https://www.tutorialspoint.com/dotnet_core"
            }
        },
        {
            "@type": "ListItem",
            "position": 3,
            "item": {
                "name": ".NET Core - Quick Guide"
            }
        }
    ]
}
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/dotnet_core/dotnet_core_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 14:43:21 GMT -->
</html>
