<!DOCTYPE html>
<!--[if IE 8]><html class="ie ie8"> <![endif]-->
<!--[if IE 9]><html class="ie ie9"> <![endif]-->
<!--[if gt IE 9]><!-->	<html> <!--<![endif]-->

<!-- Mirrored from www.tutorialspoint.com/opencv/opencv_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:21:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<!-- Basic -->
<meta charset="utf-8">
<title>OpenCV Quick Guide</title>
<meta name="description" content="OpenCV Quick Guide - Learn OpenCV in simple and easy steps starting from basic to advanced concepts with examples including Overview, Environment, Storing, Reading Images, Writing an Image, GUI, The IMREAD_XXX Flag, Reading an Image as Grayscale, BGR, Colored Images to GrayScale, Binary, Grayscale to Binary, Drawing a Circle, Line, Rectangle, Ellipse, Polylines, Convex Polylines, Arrowed Lines, Adding Text, Blur (Averaging), Gaussian, Median Blur, Bilateral, Box, SQRBox Filter, Filter2D, Dilation, Erosion, Morphological Operations, Image Pyramids, Simple, Adaptive Threshold, Adding Borders, Sobel, Scharr Operator,  Laplacian, Distance Transformation, Using Camera, Face Detection in a Picture, Face Detection using Camera, Affine Translation, Rotation, Scaling, Color Maps, Canny Edge Detection, Hough Line Transform, Histogram Equalization." />
<meta name="keywords" content="OpenCV, Tutorial, Overview, Environment, Storing, Reading Images, Writing an Image, GUI, The IMREAD_XXX Flag, Reading an Image as Grayscale, BGR, Colored Images to GrayScale, Binary, Grayscale to Binary, Drawing a Circle, Line, Rectangle, Ellipse, Polylines, Convex Polylines, Arrowed Lines, Adding Text, Blur (Averaging), Gaussian, Median Blur, Bilateral, Box, SQRBox Filter, Filter2D, Dilation, Erosion, Morphological Operations, Image Pyramids, Simple, Adaptive Threshold, Adding Borders, Sobel, Scharr Operator,  Laplacian, Distance Transformation, Using Camera, Face Detection in a Picture, Face Detection using Camera, Affine Translation, Rotation, Scaling, Color Maps, Canny Edge Detection, Hough Line Transform, Histogram Equalization." />
<base  />
<link rel="shortcut icon" href="https://www.tutorialspoint.com/favicon.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=yes">
<meta property="og:locale" content="en_US" />
<meta property="og:type" content="website" />
<meta property="fb:app_id" content="471319149685276" />
<meta property="og:site_name" content="www.tutorialspoint.com" />
<meta name="robots" content="index, follow"/>
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta name="author" content="tutorialspoint.com">
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/script-min-v4.js"></script>
<link rel="stylesheet" href="https://www.tutorialspoint.com/theme/css/style-min.css?v=2">
<!-- Head Libs -->
<!--[if IE 8]>
<link rel="stylesheet" type="text/css" href="/theme/css/ie8.css">
<![endif]-->
<style>
select{ border:0 !important; outline: 1px inset black !important; outline-offset: -1px !important; }
ul.nav-list.primary>li a.videolink{    background: none; margin: 0px; padding: 0px; border: 1px solid #d6d6d6;}
div.feature-box div.feature-box-icon, .col-md-3 .course-box, li.heading, div.footer-copyright { background: #ef0202 url(https://www.tutorialspoint.com/images/pattern.png) repeat center center !important;}
.sub-main-menu .sub-menuu div:hover, .sub-main-menu .viewall, header nav ul.nav-main li a:hover, button.btn-responsive-nav, header div.search button.btn-default { background: #ef0202 !important;}
.submenu-item{ border-bottom: 2px solid #ef0202 !important; border-top: 2px solid #ef0202 !important }
.ace_scroller{overflow: auto!important;}
</style>
<script>
$(document).ready(function() {
  $('input[name="q"]').keydown(function(event){
    if(event.keyCode == 13) {
      event.preventDefault();
      return false;
    }
  });
});
</script>
</head>
<body onload="prettyPrint()">
<div class="wrapLoader">
   <div class="imgLoader">
      <img  src="https://www.tutorialspoint.com/images/loading-cg.gif" alt="" width="70" height="70" />
   </div>
</div>
<header>
   <div class="container">			
      <h1 class="logo">
      <a href="https://www.tutorialspoint.com/index.htm" title="tutorialspoint">
      <img alt="tutorialspoint" src="https://www.tutorialspoint.com/opencv/images/logo.png">
      </a>
      </h1>			
      <nav>
         <ul class="nav nav-pills nav-top">
            <li><a href="https://www.tutorialspoint.com/about/about_careers.htm" style="background: #fffb09; font-weight: bold;"><i class="icon icon-suitcase"></i> Jobs</a></li>
            <li> <a href="http://www.sendfiles.net/"><i class="fa fa-send"></i> &nbsp;SENDFiles</a> </li>
            <li> <a href="https://www.tutorialspoint.com/whiteboard.htm"><img src="https://www.tutorialspoint.com/theme/css/icons/image-editor.png" alt="Whiteboard" title="Whiteboard"> &nbsp;Whiteboard</a> </li>
            <li> <a href="https://www.tutorialspoint.com/netmeeting.php"><i class="fa-camera"></i> &nbsp;Net Meeting</a> </li>
            <li> <a href="https://www.tutorialspoint.com/online_dev_tools.htm"> <i class="dev-tools-menu" style="opacity:.5"></i> Tools </a> </li>
            <li> <a href="https://www.tutorialspoint.com/articles/index.php"><i class="icon icon-file-text-o"></i> &nbsp;Articles</a> </li>            
            <li class="top-icons">
              <ul class="social-icons">
              <li class="facebook"><a href="https://www.facebook.com/tutorialspointindia" target="_blank" data-placement="bottom" title="tutorialspoint @ Facebook">Facebook</a></li>
              <li class="googleplus"><a href="https://plus.google.com/u/0/116678774017490391259/posts" target="_blank" data-placement="bottom" title="tutorialspoint @ Google+">Google+</a></li>
              <li class="twitter"><a href="https://www.twitter.com/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Twitter">Twitter</a></li>
              <li class="linkedin"><a href="https://www.linkedin.com/company/tutorialspoint" target="_blank" data-placement="bottom" title="tutorialspoint @ Linkedin">Linkedin</a></li>
              <li class="youtube"><a href="https://www.youtube.com/channel/UCVLbzhxVTiTLiVKeGV7WEBg" target="_blank" data-placement="bottom" title="tutorialspoint YouTube">YouTube</a></li>
              </ul>
           </li>
         </ul>
      </nav>
         <!-- search code here  --> 
      <button class="btn btn-responsive-nav btn-inverse" data-toggle="collapse" data-target=".nav-main-collapse" id="pull" style="top: 24px!important"> <i class="icon icon-bars"></i> </button>
   </div>
  
   <div class="navbar nav-main">
      <div class="container">
         <nav class="nav-main mega-menu">
            <ul class="nav nav-pills nav-main" id="mainMenu">
               <li class="dropdown no-sub-menu"> <a class="dropdown" href="https://www.tutorialspoint.com/index.htm"><i class="icon icon-home"></i> Home</a> </li>   
               <li class="dropdown" id="liTL"><a class="dropdown" href="javascript:void(0);"><span class="tut-lib"> Tutorials Library <i class="fa-caret-down"></i></span></a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/codingground.htm"><i class="fa-code"></i> Coding Ground </a> </li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/tutor_connect/index.php"><i class="fa-user"> </i> Tutor Connect</a></li>
               <li class="dropdown no-sub-menu"><a class="dropdown" href="https://www.tutorialspoint.com/videotutorials/index.htm"><i class="fa-toggle-right"></i> Videos </a></li>
               <li class="dropdown no-sub-menu">
                  <div class="searchform-popup">
                     <input class="header-search-box" type="text" id="search-string" name="q" placeholder="Search your favorite tutorials..." onfocus="if (this.value == 'Search your favorite tutorials...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Search your favorite tutorials...';}" autocomplete="off">
                     <div class="magnifying-glass"><i class="icon-search"></i> Search </div>
                 </div>
               </li>
            </ul>
         </nav>
         <div class="submenu-item sub-main-menu" id="top-sub-menu"></div>
         
      </div>
   </div>	
</header>
<div style="clear:both;"></div>
<div role="main" class="main">
<div class="container">
<div class="row">
<div class="col-md-2">
<aside class="sidebar">
<style>
.ts{
   vertical-align:middle !important;
   text-align:center !important;   
}
</style>
<div class="mini-logo">
<img src="https://www.tutorialspoint.com/opencv/images/opencv-mini-logo.jpg" alt="OpenCV Tutorial" />
</div>
<ul class="nav nav-list primary left-menu" >
<li class="heading">OpenCV Tutorial</li>
<li><a href="https://www.tutorialspoint.com/opencv/index.htm">OpenCV - Home</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_overview.htm">OpenCV - Overview</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_environment.htm">OpenCV - Environment</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_storing_images.htm">OpenCV - Storing Images</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_reading_images.htm">OpenCV - Reading Images</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_writing_image.htm">OpenCV - Writing an Image</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_gui.htm">OpenCV - GUI</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Types of Images</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_imread_xxx_flag.htm">OpenCV - The IMREAD_XXX Flag</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_reading_image_as_grayscale.htm">Reading an Image as Grayscale</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_reading_image_as_bgr.htm">OpenCV - Reading Image as BGR</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Image Conversion</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_colored_images_to_grayscale.htm">Colored Images to GrayScale</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_colored_image_to_binary.htm">OpenCV - Colored Image to Binary</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_grayscale_to_binary.htm">OpenCV - Grayscale to Binary</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Drawing Functions</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_circle.htm">OpenCV - Drawing a Circle</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_line.htm">OpenCV - Drawing a Line</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_rectangle.htm">OpenCV - Drawing a Rectangle</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_ellipse.htm">OpenCV - Drawing an Ellipse</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_polylines.htm">OpenCV - Drawing Polylines</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_convex_polylines.htm">OpenCV - Drawing Convex Polylines</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_drawing_arrowed_lines.htm">OpenCV - Drawing Arrowed Lines</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_adding_text.htm">OpenCV - Adding Text</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Blur</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_blur_averaging.htm">OpenCV - Blur (Averaging)</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_gaussian_blur.htm">OpenCV - Gaussian Blur</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_median_blur.htm">OpenCV - Median Blur</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Filtering</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_bilateral_filter.htm">OpenCV - Bilateral Filter</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_box_filter.htm">OpenCV - Box Filter</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_sqrbox_filter.htm">OpenCV - SQRBox Filter</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_filter2d.htm">OpenCV - Filter2D</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_dilation.htm">OpenCV - Dilation</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_erosion.htm">OpenCV - Erosion</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_morphological_operations.htm">OpenCV - Morphological Operations</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_image_pyramids.htm">OpenCV - Image Pyramids</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Thresholding</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_simple_threshold.htm">OpenCV - Simple Threshold</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_adaptive_threshold.htm">OpenCV - Adaptive Threshold</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_adding_borders.htm">OpenCV - Adding Borders</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Sobel Derivatives</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_sobel_operator.htm">OpenCV - Sobel Operator</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_scharr_operator.htm">OpenCV - Scharr Operator</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Transformation Operations</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_laplacian_transformation.htm">OpenCV - Laplacian Transformation</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_distance_transformation.htm">OpenCV - Distance Transformation</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Camera and Face Detection</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_using_camera.htm">OpenCV - Using Camera</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_face_detection_in_picture.htm">OpenCV - Face Detection in a Picture</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_face_detection_using_camera.htm">Face Detection using Camera</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Geometric Transformations</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_affine_translation.htm">OpenCV - Affine Translation</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_rotation.htm">OpenCV - Rotation</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_scaling.htm">OpenCV - Scaling</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_color_maps.htm">OpenCV - Color Maps</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">Miscellaneous Chapters</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_canny_edge_detection.htm">OpenCV - Canny Edge Detection</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_hough_line_transform.htm">OpenCV - Hough Line Transform</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_histogram_equalization.htm">OpenCV - Histogram Equalization</a></li>
</ul>
<ul class="nav nav-list primary left-menu" >
<li class="heading">OpenCV Useful Resources</li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_quick_guide.htm">OpenCV - Quick Guide</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_useful_resources.htm">OpenCV - Useful Resources</a></li>
<li><a href="https://www.tutorialspoint.com/opencv/opencv_discussion.htm">OpenCV - Discussion</a></li>
</ul>
<ul class="nav nav-list primary push-bottom left-menu special">
<li class="sreading">Selected Reading</li>
<li><a target="_top" href="https://www.tutorialspoint.com/developers_best_practices/index.htm">Developer's Best Practices</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/questions_and_answers.htm">Questions and Answers</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/effective_resume_writing.htm">Effective Resume Writing</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/hr_interview_questions/index.htm">HR Interview Questions</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_glossary.htm">Computer Glossary</a></li>
<li><a target="_top" href="https://www.tutorialspoint.com/computer_whoiswho.htm">Who is Who</a></li>
</ul>
</aside>
</div>
<!-- PRINTING STARTS HERE -->
<div class="row">
<div class="content">
<div class="col-md-7 middle-col">
<h1>OpenCV - Quick Guide</h1>
<div class="topgooglead">
<hr />
<div style="padding-bottom:5px;padding-left:10px;">Advertisements</div>
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js"> 
</script>
</div>
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/opencv/opencv_histogram_equalization.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/opencv/opencv_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<div class="clearer"></div>
<hr />
<h1>OpenCV - Overview</h1>
<p>OpenCV is a cross-platform library using which we can develop real-time <b>computer vision applications</b>. It mainly focuses on image processing, video capture and analysis including features like face detection and object detection.</p>
<p>Let’s start the chapter by defining the term "Computer Vision".</p>
<h2>Computer Vision</h2>
<p>Computer Vision can be defined as a discipline that explains how to reconstruct, interrupt, and understand a 3D scene from its 2D images, in terms of the properties of the structure present in the scene. It deals with modeling and replicating human vision using computer software and hardware.</p>
<p>Computer Vision overlaps significantly with the following fields &minus;</p>
<ul class="list">
<li><p><b>Image Processing</b> &minus; It focuses on image manipulation.</p></li>
<li><p><b>Pattern Recognition</b> &minus; It explains various techniques to classify patterns.</p></li>
<li><p><b>Photogrammetry</b> &minus; It is concerned with obtaining accurate measurements from images.</p></li>
</ul>
<h3>Computer Vision Vs Image Processing</h3>
<p><b>Image processing</b> deals with image-to-image transformation. The input and output of image processing are both images.</p>
<p><b>Computer vision</b> is the construction of explicit, meaningful descriptions of physical objects from their image. The output of computer vision is a description or an interpretation of structures in 3D scene.</p>
<h2>Applications of Computer Vision</h2>
<p>Here we have listed down some of major domains where Computer Vision is heavily used.</p>
<h3>Robotics Application</h3>
<ul class="list">
<li><p>Localization &minus; Determine robot location automatically</p></li>
<li><p>Navigation</p></li>
<li><p>Obstacles avoidance</p></li>
<li><p>Assembly (peg-in-hole, welding, painting)</p></li>
<li><p>Manipulation (e.g. PUMA robot manipulator)</p></li>
<li><p>Human Robot Interaction (HRI) &minus; Intelligent robotics to interact with and serve people</p></li>
</ul>
<h3>Medicine Application</h3>
<ul class="list">
<li>Classification and detection (e.g. lesion or cells classification and tumor detection)</li>
<li>2D/3D segmentation</li>
<li>3D human organ reconstruction (MRI or ultrasound)</li>
<li>Vision-guided robotics surgery</li>
</ul>
<h3>Industrial Automation Application</h3>
<ul class="list">
<li>Industrial inspection (defect detection)</li>
<li>Assembly</li>
<li>Barcode and package label reading</li>
<li>Object sorting</li>
<li>Document understanding (e.g. OCR)</li>
</ul>
<h3>Security Application</h3>
<ul class="list">
<li><p>Biometrics (iris, finger print, face recognition)</p></li>
<li><p>Surveillance &minus; Detecting certain suspicious activities or behaviors</p></li>
</ul>
<h3>Transportation Application</h3>
<ul class="list">
<li>Autonomous vehicle</li>
<li>Safety, e.g., driver vigilance monitoring</li>
</ul>
<h2>Features of OpenCV Library</h2>
<p>Using OpenCV library, you can &minus;</p>
<ul class="list">
<li><p>Read and write images</p></li>
<li><p>Capture and save videos</p></li>
<li><p>Process images (filter, transform)</p></li>
<li><p>Perform feature detection</p></li>
<li><p>Detect specific objects such as faces, eyes, cars, in the videos or images.</p></li>
<li><p>Analyze the video, i.e., estimate the motion in it, subtract the background, and track objects in it.</p></li>
</ul>
<p>OpenCV was originally developed in C&plus;&plus;. In addition to it, Python and Java bindings were provided. OpenCV runs on various Operating Systems such as windows, Linux, OSx, FreeBSD, Net BSD, Open BSD, etc.</p>
<p>This tutorial explains the concepts of OpenCV with examples using Java bindings.</p>
<h2>OpenCV Library Modules</h2>
<p>Following are the main library modules of the OpenCV library.</p>
<h3>Core Functionality</h3>
<p>This module covers the basic data structures such as Scalar, Point, Range, etc., that are used to build OpenCV applications. In addition to these, it also includes the multidimensional array <b>Mat</b>, which is used to store the images. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.core</b>.</p>
<h3>Image Processing</h3>
<p>This module covers various image processing operations such as image filtering, geometrical image transformations, color space conversion, histograms, etc. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.imgproc</b>.</p>
<h3>Video</h3>
<p>This module covers the video analysis concepts such as motion estimation, background subtraction, and object tracking. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.video</b>.</p>
<h3>Video I/O</h3>
<p>This module explains the video capturing and video codecs using OpenCV library. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.videoio</b>.</p>
<h3>calib3d</h3>
<p>This module includes algorithms regarding basic multiple-view geometry algorithms, single and stereo camera calibration, object pose estimation, stereo correspondence and elements of 3D reconstruction. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.calib3d</b>.</p>
<h3>features2d</h3>
<p>This module includes the concepts of feature detection and description. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.features2d</b>.</p>
<h3>Objdetect</h3>
<p>This module includes the detection of objects and instances of the predefined classes such as faces, eyes, mugs, people, cars, etc. In the Java library of OpenCV, this module is included as a package with the name <b>org.opencv.objdetect</b>.</p>
<h3>Highgui</h3>
<p>This is an easy-to-use interface with simple UI capabilities. In the Java library of OpenCV, the features of this module is included in two different packages namely, <b>org.opencv.imgcodecs</b> and <b>org.opencv.videoio</b>.</p>
<h2>A Brief History of OpenCV</h2>
<p>OpenCV was initially an Intel research initiative to advise CPU-intensive applications. It was officially launched in 1999.</p>
<ul class="list">
<li>In the year 2006, its first major version, OpenCV 1.0 was released.</li>
<li>In October 2009, the second major version, OpenCV 2 was released.</li>
<li>In August 2012, OpenCV was taken by a nonprofit organization OpenCV.org.</li>
</ul>
<h1>OpenCV - Environment</h1>
<p>In this chapter, you will learn how to install OpenCV and set up its environment in your system.</p>
<h2>Installing OpenCV</h2>
<p>First of all, you need to download OpenCV onto your system. Follow the steps given below.</p>
<p><b>Step 1</b> &minus; Open the homepage of <b>OpenCV</b> by clicking the following link: <a target="_blank" rel="nofollow" href="http://opencv.org/">http://opencv.org/</a> On clicking, you will see its homepage as shown below.</p>
<img src="https://www.tutorialspoint.com/opencv/images/opencv_homepage.jpg" alt="OpenCV HomePage" />
<p><b>Step 2</b> &minus; Now, click the <b>Downloads</b> link highlighted in the above screenshot. On clicking, you will be directed to the downloads page of OpenCV.</p>
<img src="https://www.tutorialspoint.com/opencv/images/opencv_downloads_page.jpg" alt="OpenCV Downloads Page" />
<p><b>Step 3</b> &minus; On clicking the highlighted link in the above screenshot, a file named <b>opencv-3.1.0.exe</b> will be downloaded. Extract this file to generate a folder <b>opencv</b> in your system, as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/opencv_downloaded.jpg" alt="OpenCV Downloaded" />
<p><b>Step 4</b> &minus; Open the folder <b>OpenCV</b> &rarr; <b>build</b> &rarr; <b>java</b>. Here you will find the jar file of OpenCV named <b>opencv-310.jar</b>. Save this file in a separate folder for further use.</p>
<img src="https://www.tutorialspoint.com/opencv/images/opencv_jar_file.jpg" alt="OpenCV Jar File" />
<h2>Eclipse Installation</h2>
<p>After downloading the required JAR files, you have to embed these JAR files to your Eclipse environment. You can do this by setting the Build Path to these JAR files and by using <b>pom.xml</b>.</p>
<h3>Setting Build Path</h3>
<p>Following are the steps to set up OpenCV in Eclipse &minus;</p>
<p><b>Step 1</b> &minus; Ensure that you have installed Eclipse in your system. If not, download and install Eclipse in your system.</p>
<p><b>Step 2</b> &minus; Open Eclipse, click on File, New, and Open a new project as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/open_eclipse.jpg" alt="Open Eclipse" />
<p><b>Step 3</b> &minus; On selecting the project, you will get the <b>New Project</b> wizard. In this wizard, select Java project and proceed by clicking the <b>Next</b> button, as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/select_project.jpg" alt="Select Project" />
<p><b>Step 4</b> &minus; On proceeding forward, you will be directed to the <b>New Java Project wizard</b>. Create a new project and click <b>Next</b>, as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/new_java_project_wizard.jpg" alt="New Java Project wizard" />
<p><b>Step 5</b> &minus; After creating a new project, right-click on it. Select <b>Build Path</b> and click <b>Configure Build Path…</b> as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/select_build_path.jpg" alt="Select Build Path" />
<p><b>Step 6</b> &minus; On clicking the <b>Build Path</b> option, you will be directed to the <b>Java Build Path wizard</b>. Click the <b>Add External JARs</b> button, as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/click_build_path.jpg" alt="Click Build Path" />
<p><b>Step 7</b> &minus; Select the path where you have saved the file <b>opencv-310.jar</b>.</p>
<p><b>Step 8</b> &minus; On clicking the <b>Open</b> button in the above screenshot, those files will be added to your library.</p>
<img src="https://www.tutorialspoint.com/opencv/images/click_open_button.jpg" alt="Click Open Button" />
<p><b>Step 9</b> &minus; On clicking <b>OK</b>, you will successfully add the required JAR files to the current project and you can verify these added libraries by expanding the Referenced Libraries.</p>
<img src="https://www.tutorialspoint.com/opencv/images/click_ok.jpg" alt="Click OK" />
<h2>Setting the Path for Native Libraries</h2>
<p>In addition to the JAR files, you need to set path for the native libraries (DLL files) of OpenCV.</p>
<p><b>Location of DLL files</b> &minus; Open the installation folder of <b>OpenCV</b> and go to the sub-folder <b>build</b> &rarr; <b>java</b>. Here you will find the two folders <b>x64</b> (64 bit) and <b>x86</b> (32 bit) which contain the <b>dll</b> files of OpenCV.</p>
<img src="https://www.tutorialspoint.com/opencv/images/dll_files_location.jpg" alt="DLL Files Location" />
<p>Open the respective folder suitable for your operating system, then you can see the <b>dll</b> file, as shown in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/open_folder.jpg" alt="Open Folder" />
<p>Now, set the path for this file too by following the steps given below &minus;</p>
<p><b>Step 1</b> &minus; Once again, open the JavaBuildPath window. Here you can observe the added JAR file and the <b>JRE System Library</b>.</p>
<img src="https://www.tutorialspoint.com/opencv/images/jre_system_library.jpg" alt="JRE System Library" />
<p><b>Step 2</b> &minus; On expanding it, you will get the system libraries and <b>Native library location</b>, as highlighted in the following screenshot.</p>
<img src="https://www.tutorialspoint.com/opencv/images/native_library_location.jpg" alt="Native Library Location" />
<p><b>Step 3</b> &minus; Double-click on the <b>Native library location</b>. Here, you can see the <b>Native Library Folder Configuration window</b> as shown below.</p>
<img src="https://www.tutorialspoint.com/opencv/images/double_click_native_library_location.jpg" alt="Double-click on Native library location" />
<p>Here, click the button <b>External Folder…</b> and select the location of the <b>dll</b> file in your system.</p>
<h1>OpenCV - Storing Images</h1>
<p>To capture an image, we use devices like cameras and scanners. These devices record numerical values of the image (Ex: pixel values). OpenCV is a library which processes the digital images, therefore we need to store these images for processing.</p>
<p>The <b>Mat</b> class of OpenCV library is used to store the values of an image. It represents an n-dimensional array and is used to store image data of grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms, etc.</p>
<p>This class comprises of two data parts: the <b>header</b> and a <b>pointer</b></p>
<ul class="list">
<li><p><b>Header</b> &minus; Contains information like size, method used for storing, and the address of the matrix (constant in size).</p></li>
<li><p><b>Pointer</b> &minus; Stores the pixel values of the image (Keeps on varying).</p></li>
</ul>
<h2>The Mat Class</h2>
<p>The OpenCV Java library provides this class with the same name (<b>Mat</b>) within the package <b>org.opencv.core</b>.</p>
<h3>Constructors</h3>
<p>The Mat class of OpenCV Java library has various constructors, using which you can construct the Mat object.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Constructors and Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td>
<p><b>Mat()</b></p>
<p>This is the default constructor with no parameters in most cases. We use this to constructor to create an empty matrix and pass this to other OpenCV methods.</p>
</td>
</tr>
<tr>
<td class="ts">2</td>
<td>
<p><b>Mat(int rows, int cols, int type)</b></p>
<p>This constructor accepts three parameters of integer type representing the number of rows and columns in a 2D array and the type of the array (that is to be used to store data).</p>
</td>
</tr>
<tr>
<td class="ts">3</td>
<td>
<p><b>Mat(int rows, int cols, int type, Scalar s)</b></p>
<p>Including the parameters of the previous one, this constructor additionally accepts an object of the class Scalar as parameter.</p>
</td>
</tr>
<tr>
<td class="ts">4</td>
<td>
<p><b>Mat(Size size, int type)</b></p>
<p>This constructor accepts two parameters, an object representing the size of the matrix and an integer representing the type of the array used to store the data.</p>
</td>
</tr>
<tr>
<td class="ts">5</td>
<td>
<p><b>Mat(Size size, int type, Scalar s)</b></p>
<p>Including the parameters of the previous one, this constructor additionally accepts an object of the class Scalar as parameter.</p>
</td>
</tr>
<tr>
<td style="text-align:center;">6</td>
<td><p><b>Mat(long addr)</b></p></td>
</tr>
<tr>
<td class="ts">7</td>
<td>
<p><b>Mat(Mat m, Range rowRange)</b></p>
<p>This constructor accepts an object of another matrix and an object of the class Range representing the range of the rows to be taken to create a new matrix.</p></td>
</tr>
<tr>
<td class="ts">8</td>
<td>
<p><b>Mat(Mat m, Range rowRange, Range colRange)</b></p>
<p>Including the parameters of the previous one, this constructor additionally accepts an object of the class. Range representing the column range.</p>
</td>
</tr>
<tr>
<td class="ts">9</td>
<td>
<p><b>Mat(Mat m, Rect roi)</b></p>
<p>This constructor accepts two objects, one representing another matrix and the other representing the <b>R</b>egion <b>O</b>f <b>I</b>nterest.</p>
</td>
</tr>
</table>
<p><b>Note</b> &minus;</p>
<ul class="list">
<li><p>Array type. Use CV_8UC1, ..., CV_64FC4 to create 1-4 channel matrices, or CV_8UC(n), ..., CV_64FC(n) to create multi-channel (up to CV_CN_MAX channels) matrices.</p></li>
<li><p>The type of the matrices were represented by various fields of the class <b>CvType</b> which belongs to the package <b>org.opencv.core</b>.</p></li>
</ul>
<h3>Methods and Description</h3>
<p>Following are some of the methods provided by the Mat class.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Methods and Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td>
<p><b>Mat col(int x)</b></p>
<p>This method accepts an integer parameter representing the index of a column and retrieves and returns that column.</p>
</td>
</tr>
<tr>
<td class="ts">2</td>
<td>
<p><b>Mat row(int y)</b></p>
<p>This method accepts an integer parameter representing the index of a row and retrieves and returns that row.</p></td>
</tr>
<tr>
<td class="ts">3</td>
<td>
<p><b>int cols()</b></p>
<p>This method returns the number of columns in the matrix.</p></td>
</tr>
<tr>
<td class="ts">4</td>
<td>
<p><b>int rows()</b></p>
<p>This method returns the number of rows in the matrix.</p>
</td>
</tr>
<tr>
<td class="ts">5</td>
<td>
<p><b>Mat setTo(Mat value)</b></p>
<p>This method accepts an object of the <b>Mat</b> type and sets the array elements to the specified value.</p>
</td>
</tr>
<tr>
<td class="ts">6</td>
<td>
<p><b>Mat setTo(Scalar s)</b></p>
<p>This method accepts an object of the <b>Scalar</b> type and sets the array elements to the specified value.</p>
</td>
</tr>
</table>
<h2>Creating and Displaying the Matrix</h2>
<p>In this section, we are going to discuss our first OpenCV example. We will see how to create and display a simple OpenCV matrix.</p>
<p>Given below are the steps to be followed to create and display a matrix in OpenCV.</p>
<h3>Step 1: Load the OpenCV native library</h3>
<p>While writing Java code using OpenCV library, the first step you need to do is to load the native library of OpenCV using the <b>loadLibrary()</b>. Load the OpenCV native library as shown below.</p>
<pre class="result notranslate">
//Loading the core library 
System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
</pre>
<h3>Step 2: Instantiate the Mat class</h3>
<p>Instantiate the Mat class using any of the functions mentioned in this chapter earlier.</p>
<pre class="result notranslate">
//Creating a matrix 
Mat matrix = new Mat(5, 5, CvType.CV_8UC1, new Scalar(0));
</pre>
<h3>Step 3: Fill the matrix using the methods</h3>
<p>You can retrieve particular rows/columns of a matrix by passing index values to the methods <b>row()/col()</b>.</p>
<p>And, you can set values to these using any of the variants of the <b>setTo()</b> methods.</p>
<pre class="prettyprint notranslate">
//Retrieving the row with index 0 
Mat row0 = matrix.row(0); 
     
//setting values of all elements in the row with index 0 
row0.setTo(new Scalar(1)); 
     
//Retrieving the row with index 3 
Mat col3 = matrix.col(3);  
     
//setting values of all elements in the row with index 3 
col3.setTo(new Scalar(3));
</pre>
<p><b>Example</b></p>
<p>You can use the following program code to create and display a simple matrix in Java using OpenCV library.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core; 
import org.opencv.core.Mat;  
import org.opencv.core.CvType;  
import org.opencv.core.Scalar;   

class DisplayingMatrix { 
   public static void main(String[] args) {     
      //Loading the core library 
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);     

      //Creating a matrix 
      Mat matrix = new Mat(5, 5, CvType.CV_8UC1, new Scalar(0));  

      //Retrieving the row with index 0 
      Mat row0 = matrix.row(0);

      //setting values of all elements in the row with index 0 
      row0.setTo(new Scalar(1)); 

      //Retrieving the row with index 3 
      Mat col3 = matrix.col(3);  

      //setting values of all elements in the row with index 3 
      col3.setTo(new Scalar(3)); 

      //Printing the matrix 
      System.out.println("OpenCV Mat data:\n" + matrix.dump()); 
   } 
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
OpenCV Mat data: 
[  1,   1,   1,   3,   1; 
   0,   0,   0,   3,   0; 
   0,   0,   0,   3,   0; 
   0,   0,   0,   3,   0; 
   0,   0,   0,   3,   0]
</pre>
<h2>Loading Image using JavaSE API</h2>
<p>The <b>BufferedImage</b> class of the <b>java.awt.image.BufferedImage</b> package is used to store an image and the <b>ImageIO</b> class of the package <b>import javax.imageio</b> provides methods to read and write Images.</p>
<p><b>Example</b></p>
<p>You can use the following program code to load and save images using JavaSE library.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage; 
import java.io.File; 
import java.io.IOException; 
import javax.imageio.ImageIO;
  
public class LoadingImage_JSE_library {
   public static void main( String[] args ) throws IOException {
      //Input File 
      File input = new File("C:/EXAMPLES/OpenCV/sample.jpg");
          
      //Reading the image 
      BufferedImage image = ImageIO.read(input);
      
      //Saving the image with a different name
      File ouptut = new File("C:/OpenCV/sample.jpg");
      ImageIO.write(image, "jpg", ouptut);
         
      System.out.println("image Saved");
   } 
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
image Saved
</pre>
<p>If you open the specified path, you can observe the saved image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/loading_image_using_javase_api.jpg" alt="Loading Image using JavaSE API" />
<h1>OpenCV - Reading Images</h1>
<p>The <b>Imgcodecs</b> class of the package <b>org.opencv.imgcodecs</b> provides methods to read and write images. Using OpenCV, you can read an image and store it in a matrix (perform transformations on the matrix if needed). Later, you can write the processed matrix to a file.</p>
<p>The <b>read()</b> method of the <b>Imgcodecs</b> class is used to read an image using OpenCV. Following is the syntax of this method.</p>
<pre class="result notranslate">
imread(filename)
</pre>
<p>It accepts an argument <b>(filename)</b>, a variable of the String type representing the path of the file that is to be read.</p>
<p>Given below are the steps to be followed to read images in Java using OpenCV library.</p>
<h2>Step 1: Load the OpenCV native library</h2>
<p>Load the OpenCV native library using the <b>load()</b> method, as shown below.</p>
<pre class="result notranslate">
//Loading the core library 
System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
</pre>
<h2>Step 2: Instantiate the Imgcodecs class</h2>
<p>Instantiate the <b>Imgcodecs</b> class.</p>
<pre class="result notranslate">
//Instantiating the Imgcodecs class 
Imgcodecs imageCodecs = new Imgcodecs();
</pre>
<h2>Step 3: Reading the image</h2>
<p>Read the image using the method <b>imread()</b>. This method accepts a string argument representing the path of the image and returns the image read as <b>Mat</b> object.</p>
<pre class="result notranslate">
//Reading the Image from the file  
Mat matrix = imageCodecs.imread(Path of the image);
</pre>
<h3>Example</h3>
<p>The following program code shows how you can <b>read an image</b> using OpenCV library.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core; 
import org.opencv.core.Mat;  
import org.opencv.imgcodecs.Imgcodecs;
 
public class ReadingImages {
   public static void main(String args[]) { 
      //Loading the OpenCV core library  
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME ); 
     
      //Instantiating the Imagecodecs class 
      Imgcodecs imageCodecs = new Imgcodecs(); 
     
      //Reading the Image from the file  
      String file ="C:/EXAMPLES/OpenCV/sample.jpg"; 
      Mat matrix = imageCodecs.imread(file); 
     
      System.out.println("Image Loaded");     
   } 
}
</pre>
<p>On executing the above program, OpenCV loads the specified image and displays the following output &minus;</p>
<pre class="result notranslate">
Image Loaded
</pre>
<h1>OpenCV - Writing an Image</h1>
<p>The <b>write()</b> method of the <b>Imgcodecs</b> class is used to write an image using OpenCV. To write an image, repeat the first three steps from the previous example.</p>
<p>To write an image, you need to invoke the <b>imwrite()</b> method of the <b>Imgcodecs</b> class.</p>
<p>Following is the syntax of this method.</p>
<pre class="result notranslate">
imwrite(filename, mat)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>filename</b> &minus; A <b>String</b> variable representing the path where to save the file.</p></li>
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image to be written.</p></li>
</ul>
<h2>Example</h2>
<p>Following program is an example to <b>write an image</b> using Java program using OpenCV library.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core; 
import org.opencv.core.Mat; 
import org.opencv.imgcodecs.Imgcodecs;
 
public class WritingImages {  
   public static void main(String args[]) { 
      //Loading the OpenCV core library  
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME); 
      
      //Instantiating the imagecodecs class 
      Imgcodecs imageCodecs = new Imgcodecs(); 

      //Reading the Image from the file and storing it in to a Matrix object 
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";   
      Mat matrix = imageCodecs.imread(file); 

      System.out.println("Image Loaded ..........");
      String file2 = "C:/EXAMPLES/OpenCV/sample_resaved.jpg"; 

      //Writing the image 
      imageCodecs.imwrite(file2, matrix); 
      System.out.println("Image Saved ............"); 
   } 
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Loaded .......... 
Image Saved ...........
</pre>
<p>If you open the specified path, you can observe the saved image as shown below &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/write_image.jpg" alt="Write Image" />
<h1>OpenCV - GUI</h1>
<p>In the earlier chapters, we have discussed how to read and save an image using OpenCV Java library. In addition to it, we can also display the loaded images in a separate window using GUI libraries such as AWT/Swings and JavaFX.</p>
<h2>Converting Mat to Buffered Image</h2>
<p>To read an image we use the method <b>imread()</b>. This method returns the image read in the form of <b>Matrix</b>. But, to use this image with GUI libraries (AWT/Swings and JavaFX), it should be converted as an object of the class <b>BufferedImage</b> of the package <b>java.awt.image.BufferedImage</b>.</p>
<p>Following are the steps to convert a <b>Mat</b> object of OpenCV to <b>BufferedImage</b> object.</p>
<h3>Step 1: encode the Mat to MatOfByte</h3>
<p>First of all, you need to convert the matrix to matrix of byte. You can do it using the method <b>imencode()</b> of the class <b>Imgcodecs</b>. Following is the syntax of this method.</p>
<pre class="result notranslate">
imencode(ext, image, matOfByte);
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>Ext</b> &minus; A String parameter specifying the image format (.jpg, .png, etc.)</p></li>
<li><p><b>image</b> &minus; A Mat object of the image</p></li>
<li><p><b>matOfByte</b> &minus; An empty object of the class MatOfByte</p></li>
</ul>
<p>Encode the image using this method as shown below.</p>
<pre class="prettyprint notranslate">
//Reading the image 
Mat image = Imgcodecs.imread(file);

//instantiating an empty MatOfByte class 
MatOfByte matOfByte = new MatOfByte();

//Converting the Mat object to MatOfByte 
Imgcodecs.imencode(".jpg", image, matOfByte);
</pre>
<h3>Step 2: Convert the MatOfByte object to byte array</h3>
<p>Convert the <b>MatOfByte</b> object into a byte array using the method <b>toArray()</b>.</p>
<pre class="result notranslate">
byte[] byteArray = matOfByte.toArray();
</pre>
<h3>Step 3: Preparing the InputStream object</h3>
<p>Prepare the InputStream object by passing the byte array created in the previous step to the constructor of the <b>ByteArrayInputStream</b> class.</p>
<pre class="result notranslate">
//Preparing the InputStream object 
InputStream in = new ByteArrayInputStream(byteArray);
</pre>
<h3>Step 4: Preparing the InputStream object</h3>
<p>Pass the Input Stream object created in the previous step to the <b>read()</b> method of the <b>ImageIO</b> class. This will return a BufferedImage object.</p>
<pre class="result notranslate">
//Preparing the BufferedImage 
BufferedImage bufImage = ImageIO.read(in);
</pre>
<h2>Displaying Image using AWT/Swings</h2>
<p>To display an image using the AWT/Swings frame, first of all, read an image using the <b>imread()</b> method and convert it into <b>BufferedImage</b> following the above-mentioned steps.</p>
<p>Then, instantiate the <b>JFrame</b> class and add the buffered image created to the ContentPane of the JFrame, as shown below &minus;</p>
<pre class="prettyprint notranslate">
//Instantiate JFrame 
JFrame frame = new JFrame();
 
//Set Content to the JFrame 
frame.getContentPane().add(new JLabel(new ImageIcon(bufImage))); 
frame.pack(); 
frame.setVisible(true);
</pre>
<p><b>Example</b></p>
<p>The following program code shows how you can <b>read</b> an image and <b>display</b> it through swing window using OpenCV library.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

import javax.imageio.ImageIO;
import javax.swing.ImageIcon;
import javax.swing.JFrame;
import javax.swing.JLabel;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.imgcodecs.Imgcodecs;

public class DisplayingImagesUsingSwings {
   public static void main(String args[]) throws Exception { 
      //Loading the OpenCV core library  
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME ); 
    
      //Reading the Image from the file and storing it in to a Matrix object 
      String file = "C:/EXAMPLES/OpenCV/sample.jpg"; 
      Mat image = Imgcodecs.imread(file); 
    
      //Encoding the image 
      MatOfByte matOfByte = new MatOfByte();       
      Imgcodecs.imencode(".jpg", image, matOfByte); 

      //Storing the encoded Mat in a byte array 
      byte[] byteArray = matOfByte.toArray(); 

      //Preparing the Buffered Image 
      InputStream in = new ByteArrayInputStream(byteArray); 
      BufferedImage bufImage = ImageIO.read(in); 

      //Instantiate JFrame 
      JFrame frame = new JFrame(); 

      //Set Content to the JFrame 
      frame.getContentPane().add(new JLabel(new ImageIcon(bufImage))); 
      frame.pack(); 
      frame.setVisible(true);
      
      System.out.println("Image Loaded");     
   } 
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Loaded
</pre>
<p>In addition to that, you can see a window displaying the image loaded, as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/displaying_image_using_swings.jpg" alt="Displaying Image using Swings" />
<h2>Displaying Image using JavaFX</h2>
<p>To display an image using JavaFX, first of all, read an image using the <b>imread()</b> method and convert it into <b>BufferedImage</b>. Then, convert the BufferedImage to WritableImage, as shown below.</p>
<pre class="result notranslate">
WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
</pre>
<p>Pass this <b>WritableImage</b> object to the constructor of the <b>ImageView</b> class.</p>
<pre class="result notranslate">
ImageView imageView = new ImageView(writableImage);
</pre>
<p><b>Example</b></p>
<p>The following program code shows how to <b>read</b> an image and <b>display</b> it through JavaFX window using OpenCV library.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import javax.imageio.ImageIO;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.imgcodecs.Imgcodecs;

public class DisplayingImagesJavaFX extends Application {
   @Override 
   public void start(Stage stage) throws IOException {   
      WritableImage writableImage = loadImage(); 
  
      //Setting the image view 
      ImageView imageView = new ImageView(writableImage); 
        
      //Setting the position of the image 
      imageView.setX(50); 
      imageView.setY(25); 
        
      //setting the fit height and width of the image view 
      imageView.setFitHeight(400); 
      imageView.setFitWidth(500);
      
      //Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);
      
      //Creating a Group object  
      Group root = new Group(imageView);
      
      //Creating a scene object
      Scene scene = new Scene(root, 600, 400);
      
      //Setting title to the Stage 
      stage.setTitle("Loading an image");
      
      //Adding scene to the stage
      stage.setScene(scene);

      //Displaying the contents of the stage
      stage.show();
   } 
   public WritableImage loadImage() throws IOException {
      //Loading the OpenCV core library  
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );
      
      //Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";
      Mat image = Imgcodecs.imread(file);
      
      //Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", image, matOfByte);

      //Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();
      
      //Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray); 
      BufferedImage bufImage = ImageIO.read(in);

      System.out.println("Image Loaded");
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      return writableImage; 
   }
   public static void main(String args[]) {
      launch(args); 
   } 
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Loaded
</pre>
<p>In addition to that, you can see a window displaying the image loaded, as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/displaying_image_using_javafx.jpg" alt="Displaying Image using JavaFX" />
<h1>OpenCV - The IMREAD_XXX Flag</h1>
<p>OpenCV supports various types of images such as colored, binary, grayscale, etc. Using the <b>imread()</b> method and predefined fields of the <b>Imgcodecs</b> class, you can read a given image as another type.</p>
<h2>The flags  parameter of imread() method (IMREAD_XXX)</h2>
<p>In the earlier chapters, we have seen the syntax of <b>imread()</b> method of the <b>Imgcodecs</b> class. It accepts a string argument representing the location of the image that is to be read.</p>
<pre class="result notranslate">
imread(filename)
</pre>
<p>The <b>imread()</b> method has another syntax.</p>
<pre class="result notranslate">
imread(filename, int flags)
</pre>
<p>This syntax accepts two parameters &minus;</p>
<ul class="list">
<li><p><b>filename</b> &minus; It accepts an argument <b>(filename)</b>, a variable of the String type representing the path of the file that is to be read.</p></li>
<li><p><b>flags</b> &minus; An integer value representing a predefined flag value. For each value, this reads the given image as a specific type (gray scale color etc.)</p></li>
</ul>
<p>Following is the table listing various fields provided in the <b>Imgproc</b> class as values for this parameter.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">S.No</th>
<th style="text-align:center;">Fields and Description</th>
</tr>
<tr>
<td class="ts">1</td>
<td>
<p><b>IMREAD_COLOR</b></p>
<p>If the flag is set to this value, the loaded image will be converted to a 3-channel BGR (Blue Green Red) color image.</p></td>
</tr>
<tr>
<td class="ts">2</td>
<td>
<p><b>IMREAD_GRAYSCALE</b></p>
<p>If the flag is set to this value, the loaded image will be converted to a single-channel grayscale image.</p>
</td>
</tr>
<tr>
<td class="ts">3</td>
<td>
<p><b>IMREAD_LOAD_GDAL</b></p>
<p>If the flag is set to this value, you can load the image using the <b>gdal</b> driver.</p>
</td>
</tr>
<tr>
<td class="ts">4</td>
<td>
<p><b>IMREAD_ANYCOLOR</b></p>
<p>If the flag is set to this value, the image is read in any possible color format.</p>
</td>
</tr>
<tr>
<td class="ts">5</td>
<td>
<p><b>IMREAD_REDUCED_COLOR_2</b></p>
<p><b>IMREAD_REDUCED_COLOR_4</b></p>
<p><b>IMREAD_REDUCED_COLOR_8</b></p>
<p>If the flag is set to this value, the image is read as three-channel BGR, and the size of the image is reduced to &frac12;, &frac14;<sup>th</sup> or &frac18;<sup>th</sup>  of the original size of the image with respect to the field used.</p></td>
</tr>
<tr>
<td class="ts">6</td>
<td>
<p><b>IMREAD_REDUCED_GRAYSCALE_2</b></p>
<p><b>IMREAD_REDUCED_GRAYSCALE_4</b></p>
<p><b>IMREAD_REDUCED_GRAYSCALE_8</b></p>
<p>If the flag is set to this value, the image is read as a single-channel grayscale image, and the size of the image is reduced to &frac12;, &frac14;<sup>th</sup> or &frac18;<sup>th</sup> of the original size of the image with respect to the field used.</p></td>
</tr>
<tr>
<td class="ts">7</td>
<td>
<p><b>IMREAD_UNCHANGED</b></p>
<p>If the flag is set to this value, the loaded image is returned as it is.</p>
</td>
</tr>
</table>
<h1>OpenCV - Reading an Image as Grayscale</h1>
<p>The following program demonstrates how to read a colored image as grayscale and display it using JavaFX window. In here, we have read the image by passing the flag <b>IMREAD_GRAYSCALE</b> along with the String holding the path of a colored image.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

public class ReadingAsGrayscale extends Application {
   @Override
   public void start(Stage stage) throws Exception {
      WritableImage writableImage = loadAndConvert();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // Setting the position of the image
      imageView.setX(10);
      imageView.setY(10);

      // setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);
      
      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);
      
      // Creating a Group object  
      Group root = new Group(imageView);
      
      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);
      
      // Setting title to the Stage
      stage.setTitle("Reading image as grayscale");
      
      // Adding scene to the stage
      stage.setScene(scene);
      
      // Displaying the contents of the stage
      stage.show();
   } 
   public WritableImage loadAndConvert() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Instantiating the imagecodecs class
      Imgcodecs imageCodecs = new Imgcodecs();

      String input = "C:/EXAMPLES/OpenCV/sample.jpg";

      // Reading the image
      Mat src = imageCodecs.imread(input, Imgcodecs.IMREAD_GRAYSCALE);
       
      byte[] data1 = new byte[src.rows() * src.cols() * (int)(src.elemSize())];
      src.get(0, 0, data1);
      
      // Creating the buffered image
      BufferedImage bufImage = new BufferedImage(src.cols(),src.rows(), 
         BufferedImage.TYPE_BYTE_GRAY);
      
      // Setting the data elements to the image
      bufImage.getRaster().setDataElements(0, 0, src.cols(), src.rows(), data1);
              
      // Creating a WritableImage
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      System.out.println("Image Read");
      return writableImage;
   } 
   public static void main(String args[]) throws Exception { 
      launch(args); 
   } 
}
</pre>
<h2>Input Image</h2>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output Image</h2>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/grayscale_output_image.jpg" alt="GrayScale Output Image" />
<h1>OpenCV - Reading Image as BGR</h1>
<p>The following program demonstrates how to read a colored image as BGR type image and display it using JavaFX window. In here, we have read the image by passing the flag <b>IMREAD_COLOR</b> to the method <b>imread()</b> along with the String holding the path of a colored image.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

public class ReadingAsColored extends Application {
   @Override 
   public void start(Stage stage) throws Exception {
      WritableImage writableImage = loadAndConvert();
       
      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // Setting the position of the image
      imageView.setX(10);
      imageView.setY(10);

      // setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);
      
      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);
      
      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);
     
      // Setting title to the Stage
      stage.setTitle("Reading as colored image");

      // Adding scene to the stage
      stage.setScene(scene);
      
      // Displaying the contents of the stage
      stage.show();
   } 
   public WritableImage loadAndConvert() throws Exception {     
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );
       
      String input = "C:/EXAMPLES/OpenCV/sample.jpg";
       
      Mat dst = new Mat();

      // Reading the image
      Mat src = Imgcodecs.imread(input, Imgcodecs.IMREAD_COLOR);

      byte[] data1 = new byte[src.rows() * src.cols() * (int)(src.elemSize())]; 
      src.get(0, 0, data1);
      
      // Creating the buffered image
      BufferedImage bufImage = new BufferedImage(src.cols(),src.rows(), 
         BufferedImage.TYPE_3BYTE_BGR);

      // Setting the data elements to the image 
      bufImage.getRaster().setDataElements(0, 0, src.cols(), src.rows(), data1);

      // Creating a WritableImage
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);

      System.out.println("Image read");
      return writableImage;
   } 
   public static void main(String args[]) throws Exception {
      launch(args);
   } 
}
</pre>
<h2>Input Image</h2>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output Image</h2>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/bgr_output_image.jpg" alt="BGR Output Image" />
<h1>OpenCV - Colored Images to GrayScale</h1>
<p>In the earlier chapters, we discussed how to read an input image as different types (binary, grayscale, BGR, etc.). In this chapter, we will learn how to convert one type of image to another.</p>
<p>The class named <b>Imgproc</b> of the package <b>org.opencv.imgproc</b> provides methods to convert an image from one color to another.</p>
<h2>Converting Colored Images to Grayscale</h2>
<p>A method named <b>cvtColor()</b> is used to convert colored images to grayscale. Following is the syntax of this method.</p>
<pre class="result notranslate">
cvtColor(Mat src, Mat dst, int code)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A matrix representing the source.</p></li>
<li><p><b>dst</b> &minus; A matrix representing the destination.</p></li>
<li><p><b>code</b> &minus; An integer code representing the type of the conversion, for example, RGB to Grayscale.</p></li>
</ul>
<p>You can convert colored images to gray scale by passing the code <b>Imgproc.COLOR_RGB2GRAY</b> along with the source and destination matrices as a parameter to the <b>cvtColor()</b> method.</p>
<h3>Example</h3>
<p>The following program demonstrates how to read a colored image as a grayscale image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;
  
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;

import javafx.stage.Stage;

public class ColorToGrayscale extends Application {
   @Override
   public void start(Stage stage) throws Exception {
      WritableImage writableImage = loadAndConvert();
       
      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // Setting the position of the image
      imageView.setX(10);
      imageView.setY(10);

      // setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Colored to grayscale image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   } 
   public WritableImage loadAndConvert() throws Exception {
      //Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      String input = "C:/EXAMPLES/OpenCV/sample.jpg";

      //Reading the image
      Mat src = Imgcodecs.imread(input);

      //Creating the empty destination matrix
      Mat dst = new Mat();

      //Converting the image to gray sacle and saving it in the dst matrix
      Imgproc.cvtColor(src, dst, Imgproc.COLOR_RGB2GRAY);
      
      //Extracting data from the transformed image (dst)
      byte[] data1 = new byte[dst.rows() * dst.cols() * (int)(dst.elemSize())];
      dst.get(0, 0, data1);

      //Creating Buffered image using the data
      BufferedImage bufImage = new BufferedImage(dst.cols(),dst.rows(), 
         BufferedImage.TYPE_BYTE_GRAY);

      //Setting the data elements to the image
      bufImage.getRaster().setDataElements(0, 0, dst.cols(), dst.rows(), data1);

      //Creating a WritableImage
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      System.out.println("Converted to Grayscale");
      return writableImage;
   }
   public static void main(String args[]) throws Exception {
      launch(args);
   }
}
</pre>
<h3>Input Image</h3>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h3>Output Image</h3>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/colored_images_to_grayscale_output.jpg" alt="Colored Images to GrayScale Output" />
<h1>OpenCV - Colored Image to Binary</h1>
<p>A method called <b>threshold()</b> is used to convert grayscale images to binary image. Following is the syntax of this method.</p>
<pre class="result notranslate">
threshold(Mat src, Mat dst, double thresh, double maxval, int type)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the input image.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the output image.</p></li>
<li><p><b>thresh</b> &minus; An integer representing the threshold value.</p></li>
<li><p><b>maxval</b> &minus; An integer representing the maximum value to use with the THRESH_BINARY and THRESH_BINARY_INV thresholding types.</p></li>
<li><p><b>type</b> &minus; An integer code representing the type of the conversion, for example, RGB to Grayscale.</p></li>
</ul>
<p>You can convert a grayscale image to binary image by passing the code <b>Imgproc.THRESH_BINARY</b> along with the values to the remaining parameters.</p>
<h2>Example</h2>
<p>The following program demonstrates how to read a colored image as a binary image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

public class ColorToBinary extends Application {
   @Override
   public void start(Stage stage) throws Exception {
      WritableImage writableImage = loadAndConvert();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // Setting the position of the image
      imageView.setX(10);
      imageView.setY(10);

      // setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);
      
      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);
      
      // Setting title to the Stage
      stage.setTitle("Loading an image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage loadAndConvert() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Instantiating the Imgcodecs class
      Imgcodecs imageCodecs = new Imgcodecs();
        
      // File input = new File("C:/EXAMPLES/OpenCV/sample.jpg");
      String input = "C:/EXAMPLES/OpenCV/sample.jpg";

      // Reading the image
      Mat src = imageCodecs.imread(input);

      // Creating the destination matrix
      Mat dst = new Mat();

      // Converting to binary image...
      Imgproc.threshold(src, dst, 200, 500, Imgproc.THRESH_BINARY);

      // Extracting data from the transformed image (dst)
      byte[] data1 = new byte[dst.rows() * dst.cols() * (int)(dst.elemSize())];
      dst.get(0, 0, data1);

      // Creating Buffered image using the data
      BufferedImage bufImage = new BufferedImage(dst.cols(),dst.rows(), 
         BufferedImage.TYPE_BYTE_GRAY);

      // Setting the data elements to the image
      bufImage.getRaster().setDataElements(0, 0, dst.cols(), dst.rows(), data1);

      // Creating a Writable image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);

      System.out.println("Converted to binary");
      return writableImage;
   }  
   public static void main(String args[]) throws Exception {
      launch(args);
   }
}
</pre>
<h2>Input Image</h2>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output Image</h2>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/colored_image_to_binary_output.jpg" alt="Colored Image to Binary Output" />
<h1>OpenCV - Grayscale to Binary</h1>
<p>You can use the same method mentioned in the previous chapter to convert a grayscale image to a binary image. Just pass the path for a grayscale image as input to this program.</p>
<h2>Example</h2>
<p>The following program demonstrates how to read a grayscale image as a binary image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

public class GrayScaleToBinary extends Application {
   @Override
   public void start(Stage stage) throws Exception {
      WritableImage writableImage = loadAndConvert();
       
      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // Setting the position of the image
      imageView.setX(10);
      imageView.setY(10);
      
      // Setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Grayscale to binary image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage loadAndConvert() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Instantiating the imagecodecs class
      Imgcodecs imageCodecs = new Imgcodecs();

      String input = "E:/OpenCV/chap7/grayscale.jpg";

      // Reading the image
      Mat src = imageCodecs.imread(input);

      // Creating the destination matrix
      Mat dst = new Mat();

      // Converting to binary image...
      Imgproc.threshold(src, dst, 200, 500, Imgproc.THRESH_BINARY);

      // Extracting data from the transformed image (dst)
      byte[] data1 = new byte[dst.rows() * dst.cols() * (int)(dst.elemSize())];
      dst.get(0, 0, data1);

      // Creating Buffered image using the data
      BufferedImage bufImage = new BufferedImage(dst.cols(),dst.rows(), 
         BufferedImage.TYPE_BYTE_BINARY);

      // Setting the data elements to the image
      bufImage.getRaster().setDataElements(0, 0, dst.cols(), dst.rows(), data1);

      // Creating a Writable image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);

      System.out.println("Converted to binary");
      return writableImage;
   }
   public static void main(String args[]) throws Exception {
      launch(args);
   }
}
</pre>
<h2>Input Image</h2>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output Image</h2>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/grayscale_to_binary.jpg" alt="GrayScale to Binary" />
<h1>OpenCV - Drawing a Circle</h1>
<p>You can draw various shapes like Circle, Rectangle, Line, Ellipse, Polylines, Convex, Polylines, Polylines on an image using the respective methods of the <b>org.opencv.imgproc</b> package.</p>
<p>You can draw a circle on an image using the method <b>circle()</b> of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
circle(img, center, radius, color, thickness)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the circle is to be drawn.</p></li>
<li><p><b>point</b> &minus; A <b>Point</b> object representing the center of the circle.</p></li>
<li><p><b>radius</b> &minus; A variable of the type <b>integer</b> representing the radius of the circle.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the circle. (BGR)</p></li>
<li><p><b>thickness</b> &minus; An <b>integer</b> representing the thickness of the circle; by default, the value of thickness is 1.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to draw a circle on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DrawingCircle extends Application {
   Mat matrix = null;
   
   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      DrawingCircle obj = new DrawingCircle();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing Circle on the image");
      
      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }      
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      <b>//Drawing a Circle
      Imgproc.circle (
         matrix,                 //Matrix obj of the image
         new Point(230, 160),    //Center of the circle
         100,                    //Radius
         new Scalar(0, 0, 255),  //Scalar object for color
         10                      //Thickness of the circle
      );</b>
      
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);
      this.matrix = matrix;
      
      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);

      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_circle.jpg" alt="Drawing Circle" />
<h1>OpenCV - Drawing a Line</h1>
<p>You can draw a line on an image using the method <b>line()</b> of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
line(img, pt1, pt2, color, thickness)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the line is to be drawn.</p></li>
<li><p><b>pt1 and pt2</b> &minus; Two <b>Point</b> objects representing the points between which the line is to be drawn.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the circle. (BGR)</p></li>
<li><p><b>thickness</b> &minus; An integer representing the thickness of the line; by default, the value of thickness is 1.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to draw a line on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DrawingLine extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
   
      // Capturing the snapshot from the camera
      DrawingLine obj = new DrawingLine();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object  
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing a line on the image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      <b>// Drawing a line
      Imgproc.line (
         matrix,                    //Matrix obj of the image
         new Point(10, 200),        //p1
         new Point(300, 200),       //p2
         new Scalar(0, 0, 255),     //Scalar object for color
         5                          //Thickness of the line
      );</b>
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);

      this.matrix = matrix;

      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_line.jpg" alt="Drawing Line" />
<h1>OpenCV - Drawing a Rectangle</h1>
<p>You can draw a rectangle on an image using the method <b>rectangle()</b> of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
rectangle(img, pt1, pt2, color, thickness)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the rectangle is to be drawn.</p></li>
<li><p><b>pt1 and pt2</b> &minus; Two <b>Point</b> objects representing the vertices of the rectangle that is to be drawn.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the rectangle. (BGR)</p></li>
<li><p><b>thickness</b> &minus; An integer representing the thickness of the rectangle; by default, the value of thickness is 1.</p></li>
</ul>
<h2>Example</h2>
<p>The following example demonstrates how to draw a rectangle on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DrawingRectangle extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      DrawingRectangle obj = new DrawingRectangle();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing Rectangle on the image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      <b>// Drawing a Rectangle
      Imgproc.rectangle (
         matrix,                    //Matrix obj of the image
         new Point(130, 50),        //p1
         new Point(300, 280),       //p2
         new Scalar(0, 0, 255),     //Scalar object for color
         5                          //Thickness of the line
      );</b>
      
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);

      this.matrix = matrix;

      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_rectangle.jpg" alt="Drawing Rectangle" />
<h1>OpenCV - Drawing an Ellipse</h1>
<p>You can draw an ellipse on an image using the method <b>rectangle()</b> of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
ellipse(img, box, color, thickness)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the Rectangle is to be drawn.</p></li>
<li><p><b>box</b> &minus; A RotatedRect object (The ellipse is drawn inscribed in this rectangle.)</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the Rectangle. (BGR)</p></li>
<li><p><b>thickness</b> &minus; An integer representing the thickness of the Rectangle; by default, the value of thickness is 1.</p></li>
</ul>
<p>The constructor of the <b>RotatedRect</b> class accepts an object of the class <b>Point</b>, an object of the class Size, and a variable of the type double, as shown below.</p>
<pre class="result notranslate">
RotatedRect(Point c, Size s, double a)
</pre>
<h2>Example</h2>
<p>The following program demonstrates how to draw an ellipse on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.Point;
import org.opencv.core.RotatedRect;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DrawingEllipse extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      DrawingEllipse obj = new DrawingEllipse();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing Ellipse on the image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      <b>// Drawing an Ellipse
      Imgproc.ellipse (
         matrix,                          //Matrix obj of the image
         new RotatedRect (                // RotatedRect(Point c, Size s, double a)
            new Point(200, 150),
            new Size(260, 180), 180 
         ),
         new Scalar(0, 0, 255),           //Scalar object for color
         10                               //Thickness of the line
      );</b>
      
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);

      this.matrix = matrix;
      
      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);

      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_ellipse.jpg" alt="Drawing Ellipse" />
<h1>OpenCV - Drawing Polylines</h1>
<p>You can draw Polylines on an image using the method <b>polylines()</b> of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
polylines(img, pts, isClosed, color, thickness)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the Polylines are to be drawn.</p></li>
<li><p><b>pts</b> &minus; A <b>List</b> object holding the objects of the type <b>MatOfPoint</b>.</p></li>
<li><p><b>isClosed</b> &minus; A parameter of the type boolean specifying weather the polylines are closed.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the Polylines. (BGR)</p></li>
<li><p><b>thickness</b> &minus; An integer representing the thickness of the Polylines; by default, the value of thickness is 1.</p></li>
</ul>
<p>The constructor of the <b>MatOfPoint</b> class accepts objects of the class <b>Point</b>.</p>
<pre class="result notranslate">
MatOfPoint(Point... a)
</pre>
<h2>Example</h2>
<p>The following program demonstrates how to draw polylines on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;

import java.util.ArrayList;
import java.util.List;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DrawingPolyLines extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      DrawingPolyLines obj = new DrawingPolyLines();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing Polylines on the image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }      
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      List&lt;MatOfPoint&gt; list = new ArrayList();
      list.add(
         new MatOfPoint (
            new Point(75, 100), new Point(350, 100),
            new Point(75, 150), new Point(350, 150),
            new Point(75, 200), new Point(350, 200),
            new Point(75, 250), new Point(350, 250)
         )
      );
      <b>// Drawing polylines
      Imgproc.polylines (
         matrix,                    // Matrix obj of the image
         list,                      // java.util.List&lt;MatOfPoint&gt; pts
         false,                     // isClosed
         new Scalar(0, 0, 255),     // Scalar object for color
         2                          // Thickness of the line
      );</b>
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);

      this.matrix = matrix;

      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_polylines.jpg" alt="Drawing Polylines" />
<h1>OpenCV - Drawing Convex Polylines</h1>
<p>You can draw convex polylines on an image using the method <b>fillconvexPoly()</b> of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
fillConvexPoly(Mat img, MatOfPoint points, Scalar color)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the convex Polylines are to be drawn.</p></li>
<li><p><b>points</b> &minus; A <b>MatOfPoint</b> object representing points between which the convex polylines are to be drawn.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the convex Polylines. (BGR)</p></li>
</ul>
<p>The constructor of the <b>MatOfPoint</b> class accepts objects of the class <b>Point</b>.</p>
<pre class="result notranslate">
MatOfPoint(Point... a)
</pre>
<h2>Example</h2>
<p>The following program demonstrates how to draw convex polylines on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class FillConvexPoly extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      FillConvexPoly obj = new FillConvexPoly();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      //Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing convex Polylines (fill) on the image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      MatOfPoint matOfPoint = new MatOfPoint (
         new Point(75, 100), new Point(350, 100),
         new Point(75, 150), new Point(350, 150),
         new Point(75, 200), new Point(350, 200),
         new Point(75, 250), new Point(350, 250)
      ); 
      <b>// Drawing polylines
      Imgproc.fillConvexPoly (
         matrix,                       // Matrix obj of the image
         matOfPoint,                   // java.util.List&lt;MatOfPoint&gt; pts
         new Scalar(0, 0, 255)         // Scalar object for color
      );</b>
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);
      this.matrix = matrix;
            
      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      return writableImage;
   } 
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_convex_polylines.jpg" alt="Drawing Convex Polylines" />
<h1>OpenCV - Drawing Arrowed Lines</h1>
<p>You can draw an arrowed line on an image using the method <b>arrowedLine()</b> of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
arrowedLine(Mat img, Point pt1, Point pt2, Scalar color)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image on which the arrowed line is to be drawn.</p></li>
<li><p><b>pt1 and pt2</b> &minus; Two <b>Point</b> objects representing the points between which the arrowed line is to be drawn.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the arrowed line. (BGR)</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to draw arrowed line on an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DrawingArrowedLine extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      DrawingArrowedLine obj = new DrawingArrowedLine();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Drawing a line on the image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/Aish.jpg";
      Mat matrix = Imgcodecs.imread(file);

      <b>//Drawing a line
      Imgproc.arrowedLine(
         matrix,                       // Matrix obj of the image
         new Point(10, 200),           // p1
         new Point(590, 200),          // p2
         new Scalar(0, 100, 255)       // Scalar object for color
      );</b>

      // arrowedLine(Mat img, Point pt1, Point pt2, Scalar color)
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);
      this.matrix = matrix;

      // Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);

      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/drawing_arrowed_lines.jpg" alt="Drawing Arrowed Lines" />
<h1>OpenCV - Adding Text</h1>
<p>You can add text to an image using the method <b>arrowedLine()</b> of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
putText(img, text, org, fontFace, fontScale, Scalar color, int thickness)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>mat</b> &minus; A <b>Mat</b> object representing the image to which the text is to be added.</p></li>
<li><p><b>text</b> &minus; A <b>string</b> variable of representing the text that is to be added.</p></li>
<li><p><b>org</b> &minus; A <b>Point</b> object representing the bottom left corner text string in the image.</p></li>
<li><p><b>fontFace</b> &minus; A variable of the type integer representing the font type.</p></li>
<li><p><b>fontScale</b> &minus; A variable of the type double representing the scale factor that is multiplied by the font-specific base size.</p></li>
<li><p><b>scalar</b> &minus; A <b>Scalar</b> object representing the color of the text that is to be added. (BGR)</p></li>
<li><p><b>thickness</b> &minus; An integer representing the thickness of the line by default, the value of thickness is 1.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to add text to an image and display it using JavaFX window.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import javax.imageio.ImageIO;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfByte;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class AddingTextToImage extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws Exception {
      // Capturing the snapshot from the camera
      AddingTextToImage obj = new AddingTextToImage();
      WritableImage writableImage = obj.LoadImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(600);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Adding text to an image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage LoadImage() throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap8/input.jpg";
      Mat matrix = Imgcodecs.imread(file);

      <b>// Adding Text
      Imgproc.putText (
         matrix,                          // Matrix obj of the image
         "Ravivarma's Painting",          // Text to be added
         new Point(10, 50),               // point
         Core.FONT_HERSHEY_SIMPLEX ,      // front face
         1,                               // front scale
         new Scalar(0, 0, 0),             // Scalar object for color
         4                                // Thickness
      );</b>
      
      // Encoding the image
      MatOfByte matOfByte = new MatOfByte();
      Imgcodecs.imencode(".jpg", matrix, matOfByte);

      // Storing the encoded Mat in a byte array
      byte[] byteArray = matOfByte.toArray();

      // Displaying the image
      InputStream in = new ByteArrayInputStream(byteArray);
      BufferedImage bufImage = ImageIO.read(in);
      this.matrix = matrix;

      //Creating the Writable Image
      WritableImage writableImage = SwingFXUtils.toFXImage(bufImage, null);
      return writableImage;
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<p>On executing the above program, you will get the following output &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/adding_text.jpg" alt="Adding Text" />
<h1>OpenCV - Blur (Averaging)</h1>
<p>Blurring (smoothing) is the commonly used image processing operation for reducing the image noise. The process removes high-frequency content, like edges, from the image and makes it smooth.</p>
<p>In general blurring is achieved by convolving (each element of the image is added to its local neighbors, weighted by the kernel) the image through a low pass filter kernel.</p>
<h2>Blur (Averaging)</h2>
<p>During this operation, the image is convolved with a box filter (normalized). In this process, the central element of the image is replaced by the average of all the pixels in the kernel area.</p>
<p>You can perform this operation on an image using the method <b>blur()</b> of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
blur(src, dst, ksize, anchor, borderType)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ksize</b> &minus; A <b>Size</b> object representing the size of the kernel.</p></li>
<li><p><b>anchor</b> &minus; A variable of the type integer representing the anchor point.</p></li>
<li><p><b>borderType</b> &minus; A variable of the type integer representing the type of the border to be used to the output.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform the averaging (blur) operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class BlurTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Creating the Size and Point objects
      Size size = new Size(45, 45);
      Point point = new Point(20, 30);

      // Applying Blur effect on the Image
      Imgproc.blur(src, dst, size, point, Core.BORDER_DEFAULT);

      // blur(Mat src, Mat dst, Size ksize, Point anchor, int borderType)
      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap9/blur.jpg", dst);
      System.out.println("Image processed");
   }
}
</pre>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/blur_averaging.jpg" alt="Blur (Averaging)" />
<h1>OpenCV - Gaussian Blur</h1>
<p>In Gaussian Blur operation, the image is convolved with a Gaussian filter instead of the box filter. The Gaussian filter is a low-pass filter that removes the high-frequency components are reduced.</p>
<p>You can perform this operation on an image using the <b>Gaussianblur()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
GaussianBlur(src, dst, ksize, sigmaX)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ksize</b> &minus; A <b>Size</b> object representing the size of the kernel.</p></li>
<li><p><b>sigmaX</b> &minus; A variable of the type double representing the Gaussian kernel standard deviation in X direction.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform the Gaussian blur operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class GaussianTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();
    
      // Applying GaussianBlur on the Image
      Imgproc.GaussianBlur(src, dst, new Size(45, 45), 0);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap9/Gaussian.jpg", dst);
      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/gaussian_blur.jpg" alt="Gaussian Blur" />
<h1>OpenCV - Median Blur</h1>
<p>The Median blur operation is similar to the other averaging methods. Here, the central element of the image is replaced by the median of all the pixels in the kernel area. This operation processes the edges while removing the noise.</p>
<p>You can perform this operation on an image using the <b>medianBlur()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
medianBlur(src, dst, ksize)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ksize</b> &minus; A <b>Size</b> object representing the size of the kernel.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform the median blur operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class MedianBlurTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying MedianBlur on the Image
      Imgproc.medianBlur(src, dst, 15);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap9/median.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/median_blur.jpg" alt="Median Blur" />
<h1>OpenCV - Bilateral Filter</h1>
<p>Image filtering allows you to apply various effects to an image. In this chapter and the subsequent three chapters, we are going to discuss various filter operations such as Bilateral Filter, Box Filter, SQR Box Filter and Filter2D.</p>
<h2>Bilateral Filter</h2>
<p>The Bilateral Filter operation applies a bilateral image to a filter. You can perform this operation on an image using the <b>medianBlur()</b> method of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
bilateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>d</b> &minus; A variable of the type integer representing the diameter of the pixel neighborhood.</p></li>
<li><p><b>sigmaColor</b> &minus; A variable of the type integer representing the filter sigma in the color space.</p></li>
<li><p><b>sigmaSpace</b> &minus; A variable of the type integer representing the filter sigma in the coordinate space.</p></li>
<li><p><b>borderType</b> &minus; An integer object representing the type of the border used.</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform the Bilateral Filter operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class BilateralFilter {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap11/filter_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying Bilateral filter on the Image
      Imgproc.bilateralFilter(src, dst, 15, 80, 80, Core.BORDER_DEFAULT);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap11/bilateralfilter.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>filter_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/filter_input.jpg" alt="Filter Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/bilateral_filter_output.jpg" alt="Bilateral Filter Output" />
<h1>OpenCV - Box Filter</h1>
<p>The Box Filter operation is similar to the averaging blur operation; it applies a bilateral image to a filter. Here, you can choose whether the box should be normalized or not.</p>
<p>You can perform this operation on an image using the <b>boxFilter()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
boxFilter(src, dst, ddepth, ksize, anchor, normalize, borderType)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ddepth</b> &minus; A variable of the type integer representing the depth of the output image.</p></li>
<li><p><b>ksize</b> &minus; A <b>Size</b> object representing the size of the blurring kernel.</p></li>
<li><p><b>anchor</b> &minus; A variable of the type integer representing the anchor point.</p></li>
<li><p><b>Normalize</b> &minus; A variable of the type boolean specifying weather the kernel should be normalized.</p></li>
<li><p><b>borderType</b> &minus; An integer object representing the type of the border used.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform the Box Filter operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class BoxFilterTest {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file = "E:/OpenCV/chap11/filter_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Creating the objects for Size and Point
      Size size = new Size(45, 45);
      Point point = Point(-1, -1);

      // Applying Box Filter effect on the Image
      Imgproc.boxFilter(src, dst, 50, size, point, true, Core.BORDER_DEFAULT);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap11/boxfilterjpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>filter_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/filter_input.jpg" alt="Filter Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/box_filter.jpg" alt="Box Filter" />
<h1>OpenCV - SQRBox Filter</h1>
<p>You can perform the SQRBox Filter operation on an image using the <b>boxFilter()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
sqrBoxFilter(src, dst, ddepth, ksize)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ddepth</b> &minus; A variable of the type integer representing the depth of the output image.</p></li>
<li><p><b>ksize</b> &minus; A <b>Size</b> object representing the size of the blurring kernel.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform Sqrbox filter operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class SqrBoxFilterTest {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap11/filter_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying Box Filter effect on the Image
      Imgproc.sqrBoxFilter(src, dst, -1, new Size(1, 1));
     
      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap11/sqrboxfilter.jpg", dst);

      System.out.println("Image Processed");
   } 
}
</pre>
<p>Assume that following is the input image <b>filter_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/filter_input.jpg" alt="Filter Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/sqrbox_filter.jpg" alt="SQRBox Filter" />
<h1>OpenCV - Filter2D</h1>
<p>The Filter2D operation convolves an image with the kernel. You can perform this operation on an image using the <b>Filter2D()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
filter2D(src, dst, ddepth, kernel)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ddepth</b> &minus; A variable of the type integer representing the depth of the output image.</p></li>
<li><p><b>kernel</b> &minus; A <b>Mat</b> object representing the convolution kernel.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform the Filter2D operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class Filter2D {
   public static void main( String[] args ) {
      //Loading the OpenCV core library  
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      //Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap11/filter_input.jpg";
      Mat src = Imgcodecs.imread(file);

      //Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Creating kernel matrix
      Mat kernel = Mat.ones(2,2, CvType.CV_32F);
      
      for(int i = 0; i&lt;kernel.rows(); i++) {
         for(int j = 0; j&lt;kernel.cols(); j++) {
            double[] m = kernel.get(i, j);

            for(int k = 1; k&lt;m.length; k++) {
               m[k] = m[k]/(2 * 2);
            }
            kernel.put(i,j, m);
         }
      }
      Imgproc.filter2D(src, dst, -1, kernel);
      Imgcodecs.imwrite("E:/OpenCV/chap11/filter2d.jpg", dst);
      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>filter_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/filter_input.jpg" alt="Filter Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/filter2d.jpg" alt="Filter2D" />
<h1>OpenCV - Dilation</h1>
<p>Erosion and dilation are the two types of morphological operations. As the name implies, morphological operations are the set of operations that process images according to their shapes.</p>
<p>Based on the given input image a "structural element" is developed. This might be done in any of the two procedures. These are aimed at removing noise and settling down the imperfections, to make the image clear.</p>
<h2>Dilation</h2>
<p>This procedure follows convolution with some kernel of a specific shape such as a square or a circle. This kernel has an anchor point, which denotes its center.</p>
<p>This kernel is overlapped over the picture to compute maximum pixel value. After calculating, the picture is replaced with anchor at the center. With this procedure, the areas of bright regions grow in size and hence the image size increases.</p>
<p>For example, the size of an object in white shade or bright shade increases, while the size of an object in black shade or dark shade decreases.</p>
<p>You can perform the dilation operation on an image using the <b>dilate()</b> method of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
dilate(src, dst, kernel)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>kernel</b> &minus; A <b>Mat</b> object representing the kernel.</p></li>
</ul>
<h3>Example</h3>
<p>You can prepare the kernel matrix using the <b>getStructuringElement()</b> method. This method accepts an integer representing the <b>morph_rect</b> type and an object of the type <b>Size</b>.</p>
<pre class="result notranslate">
Imgproc.getStructuringElement(int shape, Size ksize);
</pre>
<p>The following program demonstrates how to perform the dilation operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DilateTest {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Preparing the kernel matrix object 
      Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, 
         new  Size((2*2) + 1, (2*2)+1));

      // Applying dilate on the Image
      Imgproc.dilate(src, dst, kernel);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap10/Dilation.jpg", dst);

      System.out.println("Image Processed");
   } 
}
</pre>
<h3>Input</h3>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/dilation.jpg" alt="Dilation" />
<h1>OpenCV - Erosion</h1>
<p>Erosion is quite a similar process as dilation. But the pixel value computed here is minimum rather than maximum in dilation. The image is replaced under the anchor point with that minimum pixel value.</p>
<p>With this procedure, the areas of dark regions grow in size and bright regions reduce. For example, the size of an object in dark shade or black shade increases, while it decreases in white shade or bright shade.</p>
<h2>Example</h2>
<p>You can perform this operation on an image using the <b>erode()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
erode(src, dst, kernel)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>kernel</b> &minus; A <b>Mat</b> object representing the kernel.</p></li>
</ul>
<p>You can prepare the kernel matrix using the <b>getStructuringElement()</b> method. This method accepts an integer representing the <b>morph_rect</b> type and an object of the type <b>Size</b>.</p>
<pre class="result notranslate">
Imgproc.getStructuringElement(int shape, Size ksize);
</pre>
<p>The following program demonstrates how to perform the erosion operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class ErodeTest {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="C:/EXAMPLES/OpenCV/sample.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Preparing the kernel matrix object
      Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, 
         new  Size((2*2) + 1, (2*2)+1));

      // Applying erode on the Image
      Imgproc.erode(src, dst, kernel);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap10/Erosion.jpg", dst);

      System.out.println("Image processed");
   }
}
</pre>
<p>Assume that following is the input image <b>sample.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/sample_image.jpg" alt="Sample Image" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Loaded
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/erosion.jpg" alt="Erosion" />
<h1>OpenCV - Morphological Operations</h1>
<p>In the earlier chapters, we discussed the process of <b>erosion</b> and <b>dilation</b>. In addition to these two, OpenCV has more morphological transformations. The <b>morphologyEx()</b> of the method of the class <b>Imgproc</b> is used to perform these operations on a given image.</p>
<p>Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
morphologyEx(src, dst, op, kernel)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>op</b> &minus; An integer representing the type of the Morphological operation.</p></li>
<li><p><b>kernel</b> &minus; A kernel matrix.</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to apply the morphological operation <b>"top-hat"</b> on an image using OpenCV library.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class MorphologyExTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap12/morph_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Creating kernel matrix
      Mat kernel = Mat.ones(5,5, CvType.CV_32F);

      // Applying Blur effect on the Image 
      Imgproc.morphologyEx(src, dst, Imgproc.MORPH_TOPHAT, kernel);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap12/morph_tophat.jpg", dst);

      System.out.println("Image Processed");
   } 
}
</pre>
<p>Assume that following is the input image <b>morph_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/morph_input.jpg" alt="Morph Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/morph_output.jpg" alt="Morph Output" />
<h2>More Operations</h2>
<p>In addition to the morphological operation <b>TOPHAT</b>, demonstrated in the previous <b>example</b>, OpenCV caters various other types of morphologies. All these types are represented by predefined static fields (fixed values) of <b>Imgproc</b> class.</p>
<p>You can choose the type of the morphology you need by passing their respective predefined value to the parameter <b>op</b> of the <b>morphologyEx()</b> method.</p>
<pre class="result notranslate">
// Applying Blur effect on the Image
Imgproc.morphologyEx(src, dst, <b>Imgproc.MORPH_TOPHAT</b>, kernel);
</pre>
<p>Following are the values representing the type of morphological operations and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;width:50%">Operation and Description</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>MORPH_BLACKHAT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_blackhat.jpg" alt="MORPH_BLACKHAT" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_CLOSE</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_close.jpg" alt="MORPH_CLOSE" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_CROSS</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_cross.jpg" alt="MORPH_CROSS" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_DILATE</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_dilate.jpg" alt="MORPH_DILATE" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_ELLIPSE</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_ellipse.jpg" alt="MORPH_ELLIPSE" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_ERODE</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_erode.jpg" alt="MORPH_ERODE" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_GRADIENT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_gradient.jpg" alt="MORPH_GRADIENT" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_OPEN</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_open.jpg" alt="MORPH_OPEN" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_RECT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_rect.jpg" alt="MORPH_RECT" /></td>
</tr>
<tr>
<td class="ts"><b>MORPH_TOPHAT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/morph_tophat.jpg" alt="MORPH_TOPHAT" /></td>
</tr>
</table>
<h1>OpenCV - Image Pyramids</h1>
<p>Pyramid is an operation on an image where,</p>
<ul class="list">
<li><p>An input image is initially smoothed using a particular smoothing filter (ex: Gaussian, Laplacian) and then the smoothed image is subsampled.</p></li>
<li><p>This process is repeated multiple times.</p></li>
</ul>
<p>During the pyramid operation, the smoothness of the image is increased and the resolution (size) is decreased.</p>
<h2>Pyramid Up</h2>
<p>In Pyramid Up, the image is initially up-sampled and then blurred. You can perform Pyramid Up operation on an image using the <b>pyrUP()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
pyrUp(src, dst, dstsize, borderType)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>mat</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>size</b> &minus; An object of the class <b>Size</b> representing the size to which the image is to be increased or decreased.</p></li>
<li><p><b>borderType</b> &minus; A variable of integer type representing the type of border to be used.</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform the Pyramid Up operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class PyramidUp {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap13/pyramid_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying pyrUp on the Image
      Imgproc.pyrUp(src, dst, new Size(src.cols()*2,  src.rows()*2), Core.BORDER_DEFAULT);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap13/pyrUp_output.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>pyramid_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/pyramid_input.jpg" alt="Pyramid Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/pyramid_up_output.jpg" alt="Pyramid Up Output" />
<h2>Pyramid Down</h2>
<p>In Pyramid Down, the image is initially blurred and then down-sampled. You can perform Pyramid Down operation on an image using the <b>pyrDown()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
pyrDown(src, dst, dstsize, borderType)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>mat</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>size</b> &minus; An object of the class <b>Size</b> representing the size to which the image is to be increased or decreased.</p></li>
<li><p><b>borderType</b> &minus; A variable of integer type representing the type of border to be used.</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform the Pyramid Down operation on an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class PyramidDown {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap13/pyramid_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying pyrDown on the Image
      Imgproc.pyrDown(src, dst, new Size(src.cols()/2,  src.rows()/2),
         Core.BORDER_DEFAULT);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap13/pyrDown_output.jpg", dst);

      System.out.println("Image Processed");
   } 
}
</pre>
<p>Assume that following is the input image <b>pyramid_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/pyramid_input.jpg" alt="Pyramid Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/pyramid_down_output.jpg" alt="Pyramid Down Output" />
<h2>Mean Shift Filtering</h2>
<p>In Mean Shifting pyramid operation, an initial step of mean shift segmentation of an image is carried out.</p>
<p>You can perform pyramid Mean Shift Filtering operation on an image using the <b>pyrDown()</b> method of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
pyrMeanShiftFiltering(src, dst, sp, sr)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>mat</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>sp</b> &minus; A variable of the type double representing the spatial window radius.</p></li>
<li><p><b>sr</b> &minus; A variable of the type double representing the color window radius.</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform a Mean Shift Filtering operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class PyramidMeanShift {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap13/pyramid_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying meanShifting on the Image
      Imgproc.pyrMeanShiftFiltering(src, dst, 200, 300);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap13/meanShift_output.jpg", dst);
      
      System.out.println("Image Processed");
   } 
}
</pre>
<p>Assume that following is the input image <b>pyramid_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/pyramid_input.jpg" alt="Pyramid Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/mean_shift_filtering_output.jpg" alt="Mean Shift Filtering Output" />
<h1>OpenCV - Simple Threshold</h1>
<p>Thresholding is a method of image segmentation, in general it is used to create binary images. Thresholding is of two types namely, simple thresholding and adaptive thresholding.</p>
<h2>Simple Thresholding</h2>
<p>In simple thresholding operation the pixels whose values are greater than the specified threshold value, are assigned with a standard value.</p>
<p>You can perform simple threshold operation on an image using the method <b>threshold()</b> of the <b>Imgproc class</b>, Following is the syntax of this method.</p>
<pre class="result notranslate">
threshold(src, dst, thresh, maxval, type)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>thresh</b> &minus; A variable of double type representing the threshold value.</p></li>
<li><p><b>maxval</b> &minus; A variable of double type representing the value that is to be given if pixel value is more than the threshold value.</p></li>
<li><p><b>type</b> &minus; A variable of integer type representing the type of threshold to be used.</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform simple thresholding operation on an image in OpenCV.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class Thresh {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap14/thresh_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();
      Imgproc.threshold(src, dst, 50, 255, Imgproc.THRESH_BINARY);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap14/thresh_trunc.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>thresh_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/thresh_input.jpg" alt="Thresh Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/thresh_output.jpg" alt="Thresh Output" />
<h2>Other types of simple thresholding</h2>
<p>In addition to the <b>THRESH_BINARY</b> operation demonstrated in the previous example, OpenCV caters various other types of threshold operations. All these types are represented by predefined static fields (fixed values) of <b>Imgproc</b> class.</p>
<p>You can choose the type of the threshold operation you need, by passing its respective predefined value to the parameter named <b>type</b> of the <b>threshold()</b> method.</p>
<pre class="result notranslate">
Imgproc.threshold(src, dst, 50, 255, <b>Imgproc.THRESH_BINARY</b>);
</pre>
<p>Following are the values representing various types of threshold operations and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;width:50%">Operation and Description</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>THRESH_BINARY</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/thresh_binary.jpg" alt="THRESH_BINARY" /></td>
</tr>
<tr>
<td class="ts"><b>THRESH_BINARY_INV</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/thresh_binary_inv.jpg" alt="THRESH_BINARY_INV" /></td>
</tr>
<tr>
<td class="ts"><b>THRESH_TRUNC</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/thresh_trunc.jpg" alt="THRESH_TRUNC" /></td>
</tr>
<tr>
<td class="ts"><b>THRESH_TOZERO</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/thresh_tozero.jpg" alt="THRESH_TOZERO" /></td>
</tr>
<tr>
<td class="ts"><b>THRESH_TOZERO_INV</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/thresh_tozero_inv.jpg" alt="THRESH_TOZERO_INV" /></td>
</tr>
</table>
<h1>OpenCV - Adaptive Threshold</h1>
<p>In <b>simple thresholding</b>, the threshold value is global, i.e., it is same for all the pixels in the image. <b>Adaptive thresholding</b> is the method where the threshold value is calculated for smaller regions and therefore, there will be different threshold values for different regions.</p>
<p>In OpenCV, you can perform Adaptive threshold operation on an image using the method <b>adaptiveThreshold()</b> of the <b>Imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
adaptiveThreshold(src, dst, maxValue, adaptiveMethod, thresholdType, blockSize, C)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>maxValue</b> &minus; A variable of double type representing the value that is to be given if pixel value is more than the threshold value.</p></li>
<li><p><b>adaptiveMethod</b> &minus; A variable of integer the type representing the adaptive method to be used. This will be either of the following two values</p>
<ul class="list">
<li><p><b>ADAPTIVE_THRESH_MEAN_C</b> &minus; threshold value is the mean of neighborhood area.</p></li>
<li><p><b>ADAPTIVE_THRESH_GAUSSIAN_C</b> &minus; threshold value is the weighted sum of neighborhood values where weights are a Gaussian window.</p></li>
</li>
</ul>
<li><p><b>thresholdType</b> &minus; A variable of integer type representing the type of threshold to be used.</p></li>
<li><p><b>blockSize</b> &minus; A variable of the integer type representing size of the pixelneighborhood used to calculate the threshold value.</p></li>
<li><p><b>C</b> &minus; A variable of double type representing the constant used in the both methods (subtracted from the mean or weighted mean).</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform Adaptive threshold operation on an image in OpenCV. Here we are choosing adaptive threshold of type <b>binary</b> and <b>ADAPTIVE_THRESH_MEAN_C</b> for threshold method.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class AdaptiveThresh {
   public static void main(String args[]) throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap14/thresh_input.jpg";
      
      // Reading the image
      Mat src = Imgcodecs.imread(file,0);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      Imgproc.adaptiveThreshold(src, dst, 125, Imgproc.ADAPTIVE_THRESH_MEAN_C,
         Imgproc.THRESH_BINARY, 11, 12);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap14/Adaptivemean_thresh_binary.jpg", dst);

      System.out.println("Image Processed");
   } 
}
</pre>
<p>Assume that following is the input image <b>thresh_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/thresh_input.jpg" alt="Thresh Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/adaptive_threshold_output.jpg" alt="Adaptive Threshold Output" />
<h2>Other Types of Adaptive Thresholding</h2>
<p>In addition to the <b>ADAPTIVE_THRESH_MEAN_C</b> as the adaptive method and <b>THRESH_BINARY</b> as the threshold type as demonstrated in the previous example, we can choose more combinations of these two values.</p>
<pre class="result notranslate">
Imgproc.adaptiveThreshold(src, dst, 125, <b>Imgproc.ADAPTIVE_THRESH_MEAN_C, 
   Imgproc.THRESH_BINARY</b>, 11, 12);
</pre>
<p>Following are the values representing various combinations of values for the parameters <b>adaptiveMethod</b> and <b>thresholdType</b> and their respective outputs.</p>
<table class="table table-bordered" style="font-size:81%">
<tr>
<th style="text-align:center;">adaptiveMethod / thresholdType</th>
<th style="text-align:center;">ADAPTIVE_THRESH_MEAN_C</th>
<th style="text-align:center;">ADAPTIVE_THRESH_GAUSSIAN_C:</th>
</tr>
<tr>
<td class="ts"><b>THRESH_BINARY</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/adaptive_thresh_binary.jpg" alt="ADAPTIVE_THRESH_BINARY" /></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/adaptive_thresh_gaussian_binary.jpg" alt="ADAPTIVE_THRESH_GAUSSIAN_BINARY" /></td>
</tr>
<tr>
<td class="ts"><b>THRESH_BINARY_INV</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/adaptive_thresh_binary_inv.jpg" alt="ADAPTIVE_THRESH_BINARY_INV" /></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/adaptive_thresh_gaussian_binary_inv.jpg" alt="ADAPTIVE_THRESH_GAUSSIAN_BINARY_INV" /></td>
</tr>
</table>
<h1>OpenCV - Adding Borders</h1>
<p>This chapter teaches you how toad borders to an image.</p>
<h2>The copyMakeBorder() Method</h2>
<p>You can add various borders to an image in using the method <b>copyMakeBorder()</b> of the class named Core, which belongs to the package <b>org.opencv.core.</b> following is the syntax of this method.</p>
<pre class="result notranslate">
copyMakeBorder(src, dst, top, bottom, left, right, borderType)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>top</b> &minus; A variable of integer the type integer representing the length of the border at the top of the image.</p></li>
<li><p><b>bottom</b> &minus; A variable of integer the type integer representing the length of the border at the bottom of the image.</p></li>
<li><p><b>left</b> &minus; A variable of integer the type integer representing the length of the border at the left of the image.</p></li>
<li><p><b>right</b> &minus; A variable of integer the type integer representing the length of the border at the right of the image.</p></li>
<li><p><b>borderType</b> &minus; A variable of the type integer representing the type of the border that is to be used.</p></li>
</ul>
<h3>Example</h3>
<p>Following program is an example demonstrating, how to add border to a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;

public class AddingBorder {
   public static void main( String[] args ) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );
     
      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap15/input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();
   
      Core.copyMakeBorder(src, dst, 20, 20, 20, 20, Core.BORDER_CONSTANT);
      Imgcodecs.imwrite("E:/OpenCV/chap15/border_constant.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>thresh_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/thresh_input.jpg" alt="Thresh Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/adding_borders_output.jpg" alt="Adding Borders Output" />
<h2>Other Types of Borders</h2>
<p>In addition to the border type, <b>BORDER_CONSTANT</b> demonstrated in the previous example, OpenCV caters various other types of borders. All these types are represented by predefined static fields (fixed values) of Core class.</p>
<p>You can choose the type of the threshold operation you need, by passing its respective predefined value to the parameter named <b>borderType</b> of the <b>copyMakeBorder()</b> method.</p>
<pre class="result notranslate">
Core.copyMakeBorder(src, dst, 20, 20, 20, 20, <b>Core.BORDER_CONSTANT</b>);
</pre>
<p>Following are the values representing various types of borders operations and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;width:50%">Operation and Description</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>BORDER_CONSTANT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_constant.jpg" alt="BORDER_CONSTANT" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_ISOLATED</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_isolated.jpg" alt="BORDER_ISOLATED" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_DEFAULT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_default.jpg" alt="BORDER_DEFAULT" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_REFLECT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_reflect.jpg" alt="BORDER_REFLECT" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_REFLECT_101</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_reflect_101.jpg" alt="BORDER_REFLECT_101" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_REFLECT101</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_reflect101.jpg" alt="BORDER_REFLECT101" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_REPLICATE</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_replicate.jpg" alt="BORDER_REPLICATE" /></td>
</tr>
<tr>
<td class="ts"><b>BORDER_WRAP</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/border_wrap.jpg" alt="BORDER_WRAP" /></td>
</tr>
</table>
<h1>OpenCV - Sobel Operator</h1>
<p>Using the <b>sobel operation</b>, you can detect the edges of an image in both horizontal and vertical directions. You can apply sobel operation on an image using the method <b>sobel()</b>. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
Sobel(src, dst, ddepth, dx, dy)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>ddepth</b> &minus; An integer variable representing the depth of the image (-1)</p></li>
<li><p><b>dx</b> &minus; An integer variable representing the x-derivative. (0 or 1)</p></li>
<li><p><b>dy</b> &minus; An integer variable representing the y-derivative. (0 or 1)</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to perform Sobel operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class SobelTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap16/sobel_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying sobel on the Image
      Imgproc.Sobel(src, dst, -1, 1, 1);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap16/sobel_output.jpg", dst);

      System.out.println("Image processed");
   }
}
</pre>
<p>Assume that following is the input image <b>sobel_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/window_input.jpg" alt="Window Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/sobel_output.jpg" alt="Sobel Output" />
<h2>sobel Variants</h2>
<p>On passing different values to the last to parameters (dx and dy) (among 0 and 1), you will get different outputs &minus;</p>
<pre class="result notranslate">
// Applying sobel on the Image
Imgproc.Sobel(src, dst, -1, <b>1, 1</b>);
</pre>
<p>The following table lists various values for the variables <b>dx</b> and <b>dy</b> of the method <b>Sobel()</b> and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">X-derivative</th>
<th style="text-align:center;">Y-derivative</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>0</b></td>
<td class="ts"><b>1</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/sobel_01.jpg" alt="Sobel 01" /></td>
</tr>
<tr>
<td class="ts"><b>1</b></td>
<td class="ts"><b>0</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/sobel_10.jpg" alt="Sobel 10" /></td>
</tr>
<tr>
<td class="ts"><b>1</b></td>
<td class="ts"><b>1</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/sobel_11.jpg" alt="Sobel 11" /></td>
</tr>
</table>
<h1>OpenCV - Scharr Operator</h1>
<p>Scharr is also used to detect the second derivatives of an image in horizontal and vertical directions. You can perform scharr operation on an image using the method <b>scharr()</b>. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
Scharr(src, dst, ddepth, dx, dy)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>ddepth</b> &minus; An integer variable representing the depth of the image (-1)</p></li>
<li><p><b>dx</b> &minus; An integer variable representing the x-derivative. (0 or 1)</p></li>
<li><p><b>dy</b> &minus; An integer variable representing the y-derivative. (0 or 1)</p></li>
</ul>
<h3>Example</h3>
<p>The following program demonstrates how to apply scharr to a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class ScharrTest {

   public static void main( String[] args ) {

      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap16/sobel_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying Box Filter effect on the Image
      Imgproc.Scharr(src, dst, Imgproc.CV_SCHARR, 0, 1);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap16/scharr_output.jpg", dst);

      System.out.println("Image processed");
   }
}
</pre>
<p>Assume that following is the input image <b>scharr_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/window_input.jpg" alt="Window Input" />
<h3>Output</h3>
<p>On executing it, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/scharr_output.jpg" alt="Scharr Output" />
<h2>More scharr Derivatives</h2>
<p>On passing different values to the last to parameters (dx and dy) (among 0 and 1) you will get different outputs &minus;</p>
<pre class="result notranslate">
// Applying scharr on the Image
Imgproc.Scharr(src, dst, -1, <b>1, 1</b>);
</pre>
<p>Following is a table listing various values for the variables <b>dx</b> and <b>dy</b> of the method <b>scharr()</b> and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">X-derivative</th>
<th style="text-align:center;">Y-derivative</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>0</b></td>
<td class="ts"><b>1</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/scharr_01.jpg" alt="Scharr 01" /></td>
</tr>
<tr>
<td class="ts"><b>1</b></td>
<td class="ts"><b>0</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/scharr_10.jpg" alt="Scharr 10" /></td>
</tr>
</table>
<h1>OpenCV - Laplacian Transformation</h1>
<p>Laplacian Operator is also a derivative operator which is used to find edges in an image. It is a second order derivative mask. In this mask we have two further classifications one is Positive Laplacian Operator and other is Negative Laplacian Operator.</p>
<p>Unlike other operators Laplacian didn’t take out edges in any particular direction but it takes out edges in following classification.</p>
<ul class="list">
<li>Inward Edges</li>
<li>Outward Edges</li>
</ul>
<p>You can perform <b>Laplacian Transform</b> operation on an image using the <b>Laplacian()</b> method of the <b>imgproc</b> class, following is the syntax of this method.</p>
<pre class="result notranslate">
Laplacian(src, dst, ddepth)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>ddepth</b> &minus; A variable of the type integer representing depth of the destination image.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform Laplace transform operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class LaplacianTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);

      //Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap18/laplacian_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying GaussianBlur on the Image
      Imgproc.Laplacian(src, dst, 10);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap18/laplacian.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>laplacian_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/laplacian_input.jpg" alt="Laplacian Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/laplacian_output.jpg" alt="Laplacian Output" />
<h1>OpenCV - Distance Transformation</h1>
<p>The <b>distance transform</b> operator generally takes binary images as inputs. In this operation, the gray level intensities of the points inside the foreground regions are changed to distance their respective distances from the closest 0 value (boundary).</p>
<p>You can apply distance transform in OpenCV using the method <b>distanceTransform()</b>. Following is the syntax of this method.</p>
<pre class="result notranslate">
distanceTransform(src, dst, distanceType, maskSize)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>distanceType</b> &minus; A variable of the type integer representing the type of the distance transformation to be applied.</p></li>
<li><p><b>maskSize</b> &minus; A variable of integer type representing the mask size to be used.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to perform distance transformation operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class DistanceTransform {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap19/input.jpg";
      Mat src = Imgcodecs.imread(file,0);

      // Creating an empty matrix to store the results
      Mat dst = new Mat();
      Mat binary = new Mat();

      // Converting the grayscale image to binary image
      Imgproc.threshold(src, binary, 100, 255, Imgproc.THRESH_BINARY);

      // Applying distance transform
      Imgproc.distanceTransform(mat, dst, Imgproc.DIST_C, 3);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap19/distnceTransform.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/distance_transformation_input.jpg" alt="Distance Transformation Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p><img src="https://www.tutorialspoint.com/opencv/images/distance_transformation_output.jpg" alt="Distance Transformation Output" />
<h2>Types of Distance Transform Operations</h2>
<p>In addition to the distance operation type <b>DIST_C</b> demonstrated in the previous example, OpenCV caters various other types of distance transform operations. All these types are represented by predefined static fields (fixed values) of Imgproc class.</p>
<p>You can choose the type of the distance transform operation you need, by passing its respective predefined value to the parameter named <b>distanceType</b> of the <b>distanceTransform()</b> method.</p>
<pre class="result notranslate">
// Applying distance transform 
Imgproc.distanceTransform(mat, dst, <b>Imgproc.DIST_C</b>, 3);
</pre>
<p>Following are the values representing various types of <b>distanceTransform</b> operations and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;">Operation and Description</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>DIST_C</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/dist_c.jpg" alt="DIST_C " /></td>
</tr>
<tr>
<td class="ts"><b>DIST_L1</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/dist_l1.jpg" alt="DIST_L1" /></td>
</tr>
<tr>
<td class="ts"><b>DIST_L2</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/dist_l2.jpg" alt="DIST_L2" /></td>
</tr>
<tr>
<td class="ts"><b>DIST_LABEL_PIXEL</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/dist_label_pixel.jpg" alt="DIST_LABEL_PIXEL" /></td>
</tr>
<tr>
<td class="ts"><b>DIST_MASK_3</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/dist_mask_3.jpg" alt="DIST_MASK_3" /></td>
</tr>
</table>
<h1>OpenCV - Using Camera</h1>
<p>In this chapter, we will learn how to use OpenCV to capture frames using the system camera. The <b>VideoCapture</b> class of the <b>org.opencv.videoio</b> package contains classes and methods to capture video using the camera. Let’s go step by step and learn how to capture frames &minus;</p>
<h2>Step 1: Load the OpenCV native library</h2>
<p>While writing Java code using OpenCV library, the first step you need to do is to load the native library of OpenCV using the <b>loadLibrary()</b>. Load the OpenCV native library as shown below.</p>
<pre class="result notranslate">
// Loading the core library 
System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
</pre>
<h2>Step 2: Instantiate the video capture class</h2>
<p>Instantiate the Mat class using any of the functions mentioned in this tutorial earlier.</p>
<pre class="result notranslate">
// Instantiating the VideoCapture class (camera:: 0) 
VideoCapture capture = new VideoCapture(0);
</pre>
<h2>Step 3: Read the frames</h2>
<p>You can read the frames from the camera using the <b>read()</b> method of the <b>VideoCapture</b> class. This method accepts an object of the class <b>Mat</b> to store the frame read.</p>
<pre class="result notranslate">
// Reading the next video frame from the camera 
Mat matrix = new Mat(); 
capture.read(matrix);
</pre>
<h3>Example</h3>
<p>The following program demonstrates how to capture a frame using camera and display it using JavaFX window. It also saves the captured frame.</p>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.WritableRaster;

import java.io.FileNotFoundException;
import java.io.IOException;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.videoio.VideoCapture;

public class CameraSnapshotJavaFX extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws FileNotFoundException, IOException {
      // Capturing the snapshot from the camera
      CameraSnapshotJavaFX obj = new CameraSnapshotJavaFX();
      WritableImage writableImage = obj.capureSnapShot();

      // Saving the image
      obj.saveImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Capturing an image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage capureSnapShot() {
      WritableImage WritableImage = null;

      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Instantiating the VideoCapture class (camera:: 0)
      VideoCapture capture = new VideoCapture(0);

      // Reading the next video frame from the camera
      Mat matrix = new Mat();
      capture.read(matrix);

      // If camera is opened
      if( capture.isOpened()) {
         // If there is next video frame
         if (capture.read(matrix)) {
            // Creating BuffredImage from the matrix
            BufferedImage image = new BufferedImage(matrix.width(), 
               matrix.height(), BufferedImage.TYPE_3BYTE_BGR);
            
            WritableRaster raster = image.getRaster();
            DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();
            byte[] data = dataBuffer.getData();
            matrix.get(0, 0, data);
            this.matrix = matrix;
            
            // Creating the Writable Image
            WritableImage = SwingFXUtils.toFXImage(image, null);
         }
      }
      return WritableImage;
   }
   public void saveImage() {
      // Saving the Image
      String file = "E:/OpenCV/chap22/sanpshot.jpg";

      // Instantiating the imgcodecs class
      Imgcodecs imageCodecs = new Imgcodecs();

      // Saving it again 
      imageCodecs.imwrite(file, matrix);
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<h2>Output</h2>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/capture_frame_using_camera.jpg" alt="Capture Frame Using Camera" />
<p>If you open the specified path, you can observe the same frame which is saved as a jpg file.</p>
<h1>OpenCV - Face Detection in a Picture</h1>
<p>The <b>VideoCapture</b> class of the <b>org.opencv.videoio</b> package contains classes and methods to capture video using the system camera. Let’s go step by step and learn how to do it.</p>
<h2>Step 1: Load the OpenCV native library</h2>
<p>While writing Java code using OpenCV library, the first step you need to do is to load the native library of OpenCV using the <b>loadLibrary()</b>. Load the OpenCV native library as shown below.</p>
<pre class="result notranslate">
// Loading the core library 
System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
</pre>
<h2>Step 2: Instantiate the CascadeClassifier class</h2>
<p>The <b>CascadeClassifier</b> class of the package <b>org.opencv.objdetect</b> is used to load the classifier file. Instantiate this class by passing the <b>xml</b> file <b>lbpcascade_frontalface.xml</b> as shown below.</p>
<pre class="result notranslate">
// Instantiating the CascadeClassifier 
String xmlFile = "E:/OpenCV/facedetect/lbpcascade_frontalface.xml"; 
CascadeClassifier classifier = new CascadeClassifier(xmlFile);
</pre>
<h2>Step 3: Detect the faces</h2>
<p>You can detect the faces in the image using method <b>detectMultiScale()</b> of the class named <b>CascadeClassifier</b>. This method accepts an object of the class <b>Mat</b> holding the input image and an object of the class <b>MatOfRect</b> to store the detected faces.</p>
<pre class="result notranslate">
// Detecting the face in the snap 
MatOfRect faceDetections = new MatOfRect(); 
classifier.detectMultiScale(src, faceDetections);
</pre>
<h3>Example</h3>
<p>The following program demonstrates how to detect faces in an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfRect;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;
  
public class FaceDetectionImage {
   public static void main (String[] args) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap23/facedetection_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Instantiating the CascadeClassifier
      String xmlFile = "E:/OpenCV/facedetect/lbpcascade_frontalface.xml";
      CascadeClassifier classifier = new CascadeClassifier(xmlFile);

      // Detecting the face in the snap
      MatOfRect faceDetections = new MatOfRect();
      classifier.detectMultiScale(src, faceDetections);
      System.out.println(String.format("Detected %s faces", 
         faceDetections.toArray().length));

      <b>// Drawing boxes
      for (Rect rect : faceDetections.toArray()) {
         Imgproc.rectangle(
            src,                                               // where to draw the box
            new Point(rect.x, rect.y),                            // bottom left
            new Point(rect.x + rect.width, rect.y + rect.height), // top right
            new Scalar(0, 0, 255),
            3                                                     // RGB colour
         );</b>
      }

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap23/facedetect_output1.jpg", src);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>facedetection_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/facedetection_input.jpg" alt="FaceDetection Input" />
<h3>Output</h3>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Detected 3 faces 
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/facedetection_output.jpg" alt="FaceDetection Output" />
<h1>OpenCV - Face Detection using Camera</h1>
<p>The following program demonstrates how to detect faces using system camera and display it using JavaFX window.</p>
<h2>Example</h2>
<pre class="prettyprint notranslate">
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.WritableRaster;

import java.io.FileNotFoundException;
import java.io.IOException;

import javafx.application.Application;
import javafx.embed.swing.SwingFXUtils;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.image.ImageView;
import javafx.scene.image.WritableImage;
import javafx.stage.Stage;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfRect;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;
import org.opencv.videoio.VideoCapture;

public class faceDetectionJavaFXX extends Application {
   Mat matrix = null;

   @Override
   public void start(Stage stage) throws FileNotFoundException, IOException {
      // Capturing the snapshot from the camera
      faceDetectionJavaFXX obj = new faceDetectionJavaFXX();
      WritableImage writableImage = obj.capureFrame();

      // Saving the image
      obj.saveImage();

      // Setting the image view
      ImageView imageView = new ImageView(writableImage);

      // setting the fit height and width of the image view
      imageView.setFitHeight(400);
      imageView.setFitWidth(600);

      // Setting the preserve ratio of the image view
      imageView.setPreserveRatio(true);

      // Creating a Group object
      Group root = new Group(imageView);

      // Creating a scene object
      Scene scene = new Scene(root, 600, 400);

      // Setting title to the Stage
      stage.setTitle("Capturing an image");

      // Adding scene to the stage
      stage.setScene(scene);

      // Displaying the contents of the stage
      stage.show();
   }
   public WritableImage capureFrame() {
      WritableImage writableImage = null;

      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Instantiating the VideoCapture class (camera:: 0)
      VideoCapture capture = new VideoCapture(0);

      // Reading the next video frame from the camera
      Mat matrix = new Mat();
      capture.read(matrix);

      // If camera is opened
      if(!capture.isOpened()) {
         System.out.println("camera not detected");
      } else
         System.out.println("Camera detected ");
           
      // If there is next video frame
      if (capture.read(matrix)) {
         /////// Detecting the face in the snap /////
         String file = "E:/OpenCV/facedetect/lbpcascade_frontalface.xml";
         CascadeClassifier classifier = new CascadeClassifier(file);

         MatOfRect faceDetections = new MatOfRect();
         classifier.detectMultiScale(matrix, faceDetections);
         System.out.println(String.format("Detected %s faces",
            faceDetections.toArray().length));

         <b>// Drawing boxes
         for (Rect rect : faceDetections.toArray()) {
            Imgproc.rectangle(
               matrix,                                   //where to draw the box
               new Point(rect.x, rect.y),                            //bottom left
               new Point(rect.x + rect.width, rect.y + rect.height), //top right
               new Scalar(0, 0, 255)                                 //RGB colour
            );</b>
         }
         // Creating BuffredImage from the matrix
         BufferedImage image = new BufferedImage(matrix.width(), matrix.height(),
            BufferedImage.TYPE_3BYTE_BGR);
         
         WritableRaster raster = image.getRaster();
         DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();
         byte[] data = dataBuffer.getData();
         matrix.get(0, 0, data);

         this.matrix = matrix;
           
         // Creating the Writable Image
         writableImage = SwingFXUtils.toFXImage(image, null);
      }
      return writableImage;
   }
   public void saveImage() {
      // Saving the Image
      String file = "E:/OpenCV/chap23/facedetected.jpg";

      // Instantiating the imagecodecs class
      Imgcodecs imageCodecs = new Imgcodecs();

      // Saving it again
      imageCodecs.imwrite(file, matrix);
   }
   public static void main(String args[]) {
      launch(args);
   }
}
</pre>
<h2>Output</h2>
<p>On executing the program, you will get the following output.</p>
<img src="https://www.tutorialspoint.com/opencv/images/face_detection_using_camera.jpg" alt="Face Detection using Camera" />
<p>If you open the specified path, you can see the same snapshot saved as a <b>jpg</b> image.</p>
<h1>OpenCV - Affine Translation</h1>
<p>You can perform <b>affine translation</b> on an image using the <b>warpAffine()</b> method of the imgproc class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
Imgproc.warpAffine(src, dst, <b>tranformMatrix</b>, size);
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>tranformMatrix</b> &minus;  A <b>Mat</b> object representing the transformation matrix.</p></li>
<li><p><b>size</b> &minus;  A variable of the type integer representing the size of the output image.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to apply affine operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint2f;
import org.opencv.core.Point;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class AffineTranslation {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap24/transform_input.jpg";
      Mat src = Imgcodecs.imread(file);

      //Creating an empty matrix to store the result
      Mat dst = new Mat();

      Point p1 = new Point( 0,0 );
      Point p2 = new Point( src.cols() - 1, 0 );
      Point p3 = new Point( 0, src.rows() - 1 );
      Point p4 = new Point( src.cols()*0.0, src.rows()*0.33 );
      Point p5 = new Point( src.cols()*0.85, src.rows()*0.25 );
      Point p6 = new Point( src.cols()*0.15, src.rows()*0.7 );
      
      MatOfPoint2f ma1 = new MatOfPoint2f(p1,p2,p3);
      MatOfPoint2f ma2 = new MatOfPoint2f(p4,p5,p6);

      // Creating the transformation matrix
      Mat tranformMatrix = Imgproc.getAffineTransform(ma1,ma2);

      // Creating object of the class Size
      Size size = new Size(src.cols(), src.cols());

      // Applying Wrap Affine
      Imgproc.warpAffine(src, dst, tranformMatrix, size);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap24/Affinetranslate.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>transform_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/transform_input.jpg" alt="Transform Input" />
<h2>Output</h2>
<p>On executing it, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/affine_translation.jpg" alt="Affine Translation" />
<h1>OpenCV - Rotation</h1>
<p>You can <b>perform rotation</b> operation on an image using the <b>warpAffine()</b> method of the <b>imgproc</b> class. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
Imgproc.warpAffine(src, dst, rotationMatrix, size);
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>rotationMatrix</b> &minus;  A <b>Mat</b> object representing the rotation matrix.</p></li>
<li><p><b>size</b> &minus;  A variable of the type integer representing the size of the output image.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to rotate an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Size;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class Rotation {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap24/transform_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Creating a Point object
      Point point = new Point(300, 200)

      // Creating the transformation matrix M
      Mat rotationMatrix = Imgproc.getRotationMatrix2D(point, 30, 1);

      // Creating the object of the class Size
      Size size = new Size(src.cols(), src.cols());

      // Rotating the given image
      Imgproc.warpAffine(src, dst, rotationMatrix, size);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap24/rotate_output.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>transform_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/transform_input.jpg" alt="Transform Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/rotate_output.jpg" alt="Rotate Output" />
<h1>OpenCV - Scaling</h1>
<p>You can perform <b>scaling</b> on an image using the <b>resize()</b> method of the <b>imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
resize(Mat src, Mat dst, Size dsize, double fx, double fy, int interpolation)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>dst</b> &minus; A <b>Mat</b> object representing the destination (output image) for this operation.</p></li>
<li><p><b>dsize</b> &minus; A <b>Size</b> object representing the size of the output image.</p></li>
<li><p><b>fx</b> &minus; A variable of the type double representing the scale factor along the horizontal axis.</p></li>
<li><p><b>fy</b> &minus; A variable of the type double representing the scale factor along the vertical axis.</p></li>
<li><p><b>Interpolation</b> &minus; An integer variable representing interpolation method.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to apply <b>scale transformation</b> to an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class Scaling {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap24/transform_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Creating the Size object
      Size size = new Size(src.rows()*2, src.rows()*2);

      // Scaling the Image
      Imgproc.resize(src, dst, size, 0, 0, Imgproc.INTER_AREA);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap24/scale_output.jpg", dst);

      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>transform_input.jpg</b> specified in the above program (size &minus; Width:300px and height:300px).</p>
<img src="https://www.tutorialspoint.com/opencv/images/transform_input.jpg" alt="Transform Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows (size &minus; Width:600px and height:600px) &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/scale_output.jpg" alt="Scale Output" />
<h1>OpenCV - Color Maps</h1>
<p>In OpenCV, you can apply different color maps to an image using the method <b>applyColorMap()</b> of the class <b>Imgproc</b>. Following is the syntax of this method &minus;</p>
<pre class="result notranslate">
applyColorMap(Mat src, Mat dst, int colormap)
</pre>
<p>It accepts three parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the destination (output) image.</p></li>
<li><p><b>colormap</b> &minus; A variable of integer type representing the type of the color map to be applied.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to apply <b>color map</b> to an image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class ColorMapTest {
   public static void main(String args[]) {
      // Loading the OpenCV core library
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap25/color_input.jpg";
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat dst = new Mat();

      // Applying color map to an image
      Imgproc.applyColorMap(src, dst, Imgproc.COLORMAP_HOT);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap25/colormap_hot.jpg", dst);
      System.out.println("Image processed");
   }
}
</pre>
<p>Assume that following is the input image <b>color_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/color_input.jpg" alt="Color Input" />
<h2>Output</h2>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/color_output.jpg" alt="Color Output" />
<h2>More Operations</h2>
<p>In addition to <b>COLORMAP_HOT</b> demonstrated in the previous example, OpenCV caters various other types of color maps. All these types are represented by predefined static fields (fixed values) of Imgproc class.</p>
<p>You can choose the type of the colormap you need, by passing its respective predefined value to the parameter named <b>colormap</b> of the <b>applyColorMap()</b> method.</p>
<pre class="result notranslate">
Imgproc.applyColorMap(src, dst, <b>Imgproc.COLORMAP_HOT</b>);
</pre>
<p>Following are the values representing various types of color maps and their respective outputs.</p>
<table class="table table-bordered">
<tr>
<th style="text-align:center;width:50%">Operation and Description</th>
<th style="text-align:center;">Output</th>
</tr>
<tr>
<td class="ts"><b>COLORMAP_AUTUMN</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_autumn.jpg" alt="COLORMAP_AUTUMN" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_BONE</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_bone.jpg" alt="COLORMAP_BONE" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_COOL</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_cool.jpg" alt="COLORMAP_COOL" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_HOT</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_hot.jpg" alt="COLORMAP_HOT" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_HSV</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_hsv.jpg" alt="COLORMAP_HSV" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_JET</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_jet.jpg" alt="COLORMAP_JET" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_OCEAN</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_ocean.jpg" alt="COLORMAP_OCEAN" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_PARULA</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_parula.jpg" alt="COLORMAP_PARULA" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_PINK</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_pink.jpg" alt="COLORMAP_PINK" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_RAINBOW</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_rainbow.jpg" alt="COLORMAP_RAINBOW" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_SPRING</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_spring.jpg" alt="COLORMAP_SPRING" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_SUMMER</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_summer.jpg" alt="COLORMAP_SUMMER" /></td>
</tr>
<tr>
<td class="ts"><b>COLORMAP_WINTER</b></td>
<td><img src="https://www.tutorialspoint.com/opencv/images/colormap_winter.jpg" alt="COLORMAP_WINTER" /></td>
</tr>
</table>
<h1>OpenCV - Canny Edge Detection</h1>
<p>Canny Edge Detection is used to detect the edges in an image. It accepts a gray scale image as input and it uses a multistage algorithm.</p>
<p>You can perform this operation on an image using the <b>Canny()</b> method of the <b>imgproc</b> class, following is the syntax of this method.</p>
<pre class="result notranslate">
Canny(image, edges, threshold1, threshold2)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>image</b> &minus; A <b>Mat</b> object representing the source (input image) for this operation.</p></li>
<li><p><b>edges</b> &minus; A <b>Mat</b> object representing the destination (edges) for this operation.</p></li>
<li><p><b>threshold1</b> &minus; A variable of the type double representing the first threshold for the hysteresis procedure.</p></li>
<li><p><b>threshold2</b> &minus; A variable of the type double representing the second threshold for the hysteresis procedure.</p></li>
</ul>
<h2>Example</h2>
<p>Following program is an example demonstrating, how to perform Canny Edge Detection operation on a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class CannyEdgeDetection {
   public static void main(String args[]) throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary(Core.NATIVE_LIBRARY_NAME);

      // Reading the Image from the file and storing it in to a Matrix object
      String file = "E:/OpenCV/chap17/canny_input.jpg";

      // Reading the image
      Mat src = Imgcodecs.imread(file);

      // Creating an empty matrix to store the result
      Mat gray = new Mat();

      // Converting the image from color to Gray
      Imgproc.cvtColor(src, gray, Imgproc.COLOR_BGR2GRAY);
      Mat edges = new Mat();

      // Detecting the edges
      Imgproc.Canny(gray, edges, 60, 60*3);

      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap17/canny_output.jpg", edges);
      System.out.println("Image Loaded");
   } 
}
</pre>
<p>Assume that following is the input image <b>canny_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/canny_input.jpg" alt="Canny Input" />
<h2>Output</h2>
<p>On executing the above program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/canny_output.jpg" alt="Canny Output" />
<h1>OpenCV - Hough Line Transform</h1>
<p>You can detect the shape of a given image by applying the <b>Hough Transform technique</b> using the method <b>HoughLines()</b> of the <b>Imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
HoughLines(image, lines, rho, theta, threshold)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>image</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>lines</b> &minus; An object of the class <b>Mat</b> that stores the vector that stores the parameters (r, &Phi;) of the lines.</p></li>
<li><p><b>rho</b> &minus; A variable of the type double representing the resolution of the parameter r in pixels.</p></li>
<li><p><b>theta</b> &minus; A variable of the type double representing the resolution of the parameter &Phi; in radians.</p></li>
<li><p><b>threshold</b> &minus; A variable of the type integer representing the minimum number of intersections to “detect” a line.</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to detect Hough lines in a given image.</p>
<pre class="prettyprint notranslate">
import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Point;
import org.opencv.core.Scalar;

import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class HoughlinesTest {
   public static void main(String args[]) throws Exception {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file = "E:/OpenCV/chap21/hough_input.jpg";

      // Reading the image
      Mat src = Imgcodecs.imread(file,0);

      // Detecting edges of it
      Mat canny = new Mat();
      Imgproc.Canny(src, canny, 50, 200, 3, false);

      // Changing the color of the canny
      Mat cannyColor = new Mat();
      Imgproc.cvtColor(canny, cannyColor, Imgproc.COLOR_GRAY2BGR);

      // Detecting the hough lines from (canny)
      Mat lines = new Mat();
      Imgproc.HoughLines(canny, lines, 1, Math.PI/180, 100);

      System.out.println(lines.rows());
      System.out.println(lines.cols());

      // Drawing lines on the image
      double[] data;
      double rho, theta;
      Point pt1 = new Point();
      Point pt2 = new Point();
      double a, b;
      double x0, y0;
      
      for (int i = 0; i &lt; lines.cols(); i++) {
         data = lines.get(0, i);
         rho = data[0];
         theta = data[1];
         
         a = Math.cos(theta);
         b = Math.sin(theta);
         x0 = a*rho;
         y0 = b*rho;
         
         pt1.x = Math.round(x0 + 1000*(-b));
         pt1.y = Math.round(y0 + 1000*(a));
         pt2.x = Math.round(x0 - 1000*(-b));
         pt2.y = Math.round(y0 - 1000 *(a));
         Imgproc.line(cannyColor, pt1, pt2, new Scalar(0, 0, 255), 6);
      }
      // Writing the image
      Imgcodecs.imwrite("E:/OpenCV/chap21/hough_output.jpg", cannyColor);
          
      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>hough_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/hough_input.jpg" alt="Hough Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
143 
1 
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/hough_output.jpg" alt="Hough Output" />
<h1>OpenCV - Histogram Equalization</h1>
<p>The <b>histogram</b> of an image shows the frequency of pixels’ intensity values. In an image histogram, the X-axis shows the gray level intensities and the Y-axis shows the frequency of these intensities.</p>
<p><b>Histogram equalization</b> improves the contrast of an image, in order to stretch out the intensty range. You can equalize the histogram of a given image using the method <b>equalizeHist()</b> of the <b>Imgproc</b> class. Following is the syntax of this method.</p>
<pre class="result notranslate">
equalizeHist(src, dst)
</pre>
<p>This method accepts the following parameters &minus;</p>
<ul class="list">
<li><p><b>src</b> &minus; An object of the class <b>Mat</b> representing the source (input) image.</p></li>
<li><p><b>dst</b> &minus; An object of the class <b>Mat</b> representing the output. (Image obtained after equalizing the histogram)</p></li>
</ul>
<h2>Example</h2>
<p>The following program demonstrates how to equalize the histogram of a given image.</p>
<pre class="prettyprint notranslate">
import java.util.ArrayList;
import java.util.List;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.Size;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;

public class HistoTest {
   public static void main (String[] args) {
      // Loading the OpenCV core library
      System.loadLibrary( Core.NATIVE_LIBRARY_NAME );

      // Reading the Image from the file and storing it in to a Matrix object
      String file ="E:/OpenCV/chap20/histo_input.jpg";

      // Load the image
      Mat img = Imgcodecs.imread(file);

      // Creating an empty matrix
      Mat equ = new Mat();
      img.copyTo(equ);

      // Applying blur
      Imgproc.blur(equ, equ, new Size(3, 3));

      // Applying color
      Imgproc.cvtColor(equ, equ, Imgproc.COLOR_BGR2YCrCb);
      List&lt;Mat&gt; channels = new ArrayList&lt;Mat&gt;();

      // Splitting the channels
      Core.split(equ, channels);

      // Equalizing the histogram of the image
      Imgproc.equalizeHist(channels.get(0), channels.get(0));
      Core.merge(channels, equ);
      Imgproc.cvtColor(equ, equ, Imgproc.COLOR_YCrCb2BGR);

      Mat gray = new Mat();
      Imgproc.cvtColor(equ, gray, Imgproc.COLOR_BGR2GRAY);
      Mat grayOrig = new Mat();
      Imgproc.cvtColor(img, grayOrig, Imgproc.COLOR_BGR2GRAY);

      Imgcodecs.imwrite("E:/OpenCV/chap20/histo_output.jpg", equ);
      System.out.println("Image Processed");
   }
}
</pre>
<p>Assume that following is the input image <b>histo_input.jpg</b> specified in the above program.</p>
<img src="https://www.tutorialspoint.com/opencv/images/histo_input.jpg" alt="Histo Input" />
<h2>Output</h2>
<p>On executing the program, you will get the following output &minus;</p>
<pre class="result notranslate">
Image Processed
</pre>
<p>If you open the specified path, you can observe the output image as follows &minus;</p>
<img src="https://www.tutorialspoint.com/opencv/images/histo_output.jpg" alt="Histo Output" />
<hr />
<div class="pre-btn">
<a href="https://www.tutorialspoint.com/opencv/opencv_histogram_equalization.htm"><i class="icon icon-arrow-circle-o-left big-font"></i> Previous Page</a>
</div>
<div class="print-btn center">
<a href="https://www.tutorialspoint.com/cgi-bin/printpage.cgi" target="_blank"><i class="icon icon-print big-font"></i> Print</a>
</div>
<div class="nxt-btn">
<a href="https://www.tutorialspoint.com/opencv/opencv_useful_resources.htm">Next Page <i class="icon icon-arrow-circle-o-right big-font"></i>&nbsp;</a>
</div>
<hr />
<!-- PRINTING ENDS HERE -->
<div class="bottomgooglead">
<div class="bottomadtag">Advertisements</div>
<script type="text/javascript"><!--
var width = 580;
var height = 400;
var format = "580x400_as";
if( window.innerWidth < 468 ){
   width = 300;
   height = 250;
   format = "300x250_as";
}
google_ad_client = "pub-7133395778201029";
google_ad_width = width;
google_ad_height = height;
google_ad_format = format;
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
<div class="row">
<div class="col-md-3" id="rightbar">
<div class="simple-ad">
<a href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.facebook.com/sharer.php?u=' + 'http://www.tutorialspoint.com/opencv/opencv_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/facebookIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://twitter.com/share?url=' + 'http://www.tutorialspoint.com/opencv/opencv_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/twitterIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.linkedin.com/cws/share?url=' + 'http://www.tutorialspoint.com/opencv/opencv_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/linkedinIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://plus.google.com/share?url=http://www.tutorialspoint.com/opencv/opencv_quick_guide.htm','sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/googlePlusIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://www.stumbleupon.com/submit?url=http://www.tutorialspoint.com/opencv/opencv_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=456,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/StumbleUponIcon.jpg" alt="img" />
</a>
<a  href="javascript:void(0)" onclick="var sTop = window.screen.height/2-(218); var sLeft = window.screen.width/2-(313);window.open('https://reddit.com/submit?url=http://www.tutorialspoint.com/opencv/opencv_quick_guide.htm&amp;title='+ document.title,'sharer','toolbar=0,status=0,width=626,height=656,top='+sTop+',left='+sLeft);return false;">
<img src="https://www.tutorialspoint.com/images/reddit.jpg" alt="img" />
</a>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 250;
google_ad_format = "300x250_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "pub-7133395778201029";
google_ad_width = 300;
google_ad_height = 600;
google_ad_format = "300x600_as";
google_ad_type = "image";
google_ad_channel ="";
//--></script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
<div class="rightgooglead">
<script type="text/javascript"><!--
google_ad_client = "ca-pub-2537027957187252";
/* Right Side Ad */
google_ad_slot = "right_side_ad";
google_ad_width = 300;
google_ad_height = 250;
//-->
</script>
<script type="text/javascript"
src="https://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
</div>
</div>
</div>
</div>
</div>
</div>

<div class="footer-copyright">
<div class="container">
<div class="row">
<div class="col-md-1">
<a href="https://www.tutorialspoint.com/index.htm" class="logo"> <img alt="Tutorials Point" class="img-responsive" src="https://www.tutorialspoint.com/scripts/img/logo-footer.png"> </a>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <nav id="sub-menu">
      <ul>
         <li><a href="https://www.tutorialspoint.com/about/tutorials_writing.htm">Write for us</a></li>
         <li><a href="https://www.tutorialspoint.com/about/faq.htm">FAQ's</a></li>
         <li><a href="https://www.tutorialspoint.com/about/about_helping.htm">Helping</a></li>
         <li><a href="https://www.tutorialspoint.com/about/contact_us.htm">Contact</a></li>
      </ul>
   </nav>
</div>
<div class="col-md-3 col-sm-12 col-xs-12">
<p>&copy; Copyright 2017. All Rights Reserved.</p>
</div>
<div class="col-md-4 col-sm-12 col-xs-12">
   <div class="news-group">
      <input type="text" class="form-control-foot search" name="textemail" id="textemail" autocomplete="off" placeholder="Enter email for newsletter" onfocus="if (this.value == 'Enter email for newsletter...') {this.value = '';}" onblur="if (this.value == '') {this.value = 'Enter email for newsletter...';}">
      <span class="input-group-btn"> <button class="btn btn-default btn-footer" id="btnemail" type="submit" onclick="javascript:void(0);">go</button> </span>
      <div id="newsresponse"></div>
   </div>
</div>
</div>
</div>
</div>
</div>
<!-- Libs -->
<script type="text/javascript" src="https://www.tutorialspoint.com/theme/js/custom-min.js?v=4"></script>
<script src="https://www.google-analytics.com/urchin.js">
</script>
<script type="text/javascript">
_uacct = "UA-232293-6";
urchinTracker();
$('.pg-icon').click(function(){
   $('.wrapLoader').show();
});
</script>
</div>
</body>

<!-- Mirrored from www.tutorialspoint.com/opencv/opencv_quick_guide.htm by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 16 Aug 2017 18:21:50 GMT -->
</html>
